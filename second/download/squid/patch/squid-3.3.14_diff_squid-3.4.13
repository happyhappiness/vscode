Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/acinclude: ax_cxx_compile_stdcxx_0x.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/acinclude: ax_cxx_compile_stdcxx_11.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/acinclude/compiler-flags.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/acinclude/compiler-flags.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/acinclude/compiler-flags.m4	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/acinclude/compiler-flags.m4	2015-05-01 18:05:19.000000000 +0800
@@ -60,21 +60,20 @@
   AC_CACHE_CHECK([whether compiler requires $2],[$1],
   [{
     AC_REQUIRE([AC_PROG_CC])
     SAVED_FLAGS="$CFLAGS"
     SAVED_CXXFLAGS="$CXXFLAGS"
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM($3,$4)],[$1=no],[],[$1=no])
-    if test "$1" != "no" ; then
-      CFLAGS="$CXXFLAGS $2"
+    if test "x$1" != "xno" ; then
+      CFLAGS="$CFLAGS $2"
       CXXFLAGS="$CXXFLAGS $2"
       AC_COMPILE_IFELSE([AC_LANG_PROGRAM($3,$4)],[$1=yes],[$1=no],[$1=no])
     fi
     CFLAGS="$SAVED_CFLAGS"
     CXXFLAGS="$SAVED_CXXFLAGS"
   }])
-  AC_MSG_RESULT([$1])
 ])
 
 # detect what kind of compiler we're using, either by using hints from
 # autoconf itself, or by using predefined preprocessor macros
 # sets the variable squid_cv_compiler to one of
 #  - gcc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/acinclude/init.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/acinclude/init.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/acinclude/init.m4	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/acinclude/init.m4	2015-05-01 18:05:19.000000000 +0800
@@ -32,36 +32,36 @@
 #endif
 ]])     
 
 dnl *BSD net headers
 AC_DEFUN([SQUID_BSDNET_INCLUDES],[
 SQUID_DEFAULT_INCLUDES
+#if HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
 #if HAVE_SYS_TIME_H
 #include <sys/time.h>
 #endif
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
+#if HAVE_NET_IF_H
+#include <net/if.h>
+#endif
 #if HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #if HAVE_NETINET_IP_H
 #include <netinet/ip.h>
 #endif
 #if HAVE_NETINET_IP_COMPAT_H
 #include <netinet/ip_compat.h>
 #endif
-#if HAVE_NET_IF_H
-#include <net/if.h>
-#endif
 #if HAVE_NETINET_IP_FIL_H
 #include <netinet/ip_fil.h>
 #endif
-#if HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
 ])
 
 dnl ===========================================================================
 dnl              http://autoconf-archive.cryp.to/ax_with_prog.html
 dnl ===========================================================================
 dnl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/acinclude/os-deps.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/acinclude/os-deps.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/acinclude/os-deps.m4	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/acinclude/os-deps.m4	2015-05-01 18:05:19.000000000 +0800
@@ -899,6 +899,89 @@
      [squid_cv_recv_second_arg_type=char])
   AC_MSG_RESULT($squid_cv_recv_second_arg_type*)
   ])
   AC_DEFINE_UNQUOTED(RECV_ARG_TYPE,$squid_cv_recv_second_arg_type,
     [Base type of the second argument to recv(2)])
 ])
+
+
+dnl check whether Solaris has broken IPFilter headers (Solaris 10 at least does)
+AC_DEFUN([SQUID_CHECK_BROKEN_SOLARIS_IPFILTER],[
+  if test "x$squid_cv_broken_ipfilter_minor_t" = "x"; then
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#     include <sys/types.h>
+#     include <sys/ioccom.h>
+#     include <netinet/in.h>
+
+#     include <netinet/ip_compat.h>
+#     include <netinet/ip_fil.h>
+#     include <netinet/ip_nat.h>
+    ]])],[
+      AC_MSG_RESULT(no)
+      squid_cv_broken_ipfilter_minor_t=0
+    ],[
+      ## on fail, test the hack
+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define minor_t fubaar
+#       include <sys/types.h>
+#       include <sys/ioccom.h>
+#       include <netinet/in.h>
+#undef minor_t
+#       include <netinet/ip_compat.h>
+#       include <netinet/ip_fil.h>
+#       include <netinet/ip_nat.h>
+      ]])],[
+        AC_MSG_RESULT(yes)
+        squid_cv_broken_ipfilter_minor_t=1
+      ],[
+        AC_MSG_RESULT(unable to make IPFilter work with netinet/ headers)
+      ])
+    ])
+  fi
+
+  AC_DEFINE_UNQUOTED(USE_SOLARIS_IPFILTER_MINOR_T_HACK,$squid_cv_broken_ipfilter_minor_t,
+    [Workaround IPFilter minor_t breakage])
+
+## check for IPFilter headers that require this hack
+## (but first netinet/in.h and sys/ioccom.h which they depend on)
+  AC_CHECK_HEADERS( \
+	netinet/in.h \
+	sys/ioccom.h \
+	ip_compat.h \
+	ip_fil_compat.h \
+	ip_fil.h \
+	ip_nat.h \
+	netinet/ip_compat.h \
+	netinet/ip_fil_compat.h \
+	netinet/ip_fil.h \
+	netinet/ip_nat.h \
+  ,,,[
+#if USE_SOLARIS_IPFILTER_MINOR_T_HACK
+#define minor_t fubar
+#endif
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_SYS_IOCCOM_H
+#include <sys/ioccom.h>
+#endif
+#if USE_SOLARIS_IPFILTER_MINOR_T_HACK
+#undef minor_t
+#endif
+#if HAVE_IP_COMPAT_H
+#include <ip_compat.h>
+#elif HAVE_NETINET_IP_COMPAT_H
+#include <netinet/ip_compat.h>
+#endif
+#if HAVE_IP_FIL_H
+#include <ip_fil.h>
+#elif HAVE_NETINET_IP_FIL_H
+#include <netinet/ip_fil.h>
+#endif
+#if !defined(IPFILTER_VERSION)
+#define IPFILTER_VERSION        5000004
+#endif
+  ])
+])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/acinclude/squid-util.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/acinclude/squid-util.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/acinclude/squid-util.m4	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/acinclude/squid-util.m4	2015-05-01 18:05:19.000000000 +0800
@@ -213,16 +213,14 @@
       ;;
     *)
       squid_build_info=$enableval
       ;;
   esac
   ])
-  if test "x${squid_build_info:=no}" != "xno"; then
-    AC_DEFINE_UNQUOTED([SQUID_BUILD_INFO],["$squid_build_info"],
-       [Squid extended build info field for "squid -v" output])
-  fi
+  AC_DEFINE_UNQUOTED([SQUID_BUILD_INFO],["$squid_build_info"],
+     [Squid extended build info field for "squid -v" output])
 ])
 
 dnl like AC_SEARCH_LIBS, with an extra argument which is
 dnl a prefix to the test program
 AC_DEFUN([SQUID_SEARCH_LIBS],
 [AS_VAR_PUSHDEF([ac_Search], [ac_cv_search_$1])dnl
@@ -246,6 +244,35 @@
 AS_IF([test "$ac_res" != no],
   [test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
   $3],
       [$4])
 AS_VAR_POPDEF([ac_Search])dnl
 ])
+
+dnl Check for Cyrus SASL
+AC_DEFUN([SQUID_CHECK_SASL],[
+  squid_cv_check_sasl="auto"
+  AC_CHECK_HEADERS([sasl/sasl.h sasl.h])
+  AC_CHECK_LIB(sasl2,sasl_errstring,[LIBSASL="-lsasl2"],[
+    AC_CHECK_LIB(sasl,sasl_errstring,[LIBSASL="-lsasl"], [
+      squid_cv_check_sasl="no"
+    ])
+  ])
+  case "$squid_host_os" in
+    Darwin)
+      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
+        AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
+        echo "checking for MAC Darwin without sasl.h ... yes"
+        squid_cv_check_sasl="yes"
+      else
+        echo "checking for MAC Darwin without sasl.h ... no"
+        squid_cv_check_sasl="no"
+      fi
+      ;;
+  esac
+  if test "x$squid_cv_check_sasl" = "xno"; then
+    AC_MSG_WARN([Neither SASL nor SASL2 found])
+  else
+    squid_cv_check_sasl="yes"
+  fi
+  AC_SUBST(LIBSASL)
+])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/bootstrap.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/bootstrap.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/bootstrap.sh	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/bootstrap.sh	2015-05-01 18:05:19.000000000 +0800
@@ -120,14 +120,13 @@
 echo "automake ($amversion) : automake$amver"
 echo "autoconf ($acversion) : autoconf$acver"
 echo "libtool  ($ltversion) : ${LIBTOOL_BIN}${ltver}"
 echo "libtool path : $ltpath"
 
 for dir in \
-	"" \
-	lib/libTrie
+	"" 
 do
     if [ -z "$dir" ] || [ -d $dir ]; then
 	if (
 	echo "Bootstrapping $dir"
 	cd ./$dir
 	if [ -n "$dir" ] && [ -f bootstrap.sh ]; then
@@ -154,13 +153,15 @@
 	    exit 1
 	fi
     fi
 done
 
 # Make a copy of SPONSORS we can package
-sed -e 's/@Squid-[0-9\.]*://' <SPONSORS.list > SPONSORS || (rm -f SPONSORS && exit 1)
+if test -f SPONSORS.list; then
+  sed -e 's/@Squid-[0-9\.]*://' <SPONSORS.list > SPONSORS || (rm -f SPONSORS && exit 1)
+fi
 
 # Fixup autoconf recursion using --silent/--quiet option
 # autoconf should inherit this option whe recursing into subdirectories
 # but it currently doesn't for some reason.
 if ! grep  "configure_args --quiet" configure >/dev/null; then
 echo "Fixing configure recursion"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/ChangeLog /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/ChangeLog
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/ChangeLog	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/ChangeLog	2015-05-01 18:05:19.000000000 +0800
@@ -1,6 +1,230 @@
+Changes to squid-3.4.13 (01 May 2015):
+
+	- Bug 4212: ssl_crtd crashes with corrupt database
+	- ... and some documentation updates
+	- ... and all fixes from squid 3.3.14
+
+Changes to squid-3.4.12 (18 Feb 2015):
+
+	- Bug 4066: Digest auth nonce indefinite rollover
+	- Bug 3997: Excessive NTLM or Negotiate auth helper annotations
+	- Fix several crashes when debugging enabled
+	- Fix silent SSL/TLS failure on split-stack operating systems
+	- HTTP/1.1: Stop emitting (Proxy-)Authentication-Info for Negotiate
+	- HTTPS: Add TLS/SSL option NO_TICKET to http[s]_port
+	- Remove dst ACL dependency on HTTP request message existence
+	- Set cap_net_admin when Squid sets TOS/Diffserv packet values
+	- ... and some documentation updates
+
+Changes to squid-3.4.11 (13 Jan 2015):
+
+	- Bug 4164: SEGFAULT when %W formating code used in errorpages
+	- Bug 4057: Avoid on-exit crashes when adaptation is enabled.
+	- Bug 3760: squidclient ignores --disable-ipv6
+	- Bug 3754: configure doesnt detect IPFilter 5.1.2 system headers
+	- Bug 3664: ssl_crtd fails to build on OpenSolaris/OpenIndiana/Solaris 11
+	- cachemgr.cgi: memory leak in request parser
+	- Deleting first fs left psstate->servers pointing to uninitialized memory
+	- ... and some build issues
+
+Changes to squid-3.4.10 (09 Dec 2014):
+
+	- Bug 4148: external_acl_type header format does not accept the new libformat syntax
+	- Bug 4145: squid_endian.h compile errors with OpenBSD 5.6
+	- Bug 4033: Rebuild corrupted ssl_db/size file
+	- Bug 3902: Docs: external_acl_type cache hash key
+	- Fix segmentation fault in ACL urlpath_regex
+	- Fix bootstrap.sh dependency on SPONSORS.list
+	- Alternate-Protocol is a hop-by-hop header
+	- HTTP/2: Support 421 (Misdirected Request) status code
+
+Changes to squid-3.4.9 (31 Oct 2014):
+
+	- Regression fix: ext_kerberos_ldap_group_acl typo in 3.4.7 update
+	- Bug 4102: sslbump cert contains only a dot character in key usage extension
+	- Bug 4093: source-maintenance.sh errors and warnings due to wrong tools/options
+	- Bug 4088: memory leak in external_acl_type helper with cache=0 or ttl=0
+	- Bug 4024: Bad host/IP ::1 when using IPv4-only environment
+	- Bug 3803: ident leaks memory on failure
+	- kerberos_ldap_group/cert_tool: Remove ksh dependency
+	- ... and some automated code style updates
+	- ... and some documentation updates
+
+Changes to squid-3.4.8 (15 Sep 2014):
+
+	- Fix off by one in SNMP subsystem
+	- pinger: Fix various ICMP handling issues
+
+Changes to squid-3.4.7 (28 Aug 2014):
+
+	- Regression Fix: Kerberos LDAP authorizing groups with principle subdomain
+	- Bug 4080: worker hangs when client identd is not responding
+	- Bug 3966: Add KeyEncipherment when ssl-bump substitues RSA for EC
+	- HTTP/1.1: Ignore Range headers with unidentifiable byte-range values
+	- SSL-bump: Use v3 for fake certificate if we add _any_ certificate extension
+	- Enable compile-time override for MAXTCPLISTENPORTS
+	- ntlm_sspi_auth: Fix various build errors
+	- negotiate_wrapper: Fix build issues with non-portable vfork()
+	- negotiate_sspi_auth: Portability fixes for MinGW
+	- ext_lm_group_acl: Portability fixes for MinGW
+	- ... and several minor memory leaks
+
+Changes to squid-3.4.6 (25 Jun 2014):
+
+	- Regression: segmentation fault logging with %tg format specifier
+	- Bug 4065: round-robin neighbor selection with unequal weights
+	- Bug 4056: assertion MemPools[type] from netdbExchangeStart()
+	- Bug 4050: segmentation fault in CommSelectEngine::checkEvents on helper response
+	- Fix segmentation fault setting up server SSL connnection
+	- Fix hanging Non-HTTPS connections on SSL-bump enabled port
+	- Fix Cache Manager actions listed more than once
+	- ... and many minor memory leaks
+	- ... and several portability build issues
+	- ... and some documentation updates
+
+Changes to squid-3.4.5 (02 May 2014):
+
+	- Regression Bug 4051: inverted test on CONNECT payload existence
+	- Regression Fix: order dependency between cache_dir and maximum_object_size
+	- Fix logformat %note display
+	- Resolve 'dying from an unhandled exception: c'
+	- Copyright: Update CONTRIBUTORS list of copyright holders
+
+Changes to squid-3.4.4.2 (23 Apr 2014):
+
+	- version bump for packaging re-build with altered toolchain
+
+Changes to squid-3.4.4.1 (23 Apr 2014):
+
+	- Regression Bug 4019: Cache digest exchange segmentation fault
+	- Regression Bug 3982: EUI logging and helpers show blank MAC address
+	- Bug 4047: Support Android builds
+	- Bug 4043: Remove XMALLOC_TRACE and references to sbrk(2)
+	- Bug 4041: Missing files in compat/Makefile.am
+	- Bug 4014: Build failure with --disable-optimizations --disable-auth
+	- Bug 3986: (partial) assertion due to incorrect error page buffer size
+	- Bug 3955: Solaris EUI-48 lookup leaks FDs
+	- Bug 3371: CONNECT with data sent at once loses data
+	- C++11: Upgrade auto-detection to use the formal -std=c++11
+	- Crypto-NG: libnettle MD5 algorithm support
+	- SSL-Bump: Fix Basic auth caching on bumped connections
+	- Store-ID: Fix request URI when forwarding requests to peers
+	- ... and fix several other build errors
+	- ... and some documentation updates
+
+Changes to squid-3.4.4 (09 Mar 2014):
+
+	- Bug 4029: intercepted HTTPS requests bypass caching checks
+	- Bug 4001: remove use of strsep()
+	- Bug 3186 and 3628: Digest authentication always sending stale=false for nonce
+	- Fix stalled concurrent rock store reads
+	- Fix helper ID number assignment
+	- Fix build failures from CMSG related definitions
+	- Fix build failures from libcompat unsafe.h protections
+	- Copyright: Relicense helpers by Treehouse Networks Ltd.
+	- ... and all bug fixes from 3.3.12
+
+Changes to squid-3.4.3 (02 Feb 2014):
+
+	- Bug 4008: HttpHeader warnOnError should be an int not a bool
+	- Bug 4002: clang 3.4 unable to compile
+	- Bug 3996: Malformed DNS reply leads to crash
+	- Bug 3995: compile error on CentOS 5 with GCC 4.1.2
+	- Bug 3975: atomic detection cross-compilation failure
+	- Bug 3971: "cannot aggregate mgr:client_list: cmd->profile != NULL" in SMP mode
+	- Bug 3954: compile failure in CpuAffinity.cc
+	- Bug 3927: tests/testRock fatal.cc required
+	- Fix memory leak in peer Cache Digest exchange
+	- Fix external_acl_type async loop failures
+	- Fix destination IP address cycling
+	- ... and a few polishing changes
+
+Changes to squid-3.4.2 (30 Dec 2013):
+
+	- Regression Bug 3980: FATAL ERROR due to max_user_ip -s option
+	- Regression Fix: \-unescaping in quoted strings from helpers
+	- Regression Fix: URL helper API bypassing on URL containing '=' character
+	- Bug 3985: 60s limit introduced by balance_on_multiple_ip breaks bad IP recovery
+	- Bug 3806: Caching responses with Vary header
+	- Bug 3498: FTP PUT assertion
+	- WCCPv2: Fix assertion 'Cannot convert non-IPv4 to IPv4' on FreeBSD
+	- Enable concurrency by default for SSL certificate validator
+	- ... and fix several build errors
+
+Changes to squid-3.4.1 (09 Dec 2013):
+
+	- Bug 3935: Invalid pointer dereference when peeking at origin server certificate
+	- Bug 3589: intercepted and ICAP modified request using a cache_peer
+	- ... and several portability fixes
+	- ... and some documentation updates
+
+Changes to squid-3.4.0.3 (01 Dec 2013):
+
+	- Bug 3941: Release notes error
+	- Receive annotations from authentication and external ACL helpers
+	- basic_nis_auth: Improved portability
+	- ... and several documentation updates
+	- ... and all bug fixes from 3.3.9, 3.3.10, 3.3.11
+
+Changes to squid-3.4.0.2 (03 Oct 2013):
+
+	- Regression Bug 3891: squid.conf parser errors in 3.4.0.1
+	- Regression Fix: re-disable MinGW C++11 support
+	- Bug 3914: partial: make squidclient tool build cleanly with -Wconversion
+	- Fix memory leak in refresh_pattern parsing
+	- negotiate_kerberos_auth: upgrade to present group= keys
+	- Handle NTLM helper returning OK without user= value
+	- Add dns_multicast_local to control mDNS operation
+	- Add --disable-arch-native build option
+	- Display Build-Info in cache manager info report
+	- ... and all changes from squid 3.3.9
+	- ... and some code and debug output polishing
+
+Changes to squid-3.4.0.1 (29 Jul 2013):
+
+	- Port from 2.7: StoreURL (renamed Store-ID) support
+	- Bug 3795: fix several mistakes in the MIB file
+	- Bug 3793: configure: improved helper detection
+	- Bug 3722: Invalid markup in Armenian hy ERR_ONLY_IF_CACHED_MISS
+	- Bug 3676: Support GCC 4.7 with -Wshadow option
+	- Bug 3643: NTLM helpers stuck in reserved state by Safari
+	- Bug 3389: Auto-reconnect for tcp access_log
+	- Bug 2066: squid does not do chdir() after chroot()
+	- Fix uninitialized fields in IcapLogEntry
+	- Fix a number of minor issues detected by Coverity Scan
+	- Fix some potential memory leaks detected by Coverity Scan
+	- Fix 64-bit support for Intel compiler suite (ICC) and other similar compilers
+	- Fix ACL matching algorithm to avoid repeating tests
+	- basic_pam_auth: Add -r option to strip NTLM/Negotiate domain from username
+	- squidpurge: fix META TLV parsing issues
+	- squid.conf: enforce all the directive and option names are lower-case
+	- Support EUI on HTTPS and FTP data connections
+	- Support OK/ERR/BH response codes from any helper
+	- Support No-lookup flag (-n) on DNS ACLs
+	- Support -march=native compiler optimization by default
+	- Support forwarding intercepted but not bumped connections to cache_peers
+	- Support IPv6 NAT interception on Linux and some BSD
+	- Deprecate log_icap and log_access configuration directives
+	- HTTP/1.1: improved method invalidation and cacheability detection
+	- HTTP/1.1: support length configuration for pipeline_prefetch queue
+	- Improved TPROXY support for OpenBSD and FreeBSD
+	- Add storeid_file_rewrite helper to perform Store-ID rewrites from a rules file
+	- Add all-of and any-of ACL types for grouping sets of ACL tests
+	- Add note directive for transaction annotations
+	- Add %note log format for transaction annotation logging
+	- Add note ACL type for matching annotated transactions with by annotation name or value
+	- Add kv-pair support to URL-rewrite/redirector interface
+	- Add SSL server certificate validator interface, helper and result cache
+	- Add SSL server certificate fingerprint ACL type
+	- Add spoof_client_ip access control
+	- Add pt-bz (Belize Portuguese) dialect to translations
+	- ... and many Windows portability changes (still incomplete)
+	- ... and many documentation changes
+	- ... and much code cleanup and polishing
+
 Changes to squid-3.3.14 (01 May 2015):
 
 	- Bug 4093: source-maintenance.sh errors and warnings due to wrong tools/options
 	- ... and some documentation updates
 	- ... and all fixes from squid 3.2.14
 
@@ -63,12 +287,13 @@
 	- Bug 2287: Better fix for unsupported HTTP version handling
 	- Bug 2112: Reload into If-None-Match
 	- Fix several assert with side effects in ICAP/eCAP response handling
 	- Fix myportname ACL on ICAP/eCAP transactions
 	- Fix external ACL user:pass detail logging after adaptation
 	- Fix SMP mgr:info report 'Largest file desc currently in use'
+	- Handle infinite certificate validation loops caused by OpenSSL Bug 3090.
 	- Improved compatibility with gcc 4.8, clang and icc
 	- Show number of available filedescriptors when reserved FD changes
 	- Sync with newest OpenSSL error codes
 	- Register Http2-Settings header
 	- ... and many Windows portability fixes
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/cmsg.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/cmsg.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/cmsg.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/cmsg.h	2015-05-01 18:05:19.000000000 +0800
@@ -9,27 +9,28 @@
 #include <sys/socket.h>
 #endif
 
 // WinSock2.h defines these for Windows
 #if HAVE_WINSOCK2_H
 #include <winsock2.h>
-#define CMSG_H_ // prevent re-definition
 #endif
 
-#ifndef CMSG_H_
-#define CMSG_H_
+// sockaddr_un might be in sys/un.h if not pulled in already
+#if HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
 
-/* mostly windows-specific */
-#ifndef CMSG_SPACE
+#if !HAVE_CMSGHDR
 struct cmsghdr {
-    unsigned int    cmsg_len;
-    int  cmsg_level;
-    int     cmsg_type;
+    unsigned int cmsg_len;
+    int cmsg_level;
+    int cmsg_type;
     unsigned char cmsg_data[16]; /* dummy */
     /* followed by UCHAR cmsg_data[]; */
-} ;
+};
+#endif
 
 /* lifted off https://metacpan.org/source/SAMPO/Socket-PassAccessRights-0.03/passfd.c */
 #ifndef CMSG_DATA
 # define CMSG_DATA(cmsg) ((cmsg)->cmsg_data)
 #endif
 
@@ -45,21 +46,31 @@
 
 #ifndef CMSG_ALIGN
 # define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
              & ~(sizeof (size_t) - 1))
 #endif
 
+#ifndef CMSG_SPACE
 # define CMSG_SPACE(len) (CMSG_ALIGN (len) \
              + CMSG_ALIGN (sizeof (struct cmsghdr)))
 #undef HAVE_CONSTANT_CMSG_SPACE
 #define HAVE_CONSTANT_CMSG_SPACE 1
+#endif
 
 #ifndef CMSG_LEN
 # define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
 #endif
 
+#if !HAVE_IOVEC
+struct iovec {
+    void *iov_base;
+    size_t iov_len;
+};
+#endif
+
+#if !HAVE_MSGHDR
 struct msghdr {
     void *msg_name;             /* Address to send to/receive from.  */
     socklen_t msg_namelen;      /* Length of address data.  */
 
     struct iovec *msg_iov;      /* Vector of data to send/receive into.  */
     size_t msg_iovlen;          /* Number of elements in the vector.  */
@@ -69,25 +80,25 @@
                                    !! The type should be socklen_t but the
                                    definition of the kernel is incompatible
                                    with this.  */
 
     int msg_flags;              /* Flags on received message.  */
 };
+#endif
 
-struct iovec {
-    void *iov_base;
-    size_t iov_len;
-};
+#if !HAVE_SOCKADDR_UN
 struct sockaddr_un {
     char sun_family;
     char sun_path[256];   /* pathname */
 };
+#endif
+
+#ifndef SUN_LEN
 # define SUN_LEN(ptr) ((size_t) (((struct sockaddr_un *) 0)->sun_path)        \
         + strlen ((ptr)->sun_path))
-
-#endif /* CMSG_SPACE */
+#endif
 
 #ifndef SCM_RIGHTS
 #define SCM_RIGHTS 1
 #endif
 #ifndef SCM_CREDENTIALS
 #define SCM_CREDENTIALS 2
@@ -97,14 +108,12 @@
 #endif
 
 #ifndef AF_LOCAL
 #define AF_LOCAL 1
 #endif
 
-#endif /* CMSG_H_ */
-
 // CMSG_SPACE is not constant on some systems (in particular Max OS X),
 // provide a replacement that can be used at build time in that case
 // NP: this must go below our replacement definitions.
 
 #if HAVE_CONSTANT_CMSG_SPACE
 #define SQUID_CMSG_SPACE CMSG_SPACE
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/compat.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/compat.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/compat.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/compat.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,12 +31,23 @@
 #endif
 #ifndef _XOPEN_SOURCE_EXTENDED
 #define _XOPEN_SOURCE_EXTENDED 1
 #endif
 #endif
 
+/* Solaris 10 has a broken definition for minor_t in IPFilter compat.
+ * We must pre-define before doing anything with OS headers so the OS
+ * do not. Then un-define it before using the IPFilter *_compat.h headers.
+ */
+#if IPF_TRANSPARENT && USE_SOLARIS_IPFILTER_MINOR_T_HACK
+/* But we only need do this nasty thing for src/ip/Intercept.cc */
+#if BUILDING_SQUID_IP_INTERCEPT_CC
+#define minor_t solaris_minor_t_fubar
+#endif
+#endif
+
 /*****************************************************/
 /* FDSETSIZE is messy and needs to be done before    */
 /* sys/types.h are defined.                          */
 /*****************************************************/
 #include "compat/fdsetsize.h"
 
@@ -53,27 +64,27 @@
 /*****************************************************/
 /* per-OS hacks. One file per OS.                    */
 /* OS-macro wrapping should be done inside the OS .h */
 /*****************************************************/
 
 #include "compat/os/aix.h"
+#include "compat/os/android.h"
 #include "compat/os/dragonfly.h"
 #include "compat/os/freebsd.h"
 #include "compat/os/hpux.h"
 #include "compat/os/linux.h"
 #include "compat/os/macosx.h"
-#include "compat/os/mswin.h"
+#include "compat/os/mswindows.h"
 #include "compat/os/netbsd.h"
 #include "compat/os/next.h"
 #include "compat/os/openbsd.h"
 #include "compat/os/os2.h"
 #include "compat/os/qnx.h"
 #include "compat/os/sgi.h"
 #include "compat/os/solaris.h"
 #include "compat/os/sunos.h"
-#include "compat/os/windows.h"
 
 /*****************************************************/
 /* portabilities shared between all platforms and    */
 /* components as found to be needed                  */
 /*****************************************************/
 
@@ -91,23 +102,17 @@
 /* helper debugging requires some hacks to be clean */
 #include "compat/debug.h"
 
 /* Valgrind API macros changed between two versions squid supports */
 #include "compat/valgrind.h"
 
-/* Endian functions are usualy handled by the OS but not always. */
-#include "squid_endian.h"
-
 /**
  * A Regular Expression library is bundled with Squid.
  * Default is to use a system provided one, but the bundle
  * may be used instead with explicit configuration.
  */
 #include "compat/GnuRegex.h"
 
-/* some functions are unsafe to be used in Squid. */
-#include "compat/unsafe.h"
-
 /* cppunit is not quite C++0x compatible yet */
 #include "compat/cppunit.h"
 
 #endif /* _SQUID_COMPAT_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/eui64_aton.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/eui64_aton.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/eui64_aton.c	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/eui64_aton.c	2015-05-01 18:05:19.000000000 +0800
@@ -74,12 +74,14 @@
  * Columbia University, New York City
  */
 
 #include "squid.h"
 #include "compat/eui64_aton.h"
 
+#if SQUID_EUI64_ATON
+
 /*
  * Convert an ASCII representation of an EUI-64 to binary form.
  */
 int
 eui64_aton(const char *a, struct eui64 *e)
 {
@@ -129,6 +131,8 @@
     e->octet[5]=o5;
     e->octet[6]=o6;
     e->octet[7]=o7;
 
     return (0);
 }
+
+#endif /* !SQUID_EUI64_ATON */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/eui64_aton.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/eui64_aton.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/eui64_aton.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/eui64_aton.h	2015-05-01 18:05:19.000000000 +0800
@@ -43,12 +43,14 @@
 #ifndef _SYS_EUI64_H
 #define _SYS_EUI64_H
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+#define SQUID_EUI64_ATON 1
+
     /**
      * Size of the ASCII representation of an EUI-64.
      */
 #define EUI64_SIZ       24
 
     /**
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -6,26 +6,27 @@
 
 
 # Ideally this would be 100% inline functions and macro wrappers.
 
 # Port Specific Configurations
 
-noinst_LIBRARIES = libcompat-squid.a
-libcompat_squid_a_SOURCES = \
+noinst_LTLIBRARIES = libcompat-squid.la
+libcompat_squid_la_SOURCES = \
 	assert.cc \
 	assert.h \
 	cmsg.h \
 	compat.cc \
 	compat.h \
 	compat_shared.h \
 	cpu.h \
 	cppunit.h \
 	debug.cc \
 	debug.h \
 	drand48.h \
 	eui64_aton.h \
+	eui64_aton.c \
 	fdsetsize.h \
 	getaddrinfo.h \
 	getnameinfo.h \
 	GnuRegex.c \
 	GnuRegex.h \
 	inet_ntop.h \
@@ -35,50 +36,48 @@
 	psignal.h \
 	shm.cc \
 	shm.h \
 	stdio.h \
 	stdvarargs.h \
 	strnstr.cc \
-	strsep.h \
 	strtoll.h \
 	strnrchr.h \
 	strnrchr.c \
 	tempnam.h \
 	types.h \
-	unsafe.h \
 	valgrind.h \
 	xalloc.cc \
 	xalloc.h \
 	xis.h \
 	xstrerror.cc \
 	xstrerror.h \
 	xstring.cc \
 	xstring.h \
 	xstrto.cc \
 	xstrto.h \
 	\
 	os/aix.h \
+	os/android.h \
 	os/dragonfly.h \
 	os/freebsd.h \
 	os/hpux.h \
 	os/linux.h \
 	os/macosx.h \
-	os/mswin.h \
-	mswin.cc \
+	os/mswindows.h \
+	mswindows.cc \
 	os/netbsd.h \
 	os/next.h \
 	os/openbsd.h \
 	os/opensolaris_10_netdb.h \
 	os/os2.h \
 	os/qnx.h \
 	os/sgi.h \
 	os/solaris.h \
-	os/sunos.h \
-	os/windows.h
+	os/sunos.h
 
-libcompat_squid_a_LIBADD= $(LIBOBJS)
+libcompat_squid_la_LIBADD= $(LTLIBOBJS)
 
 check_PROGRAMS += testPreCompiler
 TESTS += testPreCompiler
 
 testPreCompiler_SOURCES= \
 	testPreCompiler.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/Makefile.in	2015-05-01 16:50:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/Makefile.in	2015-05-01 18:06:22.000000000 +0800
@@ -80,61 +80,99 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 DIST_COMMON = $(top_srcdir)/src/Common.am $(srcdir)/Makefile.in \
-	$(srcdir)/Makefile.am inet_ntop.c drand48.c getnameinfo.c \
-	strsep.c tempnam.c inet_pton.c psignal.c eui64_aton.c \
-	getaddrinfo.c strtoll.c strerror.c initgroups.c \
-	$(top_srcdir)/cfgaux/depcomp $(top_srcdir)/cfgaux/test-driver
+	$(srcdir)/Makefile.am inet_pton.c strerror.c psignal.c \
+	inet_ntop.c getnameinfo.c tempnam.c getaddrinfo.c initgroups.c \
+	strtoll.c drand48.c $(top_srcdir)/cfgaux/depcomp \
+	$(top_srcdir)/cfgaux/test-driver
 check_PROGRAMS = testPreCompiler$(EXEEXT)
 TESTS = testPreCompiler$(EXEEXT) testHeaders
 @USE_LOADABLE_MODULES_TRUE@am__append_1 = $(INCLTDL)
 subdir = compat
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude/init.m4 \
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-ARFLAGS = cru
-AM_V_AR = $(am__v_AR_@AM_V@)
-am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
-am__v_AR_0 = @echo "  AR      " $@;
-am__v_AR_1 = 
-libcompat_squid_a_AR = $(AR) $(ARFLAGS)
-libcompat_squid_a_DEPENDENCIES = $(LIBOBJS)
-am_libcompat_squid_a_OBJECTS = assert.$(OBJEXT) compat.$(OBJEXT) \
-	debug.$(OBJEXT) GnuRegex.$(OBJEXT) shm.$(OBJEXT) \
-	strnstr.$(OBJEXT) strnrchr.$(OBJEXT) xalloc.$(OBJEXT) \
-	xstrerror.$(OBJEXT) xstring.$(OBJEXT) xstrto.$(OBJEXT) \
-	mswin.$(OBJEXT)
-libcompat_squid_a_OBJECTS = $(am_libcompat_squid_a_OBJECTS)
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libcompat_squid_la_DEPENDENCIES = $(LTLIBOBJS)
+am_libcompat_squid_la_OBJECTS = assert.lo compat.lo debug.lo \
+	eui64_aton.lo GnuRegex.lo shm.lo strnstr.lo strnrchr.lo \
+	xalloc.lo xstrerror.lo xstring.lo xstrto.lo mswindows.lo
+libcompat_squid_la_OBJECTS = $(am_libcompat_squid_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 am_testPreCompiler_OBJECTS = testPreCompiler.$(OBJEXT) \
 	testMain.$(OBJEXT)
 testPreCompiler_OBJECTS = $(am_testPreCompiler_OBJECTS)
 am__DEPENDENCIES_1 =
 testPreCompiler_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-am__v_lt_1 = 
 testPreCompiler_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
 	$(AM_CXXFLAGS) $(CXXFLAGS) $(testPreCompiler_LDFLAGS) \
 	$(LDFLAGS) -o $@
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -185,14 +223,15 @@
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
 	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
 am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
 am__v_CXXLD_0 = @echo "  CXXLD   " $@;
 am__v_CXXLD_1 = 
-SOURCES = $(libcompat_squid_a_SOURCES) $(testPreCompiler_SOURCES)
-DIST_SOURCES = $(libcompat_squid_a_SOURCES) $(testPreCompiler_SOURCES)
+SOURCES = $(libcompat_squid_la_SOURCES) $(testPreCompiler_SOURCES)
+DIST_SOURCES = $(libcompat_squid_la_SOURCES) \
+	$(testPreCompiler_SOURCES)
 am__can_run_installinfo = \
   case $$AM_UPDATE_INFO_DIR in \
     n|no|NO) false;; \
     *) (install-info --version) >/dev/null 2>&1;; \
   esac
 am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
@@ -477,12 +516,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -520,12 +560,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -552,27 +593,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -638,32 +682,33 @@
 CLEANFILES = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 
 # Ideally this would be 100% inline functions and macro wrappers.
 
 # Port Specific Configurations
-noinst_LIBRARIES = libcompat-squid.a
-libcompat_squid_a_SOURCES = \
+noinst_LTLIBRARIES = libcompat-squid.la
+libcompat_squid_la_SOURCES = \
 	assert.cc \
 	assert.h \
 	cmsg.h \
 	compat.cc \
 	compat.h \
 	compat_shared.h \
 	cpu.h \
 	cppunit.h \
 	debug.cc \
 	debug.h \
 	drand48.h \
 	eui64_aton.h \
+	eui64_aton.c \
 	fdsetsize.h \
 	getaddrinfo.h \
 	getnameinfo.h \
 	GnuRegex.c \
 	GnuRegex.h \
 	inet_ntop.h \
@@ -673,50 +718,48 @@
 	psignal.h \
 	shm.cc \
 	shm.h \
 	stdio.h \
 	stdvarargs.h \
 	strnstr.cc \
-	strsep.h \
 	strtoll.h \
 	strnrchr.h \
 	strnrchr.c \
 	tempnam.h \
 	types.h \
-	unsafe.h \
 	valgrind.h \
 	xalloc.cc \
 	xalloc.h \
 	xis.h \
 	xstrerror.cc \
 	xstrerror.h \
 	xstring.cc \
 	xstring.h \
 	xstrto.cc \
 	xstrto.h \
 	\
 	os/aix.h \
+	os/android.h \
 	os/dragonfly.h \
 	os/freebsd.h \
 	os/hpux.h \
 	os/linux.h \
 	os/macosx.h \
-	os/mswin.h \
-	mswin.cc \
+	os/mswindows.h \
+	mswindows.cc \
 	os/netbsd.h \
 	os/next.h \
 	os/openbsd.h \
 	os/opensolaris_10_netdb.h \
 	os/os2.h \
 	os/qnx.h \
 	os/sgi.h \
 	os/solaris.h \
-	os/sunos.h \
-	os/windows.h
+	os/sunos.h
 
-libcompat_squid_a_LIBADD = $(LIBOBJS)
+libcompat_squid_la_LIBADD = $(LTLIBOBJS)
 testPreCompiler_SOURCES = \
 	testPreCompiler.h \
 	testPreCompiler.cc \
 	$(top_srcdir)/src/tests/testMain.cc
 
 testPreCompiler_LDADD = $(SQUID_CPPUNIT_LA) $(SQUID_CPPUNIT_LIBS)
@@ -754,19 +797,25 @@
 $(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(am__aclocal_m4_deps):
 
-clean-noinstLIBRARIES:
-	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
 
-libcompat-squid.a: $(libcompat_squid_a_OBJECTS) $(libcompat_squid_a_DEPENDENCIES) $(EXTRA_libcompat_squid_a_DEPENDENCIES) 
-	$(AM_V_at)-rm -f libcompat-squid.a
-	$(AM_V_AR)$(libcompat_squid_a_AR) libcompat-squid.a $(libcompat_squid_a_OBJECTS) $(libcompat_squid_a_LIBADD)
-	$(AM_V_at)$(RANLIB) libcompat-squid.a
+libcompat-squid.la: $(libcompat_squid_la_OBJECTS) $(libcompat_squid_la_DEPENDENCIES) $(EXTRA_libcompat_squid_la_DEPENDENCIES) 
+	$(AM_V_CXXLD)$(CXXLINK)  $(libcompat_squid_la_OBJECTS) $(libcompat_squid_la_LIBADD) $(LIBS)
 
 clean-checkPROGRAMS:
 	@list='$(check_PROGRAMS)'; test -n "$$list" || exit 0; \
 	echo " rm -f" $$list; \
 	rm -f $$list || exit $$?; \
 	test -n "$(EXEEXT)" || exit 0; \
@@ -781,38 +830,37 @@
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/drand48.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/eui64_aton.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/getaddrinfo.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/getnameinfo.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/inet_ntop.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/inet_pton.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/initgroups.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/psignal.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/strerror.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/strsep.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/strtoll.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/tempnam.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/GnuRegex.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/assert.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/compat.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/debug.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mswin.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/shm.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/strnrchr.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/strnstr.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/drand48.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/getaddrinfo.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/getnameinfo.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/inet_ntop.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/inet_pton.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/initgroups.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/psignal.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/strerror.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/strtoll.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/tempnam.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/GnuRegex.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/assert.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/compat.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/debug.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eui64_aton.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mswindows.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/shm.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/strnrchr.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/strnstr.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testMain.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testPreCompiler.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xalloc.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xstrerror.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xstring.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xstrto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xalloc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xstrerror.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xstring.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xstrto.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
@@ -1126,13 +1174,13 @@
 	  fi; \
 	done
 check-am: all-am
 	$(MAKE) $(AM_MAKEFLAGS) $(check_PROGRAMS)
 	$(MAKE) $(AM_MAKEFLAGS) check-TESTS
 check: check-am
-all-am: Makefile $(LIBRARIES)
+all-am: Makefile $(LTLIBRARIES)
 installdirs:
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
 uninstall: uninstall-am
 
@@ -1165,13 +1213,13 @@
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
 	@echo "it deletes files that may require special tools to rebuild."
 clean: clean-am
 
 clean-am: clean-checkPROGRAMS clean-generic clean-libtool \
-	clean-noinstLIBRARIES mostlyclean-am
+	clean-noinstLTLIBRARIES mostlyclean-am
 
 distclean: distclean-am
 	-rm -rf $(DEPDIR) ./$(DEPDIR)
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
@@ -1237,13 +1285,13 @@
 uninstall-am:
 
 .MAKE: check-am install-am install-strip
 
 .PHONY: CTAGS GTAGS TAGS all all-am check check-TESTS check-am clean \
 	clean-checkPROGRAMS clean-generic clean-libtool \
-	clean-noinstLIBRARIES cscopelist-am ctags ctags-am distclean \
+	clean-noinstLTLIBRARIES cscopelist-am ctags ctags-am distclean \
 	distclean-compile distclean-generic distclean-libtool \
 	distclean-tags distdir dvi dvi-am html html-am info info-am \
 	install install-am install-data install-data-am install-dvi \
 	install-dvi-am install-exec install-exec-am install-html \
 	install-html-am install-info install-info-am install-man \
 	install-pdf install-pdf-am install-ps install-ps-am \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat: mswin.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat: mswindows.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/os: android.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/os/hpux.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/os/hpux.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/os/hpux.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/os/hpux.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,8 +1,8 @@
 #ifndef SQUID_OS_HPUX_H
-#define SQUID_OS_PHUX_H
+#define SQUID_OS_HPUX_H
 
 #if _SQUID_HPUX_
 
 /****************************************************************************
  *--------------------------------------------------------------------------*
  * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/os: mswindows.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/os: mswin.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/os/solaris.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/os/solaris.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/os/solaris.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/os/solaris.h	2015-05-01 18:05:19.000000000 +0800
@@ -98,11 +98,8 @@
 #include <paths.h>
 #endif
 #if !defined(_PATH_DEVNULL)
 #define _PATH_DEVNULL "/dev/null"
 #endif
 
-/* Solaris 10 does not define strsep() */
-#include "compat/strsep.h"
-
 #endif /* _SQUID_SOLARIS_ */
 #endif /* SQUID_OS_SOALRIS_H */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/os: windows.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/psignal.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/psignal.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/psignal.c	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/psignal.c	2015-05-01 18:05:19.000000000 +0800
@@ -2,13 +2,13 @@
  * Author:   Jens-S. V?ckler <voeckler@rvs.uni-hannover.de>
  * Ripped from Purge tool implementation.
  */
 #include "squid.h"
 #include "psignal.h"
 
-#if _SQUID_AIX_ || _SQUID_MINGW_
+#if _SQUID_AIX_ || _SQUID_ANDROID_ || _SQUID_MINGW_
 extern const char* const sys_siglist[];
 #define _sys_nsig 64
 #define _sys_siglist sys_siglist
 #endif
 
 /// purpose: print message, colon, space, signal name and LF.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/stdio.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/stdio.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/stdio.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/stdio.h	2015-05-01 18:05:19.000000000 +0800
@@ -43,14 +43,14 @@
 inline FILE * tmpfile(void) { return tmpfile64(); }
 #endif
 
 #endif /* __USE_FILE_OFFSET64 && !__REDIRECT */
 
 // Finally import the <cstdio> stuff we actually use
-#if HAVE_CSTDIO
-#include<cstdio>
+#if HAVE_CSTDIO && defined(__cplusplus)
+#include <cstdio>
 #endif
 
 #ifndef MAXPATHLEN
 #define MAXPATHLEN SQUID_MAXPATHLEN
 #endif
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat: strsep.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat: strsep.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat: unsafe.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/xalloc.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/xalloc.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/xalloc.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/xalloc.cc	2015-05-01 18:05:19.000000000 +0800
@@ -89,15 +89,12 @@
 #if XMALLOC_DEBUG
     check_malloc(p, sz * n);
 #endif
 #if XMALLOC_STATISTICS
     malloc_stat(sz * n);
 #endif
-#if XMALLOC_TRACE
-    xmalloc_show_trace(p, 1);
-#endif
 #if MEM_GEN_TRACE
     if (tracefp)
         fprintf(tracefp, "c:%u:%u:%p\n", (unsigned int) n, (unsigned int) sz, p);
 #endif
 
     PROF_stop(xcalloc);
@@ -130,15 +127,12 @@
 #if XMALLOC_DEBUG
     check_malloc(p, sz);
 #endif
 #if XMALLOC_STATISTICS
     malloc_stat(sz);
 #endif
-#if XMALLOC_TRACE
-    xmalloc_show_trace(p, 1);
-#endif
 #if MEM_GEN_TRACE
     if (tracefp)
         fprintf(tracefp, "m:%d:%p\n", sz, p);
 #endif
 
     PROF_stop(xmalloc);
@@ -146,15 +140,12 @@
 }
 
 void *
 xrealloc(void *s, size_t sz)
 {
     PROF_start(xrealloc);
-#if XMALLOC_TRACE
-    xmalloc_show_trace(s, -1);
-#endif
 
     if (sz < 1)
         sz = 1;
 
 #if XMALLOC_DEBUG
     if (s != NULL)
@@ -179,15 +170,12 @@
 #if XMALLOC_DEBUG
     check_malloc(p, sz);
 #endif
 #if XMALLOC_STATISTICS
     malloc_stat(sz);
 #endif
-#if XMALLOC_TRACE
-    xmalloc_show_trace(p, 1);
-#endif
 #if MEM_GEN_TRACE
     if (tracefp)                /* new ptr, old ptr, new size */
         fprintf(tracefp, "r:%p:%p:%d\n", p, s, sz);
 #endif
     PROF_stop(xrealloc);
     return (p);
@@ -196,15 +184,12 @@
 void
 free_const(const void *s_const)
 {
     void *s = const_cast<void *>(s_const);
 
     PROF_start(free_const);
-#if XMALLOC_TRACE
-    xmalloc_show_trace(s, -1);
-#endif
 
 #if XMALLOC_DEBUG
     check_free(s);
 #endif
 
     PROF_start(free);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/xstrto.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/xstrto.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/compat/xstrto.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/compat/xstrto.cc	2015-05-01 18:05:19.000000000 +0800
@@ -52,17 +52,16 @@
 #endif
 
 bool
 xstrtoul(const char *s, char **end, unsigned long *value,
          unsigned long min, unsigned long max)
 {
-    unsigned long v;
-    char *my_end;
+    char *my_end = NULL;
 
     errno = 0;
-    v = strtoul(s, &my_end, 0);
+    unsigned long v = strtoul(s, &my_end, 0);
 
     if (my_end == s)
         return false;
     if (end != NULL)
         *end = my_end;
 
@@ -78,16 +77,14 @@
 }
 
 bool
 xstrtoui(const char *s, char **end, unsigned int *value,
          unsigned int min, unsigned int max)
 {
-    unsigned long v;
-    bool ret;
-
-    ret = xstrtoul(s, end, &v, min, max);
+    unsigned long v = 0;
+    bool ret = xstrtoul(s, end, &v, min, max);
     if (value != NULL) {
         *value = v;
 
         if (v != static_cast<unsigned long>(*value)) {
             return false;
         }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/configure	2015-05-01 16:52:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/configure	2015-05-01 18:07:10.000000000 +0800
@@ -1,10 +1,10 @@
 #! /bin/sh
 # From configure.ac Revision.
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for Squid Web Proxy 3.3.14.
+# Generated by GNU Autoconf 2.69 for Squid Web Proxy 3.4.13.
 #
 # Report bugs to <http://bugs.squid-cache.org/>.
 #
 #
 # Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
 #
@@ -592,14 +592,14 @@
 MFLAGS=
 MAKEFLAGS=
 
 # Identity of this package.
 PACKAGE_NAME='Squid Web Proxy'
 PACKAGE_TARNAME='squid'
-PACKAGE_VERSION='3.3.14'
-PACKAGE_STRING='Squid Web Proxy 3.3.14'
+PACKAGE_VERSION='3.4.13'
+PACKAGE_STRING='Squid Web Proxy 3.4.13'
 PACKAGE_BUGREPORT='http://bugs.squid-cache.org/'
 PACKAGE_URL=''
 
 ac_unique_file="src/main.cc"
 ac_default_prefix=/usr/local/squid
 # Factoring default headers for most tests.
@@ -673,15 +673,16 @@
 SQUID_CPPUNIT_LA
 SQUID_CPPUNIT_LIBS
 ENABLE_XPROF_STATS_FALSE
 ENABLE_XPROF_STATS_TRUE
 ENABLE_UNLINKD_FALSE
 ENABLE_UNLINKD_TRUE
-LIBSASL
+STOREID_REWRITE_HELPERS
 URL_REWRITE_HELPERS
 EXTERNAL_ACL_HELPERS
+WBINFO
 HAVE_SPNEGO_FALSE
 HAVE_SPNEGO_TRUE
 KRB5LIBS
 KRB5INCS
 ac_krb5_config
 LOG_DAEMON_HELPERS
@@ -696,12 +697,14 @@
 NTLM_AUTH_HELPERS
 ENABLE_AUTH_NTLM_FALSE
 ENABLE_AUTH_NTLM_TRUE
 BASIC_AUTH_HELPERS
 ENABLE_AUTH_BASIC_FALSE
 ENABLE_AUTH_BASIC_TRUE
+SMBCLIENT
+LIBSASL
 ENABLE_AUTH_FALSE
 ENABLE_AUTH_TRUE
 DEFAULT_HOSTS
 USE_SSL_CRTD_FALSE
 USE_SSL_CRTD_TRUE
 ENABLE_DNSHELPER_FALSE
@@ -709,12 +712,13 @@
 MAKE_LEAKFINDER_FALSE
 MAKE_LEAKFINDER_TRUE
 EPOLL_LIBS
 SSLLIB
 ENABLE_SSL_FALSE
 ENABLE_SSL_TRUE
+NETTLELIB
 ENABLE_HTCP_FALSE
 ENABLE_HTCP_TRUE
 USE_SQUID_EUI_FALSE
 USE_SQUID_EUI_TRUE
 EUILIB
 makesnmplib
@@ -830,12 +834,13 @@
 TRUE
 FALSE
 SH
 LN_S
 CPP
 RANLIB
+HAVE_CXX11
 EGREP
 GREP
 CXXCPP
 HOSTCXX
 host_os
 host_vendor
@@ -939,12 +944,13 @@
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
 enable_silent_rules
 enable_maintainer_mode
 enable_dependency_tracking
+enable_arch_native
 enable_strict_error_checking
 enable_loadable_modules
 enable_shared
 enable_static
 with_pic
 enable_fast_install
@@ -982,12 +988,13 @@
 enable_wccpv2
 enable_kill_parent_hack
 enable_snmp
 enable_cachemgr_hostname
 enable_eui
 enable_htcp
+with_nettle
 enable_ssl
 with_openssl
 enable_forw_via_db
 enable_cache_digests
 with_coss_membuf_size
 enable_select
@@ -996,12 +1003,13 @@
 enable_epoll
 enable_devpoll
 enable_http_violations
 enable_ipfw_transparent
 enable_ipf_transparent
 enable_pf_transparent
+with_nat_devpf
 enable_linux_netfilter
 with_netfilter_conntrack
 with_large_files
 with_build_environment
 enable_leakfinder
 enable_follow_x_forwarded_for
@@ -1015,12 +1023,13 @@
 enable_auth_negotiate
 enable_auth_digest
 enable_log_daemon_helpers
 with_krb5_config
 enable_external_acl_helpers
 enable_url_rewrite_helpers
+enable_storeid_rewrite_helpers
 with_valgrind_debug
 enable_win32_service
 enable_unlinkd
 enable_stacktraces
 enable_cpu_profiling
 enable_x_accelerator_vary
@@ -1053,14 +1062,13 @@
 PKG_CONFIG_PATH
 PKG_CONFIG_LIBDIR
 EXT_LIBECAP_CFLAGS
 EXT_LIBECAP_LIBS
 PO2HTML
 PO2TEXT'
-ac_subdirs_all='libltdl
-lib/libTrie'
+ac_subdirs_all='libltdl'
 
 # Initialize some variables set by options.
 ac_init_help=
 ac_init_version=false
 ac_unrecognized_opts=
 ac_unrecognized_sep=
@@ -1594,13 +1602,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures Squid Web Proxy 3.3.14 to adapt to many kinds of systems.
+\`configure' configures Squid Web Proxy 3.4.13 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1664,13 +1672,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of Squid Web Proxy 3.3.14:";;
+     short | recursive ) echo "Configuration of Squid Web Proxy 3.4.13:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
@@ -1681,12 +1689,16 @@
                           enable make rules and dependencies not useful (and
                           sometimes confusing) to the casual installer
   --enable-dependency-tracking
                           do not reject slow dependency extractors
   --disable-dependency-tracking
                           speeds up one-time build
+  --disable-arch-native   Some compilers offer CPU-specific optimizations with
+                          the -march=native parameter. This flag disables the
+                          optimization. The default is to auto-detect compiler
+                          support and use where available.
   --disable-strict-error-checking
                           By default squid is compiled with all possible
                           static compiler error-checks enabled. This flag
                           disables the behavior
   --disable-loadable-modules
                           do not support loadable modules
@@ -1854,12 +1866,20 @@
                           This option selects which url_rewrite helpers to
                           build and install as part of the normal build
                           process. The default is to attempt the build of all
                           possible helpers. Use --disable-url-rewrite-helpers
                           to build none. For a list of available helpers see
                           the helpers/url_rewrite directory.
+  --enable-storeid-rewrite-helpers="list of helpers"
+                          This option selects which Store-ID rewrite helpers
+                          to build and install as part of the normal build
+                          process. The default is to attempt the build of all
+                          possible helpers. Use
+                          --disable-storeid-rewrite-helpers to build none. For
+                          a list of available helpers see the
+                          helpers/storeid_rewrite directory.
   --enable-win32-service  Compile Squid as a WIN32 Service. Works only on
                           MS-Windows platforms
   --disable-unlinkd       Do not use unlinkd
   --enable-stacktraces    Enable automatic call backtrace on fatal errors
   --enable-cpu-profiling  Enable instrumentation to try and understand how CPU
                           power is spent by squid, by enabling specific probes
@@ -1880,15 +1900,15 @@
   --enable-zph-qos        Enable ZPH QOS support
   --enable-gnuregex       Compile GNUregex. Unless you have reason to use this
                           option, you should not enable it. This library file
                           is usually only required on Windows and very old
                           Unix boxes which do not have their own regex library
                           built in.
-  --disable-translation   Prevent Squid generating localized error page
-                          templates and manuals. Which is usually tried, but
-                          may not be needed.
+  --enable-translation    Generate the localized error page templates and
+                          manuals. Which can also be downloaded from
+                          http://www.squid-cache.org/Versions/langpack/.
   --disable-auto-locale   This prevents Squid providing localized error pages
                           based on the clients request headers. When disabled
                           Squid requires explicit language configuration.
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -1915,19 +1935,22 @@
                           object store.
   --with-dl               Use dynamic linking
   --without-pthreads      Disable POSIX Threads
   --without-aio           Do not use POSIX AIO. Default: auto-detect
   --without-expat         Do not use expat for ESI. Default: auto-detect
   --without-libxml2       Do not use libxml2 for ESI. Default: auto-detect
+  --without-nettle        Compile without the Nettle crypto library.
   --with-openssl=PATH     Compile with the OpenSSL libraries. The path to the
                           OpenSSL development libraries and headers
                           installation can be specified if outside of the
                           system standard directories
   --with-coss-membuf-size=size
                           COSS membuf size (default
                           $squid_opt_coss_membuf_size bytes)
+  --with-nat-devpf        Enable /dev/pf support for NAT on older OpenBSD and
+                          FreeBSD kernels.
   --without-netfilter-conntrack
                           Do not use Netfilter conntrack libraries for packet
                           marking. A path to alternative library location may
                           be specified by using
                           --with-netfilter-conntrack=PATH. Default:
                           auto-detect.
@@ -2045,13 +2068,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-Squid Web Proxy configure 3.3.14
+Squid Web Proxy configure 3.4.13
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -2135,12 +2158,58 @@
 fi
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_cxx_try_compile
 
+# ac_fn_cxx_try_link LINENO
+# -------------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_cxx_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 test -x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_cxx_try_link
+
 # ac_fn_cxx_try_cpp LINENO
 # ------------------------
 # Try to preprocess conftest.$ac_ext, and return whether this succeeded.
 ac_fn_cxx_try_cpp ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
@@ -2517,58 +2586,12 @@
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_func
 
-# ac_fn_cxx_try_link LINENO
-# -------------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded.
-ac_fn_cxx_try_link ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext conftest$ac_exeext
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 test -x conftest$ac_exeext
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
-  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
-  # interfere with the next link command; also delete a directory that is
-  # left behind by Apple's compiler.  We do this before executing the actions.
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_cxx_try_link
-
 # ac_fn_cxx_check_decl LINENO SYMBOL VAR INCLUDES
 # -----------------------------------------------
 # Tests whether SYMBOL is declared in INCLUDES, setting cache variable VAR
 # accordingly.
 ac_fn_cxx_check_decl ()
 {
@@ -2776,69 +2799,12 @@
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_cxx_check_func
 
-# ac_fn_cxx_check_member LINENO AGGR MEMBER VAR INCLUDES
-# ------------------------------------------------------
-# Tries to find if the field MEMBER exists in type AGGR, after including
-# INCLUDES, setting cache variable VAR accordingly.
-ac_fn_cxx_check_member ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2.$3" >&5
-$as_echo_n "checking for $2.$3... " >&6; }
-if eval \${$4+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$5
-int
-main ()
-{
-static $2 ac_aggr;
-if (ac_aggr.$3)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  eval "$4=yes"
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$5
-int
-main ()
-{
-static $2 ac_aggr;
-if (sizeof ac_aggr.$3)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  eval "$4=yes"
-else
-  eval "$4=no"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$4
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_cxx_check_member
-
 # ac_fn_cxx_compute_int LINENO EXPR VAR INCLUDES
 # ----------------------------------------------
 # Tries to find the compile-time value of EXPR in a program that includes
 # INCLUDES, setting VAR accordingly. Returns whether the value could be
 # computed
 ac_fn_cxx_compute_int ()
@@ -3016,12 +2982,69 @@
   fi
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_cxx_compute_int
 
+# ac_fn_cxx_check_member LINENO AGGR MEMBER VAR INCLUDES
+# ------------------------------------------------------
+# Tries to find if the field MEMBER exists in type AGGR, after including
+# INCLUDES, setting cache variable VAR accordingly.
+ac_fn_cxx_check_member ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2.$3" >&5
+$as_echo_n "checking for $2.$3... " >&6; }
+if eval \${$4+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$5
+int
+main ()
+{
+static $2 ac_aggr;
+if (ac_aggr.$3)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  eval "$4=yes"
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$5
+int
+main ()
+{
+static $2 ac_aggr;
+if (sizeof ac_aggr.$3)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  eval "$4=yes"
+else
+  eval "$4=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$4
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_cxx_check_member
+
 # ac_fn_c_find_intX_t LINENO BITS VAR
 # -----------------------------------
 # Finds a signed integer type with width BITS, setting cache variable VAR
 # accordingly.
 ac_fn_c_find_intX_t ()
 {
@@ -3149,13 +3172,13 @@
 
 } # ac_fn_c_find_uintX_t
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by Squid Web Proxy $as_me 3.3.14, which was
+It was created by Squid Web Proxy $as_me 3.4.13, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 exec 5>>config.log
@@ -4016,13 +4039,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='squid'
- VERSION='3.3.14'
+ VERSION='3.4.13'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -4514,53 +4542,50 @@
 
 
 
 
 
 # ============================================================================
-#  http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_0x.html
+#  http://www.gnu.org/software/autoconf-archive/ax_cxx_compile_stdcxx_11.html
 # ============================================================================
 #
 # SYNOPSIS
 #
-#   AX_CXX_COMPILE_STDCXX_0X
+#   AX_CXX_COMPILE_STDCXX_11([ext|noext],[mandatory|optional])
 #
 # DESCRIPTION
 #
-#   Check for baseline language coverage in the compiler for the C++0x
-#   standard.
+#   Check for baseline language coverage in the compiler for the C++11
+#   standard; if necessary, add switches to CXXFLAGS to enable support.
+#
+#   The first argument, if specified, indicates whether you insist on an
+#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
+#   -std=c++11).  If neither is specified, you get whatever works, with
+#   preference for an extended mode.
+#
+#   The second argument, if specified 'mandatory' or if left unspecified,
+#   indicates that baseline C++11 support is required and that the macro
+#   should error out if no mode with that support is found.  If specified
+#   'optional', then configuration proceeds regardless, after defining
+#   HAVE_CXX11 if and only if a supporting mode is found.
 #
 # LICENSE
 #
 #   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
+#   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
+#   Copyright (c) 2014 Alexey Sokolov <sokolov@google.com>
 #
 #   Copying and distribution of this file, with or without modification, are
 #   permitted in any medium without royalty provided the copyright notice
 #   and this notice are preserved. This file is offered as-is, without any
 #   warranty.
 
-#serial 7
+#serial 4
+
 
-# This is what autoupdate's m4 run will expand.  It fires
-# the warning (with _au_warn_XXX), outputs it into the
-# updated configure.ac (with AC_DIAGNOSE), and then outputs
-# the replacement expansion.
-
-
-# This is an auxiliary macro that is also run when
-# autoupdate runs m4.  It simply calls m4_warning, but
-# we need a wrapper so that each warning is emitted only
-# once.  We break the quoting in m4_warning's argument in
-# order to expand this macro's arguments, not AU_DEFUN's.
-
-
-# Finally, this is the expansion that is picked up by
-# autoconf.  It tells the user to run autoupdate, and
-# then outputs the replacement expansion.  We do not care
-# about autoupdate's warning because that contains
-# information on what to do *after* running autoupdate.
 
 
 
 ## Shamelessly copied from the DUNE sources under GPL version 2
 ##
 
@@ -6078,15 +6103,80 @@
 host_os=$*
 IFS=$ac_save_IFS
 case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
 
-# might be cross-compiling
+# Clang 3.2 on some CPUs requires -march-native to detect correctly.
+# GCC 4.3+ can also produce faster executables when its used.
+# But building inside a virtual machine environment has been found to
+# cause random Illegal Instruction errors due to mis-detection of CPU.
+# Check whether --enable-arch-native was given.
+if test "${enable_arch_native+set}" = set; then :
+  enableval=$enable_arch_native;
+
+if test "$enableval" != "yes" -a "$enableval" != "no" ; then
+  as_fn_error $? "Unrecognized argument to --disable-arch-native: $enableval" "$LINENO" 5
+fi
+
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: CPU -march=native optimization enabled: ${enable_arch_native:=auto}" >&5
+$as_echo "$as_me: CPU -march=native optimization enabled: ${enable_arch_native:=auto}" >&6;}
+if test "x${enable_arch_native}" != "xno"; then
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler accepts -march=native" >&5
+$as_echo_n "checking whether compiler accepts -march=native... " >&6; }
+if ${squid_cv_check_marchnative+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  {
+
+    SAVED_FLAGS="$CFLAGS"
+    SAVED_CXXFLAGS="$CXXFLAGS"
+    CFLAGS="$CFLAGS -march=native"
+    CXXFLAGS="$CXXFLAGS -march=native"
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+int foo;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  squid_cv_check_marchnative=yes
+else
+  squid_cv_check_marchnative=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    CFLAGS="$SAVED_CFLAGS"
+    CXXFLAGS="$SAVED_CXXFLAGS"
+  }
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $squid_cv_check_marchnative" >&5
+$as_echo "$squid_cv_check_marchnative" >&6; }
+
+fi
+
+# might be cross-compiling.
 if test "x$HOSTCXX" = "x"; then
   HOSTCXX="$CXX"
+  if test "x$squid_cv_check_marchnative" = "xyes"; then
+    CXXFLAGS="$CXXFLAGS -march=native"
+  fi
+fi
+if test "x$squid_cv_check_marchnative" = "xyes"; then
+  # always valid for the Host compiler.
+  HOSTCXX="$HOSTCXX -march=native"
 fi
 
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking simplified host os" >&5
 $as_echo_n "checking simplified host os... " >&6; }
 simple_host_os=`echo $host_os|sed 's/0-9.*//g;s/-.*//g'`
@@ -6100,14 +6190,13 @@
 $as_echo "$squid_host_os (version $squid_host_os_version)" >&6; }
 # on windows squid_host_os is either mingw or cygwin, version is 32
 
 # this needs to be before any test is run, to have more standard
 # functions available on some Unix sysems (e.g. Solaris)
 if test "x$squid_host_os" = "solaris" -a "x$GCC" != "x" ; then
-
-ac_ext=cpp
+	ac_ext=cpp
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C++ preprocessor" >&5
 $as_echo_n "checking how to run the C++ preprocessor... " >&6; }
@@ -6557,198 +6646,158 @@
 
   $as_echo "#define _TANDEM_SOURCE 1" >>confdefs.h
 
 
 fi
 
-# Check for C++0x compiler support
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if g++ supports C++0x features without additional flags" >&5
-$as_echo_n "checking if g++ supports C++0x features without additional flags... " >&6; }
-if ${ax_cv_cxx_compile_cxx0x_native+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-  ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-  template <typename T>
-    struct check
-    {
-      static_assert(sizeof(int) <= sizeof(T), "not big enough");
-    };
-
-    typedef check<check<bool>> right_angle_brackets;
-
-    int a;
-    decltype(a) b;
-
-    typedef check<int> check_type;
-    check_type c;
-    check_type&& cr = static_cast<check_type&&>(c);
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ax_cv_cxx_compile_cxx0x_native=yes
-else
-  ax_cv_cxx_compile_cxx0x_native=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+# Check for C++11 compiler support
+if test "x$squid_host_os" != "xmingw" ; then
+    #BUG 3613: when clang -std=c++0x is used, it activates a "strict mode"
+    # in the system libraries, which makes some c99 methods unavailable
+    # (e.g. strtoll), yet configure detects them as avilable.
+    case "$CXX" in
+      *clang++*) ;; #do nothing
+      *)
+          ax_cxx_compile_cxx11_required=false
   ac_ext=cpp
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_cxx_compile_cxx0x_native" >&5
-$as_echo "$ax_cv_cxx_compile_cxx0x_native" >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if g++ supports C++0x features with -std=c++0x" >&5
-$as_echo_n "checking if g++ supports C++0x features with -std=c++0x... " >&6; }
-if ${ax_cv_cxx_compile_cxx0x_cxx+:} false; then :
+  ac_success=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features by default" >&5
+$as_echo_n "checking whether $CXX supports C++11 features by default... " >&6; }
+if ${ax_cv_cxx_compile_cxx11+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-
-  ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-  ac_save_CXXFLAGS="$CXXFLAGS"
-  CXXFLAGS="$CXXFLAGS -std=c++0x"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
   template <typename T>
     struct check
     {
       static_assert(sizeof(int) <= sizeof(T), "not big enough");
     };
 
+    struct Base {
+    virtual void f() {}
+    };
+    struct Child : public Base {
+    virtual void f() override {}
+    };
+
     typedef check<check<bool>> right_angle_brackets;
 
     int a;
     decltype(a) b;
 
     typedef check<int> check_type;
     check_type c;
     check_type&& cr = static_cast<check_type&&>(c);
-int
-main ()
-{
 
-  ;
-  return 0;
-}
+    auto d = a;
+    auto l = [](){};
+
 _ACEOF
 if ac_fn_cxx_try_compile "$LINENO"; then :
-  ax_cv_cxx_compile_cxx0x_cxx=yes
+  ax_cv_cxx_compile_cxx11=yes
 else
-  ax_cv_cxx_compile_cxx0x_cxx=no
+  ax_cv_cxx_compile_cxx11=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  CXXFLAGS="$ac_save_CXXFLAGS"
-  ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_cxx_compile_cxx11" >&5
+$as_echo "$ax_cv_cxx_compile_cxx11" >&6; }
+  if test x$ax_cv_cxx_compile_cxx11 = xyes; then
+    ac_success=yes
+  fi
 
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_cxx_compile_cxx0x_cxx" >&5
-$as_echo "$ax_cv_cxx_compile_cxx0x_cxx" >&6; }
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if g++ supports C++0x features with -std=gnu++0x" >&5
-$as_echo_n "checking if g++ supports C++0x features with -std=gnu++0x... " >&6; }
-if ${ax_cv_cxx_compile_cxx0x_gxx+:} false; then :
+    if test x$ac_success = xno; then
+    for switch in -std=c++11 -std=c++0x; do
+      cachevar=`$as_echo "ax_cv_cxx_compile_cxx11_$switch" | $as_tr_sh`
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch" >&5
+$as_echo_n "checking whether $CXX supports C++11 features with $switch... " >&6; }
+if eval \${$cachevar+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-
-  ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
   ac_save_CXXFLAGS="$CXXFLAGS"
-  CXXFLAGS="$CXXFLAGS -std=gnu++0x"
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+         CXXFLAGS="$CXXFLAGS $switch"
+         cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
   template <typename T>
     struct check
     {
       static_assert(sizeof(int) <= sizeof(T), "not big enough");
     };
 
+    struct Base {
+    virtual void f() {}
+    };
+    struct Child : public Base {
+    virtual void f() override {}
+    };
+
     typedef check<check<bool>> right_angle_brackets;
 
     int a;
     decltype(a) b;
 
     typedef check<int> check_type;
     check_type c;
     check_type&& cr = static_cast<check_type&&>(c);
-int
-main ()
-{
 
-  ;
-  return 0;
-}
+    auto d = a;
+    auto l = [](){};
+
 _ACEOF
 if ac_fn_cxx_try_compile "$LINENO"; then :
-  ax_cv_cxx_compile_cxx0x_gxx=yes
+  eval $cachevar=yes
 else
-  ax_cv_cxx_compile_cxx0x_gxx=no
+  eval $cachevar=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  CXXFLAGS="$ac_save_CXXFLAGS"
+         CXXFLAGS="$ac_save_CXXFLAGS"
+fi
+eval ac_res=\$$cachevar
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+      if eval test x\$$cachevar = xyes; then
+        CXXFLAGS="$CXXFLAGS $switch"
+        ac_success=yes
+        break
+      fi
+    done
+  fi
   ac_ext=cpp
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
+  if test x$ax_cxx_compile_cxx11_required = xtrue; then
+    if test x$ac_success = xno; then
+      as_fn_error $? "*** A compiler with support for C++11 language features is required." "$LINENO" 5
+    fi
+  else
+    if test x$ac_success = xno; then
+      HAVE_CXX11=0
+      { $as_echo "$as_me:${as_lineno-$LINENO}: No compiler with C++11 support was found" >&5
+$as_echo "$as_me: No compiler with C++11 support was found" >&6;}
+    else
+      HAVE_CXX11=1
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ax_cv_cxx_compile_cxx0x_gxx" >&5
-$as_echo "$ax_cv_cxx_compile_cxx0x_gxx" >&6; }
+$as_echo "#define HAVE_CXX11 1" >>confdefs.h
 
-  if test "$ax_cv_cxx_compile_cxx0x_native" = yes ||
-     test "$ax_cv_cxx_compile_cxx0x_cxx" = yes ||
-     test "$ax_cv_cxx_compile_cxx0x_gxx" = yes; then
+    fi
 
-$as_echo "#define HAVE_STDCXX_0X /**/" >>confdefs.h
 
   fi
 
-if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" -a \
-  "x$squid_host_os" != "xmingw" ; then
-    #BUG 3613: when clang -std=c++0x is used, it activates a "strict mode"
-    # in the system libraries, which makes some c99 methods unavailable
-    # (e.g. strtoll), yet configure detects them as avilable.
-    case "$CXX" in
-      *clang++*) ;; #do nothing
-      *) CXXFLAGS="$CXXFLAGS -std=c++0x" ;;
     esac
 fi
 
 # test for programs
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
@@ -19822,19 +19871,19 @@
   fi
 fi
 
 if test "$squid_cv_compiler" = "gcc"; then
   case "$squid_host_os" in
   mingw)
-    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments"
+    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow"
     ;;
   *)
-    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments"
+    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments -Wshadow"
     ;;
   esac
-  SQUID_CXXFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments"
+  SQUID_CXXFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow"
 else
   SQUID_CFLAGS=
   SQUID_CXXFLAGS=
 fi
 
 if test "x$enable_strict_error_checking" != "xno"; then
@@ -19916,19 +19965,17 @@
       squid_build_info=$enableval
       ;;
   esac
 
 fi
 
-  if test "x${squid_build_info:=no}" != "xno"; then
 
 cat >>confdefs.h <<_ACEOF
 #define SQUID_BUILD_INFO "$squid_build_info"
 _ACEOF
 
-  fi
 
 
 # Check whether --enable-optimizations was given.
 if test "${enable_optimizations+set}" = set; then :
   enableval=$enable_optimizations;
 if test "x$enableval" = "xno" ; then
@@ -19973,16 +20020,15 @@
 # to be used by sub-commands
 export enable_inline
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU atomic operations support" >&5
 $as_echo_n "checking for GNU atomic operations support... " >&6; }
 if test "$cross_compiling" = yes; then :
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot run test program while cross compiling
-See \`config.log' for more details" "$LINENO" 5; }
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: cross-compiler cant tell" >&5
+$as_echo "cross-compiler cant tell" >&6; }
+
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
     int n = 0;
 
@@ -21790,13 +21834,13 @@
 else
   ENABLE_SNMP_TRUE='#'
   ENABLE_SNMP_FALSE=
 fi
 
 if test "x$enable_snmp" = "xyes"; then
-    SNMPLIB='../snmplib/libsnmplib.a'
+    SNMPLIB='../snmplib/libsnmplib.la'
     makesnmplib=snmplib
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: SNMP support enabled: $enable_snmp" >&5
 $as_echo "$as_me: SNMP support enabled: $enable_snmp" >&6;}
 
 
@@ -21849,13 +21893,13 @@
       ;;
     *)
       { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: EUI support probably will not work on host $host." >&5
 $as_echo "$as_me: WARNING: EUI support probably will not work on host $host." >&2;}
       ;;
   esac
-  #Iphlpapi.h check delayed after winsock2.h
+  # iphlpapi.h check delayed after winsock2.h
   for ac_header in \
     windows.h \
     sys/sockio.h \
     sys/param.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
@@ -21977,12 +22021,93 @@
   ENABLE_HTCP_FALSE=
 fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: HTCP support enabled: $enable_htcp" >&5
 $as_echo "$as_me: HTCP support enabled: $enable_htcp" >&6;}
 
+# Cryptograhic libraries
+
+# Check whether --with-nettle was given.
+if test "${with_nettle+set}" = set; then :
+  withval=$with_nettle;
+case "$with_nettle" in
+  yes|no)
+    : # Nothing special to do here
+    ;;
+  *)
+    if test ! -d "$withval" ; then
+      as_fn_error $? "--with-nettle path does not point to a directory" "$LINENO" 5
+    fi
+    NETTLELIBDIR="-L$with_nettle/lib"
+    CPPFLAGS="-I$with_nettle/include $CPPFLAGS"
+    with_nettle=yes
+  esac
+
+fi
+
+if test "x$with_nettle" != "xno" ; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for nettle_md5_init in -lnettle" >&5
+$as_echo_n "checking for nettle_md5_init in -lnettle... " >&6; }
+if ${ac_cv_lib_nettle_nettle_md5_init+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnettle  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char nettle_md5_init ();
+int
+main ()
+{
+return nettle_md5_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_nettle_nettle_md5_init=yes
+else
+  ac_cv_lib_nettle_nettle_md5_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nettle_nettle_md5_init" >&5
+$as_echo "$ac_cv_lib_nettle_nettle_md5_init" >&6; }
+if test "x$ac_cv_lib_nettle_nettle_md5_init" = xyes; then :
+
+    NETTLELIB="$NETTLELIBDIR -lnettle"
+    for ac_header in nettle/md5.h
+do :
+  ac_fn_cxx_check_header_mongrel "$LINENO" "nettle/md5.h" "ac_cv_header_nettle_md5_h" "$ac_includes_default"
+if test "x$ac_cv_header_nettle_md5_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_NETTLE_MD5_H 1
+_ACEOF
+
+fi
+
+done
+
+
+else
+  with_nettle=no
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: Using Nettle cryptographic library: ${with_nettle:=yes}" >&5
+$as_echo "$as_me: Using Nettle cryptographic library: ${with_nettle:=yes}" >&6;}
+
 
 # SSL is not enabled by default.
 # Default is to use OpenSSL when available
 # Check whether --enable-ssl was given.
 if test "${enable_ssl+set}" = set; then :
   enableval=$enable_ssl;
@@ -22050,30 +22175,16 @@
 cat >>confdefs.h <<_ACEOF
 #define USE_SSL $squid_tmp_define
 _ACEOF
 
 unset squid_tmp_define
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: Using OpenSSL MD5 implementation: ${with_openssl:=no}" >&5
-$as_echo "$as_me: Using OpenSSL MD5 implementation: ${with_openssl:=no}" >&6;}
-
-squid_tmp_define=""
-case "${with_openssl}" in
-  yes|true|1) squid_tmp_define="1" ;;
-  no|false|0|"") squid_tmp_define="0" ;;
-  *) as_fn_error $? "SQUID_DEFINE_BOOL: unrecognized value for USE_OPENSSL: '${with_openssl}'" "$LINENO" 5 ;;
-esac
-
-cat >>confdefs.h <<_ACEOF
-#define USE_OPENSSL $squid_tmp_define
-_ACEOF
-
-unset squid_tmp_define
-
+{ $as_echo "$as_me:${as_lineno-$LINENO}: Using OpenSSL library: ${with_openssl:=no}" >&5
+$as_echo "$as_me: Using OpenSSL library: ${with_openssl:=no}" >&6;}
 if test "x$enable_ssl" = "xyes"; then
-  if test "x$SSLLIB" = "x"; then
+  if test "x$SSLLIB" = "x" -a "x$with_nettle" = "xno"; then
     SSLLIB="-lcrypto" # for MD5 routines
   fi
   # This is a workaround for RedHat 9 brain damage..
   if test -d /usr/kerberos/include -a "x$SSLLIBDIR" = "x" -a -f /usr/include/openssl/kssl.h; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: OpenSSL depends on Kerberos" >&5
 $as_echo "$as_me: OpenSSL depends on Kerberos" >&6;}
@@ -23049,14 +23160,30 @@
 fi
 
 
 fi
 
 #will be AC_DEFINEd later, after checking for appropriate infrastructure
-{ $as_echo "$as_me:${as_lineno-$LINENO}: PF-based transparent proxying requested: ${enable_pf_transparent:=auto}" >&5
-$as_echo "$as_me: PF-based transparent proxying requested: ${enable_pf_transparent:=auto}" >&6;}
+{ $as_echo "$as_me:${as_lineno-$LINENO}: PF-based transparent proxying requested: ${enable_pf_transparent:=no}" >&5
+$as_echo "$as_me: PF-based transparent proxying requested: ${enable_pf_transparent:=no}" >&6;}
+
+
+# Check whether --with-nat-devpf was given.
+if test "${with_nat_devpf+set}" = set; then :
+  withval=$with_nat_devpf;
+
+if test "$enableval" != "yes" -a "$enableval" != "no" ; then
+  as_fn_error $? "unrecognized argument to --with-nat-devpf: $enableval" "$LINENO" 5
+fi
+
+
+fi
+
+#will be AC_DEFINEd later, after checking for appropriate infrastructure
+{ $as_echo "$as_me:${as_lineno-$LINENO}: NAT lookups via /dev/pf: ${with_nat_devpf:=no}" >&5
+$as_echo "$as_me: NAT lookups via /dev/pf: ${with_nat_devpf:=no}" >&6;}
 
 # Linux Netfilter Transparent Proxy
 # Check whether --enable-linux-netfilter was given.
 if test "${enable_linux_netfilter+set}" = set; then :
   enableval=$enable_linux_netfilter;
 
@@ -23215,12 +23342,47 @@
     ;;
 esac
 
 fi
 
 
+#hack. Let's early-detect sizeof(long)
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long" >&5
+$as_echo_n "checking size of long... " >&6; }
+if ${ac_cv_sizeof_long+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_cxx_compute_int "$LINENO" "(long int) (sizeof (long))" "ac_cv_sizeof_long"        "$ac_includes_default"; then :
+
+else
+  if test "$ac_cv_type_long" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (long)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_long=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long" >&5
+$as_echo "$ac_cv_sizeof_long" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_LONG $ac_cv_sizeof_long
+_ACEOF
+
+
+
 if test "x$squid_opt_enable_large_files" = "xyes" -a "x$buildmodel" = "x"; then
   for model in POSIX_V6_LPBIG_OFFBIG XBS5_LPBIG_OFFBIG POSIX_V6_LP64_OFF64 XBS5_LP64_OFF64 POSIX_V6_ILP32_OFFBIG XBS5_ILP32_OFFBIG; do
     if test "`getconf _$model 2>/dev/null || true`" = 1 || test "`getconf $model 2>/dev/null || true`" ; then
       buildmodel=$model
       break
     fi
@@ -23228,13 +23390,14 @@
   if test "x$buildmodel" = "x"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: No suitable build environment found for large files. Trying to use _FILE_OFFSET_BITS=64" >&5
 $as_echo "$as_me: WARNING: No suitable build environment found for large files. Trying to use _FILE_OFFSET_BITS=64" >&2;}
   fi
 fi
 if test "x$buildmodel" = "xdefault" -o "x$buildmodel" = "x"; then
-  if test "x$squid_opt_enable_large_files" = "xyes" ; then
+  # define _FILE_OFFSET_BITS if requested and needed
+  if test "x$squid_opt_enable_large_files" = "xyes" -a $ac_cv_sizeof_long -le 4 ; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: Enabling -D_FILE_OFFSET_BITS=64" >&5
 $as_echo "$as_me: Enabling -D_FILE_OFFSET_BITS=64" >&6;}
     CFLAGS="-D_FILE_OFFSET_BITS=64 $CFLAGS"
     CXXFLAGS="-D_FILE_OFFSET_BITS=64 $CXXFLAGS"
   fi
 else
@@ -23511,12 +23674,17 @@
 if test "${enable_auth_basic+set}" = set; then :
   enableval=$enable_auth_basic;
 #nothing to do really
 
 fi
 
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_basic list containing double entries.
+
 #not specified. Inherit global
 if test "x$enable_auth_basic" = "x"; then
     enable_auth_basic=$enable_auth
 fi
 #conflicts with global
 if test "x$enable_auth_basic" != "xno" -a "x$enable_auth" = "xno" ; then
@@ -23543,45 +23712,452 @@
 enable_auth_basic="`echo $enable_auth_basic| sed -e 's/,/ /g;s/  */ /g'`"
 if test "x$enable_auth_basic" != "xno" ; then
     AUTH_MODULES="$AUTH_MODULES basic"
 
 $as_echo "#define HAVE_AUTH_MODULE_BASIC 1" >>confdefs.h
 
-    for helper in $enable_auth_basic
-    do
-    dir="$srcdir/helpers/basic_auth/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xSASL" ; then
-        squid_require_sasl=yes
-      fi
-    elif test -d "$srcdir/helpers/basic_auth/$helper" ; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: Basic auth helper $helper ... found but cannot be built" >&5
-$as_echo "$as_me: Basic auth helper $helper ... found but cannot be built" >&6;}
-    fi
-    done
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: Basic auth helpers to be built: $BASIC_AUTH_HELPERS" >&5
-$as_echo "$as_me: Basic auth helpers to be built: $BASIC_AUTH_HELPERS" >&6;}
- if test "x$enable_auth_basic" != "xno"; then
-  ENABLE_AUTH_BASIC_TRUE=
-  ENABLE_AUTH_BASIC_FALSE='#'
-else
-  ENABLE_AUTH_BASIC_TRUE='#'
-  ENABLE_AUTH_BASIC_FALSE=
+    for helper in $enable_auth_basic; do
+      dir="$srcdir/helpers/basic_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xDB" ; then
+        if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="DB"
 fi
 
 
+      elif test "x$helper" = "xLDAP" ; then
+        for ac_header in ldap.h winldap.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="LDAP"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xMSNT-multi-domain" ; then
+        BUILD_HELPER="MSNT-multi-domain"
+
+
+      elif test "x$helper" = "xMSNT" ; then
+        #
+# DONT build this helper on Windows
+#
+BUILD_HELPER="MSNT"
+for ac_header in w32api/windows.h windows.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER=""
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xNCSA" ; then
+        BUILD_HELPER="NCSA"
+
+
+      elif test "x$helper" = "xNIS" ; then
+        for ac_header in sys/types.h rpc/rpc.h rpcsvc/yp_prot.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "
+#if HAVE_RPC_RPC_H
+#include <rpc/rpc.h>
+#endif
+
+
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="NIS"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xPAM" ; then
+        for ac_header in security/pam_appl.h
+do :
+  ac_fn_cxx_check_header_mongrel "$LINENO" "security/pam_appl.h" "ac_cv_header_security_pam_appl_h" "$ac_includes_default"
+if test "x$ac_cv_header_security_pam_appl_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SECURITY_PAM_APPL_H 1
+_ACEOF
+
+  BUILD_HELPER="PAM"
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for PAM conversation struct signature type" >&5
+$as_echo_n "checking for PAM conversation struct signature type... " >&6; }
+if ${squid_cv_pam_conv_signature+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <security/pam_appl.h>
+static int
+password_conversation(int num_msg, const struct pam_message **msg, struct pam_response **resp, void *appdata_ptr) {}
+static struct pam_conv conv = { &password_conversation, 0 };
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+   squid_cv_pam_conv_signature=linux
+
+else
+
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <security/pam_appl.h>
+static int
+password_conversation(int num_msg, struct pam_message **msg, struct pam_response **resp, void *appdata_ptr) {}
+static struct pam_conv conv = { &password_conversation, 0 };
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+  squid_cv_pam_conv_signature=solaris
+
+else
+
+  squid_cv_pam_conv_signature=unknown
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $squid_cv_pam_conv_signature" >&5
+$as_echo "$squid_cv_pam_conv_signature" >&6; }
+  case $squid_cv_pam_conv_signature in
+    linux) $as_echo "#define PAM_CONV_FUNC_CONST_PARM const" >>confdefs.h
+ ;;
+    solaris) $as_echo "#define PAM_CONV_FUNC_CONST_PARM /**/" >>confdefs.h
+ ;;
+    *) $as_echo "#define PAM_CONV_FUNC_CONST_PARM /**/" >>confdefs.h
+ ;;
+  esac
+
+
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xPOP3" ; then
+        BUILD_HELPER="POP3"
+
+
+      elif test "x$helper" = "xRADIUS" ; then
+        BUILD_HELPER="RADIUS"
+
+
+      elif test "x$helper" = "xSASL" ; then
+
+  squid_cv_check_sasl="auto"
+  for ac_header in sasl/sasl.h sasl.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sasl_errstring in -lsasl2" >&5
+$as_echo_n "checking for sasl_errstring in -lsasl2... " >&6; }
+if ${ac_cv_lib_sasl2_sasl_errstring+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsasl2  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char sasl_errstring ();
+int
+main ()
+{
+return sasl_errstring ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_sasl2_sasl_errstring=yes
+else
+  ac_cv_lib_sasl2_sasl_errstring=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sasl2_sasl_errstring" >&5
+$as_echo "$ac_cv_lib_sasl2_sasl_errstring" >&6; }
+if test "x$ac_cv_lib_sasl2_sasl_errstring" = xyes; then :
+  LIBSASL="-lsasl2"
+else
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sasl_errstring in -lsasl" >&5
+$as_echo_n "checking for sasl_errstring in -lsasl... " >&6; }
+if ${ac_cv_lib_sasl_sasl_errstring+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsasl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char sasl_errstring ();
+int
+main ()
+{
+return sasl_errstring ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_sasl_sasl_errstring=yes
+else
+  ac_cv_lib_sasl_sasl_errstring=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sasl_sasl_errstring" >&5
+$as_echo "$ac_cv_lib_sasl_sasl_errstring" >&6; }
+if test "x$ac_cv_lib_sasl_sasl_errstring" = xyes; then :
+  LIBSASL="-lsasl"
+else
+
+      squid_cv_check_sasl="no"
+
+fi
+
+
+fi
+
+  case "$squid_host_os" in
+    Darwin)
+      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
+
+$as_echo "#define HAVE_SASL_DARWIN 1" >>confdefs.h
+
+        echo "checking for MAC Darwin without sasl.h ... yes"
+        squid_cv_check_sasl="yes"
+      else
+        echo "checking for MAC Darwin without sasl.h ... no"
+        squid_cv_check_sasl="no"
+      fi
+      ;;
+  esac
+  if test "x$squid_cv_check_sasl" = "xno"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Neither SASL nor SASL2 found" >&5
+$as_echo "$as_me: WARNING: Neither SASL nor SASL2 found" >&2;}
+  else
+    squid_cv_check_sasl="yes"
+  fi
+
+
+
+# on success, add to the built modules list
+if test "x$squid_cv_check_sasl" = "xyes"; then
+  BUILD_HELPER="SASL"
+fi
+
+
+      elif test "x$helper" = "xSMB" ; then
+        #
+# The shell script helper require smbclient to be in the environment PATH.
+# We can install anyway, but warn if smbclient not found already
+#
+# Extract the first word of "smbclient", so it can be a program name with args.
+set dummy smbclient; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_SMBCLIENT+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $SMBCLIENT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_SMBCLIENT="$SMBCLIENT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_SMBCLIENT="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+SMBCLIENT=$ac_cv_path_SMBCLIENT
+if test -n "$SMBCLIENT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $SMBCLIENT" >&5
+$as_echo "$SMBCLIENT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+if test "x$SMBCLIENT" = "x"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Samba smbclient not found in default location. basic_smb_auth may not work on this machine" >&5
+$as_echo "$as_me: WARNING: Samba smbclient not found in default location. basic_smb_auth may not work on this machine" >&2;}
+fi
+# allow script install anyway.
+BUILD_HELPER="SMB"
+
+
+      elif test "x$helper" = "xSSPI" ; then
+        #
+# Only build this helper on Windows
+#
+for ac_header in w32api/windows.h windows.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="SSPI"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xfake" ; then
+        BUILD_HELPER="fake"
+
+
+      elif test "x$helper" = "xgetpwnam" ; then
+        for ac_header in pwd.h
+do :
+  ac_fn_cxx_check_header_mongrel "$LINENO" "pwd.h" "ac_cv_header_pwd_h" "$ac_includes_default"
+if test "x$ac_cv_header_pwd_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_PWD_H 1
+_ACEOF
+ BUILD_HELPER="getpwnam"
+fi
+
+done
+
+
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/basic_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          { $as_echo "$as_me:${as_lineno-$LINENO}: Basic auth helper $helper ... found but cannot be built" >&5
+$as_echo "$as_me: Basic auth helper $helper ... found but cannot be built" >&6;}
+        else
+          BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        as_fn_error $? "Basic auth helper $helper ... not found" "$LINENO" 5
+      fi
+    done
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: Basic auth helpers to be built: $BASIC_AUTH_HELPERS" >&5
+$as_echo "$as_me: Basic auth helpers to be built: $BASIC_AUTH_HELPERS" >&6;}
+ if test "x$enable_auth_basic" != "xno"; then
+  ENABLE_AUTH_BASIC_TRUE=
+  ENABLE_AUTH_BASIC_FALSE='#'
+else
+  ENABLE_AUTH_BASIC_TRUE='#'
+  ENABLE_AUTH_BASIC_FALSE=
+fi
+
+
+
 
 # Check whether --enable-auth-ntlm was given.
 if test "${enable_auth_ntlm+set}" = set; then :
   enableval=$enable_auth_ntlm;
 
 fi
 
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_ntlm list containing double entries.
+
+#not specified. Inherit global
 if test "x$enable_auth_ntlm" = "x"; then
     enable_auth_ntlm=$enable_auth
 fi
 #conflicts with global
 if test "x$enable_auth_ntlm" != "xno" -a "x$enable_auth" = "xno" ; then
     as_fn_error $? "NTLM auth requested but auth disabled" "$LINENO" 5
@@ -23599,48 +24175,150 @@
 
 fi
 #handle the "none" special case
 if test "x$enable_auth_ntlm" = "xnone" ; then
     enable_auth_ntlm=""
 fi
+
 NTLM_AUTH_HELPERS=""
+#enable_auth_ntlm contains either "no" or the list of modules to be built
 enable_auth_ntlm="`echo $enable_auth_ntlm| sed -e 's/,/ /g;s/  */ /g'`"
 if test "x$enable_auth_ntlm" != "xno" ; then
     AUTH_MODULES="$AUTH_MODULES ntlm"
 
 $as_echo "#define HAVE_AUTH_MODULE_NTLM 1" >>confdefs.h
 
-    for helper in $enable_auth_ntlm ; do
-        dir="$srcdir/helpers/ntlm_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: NTLM auth helper $helper ... found but cannot be built" >&5
+    for helper in $enable_auth_ntlm; do
+      dir="$srcdir/helpers/ntlm_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xfake" ; then
+        BUILD_HELPER="fake"
+
+
+      elif test "x$helper" = "xSSPI" ; then
+        #
+# Only build this helper on Windows
+#
+for ac_header in w32api/windows.h windows.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="SSPI"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xsmb_lm" ; then
+        #
+# DONT build this helper on Windows
+#
+# XXX: do we really need the mingw check?
+if test "$squid_host_os" != "mingw"; then
+  BUILD_HELPER="smb_lm"
+  for ac_header in w32api/windows.h windows.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER=""
+fi
+
+done
+
+fi
+
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/ntlm_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          { $as_echo "$as_me:${as_lineno-$LINENO}: NTLM auth helper $helper ... found but cannot be built" >&5
 $as_echo "$as_me: NTLM auth helper $helper ... found but cannot be built" >&6;}
+        else
+          NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $BUILD_HELPER"
         fi
+      else
+        as_fn_error $? "NTLM auth helper $helper ... not found" "$LINENO" 5
+      fi
     done
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: NTLM auth helpers built: $NTLM_AUTH_HELPERS" >&5
-$as_echo "$as_me: NTLM auth helpers built: $NTLM_AUTH_HELPERS" >&6;}
+{ $as_echo "$as_me:${as_lineno-$LINENO}: NTLM auth helpers to be built: $NTLM_AUTH_HELPERS" >&5
+$as_echo "$as_me: NTLM auth helpers to be built: $NTLM_AUTH_HELPERS" >&6;}
  if test "x$enable_auth_ntlm" != "xno"; then
   ENABLE_AUTH_NTLM_TRUE=
   ENABLE_AUTH_NTLM_FALSE='#'
 else
   ENABLE_AUTH_NTLM_TRUE='#'
   ENABLE_AUTH_NTLM_FALSE=
 fi
 
 
 
+## NTLM requires some special Little-Endian conversion hacks
+if test "x$enable_auth_ntlm" != "xno"; then
+  for ac_header in machine/byte_swap.h sys/bswap.h endian.h sys/endian.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+  for ac_func in bswap_16 bswap16 \
+    bswap_32 bswap32 \
+    htole16 __htole16 \
+    htole32 __htole32 \
+    le16toh __le16toh \
+    le32toh __le32toh \
+
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_cxx_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+fi
+
+
 # Check whether --enable-auth-negotiate was given.
 if test "${enable_auth_negotiate+set}" = set; then :
   enableval=$enable_auth_negotiate;
 #nothing to do, really
 
 fi
 
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_negotiate list containing double entries.
+
+#not specified. Inherit global
 if test "x$enable_auth_negotiate" = "x"; then
     enable_auth_negotiate=$enable_auth
 fi
 #conflicts with global
 if test "x$enable_auth_negotiate" != "xno" -a "x$enable_auth" = "xno" ; then
     as_fn_error $? "Negotiate auth requested but auth disabled" "$LINENO" 5
@@ -23665,24 +24344,87 @@
 enable_auth_negotiate="`echo $enable_auth_negotiate| sed -e 's/,/ /g;s/  */ /g'`"
 if test "x$enable_auth_negotiate" != "xno" ; then
     AUTH_MODULES="$AUTH_MODULES negotiate"
 
 $as_echo "#define HAVE_AUTH_MODULE_NEGOTIATE 1" >>confdefs.h
 
-    for helper in $enable_auth_negotiate ; do
-        dir="$srcdir/helpers/negotiate_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/negotiate_auth/$helper" ; then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: Negotiate auth helper $helper ... found but cannot be built" >&5
+    for helper in $enable_auth_negotiate; do
+      dir="$srcdir/helpers/negotiate_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xSSPI" ; then
+        #
+# Only build this helper on Windows
+#
+for ac_header in w32api/windows.h windows.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="SSPI"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xkerberos" ; then
+        # FIXME: use other kerberos library checks from main configure.ac
+for ac_header in gssapi/gssapi.h gssapi.h kerberosV/gssapi.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="kerberos"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xwrapper" ; then
+        for ac_func in vfork
+do :
+  ac_fn_cxx_check_func "$LINENO" "vfork" "ac_cv_func_vfork"
+if test "x$ac_cv_func_vfork" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_VFORK 1
+_ACEOF
+ BUILD_HELPER="wrapper"
+fi
+done
+
+
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/negotiate_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          { $as_echo "$as_me:${as_lineno-$LINENO}: Negotiate auth helper $helper ... found but cannot be built" >&5
 $as_echo "$as_me: Negotiate auth helper $helper ... found but cannot be built" >&6;}
+        else
+          NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $BUILD_HELPER"
         fi
+      else
+        as_fn_error $? "Negotiate auth helper $helper ... not found" "$LINENO" 5
+      fi
     done
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: Negotiate auth helpers built: $NEGOTIATE_AUTH_HELPERS" >&5
-$as_echo "$as_me: Negotiate auth helpers built: $NEGOTIATE_AUTH_HELPERS" >&6;}
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: Negotiate auth helpers to be built: $NEGOTIATE_AUTH_HELPERS" >&5
+$as_echo "$as_me: Negotiate auth helpers to be built: $NEGOTIATE_AUTH_HELPERS" >&6;}
  if test "x$enable_auth_negotiate" != "xno"; then
   ENABLE_AUTH_NEGOTIATE_TRUE=
   ENABLE_AUTH_NEGOTIATE_FALSE='#'
 else
   ENABLE_AUTH_NEGOTIATE_TRUE='#'
   ENABLE_AUTH_NEGOTIATE_FALSE=
@@ -23694,12 +24437,18 @@
 if test "${enable_auth_digest+set}" = set; then :
   enableval=$enable_auth_digest;
 #nothing to do, really
 
 fi
 
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_digest list containing double entries.
+
+#not specified. Inherit global
 if test "x$enable_auth_digest" = "x"; then
     enable_auth_digest=$enable_auth
 fi
 #conflicts with global
 if test "x$enable_auth_digest" != "xno" -a "x$enable_auth" = "xno" ; then
     as_fn_error $? "Digest auth requested but auth disabled" "$LINENO" 5
@@ -23724,24 +24474,72 @@
 enable_auth_digest="`echo $enable_auth_digest| sed -e 's/,/ /g;s/  */ /g'`"
 if test "x$enable_auth_digest" != "xno" ; then
     AUTH_MODULES="$AUTH_MODULES digest"
 
 $as_echo "#define HAVE_AUTH_MODULE_DIGEST 1" >>confdefs.h
 
-    for helper in $enable_auth_digest ; do
-        dir="$srcdir/helpers/digest_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/digest_auth/$helper" ; then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: Digest auth helper $helper ... found but cannot be built" >&5
+    for helper in $enable_auth_digest; do
+      dir="$srcdir/helpers/digest_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xLDAP" ; then
+        for ac_header in ldap.h winldap.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="LDAP"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xeDirectory" ; then
+        for ac_header in ldap.h winldap.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="LDAP"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xfile" ; then
+        BUILD_HELPER="file"
+
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/digest_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          { $as_echo "$as_me:${as_lineno-$LINENO}: Digest auth helper $helper ... found but cannot be built" >&5
 $as_echo "$as_me: Digest auth helper $helper ... found but cannot be built" >&6;}
+        else
+          DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $BUILD_HELPER"
         fi
+      else
+        as_fn_error $? "Digest auth helper $helper ... not found" "$LINENO" 5
+      fi
     done
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: Digest auth helpers built: $DIGEST_AUTH_HELPERS" >&5
-$as_echo "$as_me: Digest auth helpers built: $DIGEST_AUTH_HELPERS" >&6;}
+{ $as_echo "$as_me:${as_lineno-$LINENO}: Digest auth helpers to be built: $DIGEST_AUTH_HELPERS" >&5
+$as_echo "$as_me: Digest auth helpers to be built: $DIGEST_AUTH_HELPERS" >&6;}
  if test "x$enable_auth_digest" != "xno"; then
   ENABLE_AUTH_DIGEST_TRUE=
   ENABLE_AUTH_DIGEST_FALSE='#'
 else
   ENABLE_AUTH_DIGEST_TRUE='#'
   ENABLE_AUTH_DIGEST_FALSE=
@@ -23753,47 +24552,79 @@
 for module in $AUTH_MODULES; do
     AUTH_LIBS_TO_BUILD="$AUTH_LIBS_TO_BUILD ${module}/lib${module}.la"
 done
 
 
 
-squid_opt_logdaemon_helpers="auto"
 # Check whether --enable-log-daemon-helpers was given.
 if test "${enable_log_daemon_helpers+set}" = set; then :
   enableval=$enable_log_daemon_helpers;
-case "$enableval" in
-  yes) : ;;
-  no)  squid_opt_logdaemon_helpers="" ;;
-  *)   squid_opt_logdaemon_helpers="`echo $enableval| sed -e 's/,/ /g;s/  */ /g'`" ;;
-  esac
+#nothing to do, really
 
 fi
 
-if test "x$squid_opt_logdaemon_helpers" = "xauto" ; then
-  squid_opt_logdaemon_helpers=""
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_log_daemon_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_log_daemon_helpers:=yes}" = "xyes" ;then
+  enable_log_daemon_helpers=""
 
-squid_opt_logdaemon_helpers=""
+enable_log_daemon_helpers=""
 for dir in $srcdir/helpers/log_daemon/*; do
   module="`basename $dir`"
   if test -d "$dir" && test "$module" != CVS; then
-      squid_opt_logdaemon_helpers="$squid_opt_logdaemon_helpers $module"
+      enable_log_daemon_helpers="$enable_log_daemon_helpers $module"
   fi
 done
 
 fi
-for helper in $squid_opt_logdaemon_helpers ; do
-  dir="$srcdir/helpers/log_daemon/$helper"
-  if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-    LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $helper"
-  elif test -d "$srcdir/helpers/log_daemon/$helper" ; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: Log daemon helper $helper ... found but cannot be built" >&5
+if test "x$enable_log_daemon_helpers" = "xnone" ; then
+  enable_log_daemon_helpers=""
+fi
+
+LOG_DAEMON_HELPERS=""
+enable_log_daemon_helpers="`echo $enable_log_daemon_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_log_daemon_helpers" != "xno"; then
+  for helper in $enable_log_daemon_helpers ; do
+    dir="$srcdir/helpers/log_daemon/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xDB" ; then
+      if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="DB"
+fi
+
+
+    elif test "x$helper" = "xfile" ; then
+      BUILD_HELPER="file"
+
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/log_daemon/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: Log daemon helper $helper ... found but cannot be built" >&5
 $as_echo "$as_me: Log daemon helper $helper ... found but cannot be built" >&6;}
-  fi
-done
-{ $as_echo "$as_me:${as_lineno-$LINENO}: Log daemon helpers built: $LOG_DAEMON_HELPERS" >&5
-$as_echo "$as_me: Log daemon helpers built: $LOG_DAEMON_HELPERS" >&6;}
+      else
+       LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $BUILD_HELPER"
+      fi
+    else
+      as_fn_error $? "Log daemon helper $helper ... not found" "$LINENO" 5
+    fi
+  done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: Log daemon helpers to be built: $LOG_DAEMON_HELPERS" >&5
+$as_echo "$as_me: Log daemon helpers to be built: $LOG_DAEMON_HELPERS" >&6;}
+
 
 
 
 # save state, key is krbsave
 krbsave_CFLAGS="${CFLAGS}"
 krbsave_CXXFLAGS="${CXXFLAGS}"
@@ -23982,13 +24813,13 @@
 _ACEOF
 
 fi
 
 done
 
-  if test "x$ac_heimdal" == "x" ; then
+  if test "x$ac_heimdal" = "x" ; then
     for ac_header in gssapi/gssapi_generic.h
 do :
   ac_fn_cxx_check_header_mongrel "$LINENO" "gssapi/gssapi_generic.h" "ac_cv_header_gssapi_gssapi_generic_h" "$ac_includes_default"
 if test "x$ac_cv_header_gssapi_gssapi_generic_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_GSSAPI_GSSAPI_GENERIC_H 1
@@ -24179,25 +25010,25 @@
 fi
 
 done
 
 
   ac_com_error_message=no
-  if test "x$ac_cv_header_com_err_h" == "xyes" ; then
+  if test "x$ac_cv_header_com_err_h" = "xyes" ; then
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <com_err.h>
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   $EGREP "error_message" >/dev/null 2>&1; then :
   ac_com_error_message=yes
 fi
 rm -f conftest*
 
-  elif test "x$ac_cv_header_et_com_err_h" == "xyes" ; then
+  elif test "x$ac_cv_header_et_com_err_h" = "xyes" ; then
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <et/com_err.h>
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
@@ -24252,13 +25083,13 @@
   if test "x$squid_cv_max_skew_context" = "xyes"; then
 
 $as_echo "#define HAVE_MAX_SKEW_IN_KRB5_CONTEXT 1" >>confdefs.h
 
   fi
 
-  if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" == "xyes" ; then
+  if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" = "xyes" ; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for error_message in -lcom_err" >&5
 $as_echo_n "checking for error_message in -lcom_err... " >&6; }
 if ${ac_cv_lib_com_err_error_message+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -24295,13 +25126,13 @@
 if test "x$ac_cv_lib_com_err_error_message" = xyes; then :
 
 $as_echo "#define HAVE_ERROR_MESSAGE 1" >>confdefs.h
 
 fi
 
-  elif test  "x$ac_com_error_message" == "xyes" ; then
+  elif test  "x$ac_com_error_message" = "xyes" ; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for error_message in -lkrb5" >&5
 $as_echo_n "checking for error_message in -lkrb5... " >&6; }
 if ${ac_cv_lib_krb5_error_message+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -24435,12 +25266,20 @@
 fi
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_DECL_KRB5_KT_FREE_ENTRY $ac_have_decl
 _ACEOF
 
+  ac_fn_cxx_check_type "$LINENO" "krb5_pac" "ac_cv_type_krb5_pac" "#include <krb5.h>
+"
+if test "x$ac_cv_type_krb5_pac" = xyes; then :
+
+$as_echo "#define HAVE_KRB5_PAC 1" >>confdefs.h
+
+fi
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for krb5_kt_free_entry in -lkrb5" >&5
 $as_echo_n "checking for krb5_kt_free_entry in -lkrb5... " >&6; }
 if ${ac_cv_lib_krb5_krb5_kt_free_entry+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -24687,12 +25526,196 @@
 if test "x$ac_cv_lib_krb5_profile_release" = xyes; then :
 
 $as_echo "#define HAVE_PROFILE_RELEASE 1" >>confdefs.h
 
 fi
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for krb5_get_renewed_creds in -lkrb5" >&5
+$as_echo_n "checking for krb5_get_renewed_creds in -lkrb5... " >&6; }
+if ${ac_cv_lib_krb5_krb5_get_renewed_creds+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lkrb5  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char krb5_get_renewed_creds ();
+int
+main ()
+{
+return krb5_get_renewed_creds ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_krb5_krb5_get_renewed_creds=yes
+else
+  ac_cv_lib_krb5_krb5_get_renewed_creds=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_krb5_krb5_get_renewed_creds" >&5
+$as_echo "$ac_cv_lib_krb5_krb5_get_renewed_creds" >&6; }
+if test "x$ac_cv_lib_krb5_krb5_get_renewed_creds" = xyes; then :
+
+$as_echo "#define HAVE_KRB5_GET_RENEWED_CREDS 1" >>confdefs.h
+
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for krb5_principal_get_realm in -lkrb5" >&5
+$as_echo_n "checking for krb5_principal_get_realm in -lkrb5... " >&6; }
+if ${ac_cv_lib_krb5_krb5_principal_get_realm+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lkrb5  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char krb5_principal_get_realm ();
+int
+main ()
+{
+return krb5_principal_get_realm ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_krb5_krb5_principal_get_realm=yes
+else
+  ac_cv_lib_krb5_krb5_principal_get_realm=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_krb5_krb5_principal_get_realm" >&5
+$as_echo "$ac_cv_lib_krb5_krb5_principal_get_realm" >&6; }
+if test "x$ac_cv_lib_krb5_krb5_principal_get_realm" = xyes; then :
+
+$as_echo "#define HAVE_KRB5_PRINCIPAL_GET_REALM 1" >>confdefs.h
+
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for krb5_get_init_creds_opt_alloc in -lkrb5" >&5
+$as_echo_n "checking for krb5_get_init_creds_opt_alloc in -lkrb5... " >&6; }
+if ${ac_cv_lib_krb5_krb5_get_init_creds_opt_alloc+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lkrb5  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char krb5_get_init_creds_opt_alloc ();
+int
+main ()
+{
+return krb5_get_init_creds_opt_alloc ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_krb5_krb5_get_init_creds_opt_alloc=yes
+else
+  ac_cv_lib_krb5_krb5_get_init_creds_opt_alloc=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_krb5_krb5_get_init_creds_opt_alloc" >&5
+$as_echo "$ac_cv_lib_krb5_krb5_get_init_creds_opt_alloc" >&6; }
+if test "x$ac_cv_lib_krb5_krb5_get_init_creds_opt_alloc" = xyes; then :
+
+$as_echo "#define HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC 1" >>confdefs.h
+
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for krb5_get_init_creds_free requires krb5_context" >&5
+$as_echo_n "checking for krb5_get_init_creds_free requires krb5_context... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+	#include <krb5.h>
+
+int
+main ()
+{
+krb5_context context;
+	 krb5_get_init_creds_opt *options;
+	 krb5_get_init_creds_opt_free(context, options)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+
+$as_echo "#define HAVE_KRB5_GET_INIT_CREDS_FREE_CONTEXT 1" >>confdefs.h
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+  for ac_func in gss_map_name_to_any
+do :
+  ac_fn_cxx_check_func "$LINENO" "gss_map_name_to_any" "ac_cv_func_gss_map_name_to_any"
+if test "x$ac_cv_func_gss_map_name_to_any" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GSS_MAP_NAME_TO_ANY 1
+_ACEOF
+
+$as_echo "#define HAVE_GSS_MAP_ANY_TO_ANY 1" >>confdefs.h
+
+fi
+done
+
+  for ac_func in gsskrb5_extract_authz_data_from_sec_context
+do :
+  ac_fn_cxx_check_func "$LINENO" "gsskrb5_extract_authz_data_from_sec_context" "ac_cv_func_gsskrb5_extract_authz_data_from_sec_context"
+if test "x$ac_cv_func_gsskrb5_extract_authz_data_from_sec_context" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT 1
+_ACEOF
+
+$as_echo "#define HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT 1" >>confdefs.h
+
+fi
+done
+
 
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for memory cache" >&5
 $as_echo_n "checking for memory cache... " >&6; }
 if ${squid_cv_memory_cache+:} false; then :
   $as_echo_n "(cached) " >&6
@@ -25011,62 +26034,432 @@
 else
   HAVE_SPNEGO_TRUE='#'
   HAVE_SPNEGO_FALSE=
 fi
 
 
-# Check whether --enable-external-acl-helpers was given.
-if test "${enable_external_acl_helpers+set}" = set; then :
-  enableval=$enable_external_acl_helpers;
-#nothing to do, really
+# Check whether --enable-external-acl-helpers was given.
+if test "${enable_external_acl_helpers+set}" = set; then :
+  enableval=$enable_external_acl_helpers;
+#nothing to do, really
+
+fi
+
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_external_acl_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_external_acl_helpers:=yes}" = "xyes" ;then
+
+enable_external_acl_helpers=""
+for dir in $srcdir/helpers/external_acl/*; do
+  module="`basename $dir`"
+  if test -d "$dir" && test "$module" != CVS; then
+      enable_external_acl_helpers="$enable_external_acl_helpers $module"
+  fi
+done
+
+fi
+if test "x$enable_external_acl_helpers" = "xnone" ; then
+  enable_external_acl_helpers=""
+fi
+EXTERNAL_ACL_HELPERS=""
+enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_external_acl_helpers" != "xno" ; then
+  for helper in $enable_external_acl_helpers ; do
+    dir="$srcdir/helpers/external_acl/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xAD_group" ; then
+        for hdr in w32api/dsrole.h dsrole.h; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+    #include <$hdr>
+int
+main ()
+{
+
+      PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDSRoleInfo;
+      DWORD ret = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) & pDSRoleInfo);
+
+  ;
+  return 0;
+}
+
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  BUILD_HELPER="AD_group"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+
+
+      elif test "x$helper" = "xLDAP_group" ; then
+        for ac_header in ldap.h winldap.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="LDAP_group"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xLM_group" ; then
+        #
+# Only build this helper on Windows
+#
+for ac_header in w32api/windows.h windows.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="LM_group"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xSQL_session" ; then
+        if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="SQL_session"
+fi
+
+
+      elif test "x$helper" = "xeDirectory_userip" ; then
+        for ac_header in ldap.h winldap.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ BUILD_HELPER="eDirectory_userip"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xfile_userip" ; then
+        for ac_header in sys/socket.h
+do :
+  ac_fn_cxx_check_header_mongrel "$LINENO" "sys/socket.h" "ac_cv_header_sys_socket_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_socket_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_SOCKET_H 1
+_ACEOF
+ BUILD_HELPER="file_userip"
+fi
+
+done
+
+
+
+      elif test "x$helper" = "xkerberos_ldap_group" ; then
+        for ac_header in ldap.h
+do :
+  ac_fn_cxx_check_header_mongrel "$LINENO" "ldap.h" "ac_cv_header_ldap_h" "$ac_includes_default"
+if test "x$ac_cv_header_ldap_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LDAP_H 1
+_ACEOF
+ BUILD_HELPER="kerberos_ldap_group"
+fi
+
+done
+
+
+  squid_cv_check_sasl="auto"
+  for ac_header in sasl/sasl.h sasl.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sasl_errstring in -lsasl2" >&5
+$as_echo_n "checking for sasl_errstring in -lsasl2... " >&6; }
+if ${ac_cv_lib_sasl2_sasl_errstring+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsasl2  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char sasl_errstring ();
+int
+main ()
+{
+return sasl_errstring ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_sasl2_sasl_errstring=yes
+else
+  ac_cv_lib_sasl2_sasl_errstring=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sasl2_sasl_errstring" >&5
+$as_echo "$ac_cv_lib_sasl2_sasl_errstring" >&6; }
+if test "x$ac_cv_lib_sasl2_sasl_errstring" = xyes; then :
+  LIBSASL="-lsasl2"
+else
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sasl_errstring in -lsasl" >&5
+$as_echo_n "checking for sasl_errstring in -lsasl... " >&6; }
+if ${ac_cv_lib_sasl_sasl_errstring+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsasl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char sasl_errstring ();
+int
+main ()
+{
+return sasl_errstring ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_sasl_sasl_errstring=yes
+else
+  ac_cv_lib_sasl_sasl_errstring=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sasl_sasl_errstring" >&5
+$as_echo "$ac_cv_lib_sasl_sasl_errstring" >&6; }
+if test "x$ac_cv_lib_sasl_sasl_errstring" = xyes; then :
+  LIBSASL="-lsasl"
+else
+
+      squid_cv_check_sasl="no"
+
+fi
+
+
+fi
+
+  case "$squid_host_os" in
+    Darwin)
+      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
+
+$as_echo "#define HAVE_SASL_DARWIN 1" >>confdefs.h
+
+        echo "checking for MAC Darwin without sasl.h ... yes"
+        squid_cv_check_sasl="yes"
+      else
+        echo "checking for MAC Darwin without sasl.h ... no"
+        squid_cv_check_sasl="no"
+      fi
+      ;;
+  esac
+  if test "x$squid_cv_check_sasl" = "xno"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Neither SASL nor SASL2 found" >&5
+$as_echo "$as_me: WARNING: Neither SASL nor SASL2 found" >&2;}
+  else
+    squid_cv_check_sasl="yes"
+  fi
+
+
+
+
+      elif test "x$helper" = "xsession" ; then
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <db.h>
+int
+main ()
+{
+DB_ENV *db_env = NULL; db_env_create(&db_env, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  BUILD_HELPER="session"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+      elif test "x$helper" = "xtime_quota" ; then
+        for ac_header in db_185.h
+do :
+  ac_fn_cxx_check_header_mongrel "$LINENO" "db_185.h" "ac_cv_header_db_185_h" "$ac_includes_default"
+if test "x$ac_cv_header_db_185_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_DB_185_H 1
+_ACEOF
+ BUILD_HELPER="time_quota"
+fi
+
+done
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include </usr/include/db.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "dbopen" >/dev/null 2>&1; then :
+  BUILD_HELPER="time_quota"
+fi
+rm -f conftest*
+
+
 
+      elif test "x$helper" = "xunix_group" ; then
+        for ac_header in pwd.h
+do :
+  ac_fn_cxx_check_header_mongrel "$LINENO" "pwd.h" "ac_cv_header_pwd_h" "$ac_includes_default"
+if test "x$ac_cv_header_pwd_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_PWD_H 1
+_ACEOF
+ BUILD_HELPER="unix_group"
 fi
 
-if test "x${enable_external_acl_helpers:=yes}" = "xyes" ;then
+done
 
-enable_external_acl_helpers=""
-for dir in $srcdir/helpers/external_acl/*; do
-  module="`basename $dir`"
-  if test -d "$dir" && test "$module" != CVS; then
-      enable_external_acl_helpers="$enable_external_acl_helpers $module"
+
+
+      elif test "x$helper" = "xwbinfo_group" ; then
+        #
+# The shell script helper requires wbinfo to be in the environment PATH.
+# We can install anyway, but warn if the tool is missing
+#
+# Extract the first word of "wbinfo", so it can be a program name with args.
+set dummy wbinfo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_WBINFO+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $WBINFO in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_WBINFO="$WBINFO" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_WBINFO="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
   fi
 done
+  done
+IFS=$as_save_IFS
 
+  ;;
+esac
 fi
-if test "x$enable_external_acl_helpers" = "xnone" ; then
-  enable_external_acl_helpers=""
+WBINFO=$ac_cv_path_WBINFO
+if test -n "$WBINFO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $WBINFO" >&5
+$as_echo "$WBINFO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
-EXTERNAL_ACL_HELPERS=""
-enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_external_acl_helpers" != "xno" ; then
-  for helper in $enable_external_acl_helpers ; do
-    dir="$srcdir/helpers/external_acl/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xkerberos_ldap_group" ; then
-        squid_require_sasl=yes
+
+
+if test "x$WBINFO" = "x"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Samba wbinfo not found in default location. ext_wbinfo_group_acl may not work on this machine" >&5
+$as_echo "$as_me: WARNING: Samba wbinfo not found in default location. ext_wbinfo_group_acl may not work on this machine" >&2;}
+fi
+
+# allow script install anyway when perl is present
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="wbinfo_group"
+fi
+
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
       fi
-    else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: external acl helper $helper ... found but cannot be built" >&5
+
+      if test -d "$srcdir/helpers/external_acl/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          { $as_echo "$as_me:${as_lineno-$LINENO}: external acl helper $helper ... found but cannot be built" >&5
 $as_echo "$as_me: external acl helper $helper ... found but cannot be built" >&6;}
-    fi
+        else
+          EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $BUILD_HELPER"
+        fi
+      else
+        as_fn_error $? "external acl helper $helper ... not found" "$LINENO" 5
+      fi
   done
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: External acl helpers built: $EXTERNAL_ACL_HELPERS" >&5
-$as_echo "$as_me: External acl helpers built: $EXTERNAL_ACL_HELPERS" >&6;}
-
+{ $as_echo "$as_me:${as_lineno-$LINENO}: External acl helpers to be built: $EXTERNAL_ACL_HELPERS" >&5
+$as_echo "$as_me: External acl helpers to be built: $EXTERNAL_ACL_HELPERS" >&6;}
 
 
 
 # Check whether --enable-url-rewrite-helpers was given.
 if test "${enable_url_rewrite_helpers+set}" = set; then :
   enableval=$enable_url_rewrite_helpers;
 
 fi
 
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_url_rewrite_helpers list containing double entries.
+
+#define list of modules to build
 if test "x${enable_url_rewrite_helpers:=yes}" = "xyes" ; then
 
 enable_url_rewrite_helpers=""
 for dir in $srcdir/helpers/url_rewrite/*; do
   module="`basename $dir`"
   if test -d "$dir" && test "$module" != CVS; then
@@ -25079,25 +26473,100 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: URL rewrite helper candidates: $enable_url_rewrite_helpers" >&5
 $as_echo "$as_me: URL rewrite helper candidates: $enable_url_rewrite_helpers" >&6;}
 URL_REWRITE_HELPERS=""
 if test "x$enable_url_rewrite_helpers" != "xno" ; then
   for helper in $enable_url_rewrite_helpers; do
     dir="$srcdir/helpers/url_rewrite/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $helper"
-    elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: URL rewrite helper $helper ... found but cannot be built" >&5
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xfake" ; then
+      BUILD_HELPER="fake"
+
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/url_rewrite/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: URL rewrite helper $helper ... found but cannot be built" >&5
 $as_echo "$as_me: URL rewrite helper $helper ... found but cannot be built" >&6;}
+      else
+        URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $BUILD_HELPER"
+      fi
+    else
+      as_fn_error $? "URL rewrite helper $helper ... not found" "$LINENO" 5
+    fi
+  done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: URL rewrite helpers to be built: $URL_REWRITE_HELPERS" >&5
+$as_echo "$as_me: URL rewrite helpers to be built: $URL_REWRITE_HELPERS" >&6;}
+
+
+
+# Check whether --enable-storeid-rewrite-helpers was given.
+if test "${enable_storeid_rewrite_helpers+set}" = set; then :
+  enableval=$enable_storeid_rewrite_helpers;
+
+fi
+
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_storeid_rewrite_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_storeid_rewrite_helpers:=yes}" = "xyes" ; then
+
+enable_storeid_rewrite_helpers=""
+for dir in $srcdir/helpers/storeid_rewrite/*; do
+  module="`basename $dir`"
+  if test -d "$dir" && test "$module" != CVS; then
+      enable_storeid_rewrite_helpers="$enable_storeid_rewrite_helpers $module"
+  fi
+done
+
+fi
+
+enable_storeid_rewrite_helpers="`echo $enable_storeid_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: Store-ID rewrite helper candidates: $enable_storeid_rewrite_helpers" >&5
+$as_echo "$as_me: Store-ID rewrite helper candidates: $enable_storeid_rewrite_helpers" >&6;}
+STOREID_REWRITE_HELPERS=""
+if test "x$enable_storeid_rewrite_helpers" != "xno" ; then
+  for helper in $enable_storeid_rewrite_helpers; do
+    dir="$srcdir/helpers/storeid_rewrite/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xfile" ; then
+      if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="file"
+fi
+
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/storeid_rewrite/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: Store-ID rewrite helper $helper ... found but cannot be built" >&5
+$as_echo "$as_me: Store-ID rewrite helper $helper ... found but cannot be built" >&6;}
+      else
+        STOREID_REWRITE_HELPERS="$STOREID_REWRITE_HELPERS $BUILD_HELPER"
+      fi
     else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: URL rewrite helper $helper ... not found" >&5
-$as_echo "$as_me: URL rewrite helper $helper ... not found" >&6;}
+      as_fn_error $? "Store-ID rewrite helper $helper ... not found" "$LINENO" 5
     fi
   done
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: URL rewrite helpers built: $URL_REWRITE_HELPERS" >&5
-$as_echo "$as_me: URL rewrite helpers built: $URL_REWRITE_HELPERS" >&6;}
+{ $as_echo "$as_me:${as_lineno-$LINENO}: Store-ID rewrite helpers to be built: $STOREID_REWRITE_HELPERS" >&5
+$as_echo "$as_me: Store-ID rewrite helpers to be built: $STOREID_REWRITE_HELPERS" >&6;}
 
 
 
 
 # Check whether --with-valgrind-debug was given.
 if test "${with_valgrind_debug+set}" = set; then :
@@ -25196,129 +26665,12 @@
 unset squid_tmp_define
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: MS Windows service mode enabled: $enable_win32_service" >&5
 $as_echo "$as_me: MS Windows service mode enabled: $enable_win32_service" >&6;}
 
 
-# Check for Cyrus SASL
-if test "x$squid_require_sasl" = "xyes"; then
-  for ac_header in sasl/sasl.h sasl.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sasl_errstring in -lsasl2" >&5
-$as_echo_n "checking for sasl_errstring in -lsasl2... " >&6; }
-if ${ac_cv_lib_sasl2_sasl_errstring+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsasl2  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char sasl_errstring ();
-int
-main ()
-{
-return sasl_errstring ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_sasl2_sasl_errstring=yes
-else
-  ac_cv_lib_sasl2_sasl_errstring=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sasl2_sasl_errstring" >&5
-$as_echo "$ac_cv_lib_sasl2_sasl_errstring" >&6; }
-if test "x$ac_cv_lib_sasl2_sasl_errstring" = xyes; then :
-  LIBSASL="-lsasl2"
-else
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sasl_errstring in -lsasl" >&5
-$as_echo_n "checking for sasl_errstring in -lsasl... " >&6; }
-if ${ac_cv_lib_sasl_sasl_errstring+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsasl  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char sasl_errstring ();
-int
-main ()
-{
-return sasl_errstring ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_sasl_sasl_errstring=yes
-else
-  ac_cv_lib_sasl_sasl_errstring=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sasl_sasl_errstring" >&5
-$as_echo "$ac_cv_lib_sasl_sasl_errstring" >&6; }
-if test "x$ac_cv_lib_sasl_sasl_errstring" = xyes; then :
-  LIBSASL="-lsasl"
-else
-
-      as_fn_error $? "Neither SASL nor SASL2 found" "$LINENO" 5
-
-fi
-
-
-fi
-
-  case "$squid_host_os" in
-    Darwin)
-      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
-
-$as_echo "#define HAVE_SASL_DARWIN 1" >>confdefs.h
-
-        echo "checking for MAC Darwin without sasl.h ... yes"
-      else
-        echo "checking for MAC Darwin without sasl.h ... no"
-      fi
-      ;;
-  esac
-
-fi
-
 # Disable "unlinkd" code
 # Check whether --enable-unlinkd was given.
 if test "${enable_unlinkd+set}" = set; then :
   enableval=$enable_unlinkd;
 
 if test "$enableval" != "yes" -a "$enableval" != "no" ; then
@@ -25888,12 +27240,13 @@
   arpa/nameser.h \
   assert.h \
   bstring.h \
   cassert \
   crypt.h \
   cstdarg \
+  cstdio \
   cstdlib \
   cstring \
   list \
   ctype.h \
   errno.h \
   execinfo.h \
@@ -25905,35 +27258,29 @@
   grp.h \
   iosfwd \
   iomanip \
   iostream \
   fstream \
   climits \
-  ip_compat.h \
-  ip_fil_compat.h \
-  ip_fil.h \
-  ip_nat.h \
   ipl.h \
   lber.h \
   ldap.h \
   libc.h \
   limits \
   limits.h \
   linux/posix_types.h \
   linux/types.h \
-  machine/byte_swap.h \
   malloc.h \
   map \
   math.h \
   memory.h \
   memory \
   mount.h \
   netdb.h \
   netinet/in.h \
   netinet/in_systm.h \
-  netinet/ip_fil_compat.h \
   openssl/err.h \
   openssl/md5.h \
   openssl/opensslv.h \
   openssl/ssl.h \
   openssl/x509v3.h \
   netinet/tcp.h \
@@ -25943,13 +27290,12 @@
   paths.h \
   poll.h \
   pwd.h \
   shadow.h \
   regex.h \
   sched.h \
-  security/pam_appl.h \
   siginfo.h \
   signal.h \
   sstream \
   stdarg.h \
   stdbool.h \
   stddef.h \
@@ -25957,23 +27303,23 @@
   stdio.h \
   stdlib.h \
   string \
   string.h \
   strings.h \
   sys/bitypes.h \
-  sys/bswap.h \
-  sys/endian.h \
   sys/file.h \
   sys/ioctl.h \
+  sys/ipc.cc \
   sys/param.h \
   sys/prctl.h \
   sys/md5.h \
   sys/mman.h \
   sys/msg.h \
   sys/resource.h \
   sys/select.h \
+  sys/shm.h \
   sys/socket.h \
   sys/stat.h \
   sys/statvfs.h \
   syscall.h \
   sys/syscall.h \
   sys/time.h \
@@ -26005,86 +27351,15 @@
 
 fi
 
 done
 
 
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for PAM conversation struct signature type" >&5
-$as_echo_n "checking for PAM conversation struct signature type... " >&6; }
-if ${squid_cv_pam_conv_signature+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <security/pam_appl.h>
-static int
-password_conversation(int num_msg, const struct pam_message **msg, struct pam_response **resp, void *appdata_ptr) {}
-static struct pam_conv conv = { &password_conversation, 0 };
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-
-   squid_cv_pam_conv_signature=linux
-
-else
-
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <security/pam_appl.h>
-static int
-password_conversation(int num_msg, struct pam_message **msg, struct pam_response **resp, void *appdata_ptr) {}
-static struct pam_conv conv = { &password_conversation, 0 };
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-
-  squid_cv_pam_conv_signature=solaris
-
-else
-
-  squid_cv_pam_conv_signature=unknown
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $squid_cv_pam_conv_signature" >&5
-$as_echo "$squid_cv_pam_conv_signature" >&6; }
-  case $squid_cv_pam_conv_signature in
-    linux) $as_echo "#define PAM_CONV_FUNC_CONST_PARM const" >>confdefs.h
- ;;
-    solaris) $as_echo "#define PAM_CONV_FUNC_CONST_PARM /**/" >>confdefs.h
- ;;
-    *) $as_echo "#define PAM_CONV_FUNC_CONST_PARM /**/" >>confdefs.h
- ;;
-  esac
-
-
-for ac_header in linux/netfilter_ipv4.h
+for ac_header in \
+  linux/netfilter_ipv4.h \
+  linux/netfilter_ipv6/ip6_tables.h \
 
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_cxx_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "
 /* What a mess.. many systems have added the (now standard) bit types
  * in their own ways, so we need to scan a wide variety of headers to
@@ -26139,18 +27414,14 @@
   net/if.h \
   netinet/if_ether.h\
   netinet/icmp6.h \
   netinet/in.h \
   netinet/ip.h \
   netinet/ip6.h \
-  netinet/ip_compat.h\
-  netinet/ip_fil_compat.h\
-  netinet/ip_fil.h\
   netinet/ip_icmp.h \
   netinet/ipl.h \
-  netinet/ip_nat.h\
   net/pf/pfvar.h \
   net/pfvar.h \
   sys/mount.h\
   resolv.h \
 
 do :
@@ -26184,36 +27455,36 @@
 #include <sys/select.h>
 #endif
 #if HAVE_NETINET_IN_SYSTM_H
 #include <netinet/in_systm.h>
 #endif
 
+#if HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
 #if HAVE_SYS_TIME_H
 #include <sys/time.h>
 #endif
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
+#if HAVE_NET_IF_H
+#include <net/if.h>
+#endif
 #if HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 #if HAVE_NETINET_IP_H
 #include <netinet/ip.h>
 #endif
 #if HAVE_NETINET_IP_COMPAT_H
 #include <netinet/ip_compat.h>
 #endif
-#if HAVE_NET_IF_H
-#include <net/if.h>
-#endif
 #if HAVE_NETINET_IP_FIL_H
 #include <netinet/ip_fil.h>
 #endif
-#if HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
 
 "
 if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -28267,13 +29538,13 @@
 
 
 
   for ac_header in \
     windows.h \
     ws2tcpip.h \
-    Iphlpapi.h
+    iphlpapi.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_cxx_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "
 #if HAVE_WINDOWS_H
 #include <windows.h>
 #endif
@@ -30133,14 +31405,14 @@
 }
 _ACEOF
 if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_require_rtti=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-    if test "ac_cv_require_rtti" != "no" ; then
-      CFLAGS="$CXXFLAGS -rtti"
+    if test "xac_cv_require_rtti" != "xno" ; then
+      CFLAGS="$CFLAGS -rtti"
       CXXFLAGS="$CXXFLAGS -rtti"
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 #include <assert.h>
 #ifndef NULL
@@ -30175,14 +31447,12 @@
     CFLAGS="$SAVED_CFLAGS"
     CXXFLAGS="$SAVED_CXXFLAGS"
   }
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_require_rtti" >&5
 $as_echo "$ac_cv_require_rtti" >&6; }
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ac_cv_require_rtti" >&5
-$as_echo "ac_cv_require_rtti" >&6; }
 
     if test "$ac_cv_require_rtti" = "yes"; then
       SQUID_CFLAGS="-rtti $SQUID_CFLAGS"
       SQUID_CXXFLAGS="-rtti $SQUID_CXXFLAGS"
     fi
 
@@ -30214,14 +31484,14 @@
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
   ac_cv_require_qcpluscmt=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-    if test "ac_cv_require_qcpluscmt" != "no" ; then
-      CFLAGS="$CXXFLAGS -qcpluscmt"
+    if test "xac_cv_require_qcpluscmt" != "xno" ; then
+      CFLAGS="$CFLAGS -qcpluscmt"
       CXXFLAGS="$CXXFLAGS -qcpluscmt"
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
 main ()
@@ -30241,14 +31511,12 @@
     CFLAGS="$SAVED_CFLAGS"
     CXXFLAGS="$SAVED_CXXFLAGS"
   }
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_require_qcpluscmt" >&5
 $as_echo "$ac_cv_require_qcpluscmt" >&6; }
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ac_cv_require_qcpluscmt" >&5
-$as_echo "ac_cv_require_qcpluscmt" >&6; }
 
     ac_ext=cpp
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
@@ -30275,13 +31543,13 @@
     ;;
   esac
 
 # Remove optimization for GCC 2.95.[123]
 # gcc -O[2] on *BSD and Linux (x86) causes pointers to magically become NULL
 if test "x$GCC" = "xyes"; then
-	GCCVER=`$CC -v 2>&1 | awk '$2 ==  "version" {print $3}'`
+	GCCVER=`$CC -v 2>&1 | awk '$2 == "version" {print $3}'`
 	case "$GCCVER" in
 	2.95.[123])
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: Removing -O for gcc on $host with GCC $GCCVER" >&5
 $as_echo "$as_me: Removing -O for gcc on $host with GCC $GCCVER" >&6;}
 		CFLAGS="`echo $CFLAGS | sed -e 's/-O[0-9]*//'`"
 		;;
@@ -30340,27 +31608,22 @@
   ac_cv_func_statfs='yes'
 fi
 
 for ac_func in \
 	backtrace_symbols_fd \
 	bcopy \
-	bswap_16 \
-	bswap_32 \
-	bswap16 \
-	bswap32 \
+	eui64_aton \
 	fchmod \
 	getdtablesize \
 	getpagesize \
 	getpass \
 	getrlimit \
 	getrusage \
 	getspnam \
 	gettimeofday \
 	glob \
-	htobe16 \
-	htole16 \
 	lrand48 \
 	mallinfo \
 	mallocblksize \
 	mallopt \
 	memcpy \
 	memmove \
@@ -30379,13 +31642,12 @@
 	regcomp \
 	regexec \
 	regfree \
 	res_init \
 	__res_init \
 	rint \
-	sbrk \
 	sched_getaffinity \
 	sched_setaffinity \
 	select \
 	seteuid \
 	setgroups \
 	setpgrp \
@@ -30422,25 +31684,12 @@
   *) LIBOBJS="$LIBOBJS drand48.$ac_objext"
  ;;
 esac
 
 fi
 
-ac_fn_cxx_check_func "$LINENO" "eui64_aton" "ac_cv_func_eui64_aton"
-if test "x$ac_cv_func_eui64_aton" = xyes; then :
-  $as_echo "#define HAVE_EUI64_ATON 1" >>confdefs.h
-
-else
-  case " $LIBOBJS " in
-  *" eui64_aton.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS eui64_aton.$ac_objext"
- ;;
-esac
-
-fi
-
 ac_fn_cxx_check_func "$LINENO" "inet_ntop" "ac_cv_func_inet_ntop"
 if test "x$ac_cv_func_inet_ntop" = xyes; then :
   $as_echo "#define HAVE_INET_NTOP 1" >>confdefs.h
 
 else
   case " $LIBOBJS " in
@@ -30526,25 +31775,12 @@
   *) LIBOBJS="$LIBOBJS strerror.$ac_objext"
  ;;
 esac
 
 fi
 
-ac_fn_cxx_check_func "$LINENO" "strsep" "ac_cv_func_strsep"
-if test "x$ac_cv_func_strsep" = xyes; then :
-  $as_echo "#define HAVE_STRSEP 1" >>confdefs.h
-
-else
-  case " $LIBOBJS " in
-  *" strsep.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS strsep.$ac_objext"
- ;;
-esac
-
-fi
-
 ac_fn_cxx_check_func "$LINENO" "strtoll" "ac_cv_func_strtoll"
 if test "x$ac_cv_func_strtoll" = xyes; then :
   $as_echo "#define HAVE_STRTOLL 1" >>confdefs.h
 
 else
   case " $LIBOBJS " in
@@ -30754,12 +31990,82 @@
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
+ac_fn_cxx_check_type "$LINENO" "struct cmsghdr" "ac_cv_type_struct_cmsghdr" "
+  #if HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+  #endif
+  #if HAVE_WINSOCK2_H
+  #include <winsock2.h>
+  #endif
+
+"
+if test "x$ac_cv_type_struct_cmsghdr" = xyes; then :
+
+$as_echo "#define HAVE_CMSGHDR 1" >>confdefs.h
+
+fi
+
+
+ac_fn_cxx_check_type "$LINENO" "struct iovec" "ac_cv_type_struct_iovec" "
+  #if HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+  #endif
+  #if HAVE_WINSOCK2_H
+  #include <winsock2.h>
+  #endif
+  #if HAVE_SYS_UIO_H
+  #include <sys/uio.h>
+  #endif
+
+"
+if test "x$ac_cv_type_struct_iovec" = xyes; then :
+
+$as_echo "#define HAVE_IOVEC 1" >>confdefs.h
+
+fi
+
+
+ac_fn_cxx_check_type "$LINENO" "struct msghdr" "ac_cv_type_struct_msghdr" "
+  #if HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+  #endif
+  #if HAVE_WINSOCK2_H
+  #include <winsock2.h>
+  #endif
+
+"
+if test "x$ac_cv_type_struct_msghdr" = xyes; then :
+
+$as_echo "#define HAVE_MSGHDR 1" >>confdefs.h
+
+fi
+
+
+ac_fn_cxx_check_type "$LINENO" "struct sockaddr_un" "ac_cv_type_struct_sockaddr_un" "
+  #if HAVE_SYS_UN_H
+  #include <sys/un.h>
+  #endif
+  #if HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+  #endif
+  #if HAVE_WINSOCK2_H
+  #include <winsock2.h>
+  #endif
+
+"
+if test "x$ac_cv_type_struct_sockaddr_un" = xyes; then :
+
+$as_echo "#define HAVE_SOCKADDR_UN 1" >>confdefs.h
+
+fi
+
+
 
 
 # Yay!  This one is  a MacOSX brokenness.  Its not good enough
 # to know that strnstr() exists, because MacOSX 10.4 have a bad
 # copy that crashes with a buffer over-run!
 
@@ -30901,36 +32207,175 @@
 if test "$squid_cv_func___va_copy" = "yes" ; then
   $as_echo "#define HAVE___VA_COPY 1" >>confdefs.h
 
 fi
 
 
-
 if test "x$enable_ipf_transparent" != "xno" ; then
+
+  if test "x$squid_cv_broken_ipfilter_minor_t" = "x"; then
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#     include <sys/types.h>
+#     include <sys/ioccom.h>
+#     include <netinet/in.h>
+
+#     include <netinet/ip_compat.h>
+#     include <netinet/ip_fil.h>
+#     include <netinet/ip_nat.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+      squid_cv_broken_ipfilter_minor_t=0
+
+else
+
+      ## on fail, test the hack
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#define minor_t fubaar
+#       include <sys/types.h>
+#       include <sys/ioccom.h>
+#       include <netinet/in.h>
+#undef minor_t
+#       include <netinet/ip_compat.h>
+#       include <netinet/ip_fil.h>
+#       include <netinet/ip_nat.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+        squid_cv_broken_ipfilter_minor_t=1
+
+else
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: unable to make IPFilter work with netinet/ headers" >&5
+$as_echo "unable to make IPFilter work with netinet/ headers" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  fi
+
+
+cat >>confdefs.h <<_ACEOF
+#define USE_SOLARIS_IPFILTER_MINOR_T_HACK $squid_cv_broken_ipfilter_minor_t
+_ACEOF
+
+
+## check for IPFilter headers that require this hack
+## (but first netinet/in.h and sys/ioccom.h which they depend on)
+  for ac_header in \
+	netinet/in.h \
+	sys/ioccom.h \
+	ip_compat.h \
+	ip_fil_compat.h \
+	ip_fil.h \
+	ip_nat.h \
+	netinet/ip_compat.h \
+	netinet/ip_fil_compat.h \
+	netinet/ip_fil.h \
+	netinet/ip_nat.h \
+
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "
+#if USE_SOLARIS_IPFILTER_MINOR_T_HACK
+#define minor_t fubar
+#endif
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_SYS_IOCCOM_H
+#include <sys/ioccom.h>
+#endif
+#if USE_SOLARIS_IPFILTER_MINOR_T_HACK
+#undef minor_t
+#endif
+#if HAVE_IP_COMPAT_H
+#include <ip_compat.h>
+#elif HAVE_NETINET_IP_COMPAT_H
+#include <netinet/ip_compat.h>
+#endif
+#if HAVE_IP_FIL_H
+#include <ip_fil.h>
+#elif HAVE_NETINET_IP_FIL_H
+#include <netinet/ip_fil.h>
+#endif
+#if !defined(IPFILTER_VERSION)
+#define IPFILTER_VERSION        5000004
+#endif
+
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for availability of IP-Filter header files" >&5
 $as_echo_n "checking for availability of IP-Filter header files... " >&6; }
     # hold on to your hats...
     if test "x$ac_cv_header_ip_compat_h" = "xyes" -o \
         "x$ac_cv_header_ip_fil_compat_h" = "xyes" -o \
         "x$ac_cv_header_netinet_ip_compat_h" = "xyes" -o \
         "x$ac_cv_header_netinet_ip_fil_compat_h" = "xyes" ; then
         have_ipfilter_compat_header="yes"
-     fi
-     if test "x$have_ipfilter_compat_header" = "xyes" -a \
+    fi
+    if test "x$have_ipfilter_compat_header" = "xyes" -a \
        "x$ac_cv_header_ip_fil_h" = "xyes" -a \
        "x$ac_cv_header_ip_nat_h" = "xyes" ; then
         enable_ipf_transparent="yes"
     elif test "x$have_ipfilter_compat_header" = "xyes" -a \
          "x$ac_cv_header_netinet_ip_fil_h" = "xyes" -a \
          "x$ac_cv_header_netinet_ip_nat_h" = "xyes" ; then
         enable_ipf_transparent="yes"
     else
         enable_ipf_transparent="no"
     fi
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $IPF_TRANSPARENT" >&5
 $as_echo "$IPF_TRANSPARENT" >&6; }
+
+## On Solaris Ipfilter includes expect that SOLARIS2 is defined with the
+## Solaris minor version (8, 9, 10, ...)
+  if test "x$enable_ipf_transparent" = "xyes" -a "x$squid_host_os" = "xsolaris" ; then
+    solrev=`uname -r | sh -c 'IFS=. read j n x; echo $n'`
+    CFLAGS="-DSOLARIS2=$solrev $CFLAGS"
+    CXXFLAGS="-DSOLARIS2=$solrev $CXXFLAGS"
+  fi
+
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: IPF-based transparent proxying enabled: $enable_ipf_transparent" >&5
 $as_echo "$as_me: IPF-based transparent proxying enabled: $enable_ipf_transparent" >&6;}
 
 squid_tmp_define=""
 case "$enable_ipf_transparent" in
@@ -30943,46 +32388,54 @@
 #define IPF_TRANSPARENT $squid_tmp_define
 _ACEOF
 
 unset squid_tmp_define
 
 
-if test "x$enable_ipf_transparent" = "xyes" -a "x$squid_host_os" = "xsolaris" ; then
-  solrev=`uname -r | sh -c 'IFS=. read j n x; echo $n'`
-  CFLAGS="-DSOLARIS2=$solrev $CFLAGS"
-  CXXFLAGS="-DSOLARIS2=$solrev $CXXFLAGS"
-fi
-
-if test "x$enable_pf_transparent" != "xno" ; then
+if test "x$with_nat_devpf" != "xno" ; then
   if test "x$ac_cv_header_net_pfvar_h" = "xyes" -o \
     "x$ac_cv_header_net_pf_pfvar_h" = "xyes"; then
-    if test "x$enable_pf_transparent" = "xauto" ; then
-      enable_pf_transparent="yes"
+    if test "x$with_nat_devpf" = "xauto" ; then
+      with_nat_devpf="no"
     fi
   else
-    if test "x$enable_pf_transparent" = "xyes" ; then
-      as_fn_error $? "PF-based transparent proxy requested but needed header not found" "$LINENO" 5
+    if test "x$with_nat_devpf" = "xyes" ; then
+      as_fn_error $? "PF /dev/pf based NAT requested but needed header not found" "$LINENO" 5
     fi
-    enable_pf_transparent="no"
+    with_nat_devpf="no"
   fi
 fi
 
 squid_tmp_define=""
-case "$enable_pf_transparent" in
+case "${enable_pf_transparent:=no}" in
   yes|true|1) squid_tmp_define="1" ;;
   no|false|0|"") squid_tmp_define="0" ;;
-  *) as_fn_error $? "SQUID_DEFINE_BOOL: unrecognized value for PF_TRANSPARENT: '$enable_pf_transparent'" "$LINENO" 5 ;;
+  *) as_fn_error $? "SQUID_DEFINE_BOOL: unrecognized value for PF_TRANSPARENT: '${enable_pf_transparent:=no}'" "$LINENO" 5 ;;
 esac
 
 cat >>confdefs.h <<_ACEOF
 #define PF_TRANSPARENT $squid_tmp_define
 _ACEOF
 
 unset squid_tmp_define
 
 
+squid_tmp_define=""
+case "${with_nat_devpf:=no}" in
+  yes|true|1) squid_tmp_define="1" ;;
+  no|false|0|"") squid_tmp_define="0" ;;
+  *) as_fn_error $? "SQUID_DEFINE_BOOL: unrecognized value for USE_NAT_DEVPF: '${with_nat_devpf:=no}'" "$LINENO" 5 ;;
+esac
+
+cat >>confdefs.h <<_ACEOF
+#define USE_NAT_DEVPF $squid_tmp_define
+_ACEOF
+
+unset squid_tmp_define
+
+
 if test "x$enable_linux_netfilter" != "xno" ; then
   if test "x$ac_cv_header_linux_netfilter_ipv4_h" = "xyes"; then
     if test "x$enable_linux_netfilter" = "xauto" ; then
       enable_linux_netfilter=yes
     fi
   else
@@ -31488,12 +32941,62 @@
 #define SQUID_TCP_SO_RCVBUF $SQUID_TCP_SO_RCVBUF
 _ACEOF
 
 
 
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether recv takes a pointer to void or char as second argument" >&5
+$as_echo_n "checking whether recv takes a pointer to void or char as second argument... " >&6; }
+if ${squid_cv_recv_second_arg_type+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+                 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#if HAVE_WINSOCK2_H
+#include <winsock2.h>
+#elif HAVE_WINSOCK_H
+#include <winsock.h>
+#endif
+int main (int argc, char ** argv) {
+       void *buf;
+  recv(0,buf,0,0);
+}
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  squid_cv_recv_second_arg_type=void
+else
+  squid_cv_recv_second_arg_type=char
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $squid_cv_recv_second_arg_type*" >&5
+$as_echo "$squid_cv_recv_second_arg_type*" >&6; }
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $squid_cv_recv_second_arg_type" >&5
+$as_echo "$squid_cv_recv_second_arg_type" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define RECV_ARG_TYPE $squid_cv_recv_second_arg_type
+_ACEOF
+
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking if sys_errlist is already defined" >&5
 $as_echo_n "checking if sys_errlist is already defined... " >&6; }
 if ${ac_cv_needs_sys_errlist+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -31879,19 +33382,19 @@
 
 # Check whether --enable-translation was given.
 if test "${enable_translation+set}" = set; then :
   enableval=$enable_translation;
 
 if test "$enableval" != "yes" -a "$enableval" != "no" ; then
-  as_fn_error $? "unrecognized argument to --disable-translation: $enableval" "$LINENO" 5
+  as_fn_error $? "unrecognized argument to --enable-translation: $enableval" "$LINENO" 5
 fi
 
 
 fi
 
-if test "x${enable_translation:=yes}" = "xyes" ; then
+if test "x${enable_translation:=no}" = "xyes" ; then
 
 
 
 
 
 
@@ -32146,16 +33649,13 @@
 $as_echo "$as_me: BUILD C++ FLAGS: $CXXFLAGS" >&6;}
 { $as_echo "$as_me:${as_lineno-$LINENO}: BUILD EXTRA C++ FLAGS: $SQUID_CXXFLAGS" >&5
 $as_echo "$as_me: BUILD EXTRA C++ FLAGS: $SQUID_CXXFLAGS" >&6;}
 
 rm -f core
 
-ac_config_files="$ac_config_files Makefile compat/Makefile lib/Makefile lib/ntlmauth/Makefile lib/profiler/Makefile lib/rfcnb/Makefile lib/smblib/Makefile scripts/Makefile src/Makefile src/anyp/Makefile src/base/Makefile src/acl/Makefile src/fs/Makefile src/repl/Makefile src/auth/Makefile src/auth/basic/Makefile src/auth/digest/Makefile src/auth/negotiate/Makefile src/auth/ntlm/Makefile src/adaptation/Makefile src/adaptation/icap/Makefile src/adaptation/ecap/Makefile src/comm/Makefile src/esi/Makefile src/eui/Makefile src/format/Makefile src/icmp/Makefile src/ident/Makefile src/ip/Makefile src/log/Makefile src/ipc/Makefile src/ssl/Makefile src/mgr/Makefile src/snmp/Makefile contrib/Makefile snmplib/Makefile icons/Makefile errors/Makefile test-suite/Makefile doc/Makefile doc/manuals/Makefile helpers/Makefile helpers/basic_auth/Makefile helpers/basic_auth/DB/Makefile helpers/basic_auth/fake/Makefile helpers/basic_auth/getpwnam/Makefile helpers/basic_auth/LDAP/Makefile helpers/basic_auth/MSNT/Makefile helpers/basic_auth/MSNT-multi-domain/Makefile helpers/basic_auth/NCSA/Makefile helpers/basic_auth/NIS/Makefile helpers/basic_auth/PAM/Makefile helpers/basic_auth/POP3/Makefile helpers/basic_auth/RADIUS/Makefile helpers/basic_auth/SASL/Makefile helpers/basic_auth/SMB/Makefile helpers/basic_auth/SSPI/Makefile helpers/digest_auth/Makefile helpers/digest_auth/eDirectory/Makefile helpers/digest_auth/file/Makefile helpers/digest_auth/LDAP/Makefile helpers/ntlm_auth/Makefile helpers/ntlm_auth/fake/Makefile helpers/ntlm_auth/smb_lm/Makefile helpers/ntlm_auth/SSPI/Makefile helpers/negotiate_auth/Makefile helpers/negotiate_auth/kerberos/Makefile helpers/negotiate_auth/SSPI/Makefile helpers/negotiate_auth/wrapper/Makefile helpers/external_acl/Makefile helpers/external_acl/AD_group/Makefile helpers/external_acl/eDirectory_userip/Makefile helpers/external_acl/file_userip/Makefile helpers/external_acl/kerberos_ldap_group/Makefile helpers/external_acl/LDAP_group/Makefile helpers/external_acl/LM_group/Makefile helpers/external_acl/session/Makefile helpers/external_acl/SQL_session/Makefile helpers/external_acl/unix_group/Makefile helpers/external_acl/wbinfo_group/Makefile helpers/external_acl/time_quota/Makefile helpers/log_daemon/Makefile helpers/log_daemon/DB/Makefile helpers/log_daemon/file/Makefile helpers/url_rewrite/Makefile helpers/url_rewrite/fake/Makefile tools/Makefile tools/purge/Makefile"
-
-
-subdirs="$subdirs lib/libTrie"
+ac_config_files="$ac_config_files Makefile compat/Makefile lib/Makefile lib/ntlmauth/Makefile lib/libTrie/Makefile lib/libTrie/test/Makefile lib/profiler/Makefile lib/rfcnb/Makefile lib/smblib/Makefile scripts/Makefile src/Makefile src/anyp/Makefile src/base/Makefile src/acl/Makefile src/fs/Makefile src/repl/Makefile src/auth/Makefile src/auth/basic/Makefile src/auth/digest/Makefile src/auth/negotiate/Makefile src/auth/ntlm/Makefile src/adaptation/Makefile src/adaptation/icap/Makefile src/adaptation/ecap/Makefile src/comm/Makefile src/esi/Makefile src/eui/Makefile src/format/Makefile src/http/Makefile src/icmp/Makefile src/ident/Makefile src/ip/Makefile src/log/Makefile src/ipc/Makefile src/ssl/Makefile src/mgr/Makefile src/snmp/Makefile contrib/Makefile snmplib/Makefile icons/Makefile errors/Makefile test-suite/Makefile doc/Makefile doc/manuals/Makefile helpers/Makefile helpers/basic_auth/Makefile helpers/basic_auth/DB/Makefile helpers/basic_auth/fake/Makefile helpers/basic_auth/getpwnam/Makefile helpers/basic_auth/LDAP/Makefile helpers/basic_auth/MSNT/Makefile helpers/basic_auth/MSNT-multi-domain/Makefile helpers/basic_auth/NCSA/Makefile helpers/basic_auth/NIS/Makefile helpers/basic_auth/PAM/Makefile helpers/basic_auth/POP3/Makefile helpers/basic_auth/RADIUS/Makefile helpers/basic_auth/SASL/Makefile helpers/basic_auth/SMB/Makefile helpers/basic_auth/SSPI/Makefile helpers/digest_auth/Makefile helpers/digest_auth/eDirectory/Makefile helpers/digest_auth/file/Makefile helpers/digest_auth/LDAP/Makefile helpers/ntlm_auth/Makefile helpers/ntlm_auth/fake/Makefile helpers/ntlm_auth/smb_lm/Makefile helpers/ntlm_auth/SSPI/Makefile helpers/negotiate_auth/Makefile helpers/negotiate_auth/kerberos/Makefile helpers/negotiate_auth/SSPI/Makefile helpers/negotiate_auth/wrapper/Makefile helpers/external_acl/Makefile helpers/external_acl/AD_group/Makefile helpers/external_acl/eDirectory_userip/Makefile helpers/external_acl/file_userip/Makefile helpers/external_acl/kerberos_ldap_group/Makefile helpers/external_acl/LDAP_group/Makefile helpers/external_acl/LM_group/Makefile helpers/external_acl/session/Makefile helpers/external_acl/SQL_session/Makefile helpers/external_acl/unix_group/Makefile helpers/external_acl/wbinfo_group/Makefile helpers/external_acl/time_quota/Makefile helpers/log_daemon/Makefile helpers/log_daemon/DB/Makefile helpers/log_daemon/file/Makefile helpers/url_rewrite/Makefile helpers/url_rewrite/fake/Makefile helpers/ssl/Makefile helpers/storeid_rewrite/Makefile helpers/storeid_rewrite/file/Makefile tools/Makefile tools/purge/Makefile"
 
 
 # must configure libltdl subdir unconditionally for "make distcheck" to work
 #AC_CONFIG_SUBDIRS(libltdl)
 
 cat >confcache <<\_ACEOF
@@ -32875,13 +34375,13 @@
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # Save the log message, to keep $0 and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by Squid Web Proxy $as_me 3.3.14, which was
+This file was extended by Squid Web Proxy $as_me 3.4.13, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -32941,13 +34441,13 @@
 Report bugs to <http://bugs.squid-cache.org/>."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-Squid Web Proxy config.status 3.3.14
+Squid Web Proxy config.status 3.4.13
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
 Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
@@ -33452,12 +34952,14 @@
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
     "compat/Makefile") CONFIG_FILES="$CONFIG_FILES compat/Makefile" ;;
     "lib/Makefile") CONFIG_FILES="$CONFIG_FILES lib/Makefile" ;;
     "lib/ntlmauth/Makefile") CONFIG_FILES="$CONFIG_FILES lib/ntlmauth/Makefile" ;;
+    "lib/libTrie/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libTrie/Makefile" ;;
+    "lib/libTrie/test/Makefile") CONFIG_FILES="$CONFIG_FILES lib/libTrie/test/Makefile" ;;
     "lib/profiler/Makefile") CONFIG_FILES="$CONFIG_FILES lib/profiler/Makefile" ;;
     "lib/rfcnb/Makefile") CONFIG_FILES="$CONFIG_FILES lib/rfcnb/Makefile" ;;
     "lib/smblib/Makefile") CONFIG_FILES="$CONFIG_FILES lib/smblib/Makefile" ;;
     "scripts/Makefile") CONFIG_FILES="$CONFIG_FILES scripts/Makefile" ;;
     "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
     "src/anyp/Makefile") CONFIG_FILES="$CONFIG_FILES src/anyp/Makefile" ;;
@@ -33474,12 +34976,13 @@
     "src/adaptation/icap/Makefile") CONFIG_FILES="$CONFIG_FILES src/adaptation/icap/Makefile" ;;
     "src/adaptation/ecap/Makefile") CONFIG_FILES="$CONFIG_FILES src/adaptation/ecap/Makefile" ;;
     "src/comm/Makefile") CONFIG_FILES="$CONFIG_FILES src/comm/Makefile" ;;
     "src/esi/Makefile") CONFIG_FILES="$CONFIG_FILES src/esi/Makefile" ;;
     "src/eui/Makefile") CONFIG_FILES="$CONFIG_FILES src/eui/Makefile" ;;
     "src/format/Makefile") CONFIG_FILES="$CONFIG_FILES src/format/Makefile" ;;
+    "src/http/Makefile") CONFIG_FILES="$CONFIG_FILES src/http/Makefile" ;;
     "src/icmp/Makefile") CONFIG_FILES="$CONFIG_FILES src/icmp/Makefile" ;;
     "src/ident/Makefile") CONFIG_FILES="$CONFIG_FILES src/ident/Makefile" ;;
     "src/ip/Makefile") CONFIG_FILES="$CONFIG_FILES src/ip/Makefile" ;;
     "src/log/Makefile") CONFIG_FILES="$CONFIG_FILES src/log/Makefile" ;;
     "src/ipc/Makefile") CONFIG_FILES="$CONFIG_FILES src/ipc/Makefile" ;;
     "src/ssl/Makefile") CONFIG_FILES="$CONFIG_FILES src/ssl/Makefile" ;;
@@ -33534,12 +35037,15 @@
     "helpers/external_acl/time_quota/Makefile") CONFIG_FILES="$CONFIG_FILES helpers/external_acl/time_quota/Makefile" ;;
     "helpers/log_daemon/Makefile") CONFIG_FILES="$CONFIG_FILES helpers/log_daemon/Makefile" ;;
     "helpers/log_daemon/DB/Makefile") CONFIG_FILES="$CONFIG_FILES helpers/log_daemon/DB/Makefile" ;;
     "helpers/log_daemon/file/Makefile") CONFIG_FILES="$CONFIG_FILES helpers/log_daemon/file/Makefile" ;;
     "helpers/url_rewrite/Makefile") CONFIG_FILES="$CONFIG_FILES helpers/url_rewrite/Makefile" ;;
     "helpers/url_rewrite/fake/Makefile") CONFIG_FILES="$CONFIG_FILES helpers/url_rewrite/fake/Makefile" ;;
+    "helpers/ssl/Makefile") CONFIG_FILES="$CONFIG_FILES helpers/ssl/Makefile" ;;
+    "helpers/storeid_rewrite/Makefile") CONFIG_FILES="$CONFIG_FILES helpers/storeid_rewrite/Makefile" ;;
+    "helpers/storeid_rewrite/file/Makefile") CONFIG_FILES="$CONFIG_FILES helpers/storeid_rewrite/file/Makefile" ;;
     "tools/Makefile") CONFIG_FILES="$CONFIG_FILES tools/Makefile" ;;
     "tools/purge/Makefile") CONFIG_FILES="$CONFIG_FILES tools/purge/Makefile" ;;
 
   *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/configure.ac	2015-05-01 16:52:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/configure.ac	2015-05-01 18:07:10.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT([Squid Web Proxy],[3.3.14],[http://bugs.squid-cache.org/],[squid])
+AC_INIT([Squid Web Proxy],[3.4.13],[http://bugs.squid-cache.org/],[squid])
 AC_PREREQ(2.61)
 AC_CONFIG_HEADERS([include/autoconf.h])
 AC_CONFIG_AUX_DIR(cfgaux)
 AC_CONFIG_SRCDIR([src/main.cc])
 AM_INIT_AUTOMAKE([tar-ustar nostdinc])
 AC_REVISION($Revision$)dnl
@@ -13,13 +13,13 @@
 m4_include([acinclude/compiler-flags.m4])
 m4_include([acinclude/os-deps.m4])
 m4_include([acinclude/krb5.m4])
 m4_include([acinclude/pam.m4])
 m4_include([acinclude/pkg.m4])
 m4_include([acinclude/lib-checks.m4])
-m4_include([acinclude/ax_cxx_compile_stdcxx_0x.m4])
+m4_include([acinclude/ax_cxx_compile_stdcxx_11.m4])
 m4_include([acinclude/ax_cxx_0x_types.m4])
 
 PRESET_CFLAGS="$CFLAGS"
 PRESET_CXXFLAGS="$CXXFLAGS"
 PRESET_LDFLAGS="$LDFLAGS"
 
@@ -32,15 +32,39 @@
 AC_PROG_CC
 AM_PROG_CC_C_O
 AC_PROG_CXX
 AC_LANG([C++])
 AC_CANONICAL_HOST
 
-# might be cross-compiling
+# Clang 3.2 on some CPUs requires -march-native to detect correctly.
+# GCC 4.3+ can also produce faster executables when its used.
+# But building inside a virtual machine environment has been found to
+# cause random Illegal Instruction errors due to mis-detection of CPU.
+AC_ARG_ENABLE(arch-native,
+  AS_HELP_STRING([--disable-arch-native],[Some compilers offer CPU-specific
+                 optimizations with the -march=native parameter.
+                 This flag disables the optimization. The default is to
+                 auto-detect compiler support and use where available.]), [
+  SQUID_YESNO([$enableval],
+    [Unrecognized argument to --disable-arch-native: $enableval])
+])
+AC_MSG_NOTICE([CPU -march=native optimization enabled: ${enable_arch_native:=auto}])
+if test "x${enable_arch_native}" != "xno"; then
+  SQUID_CC_CHECK_ARGUMENT([squid_cv_check_marchnative],[-march=native])
+fi
+
+# might be cross-compiling.
 if test "x$HOSTCXX" = "x"; then
   HOSTCXX="$CXX"
+  if test "x$squid_cv_check_marchnative" = "xyes"; then
+    CXXFLAGS="$CXXFLAGS -march=native"
+  fi
+fi
+if test "x$squid_cv_check_marchnative" = "xyes"; then
+  # always valid for the Host compiler.
+  HOSTCXX="$HOSTCXX -march=native"
 fi
 AC_SUBST(HOSTCXX)
 
 AC_MSG_CHECKING([simplified host os])
 simple_host_os=`echo $host_os|sed 's/[0-9].*//g;s/-.*//g'`
 squid_host_os_version=`echo $host_os|tr -d "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-"`
@@ -55,22 +79,21 @@
 # this needs to be before any test is run, to have more standard
 # functions available on some Unix sysems (e.g. Solaris)
 if test "x$squid_host_os" = "solaris" -a "x$GCC" != "x" ; then
 	AC_USE_SYSTEM_EXTENSIONS
 fi
 
-# Check for C++0x compiler support
-AX_CXX_COMPILE_STDCXX_0X
-if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" -a \
-  "x$squid_host_os" != "xmingw" ; then
+# Check for C++11 compiler support
+if test "x$squid_host_os" != "xmingw" ; then
     #BUG 3613: when clang -std=c++0x is used, it activates a "strict mode"
     # in the system libraries, which makes some c99 methods unavailable
     # (e.g. strtoll), yet configure detects them as avilable.
     case "$CXX" in
       *clang++*) ;; #do nothing
-      *) CXXFLAGS="$CXXFLAGS -std=c++0x" ;;
+      *)
+      AX_CXX_COMPILE_STDCXX_11([noext],[optional])
     esac
 fi
 
 # test for programs
 AC_PROG_RANLIB
 AC_PROG_CPP
@@ -324,19 +347,19 @@
   case "$squid_host_os" in
   mingw)
 dnl Guido Serassio (serassio@squid-cache.org) 20070811
 dnl Using the latest MinGW (gcc 3.4.5 + mingw-runtime 3.13) cannot build with
 dnl -Werror -Wmissing-prototypes -Wmissing-declarations
 dnl TODO: check if the problem will be present in any other newer MinGW release.
-    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments"
+    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow"
     ;;
   *)
-    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments"
+    SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments -Wshadow"
     ;;
   esac
-  SQUID_CXXFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments"
+  SQUID_CXXFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow"
 else
   SQUID_CFLAGS=
   SQUID_CXXFLAGS=
 fi
 
 if test "x$enable_strict_error_checking" != "xno"; then
@@ -404,15 +427,15 @@
 ]])],
 [
     AC_DEFINE(HAVE_ATOMIC_OPS,1,[Define to 1 if you have __sync_add_and_fetch() and such])
     AC_MSG_RESULT(yes)
 ],[
     AC_MSG_RESULT(no)
+],[ AC_MSG_RESULT(cross-compiler cant tell)
 ])
 
-
 AC_ARG_ENABLE(debug-cbdata,
   AS_HELP_STRING([--enable-debug-cbdata],
       [Provide some debug information in cbdata]), [ 
 SQUID_YESNO([$enableval],
     [unrecognized argument to --enable-debug-cbdata: $enableval])
 ])
@@ -432,24 +455,12 @@
 dnl [ if test "$enableval" = "yes" ; then
 dnl     AC_MSG_NOTICE([malloc debugging enabled])
 dnl     AC_DEFINE(XMALLOC_DEBUG,1,[Define to do simple malloc debugging])
 dnl   fi
 dnl ])
 
-dnl This is a developer only option.. developers know how to set defines
-dnl
-dnl AC_ARG_ENABLE(xmalloc-debug-trace,
-dnl [  --enable-xmalloc-debug-trace
-dnl                           Detailed trace of memory allocations],
-dnl [ if test "$enableval" = "yes" ; then
-dnl     AC_MSG_NOTICE([malloc debug trace enabled])
-dnl     AC_DEFINE(XMALLOC_TRACE,1,[Define to have a detailed trace of memory allocations])
-dnl     AC_DEFINE(XMALLOC_DEBUG,1)
-dnl   fi
-dnl ])
-
 AH_TEMPLATE(XMALLOC_STATISTICS,[Define to have malloc statistics])
 AC_ARG_ENABLE(xmalloc-statistics,
   AS_HELP_STRING([--enable-xmalloc-statistics],
                  [Show malloc statistics in status page]), [
 SQUID_YESNO([$enableval],
     [unrecognized argument to --enable-xmalloc-statistics: $enableval])
@@ -1111,13 +1122,13 @@
               [unrecognized argument to --disable-snmp: $enableval])
 ])
 SQUID_DEFINE_BOOL(SQUID_SNMP,${enable_snmp:=yes},
    [Define to enable SNMP monitoring of Squid])
 AM_CONDITIONAL(ENABLE_SNMP, [test "x$enable_snmp" = "xyes"])
 if test "x$enable_snmp" = "xyes"; then
-    SNMPLIB='../snmplib/libsnmplib.a'
+    SNMPLIB='../snmplib/libsnmplib.la'
     makesnmplib=snmplib
 fi
 AC_MSG_NOTICE([SNMP support enabled: $enable_snmp])
 AC_SUBST(SNMPLIB)
 AC_SUBST(makesnmplib)
 
@@ -1155,13 +1166,13 @@
       EUILIB="-liphlpapi"
       ;;
     *)
       AC_MSG_WARN([EUI support probably will not work on host $host.])
       ;;
   esac
-  #Iphlpapi.h check delayed after winsock2.h
+  # iphlpapi.h check delayed after winsock2.h
   AC_CHECK_HEADERS( \
     windows.h \
     sys/sockio.h \
     sys/param.h,
   [], [], [[
 #if HAVE_WINDOWS_H
@@ -1201,12 +1212,36 @@
 ])
 SQUID_DEFINE_BOOL(USE_HTCP,${enable_htcp:=yes},
    [Define this to include code for the Hypertext Cache Protocol (HTCP)])
 AM_CONDITIONAL(ENABLE_HTCP, [test "x$enable_htcp" = "xyes"])
 AC_MSG_NOTICE([HTCP support enabled: $enable_htcp])
 
+# Cryptograhic libraries
+AC_ARG_WITH(nettle,
+  AS_HELP_STRING([--without-nettle],[Compile without the Nettle crypto library.]),[
+case "$with_nettle" in
+  yes|no)
+    : # Nothing special to do here
+    ;;
+  *)
+    if test ! -d "$withval" ; then
+      AC_MSG_ERROR([--with-nettle path does not point to a directory])
+    fi
+    NETTLELIBDIR="-L$with_nettle/lib"
+    CPPFLAGS="-I$with_nettle/include $CPPFLAGS"
+    with_nettle=yes
+  esac
+])
+if test "x$with_nettle" != "xno" ; then
+  AC_CHECK_LIB(nettle, nettle_md5_init,[
+    NETTLELIB="$NETTLELIBDIR -lnettle"
+    AC_CHECK_HEADERS(nettle/md5.h)
+  ],[with_nettle=no])
+fi
+AC_MSG_NOTICE([Using Nettle cryptographic library: ${with_nettle:=yes}])
+AC_SUBST(NETTLELIB)
 
 # SSL is not enabled by default.
 # Default is to use OpenSSL when available
 AC_ARG_ENABLE(ssl,
   AS_HELP_STRING([--enable-ssl],
                  [Enable ssl gatewaying support using OpenSSL]), [
@@ -1250,17 +1285,15 @@
     CPPFLAGS="-I$with_openssl/include $CPPFLAGS"
     with_openssl=yes
   esac
 ])
 SQUID_DEFINE_BOOL(USE_SSL,$enable_ssl,
    [Define this to include code for SSL gatewaying support])
-AC_MSG_NOTICE([Using OpenSSL MD5 implementation: ${with_openssl:=no}])
-SQUID_DEFINE_BOOL(USE_OPENSSL,${with_openssl},
-   [Define this to make use of the OpenSSL libraries for MD5 calculation rather than Squid-supplied MD5 implementation or if building with SSL encryption])
+AC_MSG_NOTICE([Using OpenSSL library: ${with_openssl:=no}])
 if test "x$enable_ssl" = "xyes"; then
-  if test "x$SSLLIB" = "x"; then
+  if test "x$SSLLIB" = "x" -a "x$with_nettle" = "xno"; then
     SSLLIB="-lcrypto" # for MD5 routines
   fi
   # This is a workaround for RedHat 9 brain damage..
   if test -d /usr/kerberos/include -a "x$SSLLIBDIR" = "x" -a -f /usr/include/openssl/kssl.h; then
     AC_MSG_NOTICE([OpenSSL depends on Kerberos])
     SSLLIBDIR="/usr/kerberos/lib"
@@ -1478,13 +1511,23 @@
   AS_HELP_STRING([--enable-pf-transparent],
     [Enable Transparent Proxy support for systems using PF network address redirection.]), [
   SQUID_YESNO([$enableval],
               [unrecognized argument to --enable-pf-transparent: $enableval])
 ])
 #will be AC_DEFINEd later, after checking for appropriate infrastructure
-AC_MSG_NOTICE([PF-based transparent proxying requested: ${enable_pf_transparent:=auto}])
+AC_MSG_NOTICE([PF-based transparent proxying requested: ${enable_pf_transparent:=no}])
+
+dnl Enable /dev/pf support for older PF Transparent Proxy systems (OpenBSD 4.x and older)
+AC_ARG_WITH(nat-devpf,
+  AS_HELP_STRING([--with-nat-devpf],
+    [Enable /dev/pf support for NAT on older OpenBSD and FreeBSD kernels.]), [
+  SQUID_YESNO([$enableval],
+              [unrecognized argument to --with-nat-devpf: $enableval])
+])
+#will be AC_DEFINEd later, after checking for appropriate infrastructure
+AC_MSG_NOTICE([NAT lookups via /dev/pf: ${with_nat_devpf:=no}])
 
 # Linux Netfilter Transparent Proxy
 AC_ARG_ENABLE(linux-netfilter,
   AS_HELP_STRING([--enable-linux-netfilter],
                  [Enable Transparent Proxy support for Linux (Netfilter)]), [
   SQUID_YESNO([$enableval],
@@ -1568,25 +1611,29 @@
   *)
     buildmodel="$withval"
     ;;
 esac
 ])
 
+#hack. Let's early-detect sizeof(long)
+AC_CHECK_SIZEOF(long)
+
 if test "x$squid_opt_enable_large_files" = "xyes" -a "x$buildmodel" = "x"; then
   for model in POSIX_V6_LPBIG_OFFBIG XBS5_LPBIG_OFFBIG POSIX_V6_LP64_OFF64 XBS5_LP64_OFF64 POSIX_V6_ILP32_OFFBIG XBS5_ILP32_OFFBIG; do
     if test "`getconf _$model 2>/dev/null || true`" = 1 || test "`getconf $model 2>/dev/null || true`" ; then
       buildmodel=$model
       break
     fi
   done
   if test "x$buildmodel" = "x"; then
     AC_MSG_WARN([No suitable build environment found for large files. Trying to use _FILE_OFFSET_BITS=64])
   fi
 fi
 if test "x$buildmodel" = "xdefault" -o "x$buildmodel" = "x"; then
-  if test "x$squid_opt_enable_large_files" = "xyes" ; then
+  # define _FILE_OFFSET_BITS if requested and needed
+  if test "x$squid_opt_enable_large_files" = "xyes" -a $ac_cv_sizeof_long -le 4 ; then
     AC_MSG_NOTICE([Enabling -D_FILE_OFFSET_BITS=64])
     CFLAGS="-D_FILE_OFFSET_BITS=64 $CFLAGS"
     CXXFLAGS="-D_FILE_OFFSET_BITS=64 $CXXFLAGS"
   fi
 else
   AC_MSG_NOTICE([Using $buildmodel build environment])
@@ -1725,93 +1772,24 @@
       all possible helpers. Default is to do so.
       To disable the basic authentication scheme, use --disable-auth-basic.
       To enable but build no helpers, specify "none".
       To see available helpers, see the helpers/basic_auth directory. ]),[
 #nothing to do really
 ])
-#not specified. Inherit global
-if test "x$enable_auth_basic" = "x"; then
-    enable_auth_basic=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_basic" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Basic auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_basic" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/basic_auth],[enable_auth_basic])
-fi
-#handle the "none" special case
-if test "x$enable_auth_basic" = "xnone" ; then
-    enable_auth_basic=""
-fi
-BASIC_AUTH_HELPERS=""
-#enable_auth_basic contains either "no" or the list of modules to be built
-enable_auth_basic="`echo $enable_auth_basic| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_basic" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES basic"
-    AC_DEFINE([HAVE_AUTH_MODULE_BASIC],1,[Basic auth module is built])
-    for helper in $enable_auth_basic
-    do
-    dir="$srcdir/helpers/basic_auth/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xSASL" ; then
-        squid_require_sasl=yes
-      fi
-    elif test -d "$srcdir/helpers/basic_auth/$helper" ; then
-      AC_MSG_NOTICE([Basic auth helper $helper ... found but cannot be built])
-    fi
-    done
-fi
-AC_MSG_NOTICE([Basic auth helpers to be built: $BASIC_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_BASIC, test "x$enable_auth_basic" != "xno")
-AC_SUBST(BASIC_AUTH_HELPERS)
+m4_include([helpers/basic_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-ntlm,
   AS_HELP_STRING([--enable-auth-ntlm="list of helpers"],
      [Enable the NTLM authentication scheme, and build the specified helpers.
       Not providing an explicit list of helpers will attempt build of
       all possible helpers. Default is to do so.
       To disable the NTLM authentication scheme, use --disable-auth-ntlm.
       To enable but build no helpers, specify "none".
       To see available helpers, see the helpers/ntlm_auth directory. ]),[
 ])
-if test "x$enable_auth_ntlm" = "x"; then
-    enable_auth_ntlm=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_ntlm" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([NTLM auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_ntlm" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/ntlm_auth],[enable_auth_ntlm])
-fi
-#handle the "none" special case
-if test "x$enable_auth_ntlm" = "xnone" ; then
-    enable_auth_ntlm=""
-fi
-NTLM_AUTH_HELPERS=""
-enable_auth_ntlm="`echo $enable_auth_ntlm| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_ntlm" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES ntlm"
-    AC_DEFINE([HAVE_AUTH_MODULE_NTLM],1,[NTLM auth module is built])
-    for helper in $enable_auth_ntlm ; do
-        dir="$srcdir/helpers/ntlm_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-            AC_MSG_NOTICE([NTLM auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([NTLM auth helpers built: $NTLM_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_NTLM, test "x$enable_auth_ntlm" != "xno")
-AC_SUBST(NTLM_AUTH_HELPERS)
+m4_include([helpers/ntlm_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-negotiate,
   AS_HELP_STRING([--enable-auth-negotiate="list of helpers"],
      [Enable the Negotiate authentication scheme, and build the specified 
       helpers.
       Not providing an explicit list of helpers will attempt build of
@@ -1819,126 +1797,46 @@
       To disable the Negotiate authentication scheme, 
       use --disable-auth-negotiate.
       To enable but build no helpers, specify "none".
       To see available helpers, see the helpers/negotiate_auth directory. ]),[
 #nothing to do, really
 ])
-if test "x$enable_auth_negotiate" = "x"; then
-    enable_auth_negotiate=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_negotiate" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Negotiate auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_negotiate" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/negotiate_auth],[enable_auth_negotiate])
-fi
-#handle the "none" special case
-if test "x$enable_auth_negotiate" = "xnone" ; then
-    enable_auth_negotiate=""
-fi
-NEGOTIATE_AUTH_HELPERS=""
-enable_auth_negotiate="`echo $enable_auth_negotiate| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_negotiate" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES negotiate"
-    AC_DEFINE([HAVE_AUTH_MODULE_NEGOTIATE],1,[Negotiate auth module is built])
-    for helper in $enable_auth_negotiate ; do
-        dir="$srcdir/helpers/negotiate_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/negotiate_auth/$helper" ; then
-            AC_MSG_NOTICE([Negotiate auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([Negotiate auth helpers built: $NEGOTIATE_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_NEGOTIATE, test "x$enable_auth_negotiate" != "xno")
-AC_SUBST(NEGOTIATE_AUTH_HELPERS)
+m4_include([helpers/negotiate_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-digest,
   AS_HELP_STRING([--enable-auth-digest="list of helpers"],
      [Enable the Digest authentication scheme, and build the specified helpers.
       Not providing an explicit list of helpers will attempt build of
       all possible helpers. Default is to do so.
       To disable the Digest authentication scheme, use --disable-auth-digest.
       To enable but build no helpers, specify "none".
       To see available helpers, see the helpers/digest_auth directory. ]),[
 #nothing to do, really
 ])
-if test "x$enable_auth_digest" = "x"; then
-    enable_auth_digest=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_digest" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Digest auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_digest" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/digest_auth],[enable_auth_digest])
-fi
-#handle the "none" special case
-if test "x$enable_auth_digest" = "xnone" ; then
-    enable_auth_digest=""
-fi
-DIGEST_AUTH_HELPERS=""
-enable_auth_digest="`echo $enable_auth_digest| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_digest" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES digest"
-    AC_DEFINE([HAVE_AUTH_MODULE_DIGEST],1,[Digest auth module is built])
-    for helper in $enable_auth_digest ; do
-        dir="$srcdir/helpers/digest_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/digest_auth/$helper" ; then
-            AC_MSG_NOTICE([Digest auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([Digest auth helpers built: $DIGEST_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_DIGEST, test "x$enable_auth_digest" != "xno")
-AC_SUBST(DIGEST_AUTH_HELPERS)
+m4_include([helpers/digest_auth/modules.m4])
 
 dnl Authentication libraries to build
 dnl This list will not be needed when each auth library has its own Makefile
 dnl this is to be placed AFTER each auth module's handler
 AUTH_LIBS_TO_BUILD=
 for module in $AUTH_MODULES; do
     AUTH_LIBS_TO_BUILD="$AUTH_LIBS_TO_BUILD ${module}/lib${module}.la"
 done
 AC_SUBST(AUTH_MODULES)
 AC_SUBST(AUTH_LIBS_TO_BUILD)
 
 dnl Select logging daemon helpers to build
-squid_opt_logdaemon_helpers="auto"
 AC_ARG_ENABLE(log-daemon-helpers,
   AS_HELP_STRING([--enable-log-daemon-helpers="list of helpers"],
                  [This option selects which logging daemon helpers to 
                   build and install as part of the normal build process
                   For a list of available helpers see the helpers/log_daemon
                   directory.]),[
-case "$enableval" in
-  yes) : ;;
-  no)  squid_opt_logdaemon_helpers="" ;;
-  *)   squid_opt_logdaemon_helpers="`echo $enableval| sed -e 's/,/ /g;s/  */ /g'`" ;;
-  esac
+#nothing to do, really
 ])
-if test "x$squid_opt_logdaemon_helpers" = "xauto" ; then
-  squid_opt_logdaemon_helpers=""
-  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/log_daemon],[squid_opt_logdaemon_helpers])
-fi
-for helper in $squid_opt_logdaemon_helpers ; do
-  dir="$srcdir/helpers/log_daemon/$helper"
-  if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-    LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $helper"
-  elif test -d "$srcdir/helpers/log_daemon/$helper" ; then
-    AC_MSG_NOTICE([Log daemon helper $helper ... found but cannot be built])
-  fi
-done
-AC_MSG_NOTICE([Log daemon helpers built: $LOG_DAEMON_HELPERS])
-AC_SUBST(LOG_DAEMON_HELPERS)
+m4_include([helpers/log_daemon/modules.m4])
 
 dnl
 dnl Check Kerberos/GSSAPI/SPNEGO
 dnl
 SQUID_STATE_SAVE([krbsave])
 
@@ -1984,13 +1882,13 @@
     KRB5INCS="`$krb5confpath --cflags gssapi 2>/dev/null` $KRB5INCS"
     KRB5LIBS="`$krb5confpath --libs gssapi 2>/dev/null` $KRB5LIBS"
   fi
   CPPFLAGS="$CPPFLAGS $KRB5INCS"
   LIBS="$LIBS $KRB5LIBS"
   AC_CHECK_HEADERS(gssapi.h gssapi/gssapi.h gssapi/gssapi_krb5.h)
-  if test "x$ac_heimdal" == "x" ; then
+  if test "x$ac_heimdal" = "x" ; then
     AC_CHECK_HEADERS(gssapi/gssapi_generic.h)
     AC_CHECK_HEADERS(profile.h)
   fi
 
   SQUID_CHECK_KRB5_SOLARIS_BROKEN_KRB5_H
   if test "x$squid_cv_broken_krb5_h" = "xyes"; then
@@ -2004,39 +1902,43 @@
   if test "x$squid_cv_broken_heimdal_krb5_h" = "xyes"; then
     AC_DEFINE(HAVE_BROKEN_HEIMDAL_KRB5_H, 1, [Define to 1 if Heimdal krb5.h is broken for C++])
   fi
   AC_CHECK_HEADERS(krb5.h com_err.h et/com_err.h)
 
   ac_com_error_message=no
-  if test "x$ac_cv_header_com_err_h" == "xyes" ; then
+  if test "x$ac_cv_header_com_err_h" = "xyes" ; then
       AC_EGREP_HEADER(error_message,com_err.h,ac_com_error_message=yes)
-  elif test "x$ac_cv_header_et_com_err_h" == "xyes" ; then
+  elif test "x$ac_cv_header_et_com_err_h" = "xyes" ; then
       AC_EGREP_HEADER(error_message,et/com_err.h,ac_com_error_message=yes)
   fi
 
   SQUID_CHECK_MAX_SKEW_IN_KRB5_CONTEXT
   if test "x$squid_cv_max_skew_context" = "xyes"; then
     AC_DEFINE(HAVE_MAX_SKEW_IN_KRB5_CONTEXT, 1, [Define to 1 if max_skew in struct krb5_context])
   fi
 
-  if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" == "xyes" ; then
+  if test `echo $KRB5LIBS | grep -c com_err` -ne 0 -a "x$ac_com_error_message" = "xyes" ; then
     AC_CHECK_LIB(com_err,error_message,
       AC_DEFINE(HAVE_ERROR_MESSAGE,1,
         [Define to 1 if you have error_message]),)
-  elif test  "x$ac_com_error_message" == "xyes" ; then
+  elif test  "x$ac_com_error_message" = "xyes" ; then
     AC_CHECK_LIB(krb5,error_message,
       AC_DEFINE(HAVE_ERROR_MESSAGE,1,
         [Define to 1 if you have error_message]),)
   fi
   AC_CHECK_LIB(krb5,krb5_get_err_text,
     AC_DEFINE(HAVE_KRB5_GET_ERR_TEXT,1,
       [Define to 1 if you have krb5_get_err_text]),)
   AC_CHECK_LIB(krb5,krb5_get_error_message,
     AC_DEFINE(HAVE_KRB5_GET_ERROR_MESSAGE,1,
       [Define to 1 if you have krb5_get_error_message]),)
   AC_CHECK_DECLS(krb5_kt_free_entry,,,[#include <krb5.h>])
+  AC_CHECK_TYPE(krb5_pac,
+    AC_DEFINE(HAVE_KRB5_PAC,1,
+      [Define to 1 if you have krb5_pac]),,
+      [#include <krb5.h>])
   AC_CHECK_LIB(krb5,krb5_kt_free_entry,
     AC_DEFINE(HAVE_KRB5_KT_FREE_ENTRY,1,
       [Define to 1 if you have krb5_kt_free_entry]),)
   AC_CHECK_LIB(krb5,krb5_get_init_creds_keytab,
     AC_DEFINE(HAVE_GET_INIT_CREDS_KEYTAB,1,
       [Define to 1 if you have krb5_get_init_creds_keytab]),)
@@ -2049,12 +1951,39 @@
   AC_CHECK_LIB(krb5,profile_get_integer,
     AC_DEFINE(HAVE_PROFILE_GET_INTEGER,1,
       [Define to 1 if you have profile_get_integer]),)
   AC_CHECK_LIB(krb5,profile_release,
     AC_DEFINE(HAVE_PROFILE_RELEASE,1,
       [Define to 1 if you have profile_release]),)
+  AC_CHECK_LIB(krb5,krb5_get_renewed_creds,
+    AC_DEFINE(HAVE_KRB5_GET_RENEWED_CREDS,1,
+      [Define to 1 if you have krb5_get_renewed_creds]),)
+  AC_CHECK_LIB(krb5,krb5_principal_get_realm,
+    AC_DEFINE(HAVE_KRB5_PRINCIPAL_GET_REALM,1,
+      [Define to 1 if you have krb5_principal_get_realm]),)
+  AC_CHECK_LIB(krb5, krb5_get_init_creds_opt_alloc,
+    AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC,1,
+      [Define to 1 if you have krb5_get_init_creds_opt_alloc]),)
+  AC_MSG_CHECKING([for krb5_get_init_creds_free requires krb5_context])
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+	#include <krb5.h>
+    ]],[[krb5_context context;
+	 krb5_get_init_creds_opt *options;
+	 krb5_get_init_creds_opt_free(context, options)]])],[
+	AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_FREE_CONTEXT,1,
+		  [Define to 1 if you krb5_get_init_creds_free requires krb5_context])
+	AC_MSG_RESULT(yes)
+    ],[AC_MSG_RESULT(no)],[AC_MSG_RESULT(no)])
+
+
+  AC_CHECK_FUNCS(gss_map_name_to_any,
+    AC_DEFINE(HAVE_GSS_MAP_ANY_TO_ANY,1,
+      [Define to 1 if you have gss_map_name_to_any]),)
+  AC_CHECK_FUNCS(gsskrb5_extract_authz_data_from_sec_context,
+    AC_DEFINE(HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT,1,
+      [Define to 1 if you have gsskrb5_extract_authz_data_from_sec_context]),)
 
   SQUID_CHECK_KRB5_CONTEXT_MEMORY_CACHE
   SQUID_DEFINE_BOOL(HAVE_KRB5_MEMORY_CACHE,$squid_cv_memory_cache,
        [Define if kerberos has MEMORY: cache support])
 
   SQUID_CHECK_WORKING_GSSAPI
@@ -2079,72 +2008,37 @@
                   To disable support, use --disable-external-acl-helpers.
                   To build no helpers, specify "none".
                   To see available helpers, see the helpers/external_acl
                   directory]), [
 #nothing to do, really
 ])
-if test "x${enable_external_acl_helpers:=yes}" = "xyes" ;then
-  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/external_acl],
-    [enable_external_acl_helpers])
-fi
-if test "x$enable_external_acl_helpers" = "xnone" ; then
-  enable_external_acl_helpers=""
-fi
-EXTERNAL_ACL_HELPERS=""
-enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_external_acl_helpers" != "xno" ; then
-  for helper in $enable_external_acl_helpers ; do
-    dir="$srcdir/helpers/external_acl/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xkerberos_ldap_group" ; then
-        squid_require_sasl=yes
-      fi
-    else
-      AC_MSG_NOTICE([external acl helper $helper ... found but cannot be built])
-    fi
-  done
-fi
-AC_MSG_NOTICE([External acl helpers built: $EXTERNAL_ACL_HELPERS])
-AC_SUBST(EXTERNAL_ACL_HELPERS)
-
-
+m4_include([helpers/external_acl/modules.m4])
 
 dnl Select url_rewrite helpers to build
 AC_ARG_ENABLE(url-rewrite-helpers,
   AS_HELP_STRING([--enable-url-rewrite-helpers="list of helpers"],
                  [This option selects which url_rewrite helpers to
                   build and install as part of the normal build
                   process. The default is to attempt the build of all possible
                   helpers. Use --disable-url-rewrite-helpers to build none.
                   For a list of available helpers see the
                   helpers/url_rewrite directory.]),[
 ])
-if test "x${enable_url_rewrite_helpers:=yes}" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/url_rewrite],
-                           [enable_url_rewrite_helpers])
-fi
-enable_url_rewrite_helpers="`echo $enable_url_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-AC_MSG_NOTICE([URL rewrite helper candidates: $enable_url_rewrite_helpers])
-URL_REWRITE_HELPERS=""
-if test "x$enable_url_rewrite_helpers" != "xno" ; then
-  for helper in $enable_url_rewrite_helpers; do
-    dir="$srcdir/helpers/url_rewrite/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $helper"
-    elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-      AC_MSG_NOTICE([URL rewrite helper $helper ... found but cannot be built])
-    else
-      AC_MSG_NOTICE([URL rewrite helper $helper ... not found])
-    fi
-  done
-fi
-AC_MSG_NOTICE([URL rewrite helpers built: $URL_REWRITE_HELPERS])
-AC_SUBST(URL_REWRITE_HELPERS)
+m4_include([helpers/url_rewrite/modules.m4])
 
+dnl Select storeid_rewrite helpers to build
+AC_ARG_ENABLE(storeid-rewrite-helpers,
+  AS_HELP_STRING([--enable-storeid-rewrite-helpers="list of helpers"],
+                 [This option selects which Store-ID rewrite helpers to
+                  build and install as part of the normal build
+                  process. The default is to attempt the build of all possible
+                  helpers. Use --disable-storeid-rewrite-helpers to build none.
+                  For a list of available helpers see the
+                  helpers/storeid_rewrite directory.]),[
+])
+m4_include([helpers/storeid_rewrite/modules.m4])
 
 AC_ARG_WITH(valgrind-debug,
   AS_HELP_STRING([--with-valgrind-debug],
                  [Include debug instrumentation for use with valgrind]),
 [
   SQUID_YESNO([$withval],
@@ -2183,33 +2077,12 @@
 ])
 SQUID_DEFINE_BOOL(USE_WIN32_SERVICE,${enable_win32_service:=no},
    [Enable code supporting MS Windows service mode])
 AC_MSG_NOTICE([MS Windows service mode enabled: $enable_win32_service])
 
 
-# Check for Cyrus SASL
-if test "x$squid_require_sasl" = "xyes"; then
-  AC_CHECK_HEADERS(sasl/sasl.h sasl.h)
-  AC_CHECK_LIB(sasl2,sasl_errstring,[LIBSASL="-lsasl2"],[
-    AC_CHECK_LIB(sasl,sasl_errstring,[LIBSASL="-lsasl"], [
-      AC_MSG_ERROR(Neither SASL nor SASL2 found)
-    ])
-  ])
-  case "$squid_host_os" in
-    Darwin)
-      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
-        AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
-        echo "checking for MAC Darwin without sasl.h ... yes"
-      else
-        echo "checking for MAC Darwin without sasl.h ... no"
-      fi
-      ;;
-  esac
-  AC_SUBST(LIBSASL)
-fi
-
 # Disable "unlinkd" code
 AC_ARG_ENABLE(unlinkd,
   AS_HELP_STRING([--disable-unlinkd],[Do not use unlinkd]), [
 SQUID_YESNO([$enableval],
             [unrecognized argument to --disable-unlinkd: $enableval])
 ])
@@ -2345,12 +2218,13 @@
   arpa/nameser.h \
   assert.h \
   bstring.h \
   cassert \
   crypt.h \
   cstdarg \
+  cstdio \
   cstdlib \
   cstring \
   list \
   ctype.h \
   errno.h \
   execinfo.h \
@@ -2362,35 +2236,29 @@
   grp.h \
   iosfwd \
   iomanip \
   iostream \
   fstream \
   climits \
-  ip_compat.h \
-  ip_fil_compat.h \
-  ip_fil.h \
-  ip_nat.h \
   ipl.h \
   lber.h \
   ldap.h \
   libc.h \
   limits \
   limits.h \
   linux/posix_types.h \
   linux/types.h \
-  machine/byte_swap.h \
   malloc.h \
   map \
   math.h \
   memory.h \
   memory \
   mount.h \
   netdb.h \
   netinet/in.h \
   netinet/in_systm.h \
-  netinet/ip_fil_compat.h \
   openssl/err.h \
   openssl/md5.h \
   openssl/opensslv.h \
   openssl/ssl.h \
   openssl/x509v3.h \
   netinet/tcp.h \
@@ -2400,13 +2268,12 @@
   paths.h \
   poll.h \
   pwd.h \
   shadow.h \
   regex.h \
   sched.h \
-  security/pam_appl.h \
   siginfo.h \
   signal.h \
   sstream \
   stdarg.h \
   stdbool.h \
   stddef.h \
@@ -2414,23 +2281,23 @@
   stdio.h \
   stdlib.h \
   string \
   string.h \
   strings.h \
   sys/bitypes.h \
-  sys/bswap.h \
-  sys/endian.h \
   sys/file.h \
   sys/ioctl.h \
+  sys/ipc.cc \
   sys/param.h \
   sys/prctl.h \
   sys/md5.h \
   sys/mman.h \
   sys/msg.h \
   sys/resource.h \
   sys/select.h \
+  sys/shm.h \
   sys/socket.h \
   sys/stat.h \
   sys/statvfs.h \
   syscall.h \
   sys/syscall.h \
   sys/time.h \
@@ -2450,16 +2317,15 @@
   inttypes.h \
   db.h \
   db_185.h \
   wchar.h
 )
 
-CHECK_STRUCT_PAM_CONV
-
-AC_CHECK_HEADERS(
-  linux/netfilter_ipv4.h
+AC_CHECK_HEADERS( \
+  linux/netfilter_ipv4.h \
+  linux/netfilter_ipv6/ip6_tables.h \
 ,,,
 SQUID_DEFAULT_INCLUDES
 #if HAVE_LIMITS_H
 #include <limits.h>
 #endif
 /* Netfilter ip(6)tables v1.4.0 has broken headers */
@@ -2474,18 +2340,14 @@
   net/if.h \
   netinet/if_ether.h\
   netinet/icmp6.h \
   netinet/in.h \
   netinet/ip.h \
   netinet/ip6.h \
-  netinet/ip_compat.h\
-  netinet/ip_fil_compat.h\
-  netinet/ip_fil.h\
   netinet/ip_icmp.h \
   netinet/ipl.h \
-  netinet/ip_nat.h\
   net/pf/pfvar.h \
   net/pfvar.h \
   sys/mount.h\
   resolv.h \
 ,,,
 SQUID_BSDNET_INCLUDES)
@@ -2661,13 +2523,13 @@
 dnl Check for Winsock only on MinGW, on Cygwin we must use emulated BSD socket API
 if test "x$squid_host_os" = "xmingw" ; then
   SQUID_CHECK_WINSOCK_LIB
   AC_CHECK_HEADERS( \
     windows.h \
     ws2tcpip.h \
-    Iphlpapi.h ,,,[
+    iphlpapi.h ,,,[
 #if HAVE_WINDOWS_H
 #include <windows.h>
 #endif
 #if HAVE_WINSOCK2_H
 #include <winsock2.h>
 #endif])
@@ -3124,13 +2987,13 @@
     ;;
   esac
 
 # Remove optimization for GCC 2.95.[123]
 # gcc -O[2] on *BSD and Linux (x86) causes pointers to magically become NULL
 if test "x$GCC" = "xyes"; then
-	GCCVER=`$CC -v 2>&1 | awk '$2 ==  "version" {print $3}'`
+	GCCVER=`$CC -v 2>&1 | awk '$2 == "version" {print $3}'`
 	case "$GCCVER" in
 	[2.95.[123]])
 		AC_MSG_NOTICE([Removing -O for gcc on $host with GCC $GCCVER])
 		CFLAGS="`echo $CFLAGS | sed -e 's/-O[[0-9]]*//'`"
 		;;
 	esac
@@ -3186,27 +3049,22 @@
 fi
 
 dnl Check for library functions
 AC_CHECK_FUNCS(\
 	backtrace_symbols_fd \
 	bcopy \
-	bswap_16 \
-	bswap_32 \
-	bswap16 \
-	bswap32 \
+	eui64_aton \
 	fchmod \
 	getdtablesize \
 	getpagesize \
 	getpass \
 	getrlimit \
 	getrusage \
 	getspnam \
 	gettimeofday \
 	glob \
-	htobe16 \
-	htole16 \
 	lrand48 \
 	mallinfo \
 	mallocblksize \
 	mallopt \
 	memcpy \
 	memmove \
@@ -3225,13 +3083,12 @@
 	regcomp \
 	regexec \
 	regfree \
 	res_init \
 	__res_init \
 	rint \
-	sbrk \
 	sched_getaffinity \
 	sched_setaffinity \
 	select \
 	seteuid \
 	setgroups \
 	setpgrp \
@@ -3247,21 +3104,19 @@
 	timegm \
 	vsnprintf \
 )
 dnl ... and some we provide local replacements for
 AC_REPLACE_FUNCS(\
 	drand48 \
-	eui64_aton \
 	inet_ntop \
 	inet_pton \
 	initgroups \
 	getaddrinfo \
 	getnameinfo \
 	psignal \
 	strerror \
-	strsep \
 	strtoll \
 	tempnam \
 )
 
 # Magic which checks whether we are forcing a type of comm loop we
 # are actually going to (ab)use.
@@ -3325,69 +3180,114 @@
   AC_MSG_RESULT(yes)
   AC_DEFINE(HAVE_CONSTANT_CMSG_SPACE, 1, [Define to 1 if CMSG_SPACE is constant])
 ], [
   AC_MSG_RESULT(no)
 ])
 
+AC_CHECK_TYPE(struct cmsghdr,AC_DEFINE(HAVE_CMSGHDR,1,[The system provides struct cmsghdr]),,[
+  #if HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+  #endif
+  #if HAVE_WINSOCK2_H
+  #include <winsock2.h>
+  #endif
+])
+
+AC_CHECK_TYPE(struct iovec,AC_DEFINE(HAVE_IOVEC,1,[The system provides struct iovec]),,[
+  #if HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+  #endif
+  #if HAVE_WINSOCK2_H
+  #include <winsock2.h>
+  #endif
+  #if HAVE_SYS_UIO_H
+  #include <sys/uio.h>
+  #endif
+])
+
+AC_CHECK_TYPE(struct msghdr,AC_DEFINE(HAVE_MSGHDR,1,[The system provides struct msghdr]),,[
+  #if HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+  #endif
+  #if HAVE_WINSOCK2_H
+  #include <winsock2.h>
+  #endif
+])
+
+AC_CHECK_TYPE(struct sockaddr_un,AC_DEFINE(HAVE_SOCKADDR_UN,1,[The system provides sockaddr_un]),,[
+  #if HAVE_SYS_UN_H
+  #include <sys/un.h>
+  #endif
+  #if HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+  #endif
+  #if HAVE_WINSOCK2_H
+  #include <winsock2.h>
+  #endif
+])
+
 SQUID_CHECK_FUNC_STRNSTR
 SQUID_CHECK_FUNC_VACOPY
 SQUID_CHECK_FUNC___VACOPY
 
-  
 dnl IP-Filter support requires ipf header files. These aren't
 dnl installed by default, so we need to check for them
 if test "x$enable_ipf_transparent" != "xno" ; then
+    SQUID_CHECK_BROKEN_SOLARIS_IPFILTER
     AC_MSG_CHECKING(for availability of IP-Filter header files)
     # hold on to your hats...
     if test "x$ac_cv_header_ip_compat_h" = "xyes" -o \
         "x$ac_cv_header_ip_fil_compat_h" = "xyes" -o \
         "x$ac_cv_header_netinet_ip_compat_h" = "xyes" -o \
         "x$ac_cv_header_netinet_ip_fil_compat_h" = "xyes" ; then
         have_ipfilter_compat_header="yes"
-     fi
-     if test "x$have_ipfilter_compat_header" = "xyes" -a \
+    fi
+    if test "x$have_ipfilter_compat_header" = "xyes" -a \
        "x$ac_cv_header_ip_fil_h" = "xyes" -a \
        "x$ac_cv_header_ip_nat_h" = "xyes" ; then
         enable_ipf_transparent="yes"
     elif test "x$have_ipfilter_compat_header" = "xyes" -a \
          "x$ac_cv_header_netinet_ip_fil_h" = "xyes" -a \
          "x$ac_cv_header_netinet_ip_nat_h" = "xyes" ; then
         enable_ipf_transparent="yes"
     else
         enable_ipf_transparent="no"
     fi
     AC_MSG_RESULT($IPF_TRANSPARENT)
+
+## On Solaris Ipfilter includes expect that SOLARIS2 is defined with the
+## Solaris minor version (8, 9, 10, ...)
+  if test "x$enable_ipf_transparent" = "xyes" -a "x$squid_host_os" = "xsolaris" ; then
+    solrev=`uname -r | sh -c 'IFS=. read j n x; echo $n'`
+    CFLAGS="-DSOLARIS2=$solrev $CFLAGS"
+    CXXFLAGS="-DSOLARIS2=$solrev $CXXFLAGS"
+  fi
+
 fi
 AC_MSG_NOTICE([IPF-based transparent proxying enabled: $enable_ipf_transparent])
 SQUID_DEFINE_BOOL(IPF_TRANSPARENT,$enable_ipf_transparent,
     [Enable support for IPF-style transparent proxying])
 
-if test "x$enable_ipf_transparent" = "xyes" -a "x$squid_host_os" = "xsolaris" ; then
-dnl On Solaris Ipfilter includes expect that SOLARIS2 is defined with the
-dnl Solaris minor version (8, 9, 10, ...)
-  solrev=`uname -r | sh -c 'IFS=. read j n x; echo $n'`
-  CFLAGS="-DSOLARIS2=$solrev $CFLAGS" 
-  CXXFLAGS="-DSOLARIS2=$solrev $CXXFLAGS" 
-fi
-
-dnl PF support requires a header file.
-if test "x$enable_pf_transparent" != "xno" ; then
+dnl PF /dev/pf support requires a header file.
+if test "x$with_nat_devpf" != "xno" ; then
   if test "x$ac_cv_header_net_pfvar_h" = "xyes" -o \
     "x$ac_cv_header_net_pf_pfvar_h" = "xyes"; then
-    if test "x$enable_pf_transparent" = "xauto" ; then
-      enable_pf_transparent="yes"
+    if test "x$with_nat_devpf" = "xauto" ; then
+      with_nat_devpf="no"
     fi
   else
-    if test "x$enable_pf_transparent" = "xyes" ; then
-      AC_MSG_ERROR([PF-based transparent proxy requested but needed header not found])
+    if test "x$with_nat_devpf" = "xyes" ; then
+      AC_MSG_ERROR([PF /dev/pf based NAT requested but needed header not found])
     fi
-    enable_pf_transparent="no"
+    with_nat_devpf="no"
   fi
 fi
-SQUID_DEFINE_BOOL(PF_TRANSPARENT,$enable_pf_transparent,
+SQUID_DEFINE_BOOL(PF_TRANSPARENT,${enable_pf_transparent:=no},
   [Enable support for PF-style transparent proxying])
+SQUID_DEFINE_BOOL(USE_NAT_DEVPF,${with_nat_devpf:=no},
+  [Enable support for /dev/pf NAT lookups])
 
 if test "x$enable_linux_netfilter" != "xno" ; then
   if test "x$ac_cv_header_linux_netfilter_ipv4_h" = "xyes"; then
     if test "x$enable_linux_netfilter" = "xauto" ; then
       enable_linux_netfilter=yes
     fi
@@ -3484,12 +3384,13 @@
 
 SQUID_DETECT_UDP_SND_BUFSIZE
 SQUID_DETECT_UDP_RECV_BUFSIZE
 SQUID_DETECT_TCP_SND_BUFSIZE
 SQUID_DETECT_TCP_RECV_BUFSIZE
 
+SQUID_CHECK_RECV_ARG_TYPE
 SQUID_CHECK_NEED_SYS_ERRLIST
 SQUID_CHECK_MAXPATHLEN
 
 if test "x$squid_opt_use_dnshelper" = "xyes"; then
   SQUID_CHECK_LIBRESOLV_DNS_TTL_HACK
   SQUID_CHECK_RESOLVER_FIELDS
@@ -3497,21 +3398,20 @@
 
 if test "x$ac_cv_header_sys_statvfs_h" = "xyes" ; then
   SQUID_CHECK_WORKING_STATVFS
 fi
 
 
-dnl Squid will usually attempt to translate when packaging or building from VCS 
+dnl Squid will not usually attempt to translate templates when building
 AC_ARG_ENABLE(translation,
- AS_HELP_STRING([--disable-translation],[Prevent Squid generating localized error page templates and manuals.
-		 Which is usually tried, but may not be needed.]), [ 
-SQUID_YESNO([$enableval],
-     [unrecognized argument to --disable-translation: $enableval])
+ AS_HELP_STRING([--enable-translation],[Generate the localized error page templates and manuals.
+		 Which can also be downloaded from http://www.squid-cache.org/Versions/langpack/.]), [ 
+  SQUID_YESNO([$enableval],
+     [unrecognized argument to --enable-translation: $enableval])
 ])
-dnl Squid now has .po translation capability, given the right toolkit
-if test "x${enable_translation:=yes}" = "xyes" ; then
+if test "x${enable_translation:=no}" = "xyes" ; then
   AX_WITH_PROG([PO2HTML],[po2html])
   AX_WITH_PROG([PO2TEXT],[po2txt])
 else
   PO2HTML="off"
   PO2TEXT="off"
 fi
@@ -3569,12 +3469,14 @@
 
 AC_CONFIG_FILES([
 	Makefile
 	compat/Makefile
 	lib/Makefile
 	lib/ntlmauth/Makefile
+	lib/libTrie/Makefile
+	lib/libTrie/test/Makefile
 	lib/profiler/Makefile
 	lib/rfcnb/Makefile
 	lib/smblib/Makefile
 	scripts/Makefile
 	src/Makefile
 	src/anyp/Makefile
@@ -3591,12 +3493,13 @@
 	src/adaptation/icap/Makefile
 	src/adaptation/ecap/Makefile
 	src/comm/Makefile
 	src/esi/Makefile
 	src/eui/Makefile
 	src/format/Makefile
+	src/http/Makefile
 	src/icmp/Makefile
 	src/ident/Makefile
 	src/ip/Makefile
 	src/log/Makefile
 	src/ipc/Makefile
 	src/ssl/Makefile
@@ -3651,16 +3554,17 @@
 	helpers/external_acl/time_quota/Makefile
 	helpers/log_daemon/Makefile
 	helpers/log_daemon/DB/Makefile
 	helpers/log_daemon/file/Makefile
 	helpers/url_rewrite/Makefile
 	helpers/url_rewrite/fake/Makefile
+	helpers/ssl/Makefile
+	helpers/storeid_rewrite/Makefile
+	helpers/storeid_rewrite/file/Makefile
 	tools/Makefile
 	tools/purge/Makefile
 ])
 
-AC_CONFIG_SUBDIRS(lib/libTrie)
-
 # must configure libltdl subdir unconditionally for "make distcheck" to work
 #AC_CONFIG_SUBDIRS(libltdl)
 
 AC_OUTPUT
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/contrib/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/contrib/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/contrib/Makefile.in	2015-05-01 16:50:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/contrib/Makefile.in	2015-05-01 18:06:22.000000000 +0800
@@ -89,14 +89,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -180,12 +226,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -223,12 +270,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -255,27 +303,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/CONTRIBUTORS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/CONTRIBUTORS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/CONTRIBUTORS	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/CONTRIBUTORS	2015-05-01 18:05:19.000000000 +0800
@@ -20,18 +20,20 @@
     Alex Rousskov <rousskov@squid-cache.org>
     Alin Nastac <mrness@gentoo.org>
     Alter <alter@alter.org.ua>
     Amos Jeffries <amosjeffries@squid-cache.org>
     Amos Jeffries <squid3@treenet.co.nz>
     Amos <squid3@treenet.co.nz>
+    Anatoli <me@anatoli.ws>
     Andrea Gagliardi <andrea@netlite.it>
     Andreas Jaeger <aj@suse.com>
     Andreas Lamprecht <Andreas.Lamprecht@siemens.at>
     Andres Kroonmaa <andre@ml.ee>
     Andrew Balabohin
     Andrew Beverley <andy@andybev.com>
+    Andrew Evdokimov <ae@elahi.ru>
     Andrew Hoying <andrew_hoying@blm.gov>
     Andrey Shorin <tolsty@tushino.com>
     Anonymous Pootle User
     Anonymous <redskilldough@gmail.com>
     Ansgar Hockmann <Ansgar.Hockmann@hrz.uni-dortmund.de>
     Anthony Baxter <arb@connect.com.au>
@@ -41,12 +43,13 @@
     Arthur <arthurtumanyan@yahoo.com>
     Arthur Tumanyan <arthurtumanyan@yahoo.com>
     Assar Westerlund <assar@pdc.kth.se>
     Automatic source maintenance <squidadm@squid-cache.org>
     Axel Westerhold <ml.awesterhold@dts.de>
     Barry Dobyns <barry@dobyns.com>
+    Benjamin Kerensa <bkerensa@ubuntu.com>
     Benno Rice <benno@jeamland.net>
     Benno Rice <benno@squid-cache.org>
     Bernard <fli4l.charrier@free.fr>
     Bertrand Jacquin <beber@meleeweb.net>
     Bojan Smojver <bojan@rexursive.com>
     Brad Smith <brad@comstyle.com>
@@ -56,12 +59,13 @@
     Brian <hiryuu@envisiongames.net>
     Bruce Murphy <pack-squid@rattus.net>
     Carson Gaspar (carson@lehman.com, carson@cs.columbia.edu)
     Cephas <squidwin@gmail.com>
     Chad E. Naugle <chad.naugle@travimp.com>
     Chad Naugle <chad.naugle@travimp.com>
+    Changming <me@sunchangming.com>
     Chao <chao_83@126.com>
     Chris Hills <chaz@chaz6.com>
     Christian Wittmer <chris@computersalat.de>
     Christophe Saout <christophe@saout.de>
     Christos Tsantilas <christos@chtsanti.net>
     Christos Tsantilas <chtsanti@users.sourceforge.net>
@@ -75,14 +79,14 @@
     Daniel Walter <d.walter@0x90.at>
     Dan Searle <dan.searle@censornet.com>
     David Hill <david.hill@ubisoft.com>
     David Isaacs <david.isaacs@sbhs.nsw.edu.au>
     David Luyer <luyer@ucs.uwa.edu.au>
     David Parks <davidparks21@yahoo.com>
-    declanw <declanw@is.bbc.co.uk>
     Declan White <declanw@is.bbc.co.uk>
+    Dennis Glatting
     Dhaval Varia <dhavalkvaria@gmail.com>
     Diego Woitasen <diegows@xtech.com.ar>
     D Kazarov <d.y.kazarov@mail.ru>
     Dmitry Kurochkin <dmitry.kurochkin@measurement-factory.com>
     Don Hopkins <dhopkins@DonHopkins.com>
     Doug Dixon <doug.dixon@gmail.com>
@@ -90,12 +94,13 @@
     Dragutin Cirkovic <painkiller@gromnet.net>
     Duane Wessels <wessels@squid-cache.org>
     Dustin J. Mitchell
     Ed Knowles <ed@fatboy.geog.unsw.edu.au>
     Edward Chernenko <edwardspec@gmail.com>
     Edward Moy <moy@parc.xerox.com>
+    Eliezer Croitoru <eliezer@ngtech.co.il>
     Elmar Vonlanthen <Elmar.Vonlanthen@united-security-providers.ch>
     Emilio Casbas <ecasbas@unav.es>
     Endre Balint Nagy <bne@CareNet.hu>
     Eray Aslan <eray.aslan@caf.com.tr>
     Eric Stern <estern@logisense.com>
     Eugene Gladchenko <eugene@donpac.ru>
@@ -148,12 +153,13 @@
     Ian Turner <vectro@pipeline.com>
     Igor Vinokurov <igor@cs.ibank.ru>
     IIDA Yosiaki <y-iida@secom.co.jp>
     isaac <isaacarsenal@gmail.com>
     Isnard <isnardjaquet@gmail.com>
     Ivan Mas??r <helix84@centrum.sk>
+    Jakob Bohm <jb-debbugs@wisemo.com>
     Jakub Wilk <ubanus@users.sf.net>
     James Bowe <minijb@gmail.com>
     James Brotchie <brotchie@gmail.com>
     James R Grinter <jrg@demon.net>
     Jan Klemkow <j.klemkow@wemelug.de>
     Jan Niehusmann <jan@anduin.gondor.mcs.de>
@@ -165,20 +171,23 @@
     Jerry Murdock <jmurdock@itraktech.com>
     Jiri Skala <jaskalnik@gmail.com>
     Jiri Skala <jskala@redhat.com>
     Joachim Bauch <jojo@fistofbenztown.de>
     Joao Alves Neto <alves_joao@hotmail.com>
     Jochen Voss <voss@seehuhn.de>
+    Joe Crayne <oh.hellojoe@gmail.com>
     Joe Ramey <ramey@jello.csc.ti.com>
     Joerg Lehrke <jlehrke@noc.de>
     Johnathan Conley <johnathan.conley@gmail.com>
     John Dilley <jad@hpl.hp.com>
     John Saunders <johns@rd.scitec.com.au>
+    John Xue <xgxjohn@gmail.com>
     Jonathan Larmour <JLarmour@origin-at.co.uk>
     Jonathan Wolfe <jonathan.wolfe@gmail.com>
     Jon Thackray <jrmt@uk.gdscorp.com>
+    Jorge Ivan Burgos Aguilar <jorgeivanburgosaguilar@gmail.com>
     Jose-Marcio Martins da Cruz <Jose-Marcio.Martins@mines-paristech.fr>
     Joshua Root <josh+squid@root.id.au>
     JPP <jpp1@frws.com>
     Juan <jdsq12@yahoo.es>
     Julien Pinon <jpinon@olfeo.com>
     Karl Benoit <karl.isatwork@gmail.com>
@@ -221,22 +230,22 @@
     Massimo Zito <zmax.linkedin at gmail dot com>
     Mathias Fischer <maf@open.ch>
     Matthew Morgan <atcs.matthew@gmail.com>
     Matthias Pitzl <silamael@coronamundi.de>
     Matthias "Silamael" <Silamael@coronamundi.de>
     Max Okumoto <okumoto@ucsd.edu>
-    Measurement Factory
     Michael Lupp <mike@nemesis.saar.de>
     Michael Mansour <mic@shell.gnxs.com.au>
     Michael O'Reilly <michael@metal.iinet.net.au>
     Michael Pelletier <mikep@comshare.com>
     Michael van Elst
     Michael Weiser <michael@weiser.dinsnail.net>
     Michal Luscon <mluscon@redhat.com>
     Miguel A.L. Paraz <map@iphil.net>
     Mike Groeneweg <mikeg@scorpion.murdoch.edu.au>
+    Mike Mitchell <mike.mitchell@sas.com>
     Mike Mitchell <Mike.Mitchell@sas.com>
     Mikio Kishi <mkishi@104.net>
     Milen Pankov <mail@milen.pankov.eu>
     Ming Fu <mfu@watchguard.com>
     Miquel van Smoorenburg <miquels@cistron.nl>
     Moez Mahfoudh <moez.mahfoudh@imag.fr>
@@ -245,18 +254,21 @@
     Mukaigawa Shin'ichi <shin@nff.ncl.omron.co.jp>
     Nathan Hoad <nathan@getoffmalawn.com>
     Neil Murray <neil@aone.com.au>
     nglnx - Rosetta Project
     Niall Doherty <ndoherty@eei.ericsson.se>
     Nick Rogers <ncrogers@gmail.com>
+    Nikolai Gorchilov <niki@x3me.net>
     'noloader' <noloader@gmail.com>
     Ole Christensen <olechristensende@aol.de>
     Oliver Dumschat <necromot@googlemail.com>
     Olivier W.
     OpenSolaris Project
     Oskar Pearson <oskar@is.co.za>
+    Paul Z <paulz42@gmail.com>
+    Pavel Timofeev
     Pawel Worach <pawel.worach@gmail.com>
     Pedro Lineu Orso <orso@pop.hsbcbamerindus.com.br>
     Pedro Ribeiro <pribeiro@isel.pt>
     Pete Bentley <pete@demon.net>
     Peter Hidas <peter.hidas@safeland.hu>
     Peter Payne
@@ -269,55 +281,58 @@
     Pierre-Louis BRENAC <brenacp@esiee.fr>
     Priyanka Gupta <priyanka@icelero.com>
     Przemek Czerkas <pczerkas@mgmnet.pl>
     Rafael Martinez <rmartine@fdi.ucm.es>
     Rafael Martinez Torres <rmartine@fdi.ucm.es>
     Rafal Ramocki <maniac@sistbg.net>
+    Rajiv Desai <rajiv@maginatics.com>
     Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
     Ralph Loader <loader@maths.ox.ac.uk>
     Regardt van de Vyver <squid@vdvyver.net>
     Reinhard Posmyk <Reinhard.Posmyk@arxes.de>
     Reinhard Sojka <reinhard.sojka@parlament.gv.at>
     Rene Geile <rene.geile@t-online.de>
     Ren? Geile <rene.geile@t-online.de>
     Reuben Farrelly <reuben@reub.net>
     Richard Huveneers <Richard.Huveneers@hekkihek.hacom.nl>
+    Richard Wall <richard.wall@appliansys.com>
     Robert Collins <robertc@robertcollins.net>
     Robert <Dessa@gmake.de>
     Robert Forster
     Robert Walsh <robert.walsh@bbn.com>
     Rodrigo Campos (rodrigo@geekbunker.org)
     Ron Gomes <rrg@ny.ubs.com>
     R Phillips <r.phillips@uq.edu.au>
     Russell Street <r.street@auckland.ac.nz>
     Russell Vincent <vincent@ucthpx.uct.ac.za>
     Ryan Troll <ryan+@andrew.cmu.edu>
+    Santiago Garcia Mantinan <manty@debian.org>
     Scott James Remnant <scott@netsplit.com>
     Scott Schram <scott@schram.net>
     Sean Critica <sean.critica@gmail.com>
     Sebastian Krahmer <krahmer@suse.com>
     Sebastien Wenske <sebastien@wenske.fr>
-    Serassio Guido <serassio@squid-cache.org>
     Sergey Merzlikin <sm@smsoft.ru>
     Sergio Rabellino <rabellino@di.unito.it>
     Shigechika Aikawa <shige@luck.imasy.or.jp>
     Silamael <Silamael@coronamundi.de>
     Stefan Fritsch <sf@sfritsch.de>
+    Stefano Cordibella <stefano.cordibella@edalab.it>
     Stephen R. van den Berg <srb@cuci.nl>
     Stephen Thorne <stephen@thorne.id.au>
     Steve Bennett <S.Bennett@lancaster.ac.uk>
     Steve Hill <steve@opendium.com>
     Steven Lawrance <squid@moonlightdesign.org>
     Steven Wilton <swilton@q-net.net.au>
     Steve Snyder <swsnyder@snydernet.net>
     Stewart Forster <slf@connect.com.au>
     Stuart Henderson <sthen@openbsd.org>
+    Susant Sahani <ssahani@redhat.com>
     Svenx <svensven@gmail.com>
     Taavi Talvik <taavi@uninet.ee>
     Taketo Kabe <kabe@shiratori.riec.tohoku.ac.jp>
-    The Measurement Factory
     Thomas De Schampheleire <thomas.de.schampheleire@gmail.com>
     Thomas Hozza <thozza@redhat.com>
     Thomas-Martin Seck <tmseck@netcologne.de>
     Thomas Ristic <thr@bootet.net>
     Thomas Weber <x@4t2.com>
     Tianyin Xu <tixu@cs.ucsd.edu>
@@ -326,12 +341,13 @@
     Timo Teras <timo.teras@iki.fi>
     Tim Starling <tstarling@wikimedia.org>
     Tomas Hozza <thozza@redhat.com>
     Tony Lorimer <tlorimer@au.mdis.com>
     Tsantilas Christos <chtsanti@users.sourceforge.net>
     Unknown
+    Unknown FreeBSD Contributor
     Unknown - NetBSD Project
     Various
     Various Translators
     Victor Jose Hernandez Gomez <vjhergom@cic.upo.es>
     Vincent Regnard
     Vitaliy Matytsyn (main) <vm@if.bank.gov.ua>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/CREDITS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/CREDITS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/CREDITS	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/CREDITS	2015-05-01 18:05:19.000000000 +0800
@@ -437,16 +437,50 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 ==============================================================================
 
+helpers/ defines.h:
+helpers/basic_auth/fake/ fake.cc:
+helpers/url_rewrite/fake/ fake.cc, url_fake_rewrite.sh:
+
+/*
+ * Copyright (c) 2009-2014, Treehouse Networks Ltd. New Zealand
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+==============================================================================
+
 include/IPAddress.h lib/IPAddress.cc:
 include/rfc3596.h lib/rfc3596.cc:
 src/ICMPv6.h src/ICMPv6.cc:
-helpers/url_rewrite/fake/ fake.h, fake.cc, url_fake_rewrite.sh:
 
  This code is copyright (C) 2007-2009 by Treehouse Networks Ltd
  of New Zealand. It is published and Licensed as an extension of
  squid under the same conditions as the main squid application.
 
 ==============================================================================
@@ -481,34 +515,12 @@
  *
  * -----------------------------------------------------------------------------
  */
 
 ==============================================================================
 
-compat/strsep.h, lib/strsep.c
-
- * Copyright (C) 2004 Free Software Foundation, Inc.
- * Written by Yoann Vandoorselaere <yoann@prelude-ids.org>
- * 
- * The file is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- * 
- * This file is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- * 
- * You should have received a copy of the GNU Lesser General Public
- * License along with this file; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA.
-
-==============================================================================
-
 helpers/external_acl/kerberos_ldap_group/support_ldap.cc
 
 /* get_attributes is partly from OpenLDAP Software <http://www.openldap.org/>.
  *
  * Copyright 1998-2009 The OpenLDAP Foundation.
  * All rights reserved.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/doc/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/doc/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/doc/Makefile.in	2015-05-01 16:50:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/doc/Makefile.in	2015-05-01 18:06:22.000000000 +0800
@@ -84,14 +84,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -235,12 +281,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -278,12 +325,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -310,27 +358,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/doc/manuals/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/doc/manuals/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/doc/manuals/Makefile.in	2015-05-01 16:50:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/doc/manuals/Makefile.in	2015-05-01 18:06:22.000000000 +0800
@@ -85,14 +85,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -176,12 +222,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -219,12 +266,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -251,27 +299,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/af/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/af/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/af/error-details.txt	2015-05-01 17:03:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/af/error-details.txt	2015-05-01 18:20:26.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/aliases /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/aliases
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/aliases	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/aliases	2015-05-01 18:05:19.000000000 +0800
@@ -21,12 +21,13 @@
 lt	lt-lt
 lv	lv-lv
 ms	ms-my
 nl	nl-nl
 pl	pl-pl
 pt	pt-pt
+pt-br	pt-bz
 ro	ro-ro ro-md
 ru	ru-ru
 sk	sk-sk
 sl	sl-si
 sr-latn	sr sr-sp sr-latn-cs
 sv	sv-fi sv-se
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ar/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ar/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ar/error-details.txt	2015-05-01 17:04:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ar/error-details.txt	2015-05-01 18:21:28.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/az/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/az/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/az/error-details.txt	2015-05-01 17:04:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/az/error-details.txt	2015-05-01 18:22:33.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/bg/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/bg/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/bg/error-details.txt	2015-05-01 17:05:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/bg/error-details.txt	2015-05-01 18:23:26.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ca/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ca/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ca/error-details.txt	2015-05-01 17:06:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ca/error-details.txt	2015-05-01 18:24:09.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/cs/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/cs/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/cs/error-details.txt	2015-05-01 17:07:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/cs/error-details.txt	2015-05-01 18:24:51.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/da/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/da/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/da/error-details.txt	2015-05-01 17:07:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/da/error-details.txt	2015-05-01 18:25:31.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/de/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/de/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/de/error-details.txt	2015-05-01 17:08:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/de/error-details.txt	2015-05-01 18:26:13.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/el/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/el/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/el/error-details.txt	2015-05-01 17:09:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/el/error-details.txt	2015-05-01 18:26:56.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/en/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/en/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/en/error-details.txt	2015-05-01 17:09:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/en/error-details.txt	2015-05-01 18:27:40.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/es/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/es/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/es/error-details.txt	2015-05-01 17:10:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/es/error-details.txt	2015-05-01 18:28:24.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/et/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/et/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/et/error-details.txt	2015-05-01 17:11:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/et/error-details.txt	2015-05-01 18:29:05.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/fa/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/fa/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/fa/error-details.txt	2015-05-01 17:11:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/fa/error-details.txt	2015-05-01 18:29:48.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/fi/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/fi/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/fi/error-details.txt	2015-05-01 17:12:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/fi/error-details.txt	2015-05-01 18:30:29.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/fr/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/fr/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/fr/error-details.txt	2015-05-01 17:13:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/fr/error-details.txt	2015-05-01 18:31:11.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/he/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/he/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/he/error-details.txt	2015-05-01 17:14:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/he/error-details.txt	2015-05-01 18:31:52.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/hu/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/hu/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/hu/error-details.txt	2015-05-01 17:14:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/hu/error-details.txt	2015-05-01 18:32:33.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/hy/ERR_ONLY_IF_CACHED_MISS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/hy/ERR_ONLY_IF_CACHED_MISS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/hy/ERR_ONLY_IF_CACHED_MISS	2015-05-01 17:15:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/hy/ERR_ONLY_IF_CACHED_MISS	2015-05-01 18:33:04.000000000 +0800
@@ -20,13 +20,13 @@
 <p>URL-     : <a href="%U">%U</a></p>
 
 <blockquote id="error">
 <p><b>   ;  <q>only-if-cached</q> .</b></p>
 </blockquote>
 
-<p>   <q>only-if-cached</q>   :     <em></em   <q>only-if-cached</q>    :</p>
+<p>   <q>only-if-cached</q>   :     <em></em>   <q>only-if-cached</q>    :</p>
 
 <p>   <a href="mailto:%w%W">%w</a> .</p>
 <br>
 </div>
 
 <hr>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/hy/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/hy/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/hy/error-details.txt	2015-05-01 17:15:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/hy/error-details.txt	2015-05-01 18:33:16.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/id/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/id/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/id/error-details.txt	2015-05-01 17:16:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/id/error-details.txt	2015-05-01 18:33:59.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/it/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/it/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/it/error-details.txt	2015-05-01 17:16:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/it/error-details.txt	2015-05-01 18:34:39.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ja/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ja/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ja/error-details.txt	2015-05-01 17:17:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ja/error-details.txt	2015-05-01 18:35:20.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ko/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ko/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ko/error-details.txt	2015-05-01 17:19:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ko/error-details.txt	2015-05-01 18:36:02.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/lt/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/lt/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/lt/error-details.txt	2015-05-01 17:19:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/lt/error-details.txt	2015-05-01 18:36:46.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/lv/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/lv/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/lv/error-details.txt	2015-05-01 17:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/lv/error-details.txt	2015-05-01 18:37:28.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/Makefile.in	2015-05-01 16:51:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/Makefile.in	2015-05-01 18:06:22.000000000 +0800
@@ -85,14 +85,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -176,12 +222,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -219,12 +266,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -251,27 +299,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ms/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ms/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ms/error-details.txt	2015-05-01 17:21:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ms/error-details.txt	2015-05-01 18:38:09.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/nl/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/nl/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/nl/error-details.txt	2015-05-01 17:22:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/nl/error-details.txt	2015-05-01 18:38:50.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/oc/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/oc/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/oc/error-details.txt	2015-05-01 17:23:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/oc/error-details.txt	2015-05-01 18:39:33.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/pl/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/pl/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/pl/error-details.txt	2015-05-01 17:24:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/pl/error-details.txt	2015-05-01 18:40:14.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/pt/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/pt/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/pt/error-details.txt	2015-05-01 17:26:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/pt/error-details.txt	2015-05-01 18:41:36.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/pt-br/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/pt-br/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/pt-br/error-details.txt	2015-05-01 17:25:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/pt-br/error-details.txt	2015-05-01 18:40:55.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ro/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ro/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ro/error-details.txt	2015-05-01 17:27:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ro/error-details.txt	2015-05-01 18:42:20.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ru/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ru/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/ru/error-details.txt	2015-05-01 17:28:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/ru/error-details.txt	2015-05-01 18:43:03.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sk/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sk/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sk/error-details.txt	2015-05-01 17:29:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sk/error-details.txt	2015-05-01 18:43:46.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sl/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sl/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sl/error-details.txt	2015-05-01 17:30:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sl/error-details.txt	2015-05-01 18:44:29.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sr-cyrl/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sr-cyrl/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sr-cyrl/error-details.txt	2015-05-01 17:32:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sr-cyrl/error-details.txt	2015-05-01 18:45:12.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sr-latn/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sr-latn/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sr-latn/error-details.txt	2015-05-01 17:33:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sr-latn/error-details.txt	2015-05-01 18:45:54.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sv/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sv/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/sv/error-details.txt	2015-05-01 17:34:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/sv/error-details.txt	2015-05-01 18:46:41.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/templates/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/templates/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/templates/error-details.txt	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/templates/error-details.txt	2015-05-01 18:05:19.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/th/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/th/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/th/error-details.txt	2015-05-01 17:35:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/th/error-details.txt	2015-05-01 18:47:25.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/tr/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/tr/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/tr/error-details.txt	2015-05-01 17:36:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/tr/error-details.txt	2015-05-01 18:48:09.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/uk/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/uk/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/uk/error-details.txt	2015-05-01 17:37:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/uk/error-details.txt	2015-05-01 18:48:51.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/uz/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/uz/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/uz/error-details.txt	2015-05-01 17:38:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/uz/error-details.txt	2015-05-01 18:49:34.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/vi/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/vi/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/vi/error-details.txt	2015-05-01 17:39:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/vi/error-details.txt	2015-05-01 18:50:19.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/zh-cn/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/zh-cn/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/zh-cn/error-details.txt	2015-05-01 17:40:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/zh-cn/error-details.txt	2015-05-01 18:51:02.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/zh-tw/error-details.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/zh-tw/error-details.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/errors/zh-tw/error-details.txt	2015-05-01 17:41:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/errors/zh-tw/error-details.txt	2015-05-01 18:51:44.000000000 +0800
@@ -1,6 +1,10 @@
+name: SQUID_X509_V_ERR_INFINITE_VALIDATION
+detail: "%ssl_error_descr: %ssl_subject"
+descr: "Cert validation infinite loop detected"
+
 name: SQUID_ERR_SSL_HANDSHAKE
 detail: "%ssl_error_descr: %ssl_lib_error"
 descr: "Handshake with SSL server failed"
 
 name: SQUID_X509_V_ERR_DOMAIN_MISMATCH
 detail: "%ssl_error_descr: %ssl_subject"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/DB: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/DB/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/DB/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/DB/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/DB/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -4,13 +4,13 @@
 CLEANFILES += basic_db_auth basic_db_auth.8
 man_MANS = basic_db_auth.8
 EXTRA_DIST= \
 	basic_db_auth.8 \
 	passwd.sql \
 	basic_db_auth.pl.in \
-	config.test
+	required.m4
 
 basic_db_auth.8: basic_db_auth
 	pod2man basic_db_auth basic_db_auth.8
 
 basic_db_auth: basic_db_auth.pl.in
 	$(subst_perlshell)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/DB/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/DB/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/DB/Makefile.in	2015-05-01 16:51:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/DB/Makefile.in	2015-05-01 18:06:23.000000000 +0800
@@ -89,14 +89,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -387,12 +433,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -430,12 +477,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -462,27 +510,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -548,21 +599,21 @@
 CLEANFILES = basic_db_auth basic_db_auth.8
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 libexec_SCRIPTS = basic_db_auth
 man_MANS = basic_db_auth.8
 EXTRA_DIST = \
 	basic_db_auth.8 \
 	passwd.sql \
 	basic_db_auth.pl.in \
-	config.test
+	required.m4
 
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .log .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/DB: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/fake: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/fake/fake.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/fake/fake.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/fake/fake.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/fake/fake.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,18 +1,40 @@
 /*
- * AUTHOR: Amos Jeffries <squid3@treenet.co.nz>
+ * Copyright (c) 2009-2014, Treehouse Networks Ltd. New Zealand
+ * All rights reserved.
  *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
  * Fake Basic Authentication program for Squid.
  *
  * This code gets the user details and returns OK.
  * It is intended for testing use and as a base for further implementation.
- *
- *
- * This code is copyright (C) 2009 by Treehouse Networks Ltd
- * of New Zealand. It is published and Licensed as an extension of
- * squid under the same conditions as the main squid application.
  */
 
 #include "squid.h"
 #include "helpers/defines.h"
 
 #if HAVE_CSTRING
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/fake/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/fake/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/fake/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/fake/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -2,7 +2,7 @@
 
 libexec_PROGRAMS = basic_fake_auth
 basic_fake_auth_SOURCES = fake.cc
 
 LDADD = $(COMPAT_LIB)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/fake/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/fake/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/fake/Makefile.in	2015-05-01 16:51:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/fake/Makefile.in	2015-05-01 18:06:28.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_fake_auth_OBJECTS = fake.$(OBJEXT)
 basic_fake_auth_OBJECTS = $(am_basic_fake_auth_OBJECTS)
 basic_fake_auth_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 basic_fake_auth_DEPENDENCIES = $(am__DEPENDENCIES_2)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
@@ -436,12 +483,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -479,12 +527,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -511,27 +560,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -597,17 +649,17 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 basic_fake_auth_SOURCES = fake.cc
 LDADD = $(COMPAT_LIB)
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/fake: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/getpwnam/basic_getpwnam_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/getpwnam/basic_getpwnam_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/getpwnam/basic_getpwnam_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/getpwnam/basic_getpwnam_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH basic_getpwnam_auth 8
 .
 .SH NAME
-.if !'po4a'hide' .B basic_getpwnam_auth
-.if !'po4a'hide' \-
-Local Users auth helper for Squid
+basic_getpwnam_auth \- Local Users auth helper for Squid
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_getpwnam_auth
 .
 .SH DESCRIPTION
 .B basic_getpwnam_auth
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/getpwnam: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/getpwnam/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/getpwnam/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/getpwnam/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/getpwnam/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -7,7 +7,7 @@
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(CRYPTLIB)
 
 man_MANS = basic_getpwnam_auth.8
 
-EXTRA_DIST = basic_getpwnam_auth.8 config.test
+EXTRA_DIST = basic_getpwnam_auth.8 required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/getpwnam/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/getpwnam/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/getpwnam/Makefile.in	2015-05-01 16:51:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/getpwnam/Makefile.in	2015-05-01 18:06:28.000000000 +0800
@@ -91,27 +91,74 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_getpwnam_auth_OBJECTS = basic_getpwnam_auth.$(OBJEXT)
 basic_getpwnam_auth_OBJECTS = $(am_basic_getpwnam_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_getpwnam_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -441,12 +488,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -484,12 +532,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -516,27 +565,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -602,22 +654,22 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 basic_getpwnam_auth_SOURCES = basic_getpwnam_auth.cc
 basic_getpwnam_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(CRYPTLIB)
 
 man_MANS = basic_getpwnam_auth.8
-EXTRA_DIST = basic_getpwnam_auth.8 config.test
+EXTRA_DIST = basic_getpwnam_auth.8 required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/getpwnam: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/LDAP/basic_ldap_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/LDAP/basic_ldap_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/LDAP/basic_ldap_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/LDAP/basic_ldap_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH basic_ldap_auth 8 "14 January 2005"
 .
 .SH NAME
-.if !'po4a'hide' .B basic_ldap_auth
-.if !'po4a'hide' \-
-LDAP authentication helper for Squid
+basic_ldap_auth \- LDAP authentication helper for Squid
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_ldap_auth
 .if !'po4a'hide' .B \-b\ \"
 base DN
 .if !'po4a'hide' .B \"\ [\-u
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/LDAP: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/LDAP/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/LDAP/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/LDAP/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/LDAP/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,11 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 	= basic_ldap_auth
 man_MANS 		= basic_ldap_auth.8
-EXTRA_DIST		= basic_ldap_auth.8 config.test
+EXTRA_DIST		= basic_ldap_auth.8 required.m4
 basic_ldap_auth_SOURCES	= basic_ldap_auth.cc
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(LDAPLIB) \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/LDAP/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/LDAP/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/LDAP/Makefile.in	2015-05-01 16:51:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/LDAP/Makefile.in	2015-05-01 18:06:23.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_ldap_auth_OBJECTS = basic_ldap_auth.$(OBJEXT)
 basic_ldap_auth_OBJECTS = $(am_basic_ldap_auth_OBJECTS)
 basic_ldap_auth_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_ldap_auth_DEPENDENCIES = $(top_builddir)/lib/libmiscencoding.la \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -442,12 +489,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -485,12 +533,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -517,27 +566,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -603,16 +655,16 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 man_MANS = basic_ldap_auth.8
-EXTRA_DIST = basic_ldap_auth.8 config.test
+EXTRA_DIST = basic_ldap_auth.8 required.m4
 basic_ldap_auth_SOURCES = basic_ldap_auth.cc
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(LDAPLIB) \
 	$(LBERLIB)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/LDAP: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -13,6 +13,8 @@
 	RADIUS \
 	SASL \
 	SMB \
 	SSPI
 
 SUBDIRS	= $(BASIC_AUTH_HELPERS)
+
+EXTRA_DIST = modules.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/Makefile.in	2015-05-01 16:51:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/Makefile.in	2015-05-01 18:06:24.000000000 +0800
@@ -84,14 +84,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -234,12 +280,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -277,12 +324,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -309,27 +357,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -404,12 +455,13 @@
 	RADIUS \
 	SASL \
 	SMB \
 	SSPI
 
 SUBDIRS = $(BASIC_AUTH_HELPERS)
+EXTRA_DIST = modules.m4
 all: all-recursive
 
 .SUFFIXES:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth: modules.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT/confload.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT/confload.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT/confload.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT/confload.cc	2015-05-01 18:05:19.000000000 +0800
@@ -119,13 +119,13 @@
 
     /* Check for a comment line. If found, stop . */
     if (Directive[0] == '#')
         return;
 
     /* Check for server line. Check for 3 parameters. */
-    if (strcasecmp(Directive, "server") == 0) {
+    if (strcmp(Directive, "server") == 0) {
         Param1 = strtok(NULL, " \t\n");
         if (NULL == Param1) {
             syslog(LOG_ERR, "ProcessLine: 'server' missing PDC parameter.");
             return;
         }
         Param2 = strtok(NULL, " \t\n");
@@ -139,25 +139,25 @@
             return;
         }
         AddServer(Param1, Param2, Param3);
         return;
     }
     /* Check for denyusers line */
-    if (strcasecmp(Directive, "denyusers") == 0) {
+    if (strcmp(Directive, "denyusers") == 0) {
         Param1 = strtok(NULL, " \t\n");
 
         if (NULL == Param1) {
             syslog(LOG_ERR, "ProcessLine: A 'denyusers' line needs a filename parameter.");
             return;
         }
         memset(Denyuserpath, '\0', MAXPATHLEN);
         strncpy(Denyuserpath, Param1, MAXPATHLEN - 1);
         return;
     }
     /* Check for allowusers line */
-    if (strcasecmp(Directive, "allowusers") == 0) {
+    if (strcmp(Directive, "allowusers") == 0) {
         Param1 = strtok(NULL, " \t\n");
 
         if (NULL == Param1) {
             syslog(LOG_ERR, "ProcessLine: An 'allowusers' line needs a filename parameter.");
             return;
         }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -16,13 +16,13 @@
 	valid.h
 
 EXTRA_DIST = \
 	msntauth.conf.default \
 	msntauth-v2.0.lsm \
 	README.html \
-	config.test
+	required.m4
 
 sysconf_DATA = \
 	msntauth.conf.default
 
 CFLAGS += -DSYSCONFDIR=\"$(sysconfdir)\"
 CXXFLAGS += -DSYSCONFDIR=\"$(sysconfdir)\"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT/Makefile.in	2015-05-01 16:51:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT/Makefile.in	2015-05-01 18:06:24.000000000 +0800
@@ -92,14 +92,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -109,13 +155,14 @@
 am_basic_msnt_auth_OBJECTS = allowusers.$(OBJEXT) confload.$(OBJEXT) \
 	denyusers.$(OBJEXT) msntauth.$(OBJEXT) usersfile.$(OBJEXT) \
 	valid.$(OBJEXT)
 basic_msnt_auth_OBJECTS = $(am_basic_msnt_auth_OBJECTS)
 basic_msnt_auth_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_msnt_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/smblib/libsmblib.la \
 	$(top_builddir)/lib/rfcnb/librfcnb.la \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
@@ -463,12 +510,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -506,12 +554,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -538,27 +587,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -625,13 +677,13 @@
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir) \
 	-I$(top_srcdir)/lib
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 MSNTAUTH_CONF = $(sysconfdir)/msntauth.conf
 basic_msnt_auth_SOURCES = \
 	allowusers.cc \
 	confload.cc \
 	denyusers.cc \
@@ -643,13 +695,13 @@
 	valid.h
 
 EXTRA_DIST = \
 	msntauth.conf.default \
 	msntauth-v2.0.lsm \
 	README.html \
-	config.test
+	required.m4
 
 sysconf_DATA = \
 	msntauth.conf.default
 
 LDADD = \
 	$(top_builddir)/lib/smblib/libsmblib.la \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT/msntauth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT/msntauth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT/msntauth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT/msntauth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -34,13 +34,12 @@
 #include "util.h"
 
 #include <stdio.h>
 #include <signal.h>
 #include <syslog.h>
 #include <string.h>
-#include <sys/time.h>
 
 #include "msntauth.h"
 
 extern char version[];
 char msntauth_version[] = "Msntauth v2.0.3 (C) 2 Sep 2001 Stellar-X Antonino Iannella.\nModified by the Squid HTTP Proxy team 26 Jun 2002";
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT-multi-domain: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT-multi-domain/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT-multi-domain/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT-multi-domain/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT-multi-domain/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,8 +1,8 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS	= basic_msnt_multi_domain_auth
-EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt config.test
+EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt required.m4
 CLEANFILES += basic_msnt_multi_domain_auth
 
 basic_msnt_multi_domain_auth: basic_msnt_multi_domain_auth.pl.in
 	$(subst_perlshell)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT-multi-domain/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT-multi-domain/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/MSNT-multi-domain/Makefile.in	2015-05-01 16:51:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT-multi-domain/Makefile.in	2015-05-01 18:06:24.000000000 +0800
@@ -89,14 +89,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -384,12 +430,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -427,12 +474,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -459,27 +507,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -545,16 +596,16 @@
 CLEANFILES = basic_msnt_multi_domain_auth
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 libexec_SCRIPTS = basic_msnt_multi_domain_auth
-EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt config.test
+EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .log .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/MSNT-multi-domain: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NCSA/basic_ncsa_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NCSA/basic_ncsa_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NCSA/basic_ncsa_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NCSA/basic_ncsa_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH basic_ncsa_auth 8 "May 16, 2006"
 .
 .SH NAME
-.if !'po4a'hide' .B basic_ncsa_auth
-.if !'po4a'hide' \-
-NCSA httpd-style password file authentication helper for Squid
+basic_ncsa_auth \- NCSA httpd-style password file authentication helper for Squid
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_ncsa_auth
 passwd file
 .
 .SH DESCRIPTION
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NCSA: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NCSA/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NCSA/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NCSA/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NCSA/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,16 +1,17 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS	= basic_ncsa_auth
 basic_ncsa_auth_SOURCES	= basic_ncsa_auth.cc crypt_md5.cc crypt_md5.h
 man_MANS 		= basic_ncsa_auth.8
-EXTRA_DIST		= basic_ncsa_auth.8 config.test
+EXTRA_DIST		= basic_ncsa_auth.8 required.m4
 LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
 ## we need our local files too (but avoid -I. at all costs)
 INCLUDES += -I$(srcdir)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NCSA/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NCSA/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NCSA/Makefile.in	2015-05-01 16:51:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NCSA/Makefile.in	2015-05-01 18:06:25.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -107,19 +153,20 @@
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_ncsa_auth_OBJECTS = basic_ncsa_auth.$(OBJEXT) \
 	crypt_md5.$(OBJEXT)
 basic_ncsa_auth_OBJECTS = $(am_basic_ncsa_auth_OBJECTS)
 basic_ncsa_auth_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_ncsa_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
-	$(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -463,12 +510,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -506,12 +554,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -538,27 +587,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -624,21 +676,22 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 basic_ncsa_auth_SOURCES = basic_ncsa_auth.cc crypt_md5.cc crypt_md5.h
 man_MANS = basic_ncsa_auth.8
-EXTRA_DIST = basic_ncsa_auth.8 config.test
+EXTRA_DIST = basic_ncsa_auth.8 required.m4
 LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
 all: all-am
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NCSA: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NIS: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NIS/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NIS/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NIS/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NIS/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -13,7 +13,7 @@
 basic_nis_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NIS/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NIS/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NIS/Makefile.in	2015-05-01 16:51:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NIS/Makefile.in	2015-05-01 18:06:25.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_nis_auth_OBJECTS = basic_nis_auth.$(OBJEXT) \
 	nis_support.$(OBJEXT)
 basic_nis_auth_OBJECTS = $(am_basic_nis_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_nis_auth_DEPENDENCIES = $(top_builddir)/lib/libmiscencoding.la \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -457,12 +504,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -500,12 +548,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -532,27 +581,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -618,26 +670,26 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 basic_nis_auth_SOURCES = \
 	basic_nis_auth.cc \
 	nis_support.h \
 	nis_support.cc
 
 basic_nis_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NIS/nis_support.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NIS/nis_support.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/NIS/nis_support.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NIS/nis_support.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,24 +1,40 @@
 /*
  * Written By Rabellino Sergio (rabellino@di.unito.it) For Solaris 2.x
  */
 #include "squid.h"
+
+#if HAVE_STDLIB_H
 #include <stdlib.h>
+#endif
+#if HAVE_STDIO_H
 #include <stdio.h>
+#endif
+#if HAVE_STRING_H
 #include <string.h>
+#endif
+#if HAVE_SYSLOG_H
 #include <syslog.h>
+#endif
+#if HAVE_SYS_TYPES_H
 #include <sys/types.h>
+#endif
+#if HAVE_RPC_RPC_H
 #include <rpc/rpc.h>
+#endif
 
 #if _SQUID_FREEBSD_  && !defined(BOOL_DEFINED)
 // BUG: FreeBSD rpcsvc/yp_* headers try to redefine bool unless we match their non-standard hack.
 #define BOOL_DEFINED
 #endif
 
 #include <rpcsvc/ypclnt.h>
+
+#if HAVE_RPCSVC_YP_PROT_H
 #include <rpcsvc/yp_prot.h>
+#endif
 
 #include "nis_support.h"
 
 #define NO_YPERR 0		/* There is no error */
 
 char *
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/NIS: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/PAM/basic_pam_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/PAM/basic_pam_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/PAM/basic_pam_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/PAM/basic_pam_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH basic_pam_auth 8 "5 Sep 2003"
 .
 .SH NAME
-.if !'po4a'hide' .B basic_pam_auth
-.if !'po4a'hide' \-
-Squid PAM Basic authentication helper
+basic_pam_auth \- PAM Basic authentication helper for Squid
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B "basic_pam_auth [\-n \""
 service name
 .if !'po4a'hide' .B "\"] [\-t "
 TTL
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/PAM/basic_pam_auth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/PAM/basic_pam_auth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/PAM/basic_pam_auth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/PAM/basic_pam_auth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -155,12 +155,13 @@
     fprintf(stderr, "           The PAM service name (default \"%s\")\n", DEFAULT_SQUID_PAM_SERVICE);
     fprintf(stderr, " -t ttl    PAM connection ttl in seconds (default %d)\n", DEFAULT_SQUID_PAM_TTL);
     fprintf(stderr, "           during this time the same connection will be reused\n");
     fprintf(stderr, "           to authenticate all users\n");
     fprintf(stderr, " -o        Do not perform account mgmt (account expiration etc)\n");
     fprintf(stderr, " -1        Only one user authentication per PAM connection\n");
+    fprintf(stderr, " -r        Detect and remove Negotiate/NTLM realm from username\n");
 }
 
 int
 main(int argc, char *argv[])
 {
     pam_handle_t *pamh = NULL;
@@ -169,18 +170,19 @@
     char *password_buf;
     char buf[HELPER_INPUT_BUFFER];
     time_t pamh_created = 0;
     int ttl = DEFAULT_SQUID_PAM_TTL;
     const char *service = DEFAULT_SQUID_PAM_SERVICE;
     int no_acct_mgmt = 0;
+    int no_realm = 0;
 
     /* make standard output line buffered */
     setvbuf(stdout, NULL, _IOLBF, 0);
 
     while (1) {
-        int ch = getopt(argc, argv, "1n:t:o");
+        int ch = getopt(argc, argv, "1n:t:or");
         switch (ch) {
         case -1:
             goto start;
         case 'n':
             service = optarg;
             break;
@@ -190,12 +192,15 @@
         case '1':
             ttl = 0;
             break;
         case 'o':
             no_acct_mgmt = 1;
             break;
+        case 'r':
+            no_realm = 1;
+            break;
         default:
             fprintf(stderr, "FATAL: Unknown getopt value '%c'\n", ch);
             usage(argv[0]);
             exit(1);
         }
     }
@@ -222,12 +227,24 @@
         *password_buf = '\0';
         ++password_buf;
         rfc1738_unescape(user);
         rfc1738_unescape(password_buf);
         conv.appdata_ptr = (char *) password_buf;	/* from buf above. not allocated */
 
+        if (no_realm) {
+            /* Remove DOMAIN\.. and ...@domain from the user name in case the user
+             * thought this was an NTLM or Negotiate authentication popup box
+             */
+            char * user_ptr = strchr(user, '@');
+            if (user_ptr) *user_ptr = 0;
+            else {
+                user_ptr = strchr(user, '\\');
+                if (user_ptr) user = user_ptr + 1;
+            }
+        }
+
 #if _SQUID_SOLARIS_
         /* Workaround for Solaris 2.6 where the PAM library is broken
          * and does not pass appdata_ptr to the conversation routine
          */
         password = password_buf;
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/PAM: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/PAM/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/PAM/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/PAM/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/PAM/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,10 @@
 include $(top_srcdir)/src/Common.am
 
 man_MANS		= basic_pam_auth.8
-EXTRA_DIST		= basic_pam_auth.8 config.test
+EXTRA_DIST		= basic_pam_auth.8 required.m4
 libexec_PROGRAMS	= basic_pam_auth
 basic_pam_auth_SOURCES	= basic_pam_auth.cc
 
 basic_pam_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/PAM/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/PAM/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/PAM/Makefile.in	2015-05-01 16:51:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/PAM/Makefile.in	2015-05-01 18:06:25.000000000 +0800
@@ -91,27 +91,74 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_pam_auth_OBJECTS = basic_pam_auth.$(OBJEXT)
 basic_pam_auth_OBJECTS = $(am_basic_pam_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_pam_auth_DEPENDENCIES = $(top_builddir)/lib/libmiscencoding.la \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
@@ -440,12 +487,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -483,12 +531,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -515,27 +564,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -601,16 +653,16 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 man_MANS = basic_pam_auth.8
-EXTRA_DIST = basic_pam_auth.8 config.test
+EXTRA_DIST = basic_pam_auth.8 required.m4
 basic_pam_auth_SOURCES = basic_pam_auth.cc
 basic_pam_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-lpam \
 	$(XTRA_LIBS)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/PAM: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/POP3: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/POP3/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/POP3/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/POP3/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/POP3/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,8 +1,8 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS	= basic_pop3_auth
-EXTRA_DIST = basic_pop3_auth.pl.in config.test
+EXTRA_DIST = basic_pop3_auth.pl.in required.m4
 CLEANFILES += basic_pop3_auth
 
 basic_pop3_auth: basic_pop3_auth.pl.in
 	$(subst_perlshell)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/POP3/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/POP3/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/POP3/Makefile.in	2015-05-01 16:51:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/POP3/Makefile.in	2015-05-01 18:06:26.000000000 +0800
@@ -89,14 +89,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -384,12 +430,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -427,12 +474,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -459,27 +507,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -545,16 +596,16 @@
 CLEANFILES = basic_pop3_auth
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 libexec_SCRIPTS = basic_pop3_auth
-EXTRA_DIST = basic_pop3_auth.pl.in config.test
+EXTRA_DIST = basic_pop3_auth.pl.in required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .log .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/POP3: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/RADIUS/basic_radius_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/RADIUS/basic_radius_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/RADIUS/basic_radius_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/RADIUS/basic_radius_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH basic_radius_auth 8 "7 August 2004"
 .
 .SH NAME
-.if !'po4a'hide' .B basic_radius_auth
-.if !'po4a'hide' \-
-Squid RADIUS authentication helper
+basic_radius_auth \- Squid RADIUS authentication helper
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_radius_auth
 .if !'po4a'hide' .B \-f
 config file
 .br
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/RADIUS: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/RADIUS/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/RADIUS/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/RADIUS/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/RADIUS/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -2,18 +2,19 @@
 
 ## we need our local files too (but avoid -I. at all costs)
 INCLUDES += -I$(srcdir)
 
 libexec_PROGRAMS 	= basic_radius_auth
 man_MANS 		= basic_radius_auth.8
-EXTRA_DIST		= basic_radius_auth.8 config.test
+EXTRA_DIST		= basic_radius_auth.8 required.m4
 basic_radius_auth_SOURCES = \
 			basic_radius_auth.cc \
 			radius.h \
 			radius-util.cc \
 			radius-util.h
 
 basic_radius_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/RADIUS/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/RADIUS/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/RADIUS/Makefile.in	2015-05-01 16:51:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/RADIUS/Makefile.in	2015-05-01 18:06:26.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,17 +152,19 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_radius_auth_OBJECTS = basic_radius_auth.$(OBJEXT) \
 	radius-util.$(OBJEXT)
 basic_radius_auth_OBJECTS = $(am_basic_radius_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_radius_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
-	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
+	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -460,12 +508,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -503,12 +552,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -535,27 +585,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -621,25 +674,26 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 man_MANS = basic_radius_auth.8
-EXTRA_DIST = basic_radius_auth.8 config.test
+EXTRA_DIST = basic_radius_auth.8 required.m4
 basic_radius_auth_SOURCES = \
 			basic_radius_auth.cc \
 			radius.h \
 			radius-util.cc \
 			radius-util.h
 
 basic_radius_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
 all: all-am
 
 .SUFFIXES:
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/RADIUS: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SASL/basic_sasl_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SASL/basic_sasl_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SASL/basic_sasl_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SASL/basic_sasl_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH basic_sasl_auth 8
 .
 .SH NAME
-.if !'po4a'hide' .B basic_sasl_auth
-.if !'po4a'hide' \-
-Basic Authentication using SASL (specifically the cyrus-sasl authentication method)
+basic_sasl_auth \- Basic Authentication using SASL (specifically the cyrus-sasl authentication method)
 .PP
 Version 1.0
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_sasl_auth
 .
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SASL: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SASL/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SASL/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SASL/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SASL/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -10,7 +10,7 @@
 	$(XTRA_LIBS)
 
 EXTRA_DIST = \
 	basic_sasl_auth.8 \
 	basic_sasl_auth.conf \
 	basic_sasl_auth.pam \
-	config.test
+	required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SASL/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SASL/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SASL/Makefile.in	2015-05-01 16:51:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SASL/Makefile.in	2015-05-01 18:06:27.000000000 +0800
@@ -91,27 +91,74 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_sasl_auth_OBJECTS = basic_sasl_auth.$(OBJEXT)
 basic_sasl_auth_OBJECTS = $(am_basic_sasl_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_sasl_auth_DEPENDENCIES = $(top_builddir)/lib/libmiscencoding.la \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -441,12 +488,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -484,12 +532,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -516,27 +565,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -602,13 +654,13 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 man_MANS = basic_sasl_auth.8
 basic_sasl_auth_SOURCES = basic_sasl_auth.cc
 basic_sasl_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
@@ -616,13 +668,13 @@
 	$(XTRA_LIBS)
 
 EXTRA_DIST = \
 	basic_sasl_auth.8 \
 	basic_sasl_auth.conf \
 	basic_sasl_auth.pam \
-	config.test
+	required.m4
 
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SASL: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SMB: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SMB/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SMB/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SMB/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SMB/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -8,7 +8,7 @@
 basic_smb_auth_CXXFLAGS = -DHELPERSCRIPT=\"$(libexecdir)/basic_smb_auth.sh\"
 basic_smb_auth_LDADD = \
 		$(top_builddir)/lib/libmiscencoding.la \
 		$(COMPAT_LIB) \
 		$(XTRA_LIBS)
 
-EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 config.test
+EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SMB/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SMB/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SMB/Makefile.in	2015-05-01 16:51:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SMB/Makefile.in	2015-05-01 18:06:27.000000000 +0800
@@ -93,27 +93,74 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_smb_auth_OBJECTS = basic_smb_auth-basic_smb_auth.$(OBJEXT)
 basic_smb_auth_OBJECTS = $(am_basic_smb_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_smb_auth_DEPENDENCIES = $(top_builddir)/lib/libmiscencoding.la \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
@@ -444,12 +491,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -487,12 +535,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -519,27 +568,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -605,23 +657,23 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 @ENABLE_WIN32SPECIFIC_FALSE@libexec_SCRIPTS = basic_smb_auth.sh
 basic_smb_auth_SOURCES = basic_smb_auth.cc
 basic_smb_auth_CXXFLAGS = -DHELPERSCRIPT=\"$(libexecdir)/basic_smb_auth.sh\"
 basic_smb_auth_LDADD = \
 		$(top_builddir)/lib/libmiscencoding.la \
 		$(COMPAT_LIB) \
 		$(XTRA_LIBS)
 
-EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 config.test
+EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SMB: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/basic_sspi_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/basic_sspi_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/basic_sspi_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/basic_sspi_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH basic_sspi_auth.exe 8
 .
 .SH NAME
-.if !'po4a'hide' .B basic_sspi_auth.exe
-.if !'po4a'hide' \-
-Basic authentication protocol 
+basic_sspi_auth.exe \- Basic authentication protocol 
 .PP
 Version 2.0
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B basic_sspi_auth.exe
 .if !'po4a'hide' .B "[\-d] [\-A "
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/basic_sspi_auth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/basic_sspi_auth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/basic_sspi_auth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/basic_sspi_auth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -23,13 +23,15 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
 */
 
 #include "squid.h"
 #include "helpers/defines.h"
+#include "rfc1738.h"
 #include "util.h"
+#include "valid.h"
 
 #if HAVE_STDIO_H
 #include <stdio.h>
 #endif
 #if GETOPT_H
 #include <getopt.h>
@@ -38,14 +40,12 @@
 /* Check if we try to compile on a Windows Platform */
 #if !_SQUID_WINDOWS_
 /* NON Windows Platform !!! */
 #error NON WINDOWS PLATFORM
 #endif
 
-#include "valid.h"
-
 static char NTGroup[256];
 char * NTAllowedGroup;
 char * NTDisAllowedGroup;
 int UseDisallowedGroup = 0;
 int UseAllowedGroup = 0;
 int debug_enabled = 0;
@@ -53,24 +53,22 @@
 /*
  * options:
  * -A can specify a Windows Local Group name allowed to authenticate.
  * -D can specify a Windows Local Group name not allowed to authenticate.
  * -O can specify the default Domain against to authenticate.
  */
-char *my_program_name = NULL;
-
-void
-usage()
+static void
+usage(const char *name)
 {
     fprintf(stderr, "Usage:\n%s [-A|D UserGroup][-O DefaultDomain][-d]\n"
             "-A can specify a Windows Local Group name allowed to authenticate\n"
             "-D can specify a Windows Local Group name not allowed to authenticate\n"
             "-O can specify the default Domain against to authenticate\n"
             "-d enable debugging.\n"
             "-h this message\n\n",
-            my_program_name);
+            name);
 }
 
 void
 process_options(int argc, char *argv[])
 {
     int opt;
@@ -97,13 +95,13 @@
             exit(0);
         case '?':
             opt = optopt;
             /* fall thru to default */
         default:
             fprintf(stderr, "FATAL: Unknown option: -%c\n", opt);
-            usage();
+            usage(argv[0]);
             exit(1);
         }
     }
 }
 
 /* Main program for simple authentication.
@@ -115,13 +113,12 @@
     char wstr[HELPER_INPUT_BUFFER];
     char username[256];
     char password[256];
     char *p;
     int err = 0;
 
-    my_program_name = argv[0];
     process_options(argc, argv);
 
     if (LoadSecurityDll(SSP_BASIC, NTLM_PACKAGE_NAME) == NULL) {
         fprintf(stderr, "FATAL: can't initialize SSPI, exiting.\n");
         exit(1);
     }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -17,7 +17,7 @@
 	-lsspwin32 \
 	-lmiscencoding \
 	-lnetapi32 -ladvapi32 \
 	$(XTRA_LIBS)
 
 man_MANS = basic_sspi_auth.8
-EXTRA_DIST = basic_sspi_auth.8 config.test
+EXTRA_DIST = basic_sspi_auth.8 required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/Makefile.in	2015-05-01 16:51:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/Makefile.in	2015-05-01 18:06:27.000000000 +0800
@@ -92,14 +92,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -108,13 +154,14 @@
 PROGRAMS = $(libexec_PROGRAMS)
 am_basic_sspi_auth_OBJECTS =  \
 	basic_sspi_auth-basic_sspi_auth.$(OBJEXT) \
 	basic_sspi_auth-valid.$(OBJEXT)
 basic_sspi_auth_OBJECTS = $(am_basic_sspi_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 basic_sspi_auth_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
@@ -465,12 +512,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -508,12 +556,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -540,27 +589,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -626,13 +678,13 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 basic_sspi_auth_SOURCES = \
 	basic_sspi_auth.cc \
 	valid.cc valid.h
 
 basic_sspi_auth_CXXFLAGS = -Wl,--enable-auto-import
@@ -642,13 +694,13 @@
 	-lsspwin32 \
 	-lmiscencoding \
 	-lnetapi32 -ladvapi32 \
 	$(XTRA_LIBS)
 
 man_MANS = basic_sspi_auth.8
-EXTRA_DIST = basic_sspi_auth.8 config.test
+EXTRA_DIST = basic_sspi_auth.8 required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/valid.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/valid.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/basic_auth/SSPI/valid.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/basic_auth/SSPI/valid.h	2015-05-01 18:05:19.000000000 +0800
@@ -25,29 +25,22 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
 */
 
 #ifndef _VALID_H_
 #define _VALID_H_
 
-#if _SQUID_CYGWIN_
+#include "sspwin32.h"
+
+#if HAVE_WINDOWS_H
 #include <windows.h>
 #endif
 #include <lm.h>
-#include "sspwin32.h"
+#include <sys/types.h>
 #undef debug
 
 /************* CONFIGURATION ***************/
-/*
- * define this if you want debugging
- */
-#ifndef DEBUG
-#define DEBUG
-#endif
-
-#define safe_free(x)	if (x) { free(x); x = NULL; }
-
 /* SMB User verification function */
 
 #define NTV_NO_ERROR 0
 #define NTV_SERVER_ERROR 1
 #define NTV_GROUP_ERROR 2
 #define NTV_LOGON_ERROR 3
@@ -63,45 +56,34 @@
 extern int UseDisallowedGroup;
 extern int UseAllowedGroup;
 extern int debug_enabled;
 extern char Default_NTDomain[DNLEN+1];
 extern const char * errormsg;
 
-#include <sys/types.h>
-
 /* Debugging stuff */
-
-#ifdef __GNUC__			/* this is really a gcc-ism */
-#ifdef DEBUG
+#if defined(__GNUC__)			/* this is really a gcc-ism */
 #include <stdio.h>
 #include <unistd.h>
 static char *__foo;
 #define debug(X...) if (debug_enabled) { \
                     fprintf(stderr,"nt_auth[%d](%s:%d): ", getpid(), \
                     ((__foo=strrchr(__FILE__,'/'))==NULL?__FILE__:__foo+1),\
                     __LINE__);\
                     fprintf(stderr,X); }
-#else /* DEBUG */
-#define debug(X...)		/* */
-#endif /* DEBUG */
 #else /* __GNUC__ */
 static void
 debug(char *format,...)
 {
-#ifdef DEBUG
-#if _SQUID_WINDOWS_
     if (debug_enabled) {
         va_list args;
 
         va_start(args,format);
         fprintf(stderr, "nt_auth[%d]: ",getpid());
         vfprintf(stderr, format, args);
         va_end(args);
     }
-#endif /* _SQUID_WINDOWS_ */
-#endif /* DEBUG */
 }
 #endif /* __GNUC__ */
 
 int Valid_User(char *,char *, char *);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/defines.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/defines.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/defines.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/defines.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,17 +1,52 @@
 #ifndef __SQUID_HELPERS_DEFINES_H
 #define __SQUID_HELPERS_DEFINES_H
 
 /*
+ * Copyright (c) 2009-2014, Treehouse Networks Ltd. New Zealand
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
  * This file contains several macro definitions which are
  * useful and shared between helpers.
  */
 
 #define HELPER_INPUT_BUFFER	8196
 
 /* send OK result to Squid with a string parameter. */
 #define SEND_OK(x)	fprintf(stdout, "OK %s\n",x)
 
 /* send ERR result to Squid with a string parameter. */
 #define SEND_ERR(x)	fprintf(stdout, "ERR %s\n",x)
 
+/* send ERR result to Squid with a string parameter. */
+#define SEND_BH(x)	fprintf(stdout, "BH %s\n",x)
+
+/* send TT result to Squid with a string parameter. */
+#define SEND_TT(x)	fprintf(stdout, "TT %s\n",x)
+
 #endif /* __SQUID_HELPERS_DEFINES_H */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/eDirectory: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/eDirectory/digest_pw_auth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/eDirectory/digest_pw_auth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/eDirectory/digest_pw_auth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/eDirectory/digest_pw_auth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -61,25 +61,25 @@
 static void
 OutputHHA1(RequestData * requestData)
 {
     requestData->error = 0;
     GetHHA1(requestData);
     if (requestData->error) {
-        SEND_ERR("No such user");
+        SEND_ERR("message=\"No such user\"");
         return;
     }
-    printf("%s\n", requestData->HHA1);
+    printf("OK ha1=\"%s\"\n", requestData->HHA1);
 }
 
 static void
 DoOneRequest(char *buf)
 {
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
-        SEND_ERR("");
+        SEND_BH("message=\"Invalid line received\"");
         return;
     }
     OutputHHA1(&requestData);
 }
 
 static void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/eDirectory/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/eDirectory/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/eDirectory/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/eDirectory/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -18,7 +18,7 @@
 	$(LDAPLIB) \
 	$(LBERLIB) \
 	$(CRYPTLIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/eDirectory/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/eDirectory/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/eDirectory/Makefile.in	2015-05-01 16:51:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/eDirectory/Makefile.in	2015-05-01 18:06:29.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_digest_edirectory_auth_OBJECTS = digest_pw_auth.$(OBJEXT) \
 	ldap_backend.$(OBJEXT) edir_ldapext.$(OBJEXT)
 digest_edirectory_auth_OBJECTS = $(am_digest_edirectory_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 digest_edirectory_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3)
@@ -459,12 +506,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -502,12 +550,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -534,27 +583,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -620,13 +672,13 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 digest_edirectory_auth_SOURCES = digest_pw_auth.cc \
 	digest_common.h \
 	ldap_backend.cc \
 	ldap_backend.h \
 	edir_ldapext.cc \
@@ -638,13 +690,13 @@
 	$(LDAPLIB) \
 	$(LBERLIB) \
 	$(CRYPTLIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/eDirectory: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/file: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/file/digest_file_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/file/digest_file_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/file/digest_file_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/file/digest_file_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH digest_file_auth 8
 .
 .SH NAME
-.if !'po4a'hide' .B digest_file_auth
-.if !'po4a'hide' \-
-File based digest authentication helper for Squid.
+digest_file_auth \- File based digest authentication helper for Squid.
 .PP
 Version 1.0
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B digest_file_auth
 .if !'po4a'hide' .B [\-c]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/file/digest_file_auth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/file/digest_file_auth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/file/digest_file_auth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/file/digest_file_auth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,14 +35,12 @@
 
 #include "squid.h"
 #include "digest_common.h"
 #include "helpers/defines.h"
 #include "text_backend.h"
 
-#define PROGRAM_NAME "digest_file_auth"
-
 static void
 GetHHA1(RequestData * requestData)
 {
     TextHHA1(requestData);
 }
 
@@ -65,25 +63,25 @@
 static void
 OutputHHA1(RequestData * requestData)
 {
     requestData->error = 0;
     GetHHA1(requestData);
     if (requestData->error) {
-        SEND_ERR("No such user");
+        SEND_ERR("message=\"No such user\"");
         return;
     }
-    printf("%s\n", requestData->HHA1);
+    printf("OK ha1=\"%s\"\n", requestData->HHA1);
 }
 
 static void
 DoOneRequest(char *buf)
 {
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
-        SEND_ERR("");
+        SEND_BH("message=\"Invalid line received\"");
         return;
     }
     OutputHHA1(&requestData);
 }
 
 static void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/file/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/file/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/file/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/file/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -11,11 +11,12 @@
 	text_backend.h
 
 LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = digest_file_auth.8 config.test
+EXTRA_DIST = digest_file_auth.8 required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/file/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/file/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/file/Makefile.in	2015-05-01 16:51:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/file/Makefile.in	2015-05-01 18:06:30.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -107,19 +153,20 @@
 PROGRAMS = $(libexec_PROGRAMS)
 am_digest_file_auth_OBJECTS = digest_file_auth.$(OBJEXT) \
 	text_backend.$(OBJEXT)
 digest_file_auth_OBJECTS = $(am_digest_file_auth_OBJECTS)
 digest_file_auth_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 digest_file_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
-	$(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -463,12 +510,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -506,12 +554,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -538,27 +587,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -624,29 +676,30 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 man_MANS = digest_file_auth.8
 digest_file_auth_SOURCES = digest_file_auth.cc \
 	digest_common.h \
 	text_backend.cc \
 	text_backend.h
 
 LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = digest_file_auth.8 config.test
+EXTRA_DIST = digest_file_auth.8 required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/file: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/LDAP: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/LDAP/digest_pw_auth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/LDAP/digest_pw_auth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/LDAP/digest_pw_auth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/LDAP/digest_pw_auth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -61,25 +61,25 @@
 static void
 OutputHHA1(RequestData * requestData)
 {
     requestData->error = 0;
     GetHHA1(requestData);
     if (requestData->error) {
-        SEND_ERR("No such user");
+        SEND_ERR("message=\"No such user\"");
         return;
     }
-    printf("%s\n", requestData->HHA1);
+    printf("OK ha1=\"%s\"\n", requestData->HHA1);
 }
 
 static void
 DoOneRequest(char *buf)
 {
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
-        SEND_ERR("");
+        SEND_BH("message=\"Invalid line received\"");
         return;
     }
     OutputHHA1(&requestData);
 }
 
 static void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/LDAP/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/LDAP/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/LDAP/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/LDAP/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -11,11 +11,12 @@
 
 digest_ldap_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(LDAPLIB) \
 	$(LBERLIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/LDAP/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/LDAP/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/LDAP/Makefile.in	2015-05-01 16:51:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/LDAP/Makefile.in	2015-05-01 18:06:29.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,19 +152,20 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_digest_ldap_auth_OBJECTS = digest_pw_auth.$(OBJEXT) \
 	ldap_backend.$(OBJEXT)
 digest_ldap_auth_OBJECTS = $(am_digest_ldap_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 digest_ldap_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
-	$(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -459,12 +506,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -502,12 +550,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -534,27 +583,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -620,29 +672,30 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 digest_ldap_auth_SOURCES = digest_pw_auth.cc \
 	digest_common.h \
 	ldap_backend.cc \
 	ldap_backend.h
 
 digest_ldap_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(LDAPLIB) \
 	$(LBERLIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/LDAP: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -2,6 +2,8 @@
 DIST_SUBDIRS= \
 	eDirectory \
 	file \
 	LDAP
 
 SUBDIRS= $(DIGEST_AUTH_HELPERS)
+
+EXTRA_DIST = modules.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/digest_auth/Makefile.in	2015-05-01 16:51:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth/Makefile.in	2015-05-01 18:06:29.000000000 +0800
@@ -84,14 +84,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -234,12 +280,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -277,12 +324,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -309,27 +357,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -393,12 +444,13 @@
 DIST_SUBDIRS = \
 	eDirectory \
 	file \
 	LDAP
 
 SUBDIRS = $(DIGEST_AUTH_HELPERS)
+EXTRA_DIST = modules.m4
 all: all-recursive
 
 .SUFFIXES:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/digest_auth: modules.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/AD_group: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/AD_group/ext_ad_group_acl.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/AD_group/ext_ad_group_acl.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/AD_group/ext_ad_group_acl.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/AD_group/ext_ad_group_acl.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ext_ad_group_acl.exe 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_ad_group_acl.exe 
-.if !'po4a'hide' \-
-Squid external ACL helper to check Windows users group membership.
+ext_ad_group_acl.exe \- Squid external ACL helper to check Windows users group membership.
 .PP
 Version 2.0
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_ad_group_acl.exe
 .if !'po4a'hide' .B "[\-D "
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/AD_group/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/AD_group/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/AD_group/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/AD_group/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -5,19 +5,20 @@
 man_MANS = ext_ad_group_acl.8
 
 #
 # Currently activeds and adsiid libraries are not available on MinGW or Cygwin,
 # so the following library list is just a placeholder for future MinGW/Cygwin releases.
 # This helper can be compiled only using Microsoft Visual Studio.
+# TODO: test for these libraries in required.m4
 #
 LDADD = \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
 	-ladvapi32 \
 	-lole32 \
 	-loleaut32 \
 	-lntdll \
 	-lactiveds \
 	-ladsiid \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test ext_ad_group_acl.8
+EXTRA_DIST = required.m4 ext_ad_group_acl.8
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/AD_group/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/AD_group/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/AD_group/Makefile.in	2015-05-01 16:51:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/AD_group/Makefile.in	2015-05-01 18:06:30.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ext_ad_group_acl_OBJECTS = ext_ad_group_acl.$(OBJEXT)
 ext_ad_group_acl_OBJECTS = $(am_ext_ad_group_acl_OBJECTS)
 ext_ad_group_acl_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ext_ad_group_acl_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
@@ -441,12 +488,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -484,12 +532,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -516,27 +565,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -602,34 +654,35 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 ext_ad_group_acl_SOURCES = ext_ad_group_acl.cc
 man_MANS = ext_ad_group_acl.8
 
 #
 # Currently activeds and adsiid libraries are not available on MinGW or Cygwin,
 # so the following library list is just a placeholder for future MinGW/Cygwin releases.
 # This helper can be compiled only using Microsoft Visual Studio.
+# TODO: test for these libraries in required.m4
 #
 LDADD = \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
 	-ladvapi32 \
 	-lole32 \
 	-loleaut32 \
 	-lntdll \
 	-lactiveds \
 	-ladsiid \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test ext_ad_group_acl.8
+EXTRA_DIST = required.m4 ext_ad_group_acl.8
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/AD_group: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/eDirectory_userip: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/eDirectory_userip/ext_edirectory_userip_acl.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/eDirectory_userip/ext_edirectory_userip_acl.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/eDirectory_userip/ext_edirectory_userip_acl.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/eDirectory_userip/ext_edirectory_userip_acl.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ext_edirectory_userip_acl 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_edirectory_userip_acl
-.if !'po4a'hide' \-
-Squid eDirectory IP Lookup Helper
+ext_edirectory_userip_acl \- Squid eDirectory IP Lookup Helper
 .PP
 Version 2.0
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_edirectory_userip_acl
 .if !'po4a'hide' .B "[\-h | \-\-help | \-\-usage]"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/eDirectory_userip/ext_edirectory_userip_acl.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/eDirectory_userip/ext_edirectory_userip_acl.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/eDirectory_userip/ext_edirectory_userip_acl.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/eDirectory_userip/ext_edirectory_userip_acl.cc	2015-05-01 18:05:19.000000000 +0800
@@ -974,13 +974,13 @@
                 /* How many ':' exist in bufb ? */
                 j = 0;
                 for (i = 0; i < t; ++i) {
                     if (bufb[i] == ':')
                         ++j;
                 }
-                --j;								/* Preceeding "::" doesn't count */
+                --j;								/* Preceding "::" doesn't count */
                 t = 8 - (strlen(l->search_ip) / 4) - j;			/* Remainder */
                 if (t > 0) {
                     for (i = 0; i < t; ++i)
                         strncat(l->search_ip, "0000", 4);
                 }
             }
@@ -1762,13 +1762,13 @@
             *p = '\0';
         p = strchr(bufa, ' ');
 
         /* No space given, but group string is required --> ERR */
         if ((edui_conf.mode & EDUI_MODE_GROUP) && (p == NULL)) {
             debug("while() -> Search group is missing. (required)\n");
-            local_printfx("ERR (Search Group Required)\n");
+            local_printfx("ERR message=\"(Search Group Required)\"\n");
             continue;
         }
         x = 0;
 
         /* Open LDAP connection */
         if (!(edui_ldap.status & LDAP_INIT_S)) {
@@ -1805,34 +1805,34 @@
         if (!(edui_ldap.status & LDAP_BIND_S) && (edui_conf.mode & EDUI_MODE_TLS)) {
             /* TLS binding */
             x = BindLDAP(&edui_ldap, edui_conf.dn, edui_conf.passwd, LDAP_AUTH_TLS);
             if (x != LDAP_ERR_SUCCESS) {
                 /* Unable to bind */
                 debug("BindLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                local_printfx("ERR (BindLDAP: %s - %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
+                local_printfx("ERR message=\"(BindLDAP: %s - %s)\"\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
                 continue;
             } else
                 debug("BindLDAP(-, %s, %s, (LDAP_AUTH_TLS)) -> %s\n", edui_conf.dn, edui_conf.passwd, ErrLDAP(x));
         } else if (!(edui_ldap.status & LDAP_BIND_S)) {
             if (edui_conf.dn[0] != '\0') {
                 /* Simple binding - using dn / passwd for authorization */
                 x = BindLDAP(&edui_ldap, edui_conf.dn, edui_conf.passwd, LDAP_AUTH_SIMPLE);
                 if (x != LDAP_ERR_SUCCESS) {
                     /* Unable to bind */
                     debug("BindLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                    local_printfx("ERR (BindLDAP: %s - %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
+                    local_printfx("ERR message=\"(BindLDAP: %s - %s)\"\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
                     continue;
                 } else
                     debug("BindLDAP(-, %s, %s, (LDAP_AUTH_SIMPLE)) -> %s\n", edui_conf.dn, edui_conf.passwd, ErrLDAP(x));
             } else {
                 /* Anonymous binding */
                 x = BindLDAP(&edui_ldap, edui_conf.dn, edui_conf.passwd, LDAP_AUTH_NONE);
                 if (x != LDAP_ERR_SUCCESS) {
                     /* Unable to bind */
                     debug("BindLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                    local_printfx("ERR (BindLDAP: %s - %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
+                    local_printfx("ERR message=\"(BindLDAP: %s - %s)\"\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
                     continue;
                 } else
                     debug("BindLDAP(-, -, -, (LDAP_AUTH_NONE)) -> %s\n", ErrLDAP(x));
             }
         }
         edui_ldap.err = -1;
@@ -1845,13 +1845,13 @@
                 debug("ResetLDAP() -> %s\n", ErrLDAP(x));
         }
         if (x != LDAP_ERR_SUCCESS) {
             /* Everything failed --> ERR */
             debug("while() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
             CloseLDAP(&edui_ldap);
-            local_printfx("ERR (General Failure: %s)\n", ErrLDAP(x));
+            local_printfx("ERR message=\"(General Failure: %s)\"\n", ErrLDAP(x));
             continue;
         }
         edui_ldap.err = -1;
         /* If we got a group string, split it */
         if (p != NULL) {
             /* Split string */
@@ -1860,75 +1860,75 @@
             if (i > 0) {
                 debug("StringSplit(%s, %s) done.  Result: %" PRIuSIZE "\n", bufa, bufb, i);
                 /* Got a group to match against */
                 x = ConvertIP(&edui_ldap, bufb);
                 if (x < 0) {
                     debug("ConvertIP() -> %s\n", ErrLDAP(x));
-                    local_printfx("ERR (ConvertIP: %s)\n", ErrLDAP(x));
+                    local_printfx("ERR message=\"(ConvertIP: %s)\"\n", ErrLDAP(x));
                 } else {
                     edui_ldap.err = -1;
                     debug("ConvertIP(-, %s) -> Result[%d]: %s\n", bufb, x, edui_ldap.search_ip);
                     x = SearchFilterLDAP(&edui_ldap, bufa);
                     if (x < 0) {
                         debug("SearchFilterLDAP() -> %s\n", ErrLDAP(x));
-                        local_printfx("ERR (SearchFilterLDAP: %s)\n", ErrLDAP(x));
+                        local_printfx("ERR message=\"(SearchFilterLDAP: %s)\"\n", ErrLDAP(x));
                     } else {
                         /* Do Search */
                         edui_ldap.err = -1;
                         debug("SearchFilterLDAP(-, %s) -> Length: %u\n", bufa, x);
                         x = SearchLDAP(&edui_ldap, edui_ldap.scope, edui_ldap.search_filter, (char **) &search_attrib);
                         if (x != LDAP_ERR_SUCCESS) {
                             debug("SearchLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                            local_printfx("ERR (SearchLDAP: %s)\n", ErrLDAP(x));
+                            local_printfx("ERR message=\"(SearchLDAP: %s)\"\n", ErrLDAP(x));
                         } else {
                             edui_ldap.err = -1;
                             debug("SearchLDAP(-, %d, %s, -) -> %s\n", edui_conf.scope, edui_ldap.search_filter, ErrLDAP(x));
                             x = SearchIPLDAP(&edui_ldap);
                             if (x != LDAP_ERR_SUCCESS) {
                                 debug("SearchIPLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                                local_printfx("ERR (SearchIPLDAP: %s)\n", ErrLDAP(x));
+                                local_printfx("ERR message=\"(SearchIPLDAP: %s)\"\n", ErrLDAP(x));
                             } else {
                                 debug("SearchIPLDAP(-, %s) -> %s\n", edui_ldap.userid, ErrLDAP(x));
                                 local_printfx("OK user=%s\n", edui_ldap.userid);			/* Got userid --> OK user=<userid> */
                             }
                         }
                         /* Clear for next query */
                         memset(bufc, '\0', sizeof(bufc));
                     }
                 }
             } else {
                 debug("StringSplit() -> Error: %" PRIuSIZE "\n", i);
-                local_printfx("ERR (StringSplit Error %" PRIuSIZE ")\n", i);
+                local_printfx("ERR message=\"(StringSplit Error %" PRIuSIZE ")\"\n", i);
             }
         } else {
             /* No group to match against, only an IP */
             x = ConvertIP(&edui_ldap, bufa);
             if (x < 0) {
                 debug("ConvertIP() -> %s\n", ErrLDAP(x));
-                local_printfx("ERR (ConvertIP: %s)\n", ErrLDAP(x));
+                local_printfx("ERR message=\"(ConvertIP: %s)\"\n", ErrLDAP(x));
             } else {
                 debug("ConvertIP(-, %s) -> Result[%d]: %s\n", bufa, x, edui_ldap.search_ip);
                 /* Do search */
                 x = SearchFilterLDAP(&edui_ldap, NULL);
                 if (x < 0) {
                     debug("SearchFilterLDAP() -> %s\n", ErrLDAP(x));
-                    local_printfx("ERR (SearchFilterLDAP: %s)\n", ErrLDAP(x));
+                    local_printfx("ERR message=\"(SearchFilterLDAP: %s)\"\n", ErrLDAP(x));
                 } else {
                     edui_ldap.err = -1;
                     debug("SearchFilterLDAP(-, NULL) -> Length: %u\n", x);
                     x = SearchLDAP(&edui_ldap, edui_ldap.scope, edui_ldap.search_filter, (char **) &search_attrib);
                     if (x != LDAP_ERR_SUCCESS) {
                         debug("SearchLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(x));
-                        local_printfx("ERR (SearchLDAP: %s)\n", ErrLDAP(x));
+                        local_printfx("ERR message=\"(SearchLDAP: %s)\"\n", ErrLDAP(x));
                     } else {
                         edui_ldap.err = -1;
                         debug("SearchLDAP(-, %d, %s, -) -> %s\n", edui_conf.scope, edui_ldap.search_filter, ErrLDAP(x));
                         x = SearchIPLDAP(&edui_ldap);
                         if (x != LDAP_ERR_SUCCESS) {
                             debug("SearchIPLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                            local_printfx("ERR (SearchIPLDAP: %s)\n", ErrLDAP(x));
+                            local_printfx("ERR message=\"(SearchIPLDAP: %s)\"\n", ErrLDAP(x));
                         } else {
                             debug("SearchIPLDAP(-, %s) -> %s\n", edui_ldap.userid, ErrLDAP(x));
                             local_printfx("OK user=%s\n", edui_ldap.userid);				/* Got a userid --> OK user=<userid> */
                         }
                     }
                 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/eDirectory_userip/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/eDirectory_userip/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/eDirectory_userip/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/eDirectory_userip/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -10,7 +10,7 @@
 	$(LDAPLIB) \
 	$(LBERLIB) \
 	$(XTRA_LIBS)
 
 man_MANS = ext_edirectory_userip_acl.8
 
-EXTRA_DIST = config.test ext_edirectory_userip_acl.8
+EXTRA_DIST = required.m4 ext_edirectory_userip_acl.8
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/eDirectory_userip/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/eDirectory_userip/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/eDirectory_userip/Makefile.in	2015-05-01 16:51:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/eDirectory_userip/Makefile.in	2015-05-01 18:06:32.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -107,13 +153,14 @@
 PROGRAMS = $(libexec_PROGRAMS)
 am_ext_edirectory_userip_acl_OBJECTS =  \
 	ext_edirectory_userip_acl.$(OBJEXT)
 ext_edirectory_userip_acl_OBJECTS =  \
 	$(am_ext_edirectory_userip_acl_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ext_edirectory_userip_acl_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -443,12 +490,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -486,12 +534,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -518,27 +567,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -604,25 +656,25 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 ext_edirectory_userip_acl_SOURCES = \
 	ext_edirectory_userip_acl.cc
 
 ext_edirectory_userip_acl_LDADD = \
 	$(COMPAT_LIB) \
 	$(LDAPLIB) \
 	$(LBERLIB) \
 	$(XTRA_LIBS)
 
 man_MANS = ext_edirectory_userip_acl.8
-EXTRA_DIST = config.test ext_edirectory_userip_acl.8
+EXTRA_DIST = required.m4 ext_edirectory_userip_acl.8
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/eDirectory_userip: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/file_userip: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/file_userip/ext_file_userip_acl.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/file_userip/ext_file_userip_acl.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/file_userip/ext_file_userip_acl.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/file_userip/ext_file_userip_acl.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ext_file_userip_acl 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_file_userip_acl
-.if !'po4a'hide' \-
-Restrict users to certain IP addresses, using a text file backend.
+ext_file_userip_acl \- Restrict users to certain IP addresses, using a text file backend.
 .PP
 Version 1.0
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_file_userip_acl
 .if !'po4a'hide' .B [\-dh] [\-f 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/file_userip/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/file_userip/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/file_userip/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/file_userip/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -5,12 +5,12 @@
 man_MANS = ext_file_userip_acl.8
 
 EXTRA_DIST = \
 	example.conf \
 	example-deny_all_but.conf \
 	ext_file_userip_acl.8 \
-	config.test
+	required.m4
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/file_userip/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/file_userip/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/file_userip/Makefile.in	2015-05-01 16:51:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/file_userip/Makefile.in	2015-05-01 18:06:32.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ext_file_userip_acl_OBJECTS = ext_file_userip_acl.$(OBJEXT)
 ext_file_userip_acl_OBJECTS = $(am_ext_file_userip_acl_OBJECTS)
 ext_file_userip_acl_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ext_file_userip_acl_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -442,12 +489,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -485,12 +533,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -517,27 +566,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -603,21 +655,21 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 ext_file_userip_acl_SOURCES = ext_file_userip_acl.cc
 man_MANS = ext_file_userip_acl.8
 EXTRA_DIST = \
 	example.conf \
 	example-deny_all_but.conf \
 	ext_file_userip_acl.8 \
-	config.test
+	required.m4
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/file_userip: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/cert_tool /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/cert_tool
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/cert_tool	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/cert_tool	2015-05-01 18:05:19.000000000 +0800
@@ -1,7 +1,7 @@
-#!/bin/ksh
+#!/bin/sh
 #
 #  -----------------------------------------------------------------------------
 # 
 #  Author: Markus Moeller (markus_moeller at compuserve.com)
 # 
 #  Copyright (C) 2007 Markus Moeller. All rights reserved.
@@ -61,15 +61,15 @@
 # /usr/sfw/bin on Solaris
 # 
 #
 # Create database for Sun ldap and pem file for Openldap 
 #
 rm ${server}_[0-9]*.pem 2>/dev/null
-let i=0
- ls ${server}_[0-9]*.cert | while read file; do
- let i=i+1
+i=0
+ls ${server}_[0-9]*.cert | while read file; do
+ i=$(($i+1))
  cat  $file  >> ${server}_$i.pem
  CA=`openssl x509 -noout -text -in  ${server}_$i.pem | grep -i "CA:.*true"`
  if [ -n "$CA" ]; then
    echo "CA is in ${server}_$i.pem"
    certutil -A -a -n "${server}_$i" -i $file -t "C,," -d .
  else
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/ext_kerberos_ldap_group_acl.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/ext_kerberos_ldap_group_acl.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/ext_kerberos_ldap_group_acl.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/ext_kerberos_ldap_group_acl.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ext_kerberos_ldap_group_acl 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_kerberos_ldap_group_acl
-.if !'po4a'hide' \-
-Squid LDAP external acl group helper for Kerberos or NTLM credentials.
+ext_kerberos_ldap_group_acl \- Squid LDAP external acl group helper for Kerberos or NTLM credentials.
 .PP
 Version 1.3.0sq
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_kerberos_ldap_group_acl
 .if !'po4a'hide' .B [\-h] [\-d] [\-i] [\-s] [\-a] [\-D Realm ] [\-N Netbios-Realm-List] [\-m Max-Depth] [\-u Ldap-User] [\-p Ldap-Password] [\-b Ldap-Bind-Path] [\-l Ldap-URL] [\-S ldap server list] \-g Group-Realm-List \-t  Hex-Group-Realm-List \-T Hex-Group-Hex-Realm-List 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/kerberos_ldap_group.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/kerberos_ldap_group.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/kerberos_ldap_group.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/kerberos_ldap_group.cc	2015-05-01 18:05:19.000000000 +0800
@@ -62,41 +62,31 @@
     margs->ndoms = NULL;
     margs->lservs = NULL;
 }
 
 void clean_gd(struct gdstruct *gdsp);
 void clean_nd(struct ndstruct *ndsp);
-void clean_ls(struct ndstruct *lssp);
+void clean_ls(struct lsstruct *lssp);
 
 void
 clean_gd(struct gdstruct *gdsp)
 {
     struct gdstruct *p = NULL, *pp = NULL;
 
     p = gdsp;
     while (p) {
         while (p->next) {
             pp = p;
             p = p->next;
         }
-        if (p->group) {
-            xfree(p->group);
-            p->group = NULL;
-        }
-        if (p->domain) {
-            xfree(p->domain);
-            p->domain = NULL;
-        }
-        if (pp && pp->next) {
-            xfree(pp->next);
-            pp->next = NULL;
-        }
-        if (p == gdsp) {
-            xfree(gdsp);
-            gdsp = NULL;
-        }
+        safe_free(p->group);
+        safe_free(p->domain);
+        if (pp)
+            safe_free(pp->next);
+        if (p == gdsp)
+            safe_free(gdsp);
         p = gdsp;
     }
 }
 
 void
 clean_nd(struct ndstruct *ndsp)
@@ -106,28 +96,18 @@
     p = ndsp;
     while (p) {
         while (p->next) {
             pp = p;
             p = p->next;
         }
-        if (p->netbios) {
-            xfree(p->netbios);
-            p->netbios = NULL;
-        }
-        if (p->domain) {
-            xfree(p->domain);
-            p->domain = NULL;
-        }
-        if (pp && pp->next) {
-            xfree(pp->next);
-            pp->next = NULL;
-        }
-        if (p == ndsp) {
-            xfree(ndsp);
-            ndsp = NULL;
-        }
+        safe_free(p->netbios);
+        safe_free(p->domain);
+        if (pp)
+            safe_free(pp->next);
+        if (p == ndsp)
+            safe_free(ndsp);
         p = ndsp;
     }
 }
 
 void
 clean_ls(struct lsstruct *lssp)
@@ -137,79 +117,36 @@
     p = lssp;
     while (p) {
         while (p->next) {
             pp = p;
             p = p->next;
         }
-        if (p->lserver) {
-            xfree(p->lserver);
-            p->lserver = NULL;
-        }
-        if (p->domain) {
-            xfree(p->domain);
-            p->domain = NULL;
-        }
-        if (pp && pp->next) {
-            xfree(pp->next);
-            pp->next = NULL;
-        }
-        if (p == lssp) {
-            xfree(lssp);
-            lssp = NULL;
-        }
+        safe_free(p->lserver);
+        safe_free(p->domain);
+        if (pp)
+            safe_free(pp->next);
+        if (p == lssp)
+            safe_free(lssp);
         p = lssp;
     }
 }
 
 void
 clean_args(struct main_args *margs)
 {
-    if (margs->glist) {
-        xfree(margs->glist);
-        margs->glist = NULL;
-    }
-    if (margs->ulist) {
-        xfree(margs->ulist);
-        margs->ulist = NULL;
-    }
-    if (margs->tlist) {
-        xfree(margs->tlist);
-        margs->tlist = NULL;
-    }
-    if (margs->nlist) {
-        xfree(margs->nlist);
-        margs->nlist = NULL;
-    }
-    if (margs->llist) {
-        xfree(margs->llist);
-        margs->llist = NULL;
-    }
-    if (margs->luser) {
-        xfree(margs->luser);
-        margs->luser = NULL;
-    }
-    if (margs->lpass) {
-        xfree(margs->lpass);
-        margs->lpass = NULL;
-    }
-    if (margs->lbind) {
-        xfree(margs->lbind);
-        margs->lbind = NULL;
-    }
-    if (margs->lurl) {
-        xfree(margs->lurl);
-        margs->lurl = NULL;
-    }
-    if (margs->ssl) {
-        xfree(margs->ssl);
-        margs->ssl = NULL;
-    }
-    if (margs->ddomain) {
-        xfree(margs->ddomain);
-        margs->ddomain = NULL;
-    }
+    safe_free(margs->glist);
+    safe_free(margs->ulist);
+    safe_free(margs->tlist);
+    safe_free(margs->nlist);
+    safe_free(margs->llist);
+    safe_free(margs->luser);
+    safe_free(margs->lpass);
+    safe_free(margs->lbind);
+    safe_free(margs->lurl);
+    safe_free(margs->ssl);
+    safe_free(margs->ddomain);
     if (margs->groups) {
         clean_gd(margs->groups);
         margs->groups = NULL;
     }
     if (margs->ndoms) {
         clean_nd(margs->ndoms);
@@ -410,14 +347,14 @@
             if (debug_enabled)
                 debug((char *) "%s| %s: INFO: Got User: %s Netbios Name: %s\n", LogTime(), PROGRAM, up, np);
             else
                 log((char *) "%s| %s: INFO: Got User: %s Netbios Name: %s\n", LogTime(), PROGRAM, up, np);
             domain = get_netbios_name(&margs, netbios);
             user = nuser;
-            xfree(up);
-            xfree(np);
+            safe_free(up);
+            safe_free(np);
         } else if (domain) {
             strup(domain);
             *domain = '\0';
             ++domain;
         }
         up = xstrdup(rfc1738_escape(user));
@@ -433,14 +370,14 @@
         }
         if (debug_enabled)
             debug((char *) "%s| %s: INFO: Got User: %s Domain: %s\n", LogTime(), PROGRAM, up, domain ? dp : "NULL");
         else
             log((char *) "%s| %s: INFO: Got User: %s Domain: %s\n", LogTime(), PROGRAM, up, domain ? dp : "NULL");
 
-        xfree(up);
-        xfree(dp);
+        safe_free(up);
+        safe_free(dp);
         if (!strcmp(user, "QQ") && domain && !strcmp(domain, "QQ")) {
             clean_args(&margs);
             exit(-1);
         }
         if (gopt) {
             if ((group = strtok(NULL, " \n")) != NULL) {
@@ -474,13 +411,13 @@
 }
 
 void
 strup(char *s)
 {
     while (*s) {
-        *s = toupper((unsigned char) *s);
+        *s = (char)toupper((unsigned char) *s);
         ++s;
     }
 }
 
 #else
 #include <stdio.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,9 +1,9 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = README config.test cert_tool ext_kerberos_ldap_group_acl.8
+EXTRA_DIST = README required.m4 cert_tool ext_kerberos_ldap_group_acl.8
 SUBDIRS = 
 
 AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
 
 libexec_SCRIPTS = cert_tool
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/Makefile.in	2015-05-01 16:51:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/Makefile.in	2015-05-01 18:06:33.000000000 +0800
@@ -92,14 +92,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -112,13 +158,14 @@
 	support_krb5.$(OBJEXT) support_ldap.$(OBJEXT) \
 	support_sasl.$(OBJEXT) support_resolv.$(OBJEXT) \
 	support_lserver.$(OBJEXT) support_log.$(OBJEXT)
 ext_kerberos_ldap_group_acl_OBJECTS =  \
 	$(am_ext_kerberos_ldap_group_acl_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ext_kerberos_ldap_group_acl_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3)
@@ -511,12 +558,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -554,12 +602,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -586,27 +635,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -672,15 +724,15 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
-EXTRA_DIST = README config.test cert_tool ext_kerberos_ldap_group_acl.8
+EXTRA_DIST = README required.m4 cert_tool ext_kerberos_ldap_group_acl.8
 SUBDIRS = 
 AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
 libexec_SCRIPTS = cert_tool
 ext_kerberos_ldap_group_acl_SOURCES = \
 	kerberos_ldap_group.cc \
 	support.h \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_group.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_group.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_group.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_group.cc	2015-05-01 18:05:19.000000000 +0800
@@ -28,12 +28,13 @@
 
 #ifdef HAVE_LDAP
 
 #include "support.h"
 
 struct gdstruct *init_gd(void);
+void free_gd(struct gdstruct *gdsp);
 
 struct gdstruct *
 init_gd(void) {
     struct gdstruct *gdsp;
     gdsp = (struct gdstruct *) xmalloc(sizeof(struct gdstruct));
     gdsp->group = NULL;
@@ -56,13 +57,14 @@
 
 char *utf8dup(struct main_args *margs);
 
 char *
 utf8dup(struct main_args *margs)
 {
-    int c = 0, s;
+    size_t c = 0;
+    unsigned char s;
     size_t n;
     char *src;
     unsigned char *p, *dupp;
 
     src = margs->glist;
     if (!src)
@@ -76,13 +78,13 @@
         for (n = 0; n < strlen(src); ++n) {
             s = (unsigned char) src[n];
             if (s > 127 && s < 192) {
                 *p = 194;
                 ++p;
                 *p = s;
-            } else if (s > 191 && s < 256) {
+            } else if (s > 191) {
                 *p = 195;
                 ++p;
                 *p = s - 64;
             } else
                 *p = s;
             ++p;
@@ -118,13 +120,13 @@
 
     char *up = (flag ? margs->ulist : margs->tlist);
     if (!up)
         return NULL;
 
     char *upd = strrchr(up, '@');
-    size_t a = (upd ? (upd - up) : strlen(up) );
+    size_t a = (upd ? (size_t)(upd - up) : strlen(up) );
 
     char *ul = (char *) xmalloc(strlen(up)+1);
     size_t n = 0;
     int nl = 0;
     iUTF2 = 0;
     iUTF3 = 0;
@@ -171,106 +173,106 @@
             return NULL;
         }
 
         if (iUTF2) {
             if (iUTF2 == 0xC2 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
-                ul[nl - 1] = ichar;
+                ul[nl - 1] = (char)ichar;
             } else if (iUTF2 == 0xC3 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
-                ul[nl - 1] = ichar + 64;
+                ul[nl - 1] = (char)(ichar + 64);
             } else if (iUTF2 > 0xC3 && iUTF2 < 0xE0 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else {
                 iUTF2 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
                 xfree(ul);
                 return NULL;
             }
         } else if (iUTF3) {
             if (iUTF3 == 0xE0 && ichar > 0x9F && ichar < 0xC0) {
                 iUTF3 = 1;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 > 0xE0 && iUTF3 < 0xED && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 2;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 == 0xED && ichar > 0x7F && ichar < 0xA0) {
                 iUTF3 = 3;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 > 0xED && iUTF3 < 0xF0 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 4;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 > 0 && iUTF3 < 5 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else {
                 iUTF3 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
                 xfree(ul);
                 return NULL;
             }
         } else if (iUTF4) {
             if (iUTF4 == 0xF0 && ichar > 0x8F && ichar < 0xC0) {
                 iUTF4 = 1;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF4 > 0xF0 && iUTF3 < 0xF4 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF4 = 2;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF4 == 0xF4 && ichar > 0x7F && ichar < 0x90) {
                 iUTF4 = 3;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF4 > 0 && iUTF4 < 5 && ichar > 0x7F && ichar < 0xC0) {
                 if (iUTF4 == 4)
                     iUTF4 = 0;
                 else
                     iUTF4 = 4;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else {
                 iUTF4 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
                 xfree(ul);
                 return NULL;
             }
         } else if (ichar < 0x80) {
             /* UTF1 */
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else if (ichar > 0xC1 && ichar < 0xE0) {
             /* UTF2 (Latin) */
             iUTF2 = ichar;
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else if (ichar > 0xDF && ichar < 0xF0) {
             /* UTF3 */
             iUTF3 = ichar;
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else if (ichar > 0xEF && ichar < 0xF5) {
             /* UTF4 */
             iUTF4 = ichar;
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else {
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ul[nl + 1] = '\0';
             debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
             xfree(ul);
             return NULL;
         }
         ++n;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support.h	2015-05-01 18:05:19.000000000 +0800
@@ -19,13 +19,13 @@
  *   along with this program; if not, write to the Free Software
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
  *
  * -----------------------------------------------------------------------------
  */
 
-#define KERBEROS_LDAP_GROUP_VERSION "1.3.0sq"
+#define KERBEROS_LDAP_GROUP_VERSION "1.3.1sq"
 
 #if HAVE_STRING_H
 #include <string.h>
 #endif
 
 #if HAVE_KRB5_H
@@ -153,19 +153,19 @@
 
 int create_gd(struct main_args *margs);
 int create_nd(struct main_args *margs);
 int create_ls(struct main_args *margs);
 
 #ifdef HAVE_KRB5
-int krb5_create_cache(struct main_args *margs, char *domain);
+int krb5_create_cache(char *domain);
 void krb5_cleanup(void);
 #endif
 
-int get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, char *domain);
-int get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, char *name);
-int free_hostname_list(struct hstruct **hlist, int nhosts);
+size_t get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t nhosts, char *domain);
+size_t get_hostname_list(struct hstruct **hlist, size_t nhosts, char *name);
+size_t free_hostname_list(struct hstruct **hlist, size_t nhosts);
 
 #if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
 int tool_sasl_bind(LDAP * ld, char *binddn, char *ssl);
 #endif
 
 #define PROGRAM "kerberos_ldap_group"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_krb5.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_krb5.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_krb5.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_krb5.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,13 +30,15 @@
 #include "support.h"
 
 struct kstruct {
     krb5_context context;
     char *mem_cache_env;
     krb5_ccache cc;
-} kparam;
+};
+
+static struct kstruct kparam;
 
 #define KT_PATH_MAX 256
 
 void
 krb5_cleanup()
 {
@@ -47,29 +49,26 @@
     }
 }
 /*
  * create Kerberos memory cache
  */
 int
-krb5_create_cache(struct main_args *margs, char *domain)
+krb5_create_cache(char *domain)
 {
 
     krb5_keytab keytab = 0;
     krb5_keytab_entry entry;
     krb5_kt_cursor cursor;
     krb5_creds *creds = NULL;
-    krb5_creds *tgt_creds = NULL;
     krb5_principal *principal_list = NULL;
     krb5_principal principal = NULL;
     char *service;
     char *keytab_name = NULL, *principal_name = NULL, *mem_cache = NULL;
     char buf[KT_PATH_MAX], *p;
-    int nprinc = 0;
-    int i;
+    size_t j,nprinc = 0;
     int retval = 0;
-    int found = 0;
     krb5_error_code code = 0;
 
     kparam.context = NULL;
 
     if (!domain || !strcmp(domain, ""))
         return (1);
@@ -109,12 +108,13 @@
         goto cleanup;
     }
     debug((char *) "%s| %s: DEBUG: Get principal name from keytab %s\n", LogTime(), PROGRAM, keytab_name);
 
     nprinc = 0;
     while ((code = krb5_kt_next_entry(kparam.context, keytab, &entry, &cursor)) == 0) {
+        int found = 0;
 
         principal_list = (krb5_principal *) xrealloc(principal_list, sizeof(krb5_principal) * (nprinc + 1));
         krb5_copy_principal(kparam.context, entry.principal, &principal_list[nprinc++]);
 #ifdef HAVE_HEIMDAL_KERBEROS
         debug((char *) "%s| %s: DEBUG: Keytab entry has realm name: %s\n", LogTime(), PROGRAM, entry.principal->realm);
 #else
@@ -179,18 +179,20 @@
         goto cleanup;
     }
     /*
      * if no principal name found in keytab for domain use the prinipal name which can get a TGT
      */
     if (!principal_name) {
+        size_t i;
         debug((char *) "%s| %s: DEBUG: Did not find a principal in keytab for domain %s.\n", LogTime(), PROGRAM, domain);
         debug((char *) "%s| %s: DEBUG: Try to get principal of trusted domain.\n", LogTime(), PROGRAM);
-        creds = (krb5_creds *) xmalloc(sizeof(*creds));
-        memset(creds, 0, sizeof(*creds));
 
         for (i = 0; i < nprinc; ++i) {
+            krb5_creds *tgt_creds = NULL;
+            creds = (krb5_creds *) xmalloc(sizeof(*creds));
+            memset(creds, 0, sizeof(*creds));
             /*
              * get credentials
              */
             code = krb5_unparse_name(kparam.context, principal_list[i], &principal_name);
             if (code) {
                 debug((char *) "%s| %s: DEBUG: Error while unparsing principal name : %s\n", LogTime(), PROGRAM, error_message(code));
@@ -202,14 +204,13 @@
             code = krb5_get_init_creds_keytab(kparam.context, creds, principal_list[i], keytab, 0, NULL, NULL);
 #else
             service = (char *) xmalloc(strlen("krbtgt") + 2 * strlen(domain) + 3);
             snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
             creds->client = principal_list[i];
             code = krb5_parse_name(kparam.context, service, &creds->server);
-            if (service)
-                xfree(service);
+            xfree(service);
             code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
             if (code) {
                 debug((char *) "%s| %s: DEBUG: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
                 goto loop_end;
             }
@@ -230,37 +231,38 @@
             snprintf(service, strlen("krbtgt") + strlen(domain) + strlen(principal_list[i]->realm) + 3, "krbtgt/%s@%s", domain, principal_list[i]->realm);
 #else
             service = (char *) xmalloc(strlen("krbtgt") + strlen(domain) + strlen(krb5_princ_realm(kparam.context, principal_list[i])->data) + 3);
             snprintf(service, strlen("krbtgt") + strlen(domain) + strlen(krb5_princ_realm(kparam.context, principal_list[i])->data) + 3, "krbtgt/%s@%s", domain, krb5_princ_realm(kparam.context, principal_list[i])->data);
 #endif
             code = krb5_parse_name(kparam.context, service, &creds->server);
-            if (service)
-                xfree(service);
+            xfree(service);
             if (code) {
                 error((char *) "%s| %s: ERROR: Error while initialising TGT credentials : %s\n", LogTime(), PROGRAM, error_message(code));
                 goto loop_end;
             }
             code = krb5_get_credentials(kparam.context, 0, kparam.cc, creds, &tgt_creds);
             if (code) {
                 debug((char *) "%s| %s: DEBUG: Error while getting tgt : %s\n", LogTime(), PROGRAM, error_message(code));
                 goto loop_end;
             } else {
                 debug((char *) "%s| %s: DEBUG: Found trusted principal name: %s\n", LogTime(), PROGRAM, principal_name);
-                found = 1;
                 break;
             }
 
 loop_end:
-            if (principal_name)
-                xfree(principal_name);
-            principal_name = NULL;
+            safe_free(principal_name);
+            if (tgt_creds) {
+                krb5_free_creds(kparam.context, tgt_creds);
+                tgt_creds = NULL;
+            }
+            if (creds)
+                krb5_free_creds(kparam.context, creds);
+            creds = NULL;
+
         }
 
-        if (tgt_creds)
-            krb5_free_creds(kparam.context, tgt_creds);
-        tgt_creds = NULL;
         if (creds)
             krb5_free_creds(kparam.context, creds);
         creds = NULL;
     }
     if (principal_name) {
 
@@ -284,14 +286,13 @@
         code = krb5_get_init_creds_keytab(kparam.context, creds, principal, keytab, 0, NULL, NULL);
 #else
         service = (char *) xmalloc(strlen("krbtgt") + 2 * strlen(domain) + 3);
         snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
         creds->client = principal;
         code = krb5_parse_name(kparam.context, service, &creds->server);
-        if (service)
-            xfree(service);
+        xfree(service);
         code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
         if (code) {
             error((char *) "%s| %s: ERROR: Error while initialising credentials from keytab : %s\n", LogTime(), PROGRAM, error_message(code));
             retval = 1;
             goto cleanup;
@@ -313,26 +314,22 @@
         debug((char *) "%s| %s: DEBUG: Got no principal name\n", LogTime(), PROGRAM);
         retval = 1;
     }
 cleanup:
     if (keytab)
         krb5_kt_close(kparam.context, keytab);
-    if (keytab_name)
-        xfree(keytab_name);
-    if (principal_name)
-        xfree(principal_name);
-    if (mem_cache)
-        xfree(mem_cache);
+    xfree(keytab_name);
+    xfree(principal_name);
+    xfree(mem_cache);
     if (principal)
         krb5_free_principal(kparam.context, principal);
-    for (i = 0; i < nprinc; ++i) {
-        if (principal_list[i])
-            krb5_free_principal(kparam.context, principal_list[i]);
+    for (j = 0; j < nprinc; ++j) {
+        if (principal_list[j])
+            krb5_free_principal(kparam.context, principal_list[j]);
     }
-    if (principal_list)
-        xfree(principal_list);
+    xfree(principal_list);
     if (creds)
         krb5_free_creds(kparam.context, creds);
 
     return (retval);
 }
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_ldap.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_ldap.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_ldap.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_ldap.cc	2015-05-01 18:05:19.000000000 +0800
@@ -32,13 +32,13 @@
 #include <errno.h>
 #endif
 
 char *convert_domain_to_bind_path(char *domain);
 char *escape_filter(char *filter);
 int check_AD(struct main_args *margs, LDAP * ld);
-int ldap_set_defaults(struct main_args *margs, LDAP * ld);
+int ldap_set_defaults(LDAP * ld);
 int ldap_set_ssl_defaults(struct main_args *margs);
 LDAP *tool_ldap_open(struct main_args *margs, char *host, int port, char *ssl);
 
 #define CONNECT_TIMEOUT 2
 #define SEARCH_TIMEOUT 30
 
@@ -48,13 +48,13 @@
 #define FILTER_GID "(&(gidNumber=%s)(objectclass=posixgroup))"
 #define ATTRIBUTE_GID "gidNumber"
 
 #define FILTER_AD "(samaccountname=%s)"
 #define ATTRIBUTE_AD "memberof"
 
-int get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
+size_t get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
 int search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_group, char *group, int depth);
 
 #if defined(HAVE_SUN_LDAP_SDK) || defined(HAVE_MOZILLA_LDAP_SDK)
 #ifdef HAVE_LDAP_REBINDPROC_CALLBACK
 
 #if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
@@ -207,13 +207,13 @@
 
 #endif
 char *
 convert_domain_to_bind_path(char *domain)
 {
     char *dp, *bindp = NULL, *bp = NULL;
-    int i = 0;
+    size_t i = 0;
 
     if (!domain)
         return NULL;
 
     for (dp = domain; *dp; ++dp) {
         if (*dp == '.')
@@ -240,14 +240,14 @@
     return bindp;
 }
 
 char *
 escape_filter(char *filter)
 {
-    int i;
     char *ldap_filter_esc, *ldf;
+    size_t i;
 
     i = 0;
     for (ldap_filter_esc = filter; *ldap_filter_esc; ++ldap_filter_esc) {
         if ((*ldap_filter_esc == '*') ||
                 (*ldap_filter_esc == '(') ||
                 (*ldap_filter_esc == ')') ||
@@ -275,22 +275,22 @@
             ++ldf;
         }
     }
     *ldf = '\0';
 
     return ldap_filter_esc;
-};
+}
 
 int
 check_AD(struct main_args *margs, LDAP * ld)
 {
     LDAPMessage *res;
     char **attr_value = NULL;
     struct timeval searchtime;
-    int max_attr = 0;
-    int j, rc = 0;
+    size_t max_attr = 0;
+    int rc = 0;
 
 #define FILTER_SCHEMA "(objectclass=*)"
 #define ATTRIBUTE_SCHEMA "schemaNamingContext"
 #define FILTER_SAM "(ldapdisplayname=samaccountname)"
 
     searchtime.tv_sec = SEARCH_TIMEOUT;
@@ -298,13 +298,13 @@
 
     debug((char *) "%s| %s: DEBUG: Search ldap server with bind path \"\" and filter: %s\n", LogTime(), PROGRAM, FILTER_SCHEMA);
     rc = ldap_search_ext_s(ld, (char *) "", LDAP_SCOPE_BASE, (char *) FILTER_SCHEMA, NULL, 0,
                            NULL, NULL, &searchtime, 0, &res);
 
     if (rc == LDAP_SUCCESS)
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE_SCHEMA, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE_SCHEMA, &attr_value);
 
     if (max_attr == 1) {
         ldap_msgfree(res);
         debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, attr_value[0], FILTER_SAM);
         rc = ldap_search_ext_s(ld, attr_value[0], LDAP_SCOPE_SUBTREE, (char *) FILTER_SAM, NULL, 0,
                                NULL, NULL, &searchtime, 0, &res);
@@ -315,31 +315,30 @@
         debug((char *) "%s| %s: DEBUG: Did not find ldap entry for subschemasubentry\n", LogTime(), PROGRAM);
     debug((char *) "%s| %s: DEBUG: Determined ldap server %sas an Active Directory server\n", LogTime(), PROGRAM, margs->AD ? "" : "not ");
     /*
      * Cleanup
      */
     if (attr_value) {
+        size_t j;
         for (j = 0; j < max_attr; ++j) {
             xfree(attr_value[j]);
         }
-        xfree(attr_value);
-        attr_value = NULL;
+        safe_free(attr_value);
     }
     ldap_msgfree(res);
     return rc;
 }
 int
 search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_group, char *group, int depth)
 {
     LDAPMessage *res = NULL;
     char **attr_value = NULL;
-    int max_attr = 0;
+    size_t max_attr = 0;
     char *filter = NULL;
     char *search_exp = NULL;
-    int j, rc = 0, retval = 0;
-    char *av = NULL, *avp = NULL;
+    int rc = 0, retval = 0;
     int ldepth;
     char *ldap_filter_esc = NULL;
     struct timeval searchtime;
 
 #define FILTER_GROUP_AD "(&(%s)(objectclass=group))"
 #define FILTER_GROUP "(&(memberuid=%s)(objectclass=posixgroup))"
@@ -375,82 +374,84 @@
         ldap_unbind_s(ld);
         return 0;
     }
     debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
     if (margs->AD)
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE_AD, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE_AD, &attr_value);
     else
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE, &attr_value);
 
     /*
      * Compare group names
      */
     retval = 0;
     ldepth = depth + 1;
-    for (j = 0; j < max_attr; ++j) {
+    for (size_t j = 0; j < max_attr; ++j) {
+        char *av = NULL;
 
         /* Compare first CN= value assuming it is the same as the group name itself */
         av = attr_value[j];
         if (!strncasecmp("CN=", av, 3)) {
+            char *avp = NULL;
             av += 3;
             if ((avp = strchr(av, ','))) {
                 *avp = '\0';
             }
         }
         if (debug_enabled) {
             int n;
-            debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
             for (n = 0; av[n] != '\0'; ++n)
                 fprintf(stderr, "%02x", (unsigned char) av[n]);
             fprintf(stderr, "\n");
         }
         if (!strcasecmp(group, av)) {
             retval = 1;
-            debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
             break;
         } else
-            debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
         /*
          * Do recursive group search
          */
         debug((char *) "%s| %s: DEBUG: Perform recursive group search for group \"%s\"\n", LogTime(), PROGRAM, av);
         av = attr_value[j];
         if (search_group_tree(margs, ld, bindp, av, group, ldepth)) {
             retval = 1;
             if (!strncasecmp("CN=", av, 3)) {
+                char *avp = NULL;
                 av += 3;
                 if ((avp = strchr(av, ','))) {
                     *avp = '\0';
                 }
             }
             if (debug_enabled)
-                debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" is member of group named \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" is member of group named \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
             else
                 break;
 
         }
     }
 
     /*
      * Cleanup
      */
     if (attr_value) {
-        for (j = 0; j < max_attr; ++j) {
+        for (size_t j = 0; j < max_attr; ++j) {
             xfree(attr_value[j]);
         }
-        xfree(attr_value);
-        attr_value = NULL;
+        safe_free(attr_value);
     }
     ldap_msgfree(res);
 
     return retval;
 }
 
 int
-ldap_set_defaults(struct main_args *margs, LDAP * ld)
+ldap_set_defaults(LDAP * ld)
 {
     int val, rc = 0;
 #ifdef LDAP_OPT_NETWORK_TIMEOUT
     struct timeval tv;
 #endif
     val = LDAP_VERSION3;
@@ -481,20 +482,20 @@
 {
 #if defined(HAVE_OPENLDAP) || defined(HAVE_LDAPSSL_CLIENT_INIT)
     int rc = 0;
 #endif
 #ifdef HAVE_OPENLDAP
     int val;
-    char *ssl_cacertfile = NULL;
-    int free_path;
 #elif defined(HAVE_LDAPSSL_CLIENT_INIT)
     char *ssl_certdbpath = NULL;
 #endif
 
 #ifdef HAVE_OPENLDAP
     if (!margs->rc_allow) {
+        char *ssl_cacertfile = NULL;
+        int free_path;
         debug((char *) "%s| %s: DEBUG: Enable server certificate check for ldap server.\n", LogTime(), PROGRAM);
         val = LDAP_OPT_X_TLS_DEMAND;
         rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &val);
         if (rc != LDAP_SUCCESS) {
             error((char *) "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_REQUIRE_CERT DEMAND for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
             return rc;
@@ -506,13 +507,12 @@
             free_path = 1;
         }
         debug((char *) "%s| %s: DEBUG: Set certificate file for ldap server to %s.(Changeable through setting environment variable TLS_CACERTFILE)\n", LogTime(), PROGRAM, ssl_cacertfile);
         rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_CACERTFILE, ssl_cacertfile);
         if (ssl_cacertfile && free_path) {
             xfree(ssl_cacertfile);
-            ssl_cacertfile = NULL;
         }
         if (rc != LDAP_OPT_SUCCESS) {
             error((char *) "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_CACERTFILE for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
             return rc;
         }
     } else {
@@ -540,33 +540,30 @@
     if (!margs->rc_allow) {
         rc = ldapssl_advclientauth_init(ssl_certdbpath, NULL, 0, NULL, NULL, 0, NULL, 2);
     } else {
         rc = ldapssl_advclientauth_init(ssl_certdbpath, NULL, 0, NULL, NULL, 0, NULL, 0);
         debug((char *) "%s| %s: DEBUG: Disable server certificate check for ldap server.\n", LogTime(), PROGRAM);
     }
-    if (ssl_certdbpath) {
-        xfree(ssl_certdbpath);
-        ssl_certdbpath = NULL;
-    }
+    xfree(ssl_certdbpath);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while setting SSL for ldap server: %s\n", LogTime(), PROGRAM, ldapssl_err2string(rc));
         return rc;
     }
 #else
     error((char *) "%s| %s: ERROR: SSL not supported by ldap library\n", LogTime(), PROGRAM);
 #endif
     return LDAP_SUCCESS;
 }
 
-int
-get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value)
+size_t
+get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value)
 {
 
     LDAPMessage *msg;
     char **attr_value = NULL;
-    int max_attr = 0;
+    size_t max_attr = 0;
 
     attr_value = *ret_value;
     /*
      * loop over attributes
      */
     debug((char *) "%s| %s: DEBUG: Search ldap entries for attribute : %s\n", LogTime(), PROGRAM, attribute);
@@ -585,21 +582,21 @@
                     struct berval **values;
                     int il;
 
                     if ((values = ldap_get_values_len(ld, msg, attr)) != NULL) {
                         for (il = 0; values[il] != NULL; ++il) {
 
-                            attr_value = (char **) xrealloc(attr_value, (il + 1) * sizeof(char *));
+                            attr_value = (char **) xrealloc(attr_value, (max_attr + 1) * sizeof(char *));
                             if (!attr_value)
                                 break;
 
-                            attr_value[il] = (char *) xmalloc(values[il]->bv_len + 1);
-                            memcpy(attr_value[il], values[il]->bv_val, values[il]->bv_len);
-                            attr_value[il][values[il]->bv_len] = 0;
+                            attr_value[max_attr] = (char *) xmalloc(values[il]->bv_len + 1);
+                            memcpy(attr_value[max_attr], values[il]->bv_val, values[il]->bv_len);
+                            attr_value[max_attr][values[il]->bv_len] = 0;
+                            max_attr++;
                         }
-                        max_attr = il;
                     }
                     ber_bvecfree(values);
                 }
                 ldap_memfree(attr);
             }
             ber_free(b, 0);
@@ -612,13 +609,13 @@
             break;
         default:
             break;
         }
     }
 
-    debug((char *) "%s| %s: DEBUG: %d ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
+    debug((char *) "%s| %s: DEBUG: %" PRIuSIZE " ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
 
     *ret_value = attr_value;
     return max_attr;
 }
 
 /*
@@ -658,31 +655,31 @@
     ldapuri = ldap_url_desc2str(url);
 #elif defined(HAVE_LDAP_URL_PARSE)
     rc = ldap_url_parse(ldapuri, &url);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
         xfree(ldapuri);
-        xfree(url);
+        ldap_free_urldesc(url);
         return NULL;
     }
 #else
 #error "No URL parsing function"
 #endif
-    safe_free(url);
+    ldap_free_urldesc(url);
     rc = ldap_initialize(&ld, ldapuri);
     xfree(ldapuri);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while initialising connection to ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
         ldap_unbind(ld);
         ld = NULL;
         return NULL;
     }
 #else
     ld = ldap_init(host, port);
 #endif
-    rc = ldap_set_defaults(margs, ld);
+    rc = ldap_set_defaults(ld);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
         ldap_unbind(ld);
         ld = NULL;
         return NULL;
     }
@@ -723,28 +720,28 @@
             ldapuri = ldap_url_desc2str(url);
 #elif defined(HAVE_LDAP_URL_PARSE)
             rc = ldap_url_parse(ldapuri, &url);
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
                 xfree(ldapuri);
-                xfree(url);
+                ldap_free_urldesc(url);
                 return NULL;
             }
 #else
 #error "No URL parsing function"
 #endif
-            safe_free(url);
+            ldap_free_urldesc(url);
             rc = ldap_initialize(&ld, ldapuri);
             xfree(ldapuri);
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while initialising connection to ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
                 ldap_unbind(ld);
                 ld = NULL;
                 return NULL;
             }
-            rc = ldap_set_defaults(margs, ld);
+            rc = ldap_set_defaults(ld);
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
                 ldap_unbind(ld);
                 ld = NULL;
                 return NULL;
             }
@@ -754,13 +751,13 @@
         if (!ld) {
             error((char *) "%s| %s: ERROR: Error while setting SSL for ldap server: %s\n", LogTime(), PROGRAM, ldapssl_err2string(rc));
             ldap_unbind(ld);
             ld = NULL;
             return NULL;
         }
-        rc = ldap_set_defaults(margs, ld);
+        rc = ldap_set_defaults(ld);
         if (rc != LDAP_SUCCESS) {
             error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
             ldap_unbind(ld);
             ld = NULL;
             return NULL;
         }
@@ -784,46 +781,40 @@
 #endif
     struct ldap_creds *lcreds = NULL;
     char *bindp = NULL;
     char *filter = NULL;
     char *search_exp;
     struct timeval searchtime;
-    int i, j, rc = 0, kc = 1;
+    int rc = 0, kc = 1;
     int retval;
     char **attr_value = NULL;
-    char *av = NULL, *avp = NULL;
-    int max_attr = 0;
+    size_t max_attr = 0;
     struct hstruct *hlist = NULL;
-    int nhosts = 0;
-    char *hostname;
-    char *host;
-    int port;
-    char *ssl = NULL;
-    char *p;
+    size_t nhosts = 0;
     char *ldap_filter_esc = NULL;
 
     searchtime.tv_sec = SEARCH_TIMEOUT;
     searchtime.tv_usec = 0;
     /*
      * Fill Kerberos memory cache with credential from keytab for SASL/GSSAPI
      */
     if (domain) {
         debug((char *) "%s| %s: DEBUG: Setup Kerberos credential cache\n", LogTime(), PROGRAM);
 
 #ifdef HAVE_KRB5
-        kc = krb5_create_cache(margs, domain);
+        kc = krb5_create_cache(domain);
         if (kc) {
             error((char *) "%s| %s: ERROR: Error during setup of Kerberos credential cache\n", LogTime(), PROGRAM);
         }
 #else
         kc = 1;
         debug((char *) "%s| %s: DEBUG: Kerberos is not supported. Use username/passwaord with ldap url instead\n", LogTime(), PROGRAM);
 #endif
     }
 
-    if (kc && (!margs->lurl || !margs->luser | !margs->lpass)) {
+    if (kc && (!margs->lurl || !margs->luser || !margs->lpass)) {
         /*
          * If Kerberos fails and no url given exit here
          */
         retval = 0;
         goto cleanup;
     }
@@ -844,14 +835,14 @@
         }
         debug((char *) "%s| %s: DEBUG: Canonicalise ldap server name for domain %s\n", LogTime(), PROGRAM, domain);
         /*
          * Loop over list of ldap servers of users domain
          */
         nhosts = get_ldap_hostname_list(margs, &hlist, 0, domain);
-        for (i = 0; i < nhosts; ++i) {
-            port = 389;
+        for (size_t i = 0; i < nhosts; ++i) {
+            int port = 389;
             if (hlist[i].port != -1)
                 port = hlist[i].port;
             debug((char *) "%s| %s: DEBUG: Setting up connection to ldap server %s:%d\n", LogTime(), PROGRAM, hlist[i].host, port);
 
             ld = tool_ldap_open(margs, hlist[i].host, port, margs->ssl);
             if (!ld)
@@ -890,12 +881,17 @@
         if (ld == NULL) {
             debug((char *) "%s| %s: DEBUG: Error during initialisation of ldap connection: %s\n", LogTime(), PROGRAM, strerror(errno));
         }
         bindp = convert_domain_to_bind_path(domain);
     }
     if ((!domain || !ld) && margs->lurl && strstr(margs->lurl, "://")) {
+        char *hostname;
+        char *host;
+        int port;
+        char *ssl = NULL;
+        char *p;
         /*
          * If username does not contain a domain and a url was given then try it
          */
         hostname = strstr(margs->lurl, "://") + 3;
         ssl = strstr(margs->lurl, "ldaps://");
         if (ssl) {
@@ -909,15 +905,15 @@
         port = 389;
         if ((p = strchr(host, ':'))) {
             *p = '\0';
             ++p;
             port = atoi(p);
         }
-        nhosts = get_hostname_list(margs, &hlist, 0, host);
-        safe_free(host);
-        for (i = 0; i < nhosts; ++i) {
+        nhosts = get_hostname_list(&hlist, 0, host);
+        xfree(host);
+        for (size_t i = 0; i < nhosts; ++i) {
 
             ld = tool_ldap_open(margs, hlist[i].host, port, ssl);
             if (!ld)
                 continue;
             /*
              * ldap bind with username/password authentication
@@ -994,81 +990,83 @@
     }
     debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
     if (ldap_count_entries(ld, res) != 0) {
 
         if (margs->AD)
-            max_attr = get_attributes(margs, ld, res, ATTRIBUTE_AD, &attr_value);
+            max_attr = get_attributes(ld, res, ATTRIBUTE_AD, &attr_value);
         else {
-            max_attr = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value);
+            max_attr = get_attributes(ld, res, ATTRIBUTE, &attr_value);
         }
 
         /*
          * Compare group names
          */
         retval = 0;
-        for (j = 0; j < max_attr; ++j) {
+        for (size_t k = 0; k < max_attr; ++k) {
+            char *av = NULL;
 
             /* Compare first CN= value assuming it is the same as the group name itself */
-            av = attr_value[j];
+            av = attr_value[k];
             if (!strncasecmp("CN=", av, 3)) {
+                char *avp = NULL;
                 av += 3;
                 if ((avp = strchr(av, ','))) {
                     *avp = '\0';
                 }
             }
             if (debug_enabled) {
-                int n;
-                debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
-                for (n = 0; av[n] != '\0'; ++n)
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, k + 1, av);
+                for (unsigned int n = 0; av[n] != '\0'; ++n)
                     fprintf(stderr, "%02x", (unsigned char) av[n]);
                 fprintf(stderr, "\n");
             }
             if (!strcasecmp(group, av)) {
                 retval = 1;
                 if (debug_enabled)
-                    debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                    debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, k + 1, av, group);
                 else
                     break;
             } else
-                debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, k + 1, av, group);
         }
         /*
          * Do recursive group search for AD only since posixgroups can not contain other groups
          */
         if (!retval && margs->AD) {
             if (debug_enabled && max_attr > 0) {
                 debug((char *) "%s| %s: DEBUG: Perform recursive group search\n", LogTime(), PROGRAM);
             }
-            for (j = 0; j < max_attr; ++j) {
+            for (size_t j = 0; j < max_attr; ++j) {
+                char *av = NULL;
 
                 av = attr_value[j];
                 if (search_group_tree(margs, ld, bindp, av, group, 1)) {
                     retval = 1;
                     if (!strncasecmp("CN=", av, 3)) {
+                        char *avp = NULL;
                         av += 3;
                         if ((avp = strchr(av, ','))) {
                             *avp = '\0';
                         }
                     }
                     if (debug_enabled)
-                        debug((char *) "%s| %s: DEBUG: Entry %d group \"%s\" is (in)direct member of group \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                        debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " group \"%s\" is (in)direct member of group \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
                     else
                         break;
                 }
             }
         }
         /*
          * Cleanup
          */
         if (attr_value) {
-            for (j = 0; j < max_attr; ++j) {
+            for (size_t j = 0; j < max_attr; ++j) {
                 xfree(attr_value[j]);
             }
-            xfree(attr_value);
-            attr_value = NULL;
+            safe_free(attr_value);
         }
         ldap_msgfree(res);
     } else if (ldap_count_entries(ld, res) == 0 && margs->AD) {
         ldap_msgfree(res);
         ldap_unbind(ld);
         ld = NULL;
@@ -1098,17 +1096,17 @@
                                search_exp, NULL, 0,
                                NULL, NULL, &searchtime, 0, &res);
         xfree(search_exp);
 
         debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE_GID, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE_GID, &attr_value);
 
         if (max_attr == 1) {
             char **attr_value_2 = NULL;
-            int max_attr_2 = 0;
+            size_t max_attr_2 = 0;
 
             ldap_msgfree(res);
             filter = (char *) FILTER_GID;
 
             ldap_filter_esc = escape_filter(attr_value[0]);
 
@@ -1120,37 +1118,36 @@
             debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, bindp, search_exp);
             rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
                                    search_exp, NULL, 0,
                                    NULL, NULL, &searchtime, 0, &res);
             xfree(search_exp);
 
-            max_attr_2 = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value_2);
+            max_attr_2 = get_attributes(ld, res, ATTRIBUTE, &attr_value_2);
             /*
              * Compare group names
              */
             retval = 0;
             if (max_attr_2 == 1) {
-
                 /* Compare first CN= value assuming it is the same as the group name itself */
-                av = attr_value_2[0];
+                char *av = attr_value_2[0];
                 if (!strcasecmp(group, av)) {
                     retval = 1;
                     debug((char *) "%s| %s: DEBUG: \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, av, group);
                 } else
                     debug((char *) "%s| %s: DEBUG: \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, av, group);
 
             }
             /*
              * Cleanup
              */
             if (attr_value_2) {
+                size_t j;
                 for (j = 0; j < max_attr_2; ++j) {
                     xfree(attr_value_2[j]);
                 }
-                xfree(attr_value_2);
-                attr_value_2 = NULL;
+                safe_free(attr_value_2);
             }
             ldap_msgfree(res);
 
             debug((char *) "%s| %s: DEBUG: Users primary group %s %s\n", LogTime(), PROGRAM, retval ? "matches" : "does not match", group);
 
         } else {
@@ -1158,17 +1155,16 @@
             debug((char *) "%s| %s: DEBUG: Did not find ldap entry for group %s\n", LogTime(), PROGRAM, group);
         }
         /*
          * Cleanup
          */
         if (attr_value) {
-            for (j = 0; j < max_attr; ++j) {
+            for (size_t j = 0; j < max_attr; ++j) {
                 xfree(attr_value[j]);
             }
-            xfree(attr_value);
-            attr_value = NULL;
+            safe_free(attr_value);
         }
     }
     rc = ldap_unbind(ld);
     ld = NULL;
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error unbind ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_log.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_log.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_log.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_log.cc	2015-05-01 18:05:19.000000000 +0800
@@ -31,19 +31,19 @@
 #include <time.h>
 #endif
 
 const char *
 LogTime()
 {
-    struct tm *tm;
-    struct timeval now;
     static time_t last_t = 0;
+    struct timeval now;
     static char buf[128];
 
     gettimeofday(&now, NULL);
     if (now.tv_sec != last_t) {
+        struct tm *tm;
         time_t tmp = now.tv_sec;
         tm = localtime(&tmp);
         strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
         last_t = now.tv_sec;
     }
     return buf;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_lserver.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_lserver.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_lserver.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_lserver.cc	2015-05-01 18:05:19.000000000 +0800
@@ -26,12 +26,13 @@
 #include "util.h"
 
 #ifdef HAVE_LDAP
 
 #include "support.h"
 struct lsstruct *init_ls(void);
+void free_ls(struct lsstruct *lssp);
 
 struct lsstruct *
 init_ls(void) {
     struct lsstruct *lssp;
     lssp = (struct lsstruct *) xmalloc(sizeof(struct lsstruct));
     lssp->lserver = NULL;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_netbios.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_netbios.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_netbios.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_netbios.cc	2015-05-01 18:05:19.000000000 +0800
@@ -27,12 +27,13 @@
 
 #ifdef HAVE_LDAP
 
 #include "support.h"
 
 struct ndstruct *init_nd(void);
+void free_nd(struct ndstruct *ndsp);
 
 struct ndstruct *
 init_nd(void) {
     struct ndstruct *ndsp;
     ndsp = (struct ndstruct *) xmalloc(sizeof(struct ndstruct));
     ndsp->netbios = NULL;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_resolv.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_resolv.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_resolv.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_resolv.cc	2015-05-01 18:05:19.000000000 +0800
@@ -92,16 +92,16 @@
 }
 
 static void
 sort(struct hstruct *array, int nitems, int (*cmp) (struct hstruct *, struct hstruct *), int begin, int end)
 {
     if (end > begin) {
-        int pivot = begin;
         int l = begin + 1;
         int r = end;
         while (l < r) {
+            int pivot = begin;
             if (cmp(&array[l], &array[pivot]) <= 0) {
                 l += 1;
             } else {
                 r -= 1;
                 swap(&array[l], &array[r]);
             }
@@ -113,13 +113,13 @@
     }
 }
 
 static void
 msort(struct hstruct *array, size_t nitems, int (*cmp) (struct hstruct *, struct hstruct *))
 {
-    sort(array, nitems, cmp, 0, nitems - 1);
+    sort(array, (int)nitems, cmp, 0, (int)(nitems - 1));
 }
 
 static int
 compare_hosts(struct hstruct *host1, struct hstruct *host2)
 {
     /*
@@ -142,39 +142,31 @@
         if (host1->weight < host2->weight)
             return 1;
     }
     return 0;
 }
 
-int
-free_hostname_list(struct hstruct **hlist, int nhosts)
+size_t
+free_hostname_list(struct hstruct **hlist, size_t nhosts)
 {
     struct hstruct *hp = NULL;
-    int i;
+    size_t i;
 
     hp = *hlist;
     for (i = 0; i < nhosts; ++i) {
-        if (hp[i].host)
-            xfree(hp[i].host);
-        hp[i].host = NULL;
+        xfree(hp[i].host);
     }
 
-    if (hp)
-        xfree(hp);
-    hp = NULL;
+    safe_free(hp);
     *hlist = hp;
     return 0;
 }
 
-int
-get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, char *name)
+size_t
+get_hostname_list(struct hstruct **hlist, size_t nhosts, char *name)
 {
-    /*
-     * char host[sysconf(_SC_HOST_NAME_MAX)];
-     */
-    char host[1024];
     struct addrinfo *hres = NULL, *hres_list;
     int rc, count;
     struct hstruct *hp = NULL;
 
     if (!name)
         return (nhosts);
@@ -191,12 +183,16 @@
         ++count;
         hres_list = hres_list->ai_next;
     }
     hres_list = hres;
     count = 0;
     while (hres_list) {
+        /*
+         * char host[sysconf(_SC_HOST_NAME_MAX)];
+         */
+        char host[1024];
         rc = getnameinfo(hres_list->ai_addr, hres_list->ai_addrlen, host, sizeof(host), NULL, 0, 0);
         if (rc != 0) {
             error((char *) "%s| %s: ERROR: Error while resolving ip address with getnameinfo: %s\n", LogTime(), PROGRAM, gai_strerror(rc));
             freeaddrinfo(hres);
             *hlist = hp;
             return (nhosts);
@@ -216,30 +212,27 @@
 
     freeaddrinfo(hres);
     *hlist = hp;
     return (nhosts);
 }
 
-int
-get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh, char *domain)
+size_t
+get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t nh, char *domain)
 {
 
     /*
      * char name[sysconf(_SC_HOST_NAME_MAX)];
      */
     char name[1024];
-    char host[NS_MAXDNAME];
     char *service = NULL;
     struct hstruct *hp = NULL;
     struct lsstruct *ls = NULL;
-    int nhosts = 0;
+    size_t nhosts = 0;
     int size;
-    int type, rdlength;
-    int priority, weight, port;
     int len, olen;
-    int i, j, k;
+    size_t i, j, k;
     u_char *buffer = NULL;
     u_char *p;
 
     ls = margs->lservs;
     while (ls) {
         debug((char *) "%s| %s: DEBUG: Ldap server loop: lserver@domain %s@%s\n", LogTime(), PROGRAM, ls->lserver, ls->domain?ls->domain:"NULL");
@@ -302,13 +295,13 @@
         } else {
             goto finalise;
         }
     }
     if (len > PACKETSZ_MULT * NS_PACKETSZ) {
         olen = len;
-        buffer = (u_char *) xrealloc(buffer, len);
+        buffer = (u_char *) xrealloc(buffer, (size_t)len);
         if ((len = res_search(service, ns_c_in, ns_t_srv, (u_char *) buffer, len)) < 0) {
             error((char *) "%s| %s: ERROR: Error while resolving service record %s with res_search\n", LogTime(), PROGRAM, service);
             nsError(h_errno, service);
             goto finalise;
         }
         if (len > olen) {
@@ -319,24 +312,25 @@
     p = buffer;
     p += 6 * NS_INT16SZ;	/* Header(6*16bit) = id + flags + 4*section count */
     if (p > buffer + len) {
         error((char *) "%s| %s: ERROR: Message to small: %d < header size\n", LogTime(), PROGRAM, len);
         goto finalise;
     }
-    if ((size = dn_expand(buffer, buffer + len, p, name, sysconf(_SC_HOST_NAME_MAX))) < 0) {
+    if ((size = dn_expand(buffer, buffer + len, p, name, sizeof(name))) < 0) {
         error((char *) "%s| %s: ERROR: Error while expanding query name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
         goto finalise;
     }
     p += size;			/* Query name */
     p += 2 * NS_INT16SZ;	/* Query type + class (2*16bit) */
     if (p > buffer + len) {
         error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class \n", LogTime(), PROGRAM, len);
         goto finalise;
     }
     while (p < buffer + len) {
-        if ((size = dn_expand(buffer, buffer + len, p, name, sysconf(_SC_HOST_NAME_MAX))) < 0) {
+        int type, rdlength;
+        if ((size = dn_expand(buffer, buffer + len, p, name, sizeof(name))) < 0) {
             error((char *) "%s| %s: ERROR: Error while expanding answer name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
             goto finalise;
         }
         p += size;		/* Resource Record name */
         if (p > buffer + len) {
             error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name\n", LogTime(), PROGRAM, len);
@@ -348,12 +342,14 @@
             error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name + RR type,class,ttl\n", LogTime(), PROGRAM, len);
             goto finalise;
         }
         NS_GET16(rdlength, p);	/* RR data length (16bit) */
 
         if (type == ns_t_srv) {	/* SRV record */
+            int priority, weight, port;
+            char host[NS_MAXDNAME];
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name + RR type,class,ttl + RR data length\n", LogTime(), PROGRAM, len);
                 goto finalise;
             }
             NS_GET16(priority, p);	/* Priority (16bit) */
             if (p > buffer + len) {
@@ -397,13 +393,13 @@
         error((char *) "%s| %s: ERROR: Inconsistence message length: %d!=0\n", LogTime(), PROGRAM, buffer + len - p);
 #endif
         goto finalise;
     }
 
 finalise:
-    nhosts = get_hostname_list(margs, &hp, nh, domain);
+    nhosts = get_hostname_list(&hp, nh, domain);
 
     debug("%s| %s: DEBUG: Adding %s to list\n", LogTime(), PROGRAM, domain);
 
     hp = (struct hstruct *) xrealloc(hp, sizeof(struct hstruct) * (nhosts + 1));
     hp[nhosts].host = strdup(domain);
     hp[nhosts].port = -1;
@@ -432,22 +428,20 @@
                 }
             }
         }
     }
 
     /* Sort by Priority / Weight */
-    msort(hp, nhosts, compare_hosts);
+    msort(hp, (size_t)nhosts, compare_hosts);
 
     if (debug_enabled) {
         debug((char *) "%s| %s: DEBUG: Sorted ldap server names for domain %s:\n", LogTime(), PROGRAM, domain);
         for (i = 0; i < nhosts; ++i) {
             debug((char *) "%s| %s: DEBUG: Host: %s Port: %d Priority: %d Weight: %d\n", LogTime(), PROGRAM, hp[i].host, hp[i].port, hp[i].priority, hp[i].weight);
         }
     }
-    if (buffer)
-        xfree(buffer);
-    if (service)
-        xfree(service);
+    xfree(buffer);
+    xfree(service);
     *hlist = hp;
     return (nhosts);
 }
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_sasl.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_sasl.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/kerberos_ldap_group/support_sasl.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/kerberos_ldap_group/support_sasl.cc	2015-05-01 18:05:19.000000000 +0800
@@ -193,24 +193,18 @@
 void
 lutil_sasl_freedefs(
     void *defaults)
 {
     lutilSASLdefaults *defs = (lutilSASLdefaults *) defaults;
 
-    if (defs->mech)
-        xfree(defs->mech);
-    if (defs->realm)
-        xfree(defs->realm);
-    if (defs->authcid)
-        xfree(defs->authcid);
-    if (defs->passwd)
-        xfree(defs->passwd);
-    if (defs->authzid)
-        xfree(defs->authzid);
-    if (defs->resps)
-        xfree(defs->resps);
+    xfree(defs->mech);
+    xfree(defs->realm);
+    xfree(defs->authcid);
+    xfree(defs->passwd);
+    xfree(defs->authzid);
+    xfree(defs->resps);
 
     xfree(defs);
 }
 
 int
 tool_sasl_bind(LDAP * ld, char *binddn, char *ssl)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LDAP_group: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LDAP_group/ext_ldap_group_acl.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LDAP_group/ext_ldap_group_acl.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LDAP_group/ext_ldap_group_acl.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LDAP_group/ext_ldap_group_acl.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ext_ldap_group_acl 8 "30 January 2005"
 .
 .SH NAME
-.if !'po4a'hide' .B ext_ldap_group_acl
-.if !'po4a'hide' \-
-Squid LDAP external acl group helper
+ext_ldap_group_acl \- Squid LDAP external acl group helper
 .PP
 Version 2.17
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_ldap_group_acl
 .if !'po4a'hide' .B \-b
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LDAP_group/ext_ldap_group_acl.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LDAP_group/ext_ldap_group_acl.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LDAP_group/ext_ldap_group_acl.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LDAP_group/ext_ldap_group_acl.cc	2015-05-01 18:05:19.000000000 +0800
@@ -86,16 +86,12 @@
 #if HAVE_LDAP_H
 #include <ldap.h>
 #endif
 
 #endif
 
-#if defined(LDAP_OPT_NETWORK_TIMEOUT)
-#include <sys/time.h>
-#endif
-
 #define PROGRAM_NAME "ext_ldap_group_acl"
 #define PROGRAM_VERSION "2.17"
 
 /* Globals */
 
 static const char *basedn = NULL;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LDAP_group/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LDAP_group/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LDAP_group/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LDAP_group/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,13 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_ldap_group_acl
 ext_ldap_group_acl_SOURCES	= ext_ldap_group_acl.cc
 
 man_MANS 			= ext_ldap_group_acl.8
-EXTRA_DIST			= ext_ldap_group_acl.8 config.test
+EXTRA_DIST			= ext_ldap_group_acl.8 required.m4
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(LDAPLIB) \
 	$(LBERLIB) \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LDAP_group/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LDAP_group/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LDAP_group/Makefile.in	2015-05-01 16:51:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LDAP_group/Makefile.in	2015-05-01 18:06:31.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ext_ldap_group_acl_OBJECTS = ext_ldap_group_acl.$(OBJEXT)
 ext_ldap_group_acl_OBJECTS = $(am_ext_ldap_group_acl_OBJECTS)
 ext_ldap_group_acl_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ext_ldap_group_acl_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
@@ -443,12 +490,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -486,12 +534,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -518,27 +567,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -604,17 +656,17 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 ext_ldap_group_acl_SOURCES = ext_ldap_group_acl.cc
 man_MANS = ext_ldap_group_acl.8
-EXTRA_DIST = ext_ldap_group_acl.8 config.test
+EXTRA_DIST = ext_ldap_group_acl.8 required.m4
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(LDAPLIB) \
 	$(LBERLIB) \
 	$(XTRA_LIBS)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LDAP_group: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LM_group: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LM_group/ext_lm_group_acl.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LM_group/ext_lm_group_acl.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LM_group/ext_lm_group_acl.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LM_group/ext_lm_group_acl.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ext_lm_group_acl 8
 .
 .SH NAME
-.if !'po4a'hide' .B ext_lm_group_acl
-.if !'po4a'hide' \-
-Squid external ACL helper to check Windows users group membership.
+ext_lm_group_acl \- Squid external ACL helper to check Windows users group membership.
 .PP
 Version 1.22
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_lm_group_acl
 .if !'po4a'hide' .B "[\-D "
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LM_group/ext_lm_group_acl.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LM_group/ext_lm_group_acl.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LM_group/ext_lm_group_acl.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LM_group/ext_lm_group_acl.cc	2015-05-01 18:05:19.000000000 +0800
@@ -94,13 +94,13 @@
 #include <windows.h>
 #include <lm.h>
 #include <ntsecapi.h>
 
 int use_global = 0;
 int use_PDC_only = 0;
-char *program_name;
+const char *program_name;
 pid_t mypid;
 char *machinedomain;
 int use_case_insensitive_compare = 0;
 char *DefaultDomain = NULL;
 const char NTV_VALID_DOMAIN_SEPARATOR[] = "\\/";
 
@@ -538,18 +538,21 @@
         strlwr(machinedomain);
         if (!DefaultDomain)
             DefaultDomain = xstrdup(machinedomain);
     }
     debug("External ACL win32 group helper build " __DATE__ ", " __TIME__
           " starting up...\n");
-    if (use_global)
+    if (use_global) {
         debug("Domain Global group mode enabled using '%s' as default domain.\n", DefaultDomain);
-    if (use_case_insensitive_compare)
+    }
+    if (use_case_insensitive_compare) {
         debug("Warning: running in case insensitive mode !!!\n");
-    if (use_PDC_only)
+    }
+    if (use_PDC_only) {
         debug("Warning: using only PDCs for group validation !!!\n");
+    }
 
     /* Main Loop */
     while (fgets(buf, HELPER_INPUT_BUFFER, stdin)) {
         if (NULL == strchr(buf, '\n')) {
             /* too large message received.. skip and deny */
             debug("%s: ERROR: Too large: %s\n", argv[0], buf);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LM_group/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LM_group/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LM_group/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LM_group/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,15 +1,16 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS = ext_lm_group_acl
 ext_lm_group_acl_SOURCES = ext_lm_group_acl.cc
 
 LDADD = \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
 	-ladvapi32 \
 	-lntdll \
 	$(XTRA_LIBS)
 
 man_MANS = ext_lm_group_acl.8
 
-EXTRA_DIST = config.test ext_lm_group_acl.8
+EXTRA_DIST = required.m4 ext_lm_group_acl.8
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LM_group/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LM_group/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/LM_group/Makefile.in	2015-05-01 16:51:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LM_group/Makefile.in	2015-05-01 18:06:31.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,15 +152,17 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ext_lm_group_acl_OBJECTS = ext_lm_group_acl.$(OBJEXT)
 ext_lm_group_acl_OBJECTS = $(am_ext_lm_group_acl_OBJECTS)
 ext_lm_group_acl_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
-ext_lm_group_acl_DEPENDENCIES = $(am__DEPENDENCIES_2) \
+ext_lm_group_acl_DEPENDENCIES =  \
+	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
@@ -441,12 +489,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -484,12 +533,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -516,27 +566,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -602,24 +655,25 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 ext_lm_group_acl_SOURCES = ext_lm_group_acl.cc
 LDADD = \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
 	-ladvapi32 \
 	-lntdll \
 	$(XTRA_LIBS)
 
 man_MANS = ext_lm_group_acl.8
-EXTRA_DIST = config.test ext_lm_group_acl.8
+EXTRA_DIST = required.m4 ext_lm_group_acl.8
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/LM_group: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/Makefile.in	2015-05-01 16:51:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/Makefile.in	2015-05-01 18:06:31.000000000 +0800
@@ -84,14 +84,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -234,12 +280,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -277,12 +324,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -309,27 +357,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl: modules.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/session: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/session/ext_session_acl.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/session/ext_session_acl.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/session/ext_session_acl.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/session/ext_session_acl.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ext_session_acl 8 "9 October 2011"
 .
 .SH NAME
-.if !'po4a'hide' .B ext_session_acl
-.if !'po4a'hide' \-
-Squid session tracking external acl helper.
+ext_session_acl \- Squid session tracking external acl helper.
 .PP
 Version 1.2
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_session_acl
 .if !'po4a'hide' .B "[\-t"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/session/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/session/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/session/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/session/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,10 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_session_acl
 man_MANS 			= ext_session_acl.8
-EXTRA_DIST			= ext_session_acl.8 config.test
+EXTRA_DIST			= ext_session_acl.8 required.m4
 ext_session_acl_SOURCES		= ext_session_acl.cc
 
 LDADD = \
 	$(COMPAT_LIB) \
 	$(LIB_DB)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/session/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/session/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/session/Makefile.in	2015-05-01 16:51:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/session/Makefile.in	2015-05-01 18:06:33.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ext_session_acl_OBJECTS = ext_session_acl.$(OBJEXT)
 ext_session_acl_OBJECTS = $(am_ext_session_acl_OBJECTS)
 ext_session_acl_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ext_session_acl_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
@@ -441,12 +488,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -484,12 +532,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -516,27 +565,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -602,16 +654,16 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 man_MANS = ext_session_acl.8
-EXTRA_DIST = ext_session_acl.8 config.test
+EXTRA_DIST = ext_session_acl.8 required.m4
 ext_session_acl_SOURCES = ext_session_acl.cc
 LDADD = \
 	$(COMPAT_LIB) \
 	$(LIB_DB)
 
 all: all-am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/session: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/SQL_session: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/SQL_session/ext_sql_session_acl.pl.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/SQL_session/ext_sql_session_acl.pl.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/SQL_session/ext_sql_session_acl.pl.in	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/SQL_session/ext_sql_session_acl.pl.in	2015-05-01 18:05:19.000000000 +0800
@@ -148,16 +148,16 @@
     $status = "ERR";
     $cid =~ s/%(..)/pack("H*", $1)/ge;
     $uid =~ s/%(..)/pack("H*", $1)/ge;
 
     print(stderr "Received: Channel=".$cid.", UID='".$uid."'\n") if ($debug);
 
-    $status = $cid . " ERR database error";
+    $status = $cid . " ERR message=\"database error\"";
     my $sth = query_db($uid) || next;
     print(stderr "Rows: ". $sth->rows()."\n") if ($debug);
-    $status = $cid . " ERR unknown UID '".$uid."'";
+    $status = $cid . " ERR message=\"unknown UID '".$uid."'\"";
     my $row = $sth->fetchrow_hashref() || next;
     $status = $cid . " OK" . ($row->{'user'} ne "" ? " user=" . $row->{'user'} : "" ) . ($row->{'tag'} ne "" ? " tag=" . $row->{'tag'} : "" );
     $sth->finish();
 } continue {
     close_db() if (!$persist);
     print $status . "\n";
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/SQL_session/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/SQL_session/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/SQL_session/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/SQL_session/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -3,13 +3,13 @@
 libexec_SCRIPTS	= ext_sql_session_acl
 CLEANFILES += ext_sql_session_acl ext_sql_session_acl.8
 man_MANS = ext_sql_session_acl.8
 EXTRA_DIST= \
 	ext_sql_session_acl.8 \
 	ext_sql_session_acl.pl.in \
-	config.test
+	required.m4
 
 ext_sql_session_acl.8: ext_sql_session_acl
 	pod2man ext_sql_session_acl ext_sql_session_acl.8
 
 ext_sql_session_acl: ext_sql_session_acl.pl.in
 	$(subst_perlshell)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/SQL_session/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/SQL_session/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/SQL_session/Makefile.in	2015-05-01 16:51:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/SQL_session/Makefile.in	2015-05-01 18:06:32.000000000 +0800
@@ -89,14 +89,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -387,12 +433,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -430,12 +477,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -462,27 +510,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -548,20 +599,20 @@
 CLEANFILES = ext_sql_session_acl ext_sql_session_acl.8
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 libexec_SCRIPTS = ext_sql_session_acl
 man_MANS = ext_sql_session_acl.8
 EXTRA_DIST = \
 	ext_sql_session_acl.8 \
 	ext_sql_session_acl.pl.in \
-	config.test
+	required.m4
 
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .log .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/SQL_session: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/time_quota: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/time_quota/ext_time_quota_acl.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/time_quota/ext_time_quota_acl.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/time_quota/ext_time_quota_acl.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/time_quota/ext_time_quota_acl.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ext_time_quota_acl 8 "22 March 2011"
 .
 .SH NAME
-.if !'po4a'hide' .B ext_time_quota_acl
-.if !'po4a'hide' \-
-Squid time quota external acl helper.
+ext_time_quota_acl \- Squid time quota external acl helper.
 .PP
 Version 1.0
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ext_time_quota_acl
 .if !'po4a'hide' .B "[\-b database] [\-l logfile] [\-d] [\-p pauselen] [\-h] configfile
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/time_quota/ext_time_quota_acl.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/time_quota/ext_time_quota_acl.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/time_quota/ext_time_quota_acl.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/time_quota/ext_time_quota_acl.cc	2015-05-01 18:05:19.000000000 +0800
@@ -444,13 +444,13 @@
 
     log_info("Waiting for requests...\n");
     while (fgets(request, HELPER_INPUT_BUFFER, stdin)) {
         // we expect the following line syntax: %LOGIN
         const char *user_key = strtok(request, " \n");
         if (!user_key) {
-            SEND_ERR("User name missing");
+            SEND_BH("message=\"User name missing\"");
             continue;
         }
         processActivity(user_key);
     }
     log_info("Ending %s\n", __FILE__);
     shutdown_db();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/time_quota/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/time_quota/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/time_quota/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/time_quota/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,11 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_time_quota_acl
 man_MANS 			= ext_time_quota_acl.8
-EXTRA_DIST			= ext_time_quota_acl.8 config.test
+EXTRA_DIST			= ext_time_quota_acl.8 required.m4
 ext_time_quota_acl_SOURCES	= ext_time_quota_acl.cc
 
 DEFS += -DDEFAULT_QUOTA_DB=\"$(localstatedir)/ext_time_quota.db\" 
 
 LDADD = \
 	$(COMPAT_LIB) \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/time_quota/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/time_quota/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/time_quota/Makefile.in	2015-05-01 16:51:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/time_quota/Makefile.in	2015-05-01 18:06:34.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ext_time_quota_acl_OBJECTS = ext_time_quota_acl.$(OBJEXT)
 ext_time_quota_acl_OBJECTS = $(am_ext_time_quota_acl_OBJECTS)
 ext_time_quota_acl_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ext_time_quota_acl_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
@@ -442,12 +489,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -485,12 +533,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -517,27 +566,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -603,16 +655,16 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 man_MANS = ext_time_quota_acl.8
-EXTRA_DIST = ext_time_quota_acl.8 config.test
+EXTRA_DIST = ext_time_quota_acl.8 required.m4
 ext_time_quota_acl_SOURCES = ext_time_quota_acl.cc
 LDADD = \
 	$(COMPAT_LIB) \
 	$(LIB_DB)
 
 all: all-am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/time_quota: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/unix_group/check_group.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/unix_group/check_group.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/unix_group/check_group.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/unix_group/check_group.cc	2015-05-01 18:05:19.000000000 +0800
@@ -172,12 +172,13 @@
         case '?':
             if (xisprint(optopt)) {
                 fprintf(stderr, "Unknown option '-%c'.\n", optopt);
             } else {
                 fprintf(stderr, "Unknown option character `\\x%x'.\n", optopt);
             }
+            // fall through to display help texts.
 
         default:
             usage(argv[0]);
             exit(1);
         }
     }
@@ -203,13 +204,13 @@
         if ((p = strtok(buf, " ")) == NULL) {
             SEND_ERR("No username given.");
             continue;
         } else {
             user = p;
             rfc1738_unescape(user);
-            if (user && strip_dm) {
+            if (strip_dm) {
                 suser = strchr(user, '\\');
                 if (!suser) suser = strchr(user, '/');
                 if (suser && suser[1]) user = suser + 1;
             }
             /* check groups supplied by Squid */
             while ((p = strtok(NULL, " ")) != NULL) {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/unix_group: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/unix_group/ext_unix_group_acl.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/unix_group/ext_unix_group_acl.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/unix_group/ext_unix_group_acl.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/unix_group/ext_unix_group_acl.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ext_unix_group_acl 8 "12 August 2002"
 .
 .SH NAME
-.if !'po4a'hide' .B ext_unix_group_acl
-.if !'po4a'hide' \-
-Squid UNIX Group ACL helper
+ext_unix_group_acl \- Squid UNIX Group ACL helper
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B "ext_unix_group_acl [\-d] [\-g "
 group
 .if !'po4a'hide' .B "] [\-g "
 group
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/unix_group/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/unix_group/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/unix_group/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/unix_group/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,11 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_unix_group_acl
 man_MANS 			= ext_unix_group_acl.8
-EXTRA_DIST			= ext_unix_group_acl.8 config.test
+EXTRA_DIST			= ext_unix_group_acl.8 required.m4
 ext_unix_group_acl_SOURCES	= check_group.cc
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/unix_group/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/unix_group/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/unix_group/Makefile.in	2015-05-01 16:51:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/unix_group/Makefile.in	2015-05-01 18:06:34.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,13 +152,14 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ext_unix_group_acl_OBJECTS = check_group.$(OBJEXT)
 ext_unix_group_acl_OBJECTS = $(am_ext_unix_group_acl_OBJECTS)
 ext_unix_group_acl_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ext_unix_group_acl_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -442,12 +489,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -485,12 +533,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -517,27 +566,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -603,16 +655,16 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 man_MANS = ext_unix_group_acl.8
-EXTRA_DIST = ext_unix_group_acl.8 config.test
+EXTRA_DIST = ext_unix_group_acl.8 required.m4
 ext_unix_group_acl_SOURCES = check_group.cc
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/unix_group: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/wbinfo_group: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/wbinfo_group/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/wbinfo_group/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/wbinfo_group/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/wbinfo_group/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,10 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS = ext_wbinfo_group_acl
-EXTRA_DIST	= ext_wbinfo_group_acl.pl.in config.test
+EXTRA_DIST	= ext_wbinfo_group_acl.pl.in required.m4
 
 ext_wbinfo_group_acl: ext_wbinfo_group_acl.pl.in
 	$(subst_perlshell)
 
 EXTRA_DIST += ext_wbinfo_group_acl.8
 man_MANS = ext_wbinfo_group_acl.8
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/wbinfo_group/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/wbinfo_group/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/external_acl/wbinfo_group/Makefile.in	2015-05-01 16:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/wbinfo_group/Makefile.in	2015-05-01 18:06:34.000000000 +0800
@@ -89,14 +89,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -387,12 +433,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -430,12 +477,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -462,27 +510,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -548,16 +599,16 @@
 CLEANFILES = ext_wbinfo_group_acl.8 ext_wbinfo_group_acl
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 libexec_SCRIPTS = ext_wbinfo_group_acl
-EXTRA_DIST = ext_wbinfo_group_acl.pl.in config.test \
+EXTRA_DIST = ext_wbinfo_group_acl.pl.in required.m4 \
 	ext_wbinfo_group_acl.8
 man_MANS = ext_wbinfo_group_acl.8
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .log .test .test$(EXEEXT) .trs
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/external_acl/wbinfo_group: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/DB: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/DB/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/DB/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/DB/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/DB/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,13 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS	= log_db_daemon
 CLEANFILES += log_db_daemon log_db_daemon.8
 man_MANS = log_db_daemon.8
 EXTRA_DIST= \
-	config.test \
+	required.m4 \
 	doc/views.sql \
 	doc/date_day_column.sql \
 	log_db_daemon.8 \
 	log_db_daemon.pl.in
 
 log_db_daemon.8: log_db_daemon
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/DB/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/DB/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/DB/Makefile.in	2015-05-01 16:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/DB/Makefile.in	2015-05-01 18:06:35.000000000 +0800
@@ -89,14 +89,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -387,12 +433,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -430,12 +477,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -462,27 +510,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -548,18 +599,18 @@
 CLEANFILES = log_db_daemon log_db_daemon.8
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 libexec_SCRIPTS = log_db_daemon
 man_MANS = log_db_daemon.8
 EXTRA_DIST = \
-	config.test \
+	required.m4 \
 	doc/views.sql \
 	doc/date_day_column.sql \
 	log_db_daemon.8 \
 	log_db_daemon.pl.in
 
 all: all-am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/DB: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/file: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/file/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/file/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/file/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/file/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -2,7 +2,7 @@
 
 libexec_PROGRAMS = log_file_daemon
 log_file_daemon_SOURCES = log_file_daemon.cc
 log_file_daemon_LDADD = \
 	-L$(top_builddir)/lib $(COMPAT_LIB) \
 	$(XTRA_LIBS)
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/file/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/file/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/file/Makefile.in	2015-05-01 16:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/file/Makefile.in	2015-05-01 18:06:35.000000000 +0800
@@ -91,27 +91,74 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_log_file_daemon_OBJECTS = log_file_daemon.$(OBJEXT)
 log_file_daemon_OBJECTS = $(am_log_file_daemon_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 log_file_daemon_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
@@ -437,12 +484,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -480,12 +528,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -512,27 +561,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -598,20 +650,20 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 log_file_daemon_SOURCES = log_file_daemon.cc
 log_file_daemon_LDADD = \
 	-L$(top_builddir)/lib $(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/file: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,6 +1,7 @@
 ## Alphabetical list of sub-directories to distribute with Squid:
 DIST_SUBDIRS = \
 	DB \
 	file
 
 SUBDIRS	= $(LOG_DAEMON_HELPERS)
+EXTRA_DIST = modules.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/log_daemon/Makefile.in	2015-05-01 16:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon/Makefile.in	2015-05-01 18:06:35.000000000 +0800
@@ -84,14 +84,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -234,12 +280,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -277,12 +324,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -309,27 +357,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -392,12 +443,13 @@
 top_srcdir = @top_srcdir@
 DIST_SUBDIRS = \
 	DB \
 	file
 
 SUBDIRS = $(LOG_DAEMON_HELPERS)
+EXTRA_DIST = modules.m4
 all: all-recursive
 
 .SUFFIXES:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/log_daemon: modules.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -4,19 +4,27 @@
 	basic_auth \
 	digest_auth \
 	external_acl \
 	log_daemon \
 	negotiate_auth \
 	ntlm_auth \
-	url_rewrite
+	url_rewrite \
+	ssl \
+	storeid_rewrite
 
 SUBDIRS = \
 	basic_auth \
 	digest_auth \
 	external_acl \
 	log_daemon \
 	negotiate_auth \
-	url_rewrite
+	url_rewrite \
+	storeid_rewrite
 
 if ENABLE_AUTH_NTLM
 SUBDIRS += ntlm_auth
 endif
+
+if ENABLE_SSL
+SUBDIRS += ssl
+endif
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/Makefile.in	2015-05-01 16:51:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/Makefile.in	2015-05-01 18:06:23.000000000 +0800
@@ -75,24 +75,71 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 @ENABLE_AUTH_NTLM_TRUE@am__append_1 = ntlm_auth
+@ENABLE_SSL_TRUE@am__append_2 = ssl
 subdir = helpers
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude/init.m4 \
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -235,12 +282,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -278,12 +326,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -310,27 +359,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -396,16 +448,19 @@
 	basic_auth \
 	digest_auth \
 	external_acl \
 	log_daemon \
 	negotiate_auth \
 	ntlm_auth \
-	url_rewrite
+	url_rewrite \
+	ssl \
+	storeid_rewrite
 
 SUBDIRS = basic_auth digest_auth external_acl log_daemon \
-	negotiate_auth url_rewrite $(am__append_1)
+	negotiate_auth url_rewrite storeid_rewrite $(am__append_1) \
+	$(am__append_2)
 all: all-recursive
 
 .SUFFIXES:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,26 +1,28 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = README COPYING config.test negotiate_kerberos_auth.8
+EXTRA_DIST = README COPYING required.m4 negotiate_kerberos_auth.8
 SUBDIRS = 
 
 libexec_PROGRAMS = negotiate_kerberos_auth negotiate_kerberos_auth_test
 
 AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
 
-negotiate_kerberos_auth_SOURCES = negotiate_kerberos_auth.cc
+negotiate_kerberos_auth_SOURCES = negotiate_kerberos_auth.cc negotiate_kerberos_pac.cc negotiate_kerberos.h
 negotiate_kerberos_auth_LDFLAGS = 
 negotiate_kerberos_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
 
 negotiate_kerberos_auth_test_SOURCES = negotiate_kerberos_auth_test.cc
 negotiate_kerberos_auth_test_LDFLAGS = 
 negotiate_kerberos_auth_test_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
 
 man_MANS = negotiate_kerberos_auth.8
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/Makefile.in	2015-05-01 16:51:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/Makefile.in	2015-05-01 18:06:36.000000000 +0800
@@ -92,33 +92,82 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_negotiate_kerberos_auth_OBJECTS =  \
-	negotiate_kerberos_auth.$(OBJEXT)
+	negotiate_kerberos_auth.$(OBJEXT) \
+	negotiate_kerberos_pac.$(OBJEXT)
 negotiate_kerberos_auth_OBJECTS =  \
 	$(am_negotiate_kerberos_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 negotiate_kerberos_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
-	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
+	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 negotiate_kerberos_auth_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
@@ -127,13 +176,14 @@
 am_negotiate_kerberos_auth_test_OBJECTS =  \
 	negotiate_kerberos_auth_test.$(OBJEXT)
 negotiate_kerberos_auth_test_OBJECTS =  \
 	$(am_negotiate_kerberos_auth_test_OBJECTS)
 negotiate_kerberos_auth_test_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
-	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
+	$(am__DEPENDENCIES_3)
 negotiate_kerberos_auth_test_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
 	$(AM_CXXFLAGS) $(CXXFLAGS) \
 	$(negotiate_kerberos_auth_test_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -166,12 +216,30 @@
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
 	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
 am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
 am__v_CXXLD_0 = @echo "  CXXLD   " $@;
 am__v_CXXLD_1 = 
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
 SOURCES = $(negotiate_kerberos_auth_SOURCES) \
 	$(negotiate_kerberos_auth_test_SOURCES)
 DIST_SOURCES = $(negotiate_kerberos_auth_SOURCES) \
 	$(negotiate_kerberos_auth_test_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
 	ctags-recursive dvi-recursive html-recursive info-recursive \
@@ -502,12 +570,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -545,12 +614,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -577,27 +647,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -663,30 +736,32 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
-EXTRA_DIST = README COPYING config.test negotiate_kerberos_auth.8
+EXTRA_DIST = README COPYING required.m4 negotiate_kerberos_auth.8
 SUBDIRS = 
 AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
-negotiate_kerberos_auth_SOURCES = negotiate_kerberos_auth.cc
+negotiate_kerberos_auth_SOURCES = negotiate_kerberos_auth.cc negotiate_kerberos_pac.cc negotiate_kerberos.h
 negotiate_kerberos_auth_LDFLAGS = 
 negotiate_kerberos_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
 
 negotiate_kerberos_auth_test_SOURCES = negotiate_kerberos_auth_test.cc
 negotiate_kerberos_auth_test_LDFLAGS = 
 negotiate_kerberos_auth_test_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
 
 man_MANS = negotiate_kerberos_auth.8
 all: all-recursive
 
@@ -795,12 +870,13 @@
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/negotiate_kerberos_auth.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/negotiate_kerberos_auth_test.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/negotiate_kerberos_pac.Po@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
 @am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH negotiate_kerberos_auth 8
 .
 .SH NAME
-.if !'po4a'hide' .B negotiate_kerberos_auth
-.if !'po4a'hide' \-
-Squid kerberos based authentication helper
+negotiate_kerberos_auth \- Squid kerberos based authentication helper
 .PP
 Version 3.0.4sq
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B negotiate_kerberos_auth
 .if !'po4a'hide' .B [\-h] [\-d] [\-i] [\-r] [\-s Service-Principal-Name] 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -33,85 +33,13 @@
 #include "rfc1738.h"
 #include "compat/getaddrinfo.h"
 #include "compat/getnameinfo.h"
 
 #if HAVE_GSSAPI
 
-#if HAVE_STRING_H
-#include <string.h>
-#endif
-#if HAVE_STDOI_H
-#include <stdio.h>
-#endif
-#if HAVE_NETDB_H
-#include <netdb.h>
-#endif
-#if HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#if HAVE_TIME_H
-#include <time.h>
-#endif
-
-#include "util.h"
-#include "base64.h"
-
-#if HAVE_GSSAPI_GSSAPI_H
-#include <gssapi/gssapi.h>
-#elif HAVE_GSSAPI_H
-#include <gssapi.h>
-#endif
-
-#if !HAVE_HEIMDAL_KERBEROS
-#if HAVE_GSSAPI_GSSAPI_KRB5_H
-#include <gssapi/gssapi_krb5.h>
-#endif
-#if HAVE_GSSAPI_GSSAPI_GENERIC_H
-#include <gssapi/gssapi_generic.h>
-#endif
-#if HAVE_GSSAPI_GSSAPI_EXT_H
-#include <gssapi/gssapi_ext.h>
-#endif
-#endif
-
-#ifndef gss_nt_service_name
-#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE
-#endif
-
-#define PROGRAM "negotiate_kerberos_auth"
-
-#ifndef MAX_AUTHTOKEN_LEN
-#define MAX_AUTHTOKEN_LEN   65535
-#endif
-#ifndef SQUID_KERB_AUTH_VERSION
-#define SQUID_KERB_AUTH_VERSION "3.0.4sq"
-#endif
-
-int check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
-                  const char *function, int log);
-char *gethost_name(void);
-static const char *LogTime(void);
-
-static const unsigned char ntlmProtocol[] = {'N', 'T', 'L', 'M', 'S', 'S', 'P', 0};
-
-static const char *
-LogTime()
-{
-    struct tm *tm;
-    struct timeval now;
-    static time_t last_t = 0;
-    static char buf[128];
-
-    gettimeofday(&now, NULL);
-    if (now.tv_sec != last_t) {
-        tm = localtime((time_t *) & now.tv_sec);
-        strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
-        last_t = now.tv_sec;
-    }
-    return buf;
-}
+#include "negotiate_kerberos.h"
 
 char *
 gethost_name(void)
 {
     /*
      * char hostname[sysconf(_SC_HOST_NAME_MAX)];
@@ -152,13 +80,13 @@
     hostname[sizeof(hostname)-1] = '\0';
     return (xstrdup(hostname));
 }
 
 int
 check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
-              const char *function, int log)
+              const char *function, int log, int sout)
 {
     if (GSS_ERROR(major_status)) {
         OM_uint32 maj_stat, min_stat;
         OM_uint32 msg_ctx = 0;
         gss_buffer_desc status_string;
         char buf[1024];
@@ -195,13 +123,14 @@
                 }
             } else
                 msg_ctx = 0;
             gss_release_buffer(&min_stat, &status_string);
         } while (msg_ctx);
         debug((char *) "%s| %s: ERROR: %s failed: %s\n", LogTime(), PROGRAM, function, buf);
-        fprintf(stdout, "BH %s failed: %s\n", function, buf);
+        if (sout)
+            fprintf(stdout, "BH %s failed: %s\n", function, buf);
         if (log)
             fprintf(stderr, "%s| %s: INFO: User not authenticated\n", LogTime(),
                     PROGRAM);
         return (1);
     }
     return (0);
@@ -210,13 +139,26 @@
 int
 main(int argc, char *const argv[])
 {
     char buf[MAX_AUTHTOKEN_LEN];
     char *c, *p;
     char *user = NULL;
-    int length = 0;
+    char *rfc_user = NULL;
+#if HAVE_PAC_SUPPORT
+    char ad_groups[MAX_PAC_GROUP_SIZE];
+    char *ag=NULL;
+    krb5_context context = NULL;
+    krb5_error_code ret;
+    krb5_pac pac;
+#if HAVE_HEIMDAL_KERBEROS
+    gss_buffer_desc data_set = GSS_C_EMPTY_BUFFER;
+#else
+    gss_buffer_desc type_id = GSS_C_EMPTY_BUFFER;
+#endif
+#endif
+    long length = 0;
     static int err = 0;
     int opt, log = 0, norealm = 0;
     OM_uint32 ret_flags = 0, spnego_flag = 0;
     char *service_name = (char *) "HTTP", *host_name = NULL;
     char *token = NULL;
     char *service_principal = NULL;
@@ -281,12 +223,13 @@
             exit(-1);
         }
         service.value = xmalloc(strlen(service_name) + strlen(host_name) + 2);
         snprintf((char *) service.value, strlen(service_name) + strlen(host_name) + 2,
                  "%s@%s", service_name, host_name);
         service.length = strlen((char *) service.value);
+        xfree(host_name);
     }
 
     while (1) {
         if (fgets(buf, sizeof(buf) - 1, stdin) == NULL) {
             if (ferror(stdin)) {
                 debug((char *) "%s| %s: FATAL: fgets() failed! dying..... errno=%d (%s)\n",
@@ -309,13 +252,13 @@
         if (err) {
             debug((char *) "%s| %s: ERROR: Oversized message\n", LogTime(), PROGRAM);
             fprintf(stdout, "BH Oversized message\n");
             err = 0;
             continue;
         }
-        debug((char *) "%s| %s: DEBUG: Got '%s' from squid (length: %d).\n", LogTime(), PROGRAM, buf, length);
+        debug((char *) "%s| %s: DEBUG: Got '%s' from squid (length: %ld).\n", LogTime(), PROGRAM, buf, length);
 
         if (buf[0] == '\0') {
             debug((char *) "%s| %s: ERROR: Invalid request\n", LogTime(), PROGRAM);
             fprintf(stdout, "BH Invalid request\n");
             continue;
         }
@@ -335,29 +278,19 @@
                 gss_release_name(&minor_status, &client_name);
             if (gss_context != GSS_C_NO_CONTEXT)
                 gss_delete_sec_context(&minor_status, &gss_context, NULL);
             if (kerberosToken) {
                 /* Allocated by parseNegTokenInit, but no matching free function exists.. */
                 if (!spnego_flag)
-                    xfree((char *) kerberosToken);
-                kerberosToken = NULL;
+                    xfree(kerberosToken);
             }
             if (spnego_flag) {
                 /* Allocated by makeNegTokenTarg, but no matching free function exists.. */
-                if (spnegoToken)
-                    xfree((char *) spnegoToken);
-                spnegoToken = NULL;
-            }
-            if (token) {
-                xfree(token);
-                token = NULL;
-            }
-            if (host_name) {
-                xfree(host_name);
-                host_name = NULL;
+                xfree(spnegoToken);
             }
+            xfree(token);
             fprintf(stdout, "BH quit command\n");
             exit(0);
         }
         if (strncmp(buf, "YR", 2) && strncmp(buf, "KK", 2)) {
             debug((char *) "%s| %s: ERROR: Invalid request [%s]\n", LogTime(), PROGRAM, buf);
             fprintf(stdout, "BH Invalid request\n");
@@ -370,18 +303,18 @@
         }
         if (strlen(buf) <= 3) {
             debug((char *) "%s| %s: ERROR: Invalid negotiate request [%s]\n", LogTime(), PROGRAM, buf);
             fprintf(stdout, "BH Invalid negotiate request\n");
             continue;
         }
-        input_token.length = base64_decode_len(buf+3);
+        input_token.length = (size_t)base64_decode_len(buf+3);
         debug((char *) "%s| %s: DEBUG: Decode '%s' (decoded length: %d).\n",
               LogTime(), PROGRAM, buf + 3, (int) input_token.length);
         input_token.value = xmalloc(input_token.length);
 
-        input_token.length = base64_decode((char *) input_token.value, input_token.length, buf+3);
+        input_token.length = (size_t)base64_decode((char *) input_token.value, (unsigned int)input_token.length, buf+3);
 
         if ((input_token.length >= sizeof ntlmProtocol + 1) &&
                 (!memcmp(input_token.value, ntlmProtocol, sizeof ntlmProtocol))) {
             debug((char *) "%s| %s: WARNING: received type %d NTLM token\n",
                   LogTime(), PROGRAM,
                   (int) *((unsigned char *) input_token.value +
@@ -396,91 +329,127 @@
                 major_status = gss_import_name(&minor_status, &service,
                                                (gss_OID) GSS_C_NULL_OID, &server_name);
 
             } else {
                 server_name = GSS_C_NO_NAME;
                 major_status = GSS_S_COMPLETE;
+                minor_status = 0;
             }
         } else {
             major_status = gss_import_name(&minor_status, &service,
                                            gss_nt_service_name, &server_name);
         }
 
-        if (check_gss_err(major_status, minor_status, "gss_import_name()", log))
+        if (check_gss_err(major_status, minor_status, "gss_import_name()", log, 1))
             goto cleanup;
 
         major_status =
             gss_acquire_cred(&minor_status, server_name, GSS_C_INDEFINITE,
                              GSS_C_NO_OID_SET, GSS_C_ACCEPT, &server_creds, NULL, NULL);
-        if (check_gss_err(major_status, minor_status, "gss_acquire_cred()", log))
+        if (check_gss_err(major_status, minor_status, "gss_acquire_cred()", log, 1))
             goto cleanup;
 
         major_status = gss_accept_sec_context(&minor_status,
                                               &gss_context,
                                               server_creds,
                                               &input_token,
                                               GSS_C_NO_CHANNEL_BINDINGS,
                                               &client_name, NULL, &output_token, &ret_flags, NULL, NULL);
 
         if (output_token.length) {
             spnegoToken = (const unsigned char *) output_token.value;
             spnegoTokenLength = output_token.length;
-            token = (char *) xmalloc(base64_encode_len(spnegoTokenLength));
+            token = (char *) xmalloc((size_t)base64_encode_len((int)spnegoTokenLength));
             if (token == NULL) {
                 debug((char *) "%s| %s: ERROR: Not enough memory\n", LogTime(), PROGRAM);
                 fprintf(stdout, "BH Not enough memory\n");
                 goto cleanup;
             }
-            base64_encode_str(token, base64_encode_len(spnegoTokenLength),
-                              (const char *) spnegoToken, spnegoTokenLength);
+            base64_encode_str(token, base64_encode_len((int)spnegoTokenLength),
+                              (const char *) spnegoToken, (int)spnegoTokenLength);
 
-            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log))
+            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log, 1))
                 goto cleanup;
             if (major_status & GSS_S_CONTINUE_NEEDED) {
                 debug((char *) "%s| %s: INFO: continuation needed\n", LogTime(), PROGRAM);
                 fprintf(stdout, "TT %s\n", token);
                 goto cleanup;
             }
             gss_release_buffer(&minor_status, &output_token);
             major_status =
                 gss_display_name(&minor_status, client_name, &output_token,
                                  NULL);
 
-            if (check_gss_err(major_status, minor_status, "gss_display_name()", log))
+            if (check_gss_err(major_status, minor_status, "gss_display_name()", log, 1))
                 goto cleanup;
             user = (char *) xmalloc(output_token.length + 1);
             if (user == NULL) {
                 debug((char *) "%s| %s: ERROR: Not enough memory\n", LogTime(), PROGRAM);
                 fprintf(stdout, "BH Not enough memory\n");
                 goto cleanup;
             }
             memcpy(user, output_token.value, output_token.length);
             user[output_token.length] = '\0';
             if (norealm && (p = strchr(user, '@')) != NULL) {
                 *p = '\0';
             }
+
+#if HAVE_PAC_SUPPORT
+            ret = krb5_init_context(&context);
+            if (!check_k5_err(context, "krb5_init_context", ret)) {
+#if HAVE_HEIMDAL_KERBEROS
+#define ADWIN2KPAC 128
+                major_status = gsskrb5_extract_authz_data_from_sec_context(&minor_status,
+                               gss_context, ADWIN2KPAC, &data_set);
+                if (!check_gss_err(major_status, minor_status,
+                                   "gsskrb5_extract_authz_data_from_sec_context()", log, 0)) {
+                    ret = krb5_pac_parse(context, data_set.value, data_set.length, &pac);
+                    gss_release_buffer(&minor_status, &data_set);
+                    if (!check_k5_err(context, "krb5_pac_parse", ret)) {
+                        ag = get_ad_groups((char *)&ad_groups, context, pac);
+                        krb5_pac_free(context, pac);
+                    }
+                    krb5_free_context(context);
+                }
+#else
+                type_id.value = (void *)"mspac";
+                type_id.length = strlen((char *)type_id.value);
+#define KRB5PACLOGONINFO        1
+                major_status = gss_map_name_to_any(&minor_status, client_name, KRB5PACLOGONINFO, &type_id, (gss_any_t *)&pac);
+                if (!check_gss_err(major_status, minor_status, "gss_map_name_to_any()", log, 0)) {
+                    ag = get_ad_groups((char *)&ad_groups,context, pac);
+                }
+                (void)gss_release_any_name_mapping(&minor_status, client_name, &type_id, (gss_any_t *)&pac);
+                krb5_free_context(context);
+#endif
+            }
+            if (ag) {
+                debug((char *) "%s| %s: DEBUG: Groups %s\n", LogTime(), PROGRAM, ag);
+            }
+#endif
             fprintf(stdout, "AF %s %s\n", token, user);
-            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, token, rfc1738_escape(user));
+            rfc_user = rfc1738_escape(user);
+            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, token, rfc_user);
             if (log)
                 fprintf(stderr, "%s| %s: INFO: User %s authenticated\n", LogTime(),
                         PROGRAM, rfc1738_escape(user));
             goto cleanup;
         } else {
-            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log))
+            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log, 1))
                 goto cleanup;
             if (major_status & GSS_S_CONTINUE_NEEDED) {
                 debug((char *) "%s| %s: INFO: continuation needed\n", LogTime(), PROGRAM);
                 fprintf(stdout, "NA %s\n", token);
                 goto cleanup;
             }
             gss_release_buffer(&minor_status, &output_token);
             major_status =
                 gss_display_name(&minor_status, client_name, &output_token,
                                  NULL);
 
-            if (check_gss_err(major_status, minor_status, "gss_display_name()", log))
+            if (check_gss_err(major_status, minor_status, "gss_display_name()", log, 1))
                 goto cleanup;
             /*
              *  Return dummy token AA. May need an extra return tag then AF
              */
             user = (char *) xmalloc(output_token.length + 1);
             if (user == NULL) {
@@ -508,29 +477,20 @@
             gss_release_name(&minor_status, &server_name);
         if (client_name)
             gss_release_name(&minor_status, &client_name);
         if (kerberosToken) {
             /* Allocated by parseNegTokenInit, but no matching free function exists.. */
             if (!spnego_flag)
-                xfree((char *) kerberosToken);
-            kerberosToken = NULL;
+                safe_free(kerberosToken);
         }
         if (spnego_flag) {
             /* Allocated by makeNegTokenTarg, but no matching free function exists.. */
-            if (spnegoToken)
-                xfree((char *) spnegoToken);
-            spnegoToken = NULL;
-        }
-        if (token) {
-            xfree(token);
-            token = NULL;
-        }
-        if (user) {
-            xfree(user);
-            user = NULL;
+            safe_free(spnegoToken);
         }
+        safe_free(token);
+        safe_free(user);
         continue;
     }
 }
 #else
 #include <stdio.h>
 #include <stdlib.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth_test.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth_test.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth_test.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos/negotiate_kerberos_auth_test.cc	2015-05-01 18:05:19.000000000 +0800
@@ -193,15 +193,15 @@
                                         &input_token, NULL, &output_token, NULL, NULL);
 
     if (check_gss_err(major_status, minor_status, "gss_init_sec_context()"))
         goto cleanup;
 
     if (output_token.length) {
-        token = (char *) xmalloc(base64_encode_len(output_token.length));
-        base64_encode_str(token, base64_encode_len(output_token.length),
-                          (const char *) output_token.value, output_token.length);
+        token = (char *) xmalloc((size_t)base64_encode_len((int)output_token.length));
+        base64_encode_str(token, base64_encode_len((int)output_token.length),
+                          (const char *) output_token.value, (int)output_token.length);
     }
 cleanup:
     gss_delete_sec_context(&minor_status, &gss_context, NULL);
     gss_release_buffer(&minor_status, &service);
     gss_release_buffer(&minor_status, &input_token);
     gss_release_buffer(&minor_status, &output_token);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos: negotiate_kerberos.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos: negotiate_kerberos_pac.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/kerberos: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/Makefile.in	2015-05-01 16:51:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/Makefile.in	2015-05-01 18:06:36.000000000 +0800
@@ -84,14 +84,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -234,12 +280,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -277,12 +324,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -309,27 +357,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth: modules.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/SSPI: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/SSPI/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/SSPI/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/SSPI/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/SSPI/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -3,11 +3,12 @@
 libexec_PROGRAMS = negotiate_sspi_auth
 
 negotiate_sspi_auth_SOURCES = negotiate_sspi_auth.cc
 
 LDADD	= \
 	-L$(top_builddir)/lib -lsspwin32 \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = readme.txt config.test
+EXTRA_DIST = readme.txt required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/SSPI/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/SSPI/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/SSPI/Makefile.in	2015-05-01 16:51:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/SSPI/Makefile.in	2015-05-01 18:06:36.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,15 +152,17 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_negotiate_sspi_auth_OBJECTS = negotiate_sspi_auth.$(OBJEXT)
 negotiate_sspi_auth_OBJECTS = $(am_negotiate_sspi_auth_OBJECTS)
 negotiate_sspi_auth_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
-negotiate_sspi_auth_DEPENDENCIES = $(am__DEPENDENCIES_2) \
+negotiate_sspi_auth_DEPENDENCIES =  \
+	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
@@ -438,12 +486,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -481,12 +530,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -513,27 +563,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -599,22 +652,23 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 negotiate_sspi_auth_SOURCES = negotiate_sspi_auth.cc
 LDADD = \
 	-L$(top_builddir)/lib -lsspwin32 \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = readme.txt config.test
+EXTRA_DIST = readme.txt required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/SSPI/negotiate_sspi_auth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/SSPI/negotiate_sspi_auth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/SSPI/negotiate_sspi_auth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/SSPI/negotiate_sspi_auth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -34,14 +34,16 @@
  * 29-10-2005 Guido Serassio
  *              First release.
  *
  *
  */
 #include "squid.h"
+#include "base64.h"
 #include "helpers/defines.h"
-#include "libntlmauth/support_bits.cci"
+#include "ntlmauth/ntlmauth.h"
+#include "ntlmauth/support_bits.cci"
 #include "sspwin32.h"
 #include "util.h"
 
 #include <windows.h>
 #include <sspi.h>
 #include <security.h>
@@ -132,13 +134,13 @@
     BOOL Done = FALSE;
 
 try_again:
     if (fgets(buf, HELPER_INPUT_BUFFER, stdin))
         return 0;
 
-    c = memchr(buf, '\n', HELPER_INPUT_BUFFER);		/* safer against overrun than strchr */
+    c = static_cast<char*>(memchr(buf, '\n', HELPER_INPUT_BUFFER));
     if (c) {
         if (oversized) {
             SEND("BH illegal request received");
             fprintf(stderr, "ERROR: Illegal request received: '%s'\n", buf);
             return 1;
         }
@@ -150,19 +152,19 @@
     }
 
     if ((strlen(buf) > 3) && Negotiate_packet_debug_enabled) {
         decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
         strncpy(helper_command, buf, 2);
         debug("Got '%s' from Squid with data:\n", helper_command);
-        hex_dump(decoded, decodedLen);
+        hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
     } else
         debug("Got '%s' from Squid\n", buf);
 
     if (memcmp(buf, "YR ", 3) == 0) {	/* refresh-request */
         /* figure out what we got */
-        decoded = base64_decode(buf + 3);
+        decodedLen = base64_decode(decoded, sizeof(decoded), buf + 3);
         if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
             SEND("NA * Packet format error, couldn't base64-decode");
             return 1;
         }
         /* Obtain server blob against SSPI */
         c = (char *) SSP_MakeNegotiateBlob(decoded, decodedLen, &Done, &status, cred);
@@ -173,23 +175,23 @@
                 have_serverblob = 0;
                 Done = FALSE;
                 if (Negotiate_packet_debug_enabled) {
                     decodedLen = base64_decode(decoded, sizeof(decoded), c);
                     debug("sending 'AF' %s to squid with data:\n", cred);
                     if (c != NULL)
-                        hex_dump(decoded, decodedLen);
+                        hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                     else
                         fprintf(stderr, "No data available.\n");
                     printf("AF %s %s\n", c, cred);
                 } else
                     SEND3("AF %s %s", c, cred);
             } else {
                 if (Negotiate_packet_debug_enabled) {
                     decodedLen = base64_decode(decoded, sizeof(decoded), c);
                     debug("sending 'TT' to squid with data:\n");
-                    hex_dump(decoded, decodedLen);
+                    hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                     printf("TT %s\n", c);
                 } else {
                     SEND2("TT %s", c);
                 }
                 have_serverblob = 1;
             }
@@ -233,25 +235,25 @@
             have_serverblob = 0;
             Done = FALSE;
             if (Negotiate_packet_debug_enabled) {
                 decodedLen = base64_decode(decoded, sizeof(decoded), c);
                 debug("sending 'AF' %s to squid with data:\n", cred);
                 if (c != NULL)
-                    hex_dump(decoded, decodedLen);
+                    hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                 else
                     fprintf(stderr, "No data available.\n");
                 printf("AF %s %s\n", c, cred);
             } else {
                 SEND3("AF %s %s", c, cred);
             }
             return 1;
         } else {
             if (Negotiate_packet_debug_enabled) {
                 decodedLen = base64_decode(decoded, sizeof(decoded), c);
                 debug("sending 'TT' to squid with data:\n");
-                hex_dump(decoded, decodedLen);
+                hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
                 printf("TT %s\n", c);
             } else
                 SEND2("TT %s", c);
             return 1;
         }
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/SSPI: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/wrapper: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/wrapper/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/wrapper/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/wrapper/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/wrapper/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,12 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 
 libexec_PROGRAMS = negotiate_wrapper_auth
 
 negotiate_wrapper_auth_SOURCES = negotiate_wrapper.cc
 negotiate_wrapper_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(XTRA_LIBS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/wrapper/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/wrapper/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/wrapper/Makefile.in	2015-05-01 16:51:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/wrapper/Makefile.in	2015-05-01 18:06:37.000000000 +0800
@@ -91,31 +91,78 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_negotiate_wrapper_auth_OBJECTS = negotiate_wrapper.$(OBJEXT)
 negotiate_wrapper_auth_OBJECTS = $(am_negotiate_wrapper_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 negotiate_wrapper_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
-	$(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -438,12 +485,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -481,12 +529,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -513,27 +562,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -599,19 +651,20 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 negotiate_wrapper_auth_SOURCES = negotiate_wrapper.cc
 negotiate_wrapper_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(XTRA_LIBS)
 
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/wrapper/negotiate_wrapper.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/wrapper/negotiate_wrapper.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/negotiate_auth/wrapper/negotiate_wrapper.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/wrapper/negotiate_wrapper.cc	2015-05-01 18:05:19.000000000 +0800
@@ -43,15 +43,12 @@
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #if HAVE_TIME_H
 #include <time.h>
 #endif
-#if HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
 
 #if !defined(HAVE_DECL_XMALLOC) || !HAVE_DECL_XMALLOC
 #define xmalloc malloc
@@ -111,13 +108,12 @@
     int debug = 0;
     int length;
     int nstart = 0, kstart = 0;
     int nend = 0, kend = 0;
     char *token;
     char **nargs, **kargs;
-    int i,j;
     int fpid;
     FILE *FDKIN,*FDKOUT;
     FILE *FDNIN,*FDNOUT;
     int pkin[2];
     int pkout[2];
     int pnin[2];
@@ -128,19 +124,19 @@
 
     if (argc ==1 || !strncasecmp(argv[1],"-h",2)) {
         usage();
         return 0;
     }
 
-    j = 1;
+    int j = 1;
     if (!strncasecmp(argv[1],"-d",2)) {
         debug = 1;
         j = 2;
     }
 
-    for (i=j; i<argc; ++i) {
+    for (int i=j; i<argc; ++i) {
         if (!strncasecmp(argv[i],"--ntlm",6))
             nstart = i;
         if (!strncasecmp(argv[i],"--kerberos",10))
             kstart = i;
     }
     if (nstart > kstart) {
@@ -164,25 +160,25 @@
         return 1;
     }
     memcpy(nargs,argv+nstart+1,(nend-nstart)*sizeof(char *));
     nargs[nend-nstart]=NULL;
     if (debug) {
         fprintf(stderr, "%s| %s: NTLM command: ", LogTime(), PROGRAM);
-        for (i=0; i<nend-nstart; ++i)
+        for (int i=0; i<nend-nstart; ++i)
             fprintf(stderr, "%s ", nargs[i]);
         fprintf(stderr, "\n");
     }
     if ((kargs = (char **)xmalloc((kend-kstart+1)*sizeof(char *))) == NULL) {
         fprintf(stderr, "%s| %s: Error allocating memory for kerberos helper\n", LogTime(), PROGRAM);
         return 1;
     }
     memcpy(kargs,argv+kstart+1,(kend-kstart)*sizeof(char *));
     kargs[kend-kstart]=NULL;
     if (debug) {
         fprintf(stderr, "%s| %s: Kerberos command: ", LogTime(), PROGRAM);
-        for (i=0; i<kend-kstart; ++i)
+        for (int i=0; i<kend-kstart; ++i)
             fprintf(stderr, "%s ", kargs[i]);
         fprintf(stderr, "\n");
     }
     /*
        Fork Kerberos helper and NTLM helper and manage IO to send NTLM requests
        to the right helper. squid must keep session state
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/negotiate_auth/wrapper: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/fake: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/fake/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/fake/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/fake/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/fake/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -4,17 +4,18 @@
 ntlm_fake_auth_SOURCES	= ntlm_fake_auth.cc
 
 ntlm_fake_auth_LDADD = \
 	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
 INCLUDES += -I$(top_srcdir)/lib
 
 ## Demo using perl.
 ## ntlm_fake_auth.pl: ntlm_fake_auth.pl.in
 ##	$(subst_perlshell)
 
-EXTRA_DIST = config.test \
+EXTRA_DIST = required.m4 \
 	ntlm_fake_auth.pl.in
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/fake/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/fake/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/fake/Makefile.in	2015-05-01 16:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/fake/Makefile.in	2015-05-01 18:06:38.000000000 +0800
@@ -91,32 +91,80 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ntlm_fake_auth_OBJECTS = ntlm_fake_auth.$(OBJEXT)
 ntlm_fake_auth_OBJECTS = $(am_ntlm_fake_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ntlm_fake_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
-	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
+	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -439,12 +487,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -482,12 +531,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -514,27 +564,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -601,23 +654,24 @@
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) \
 	-I$(top_srcdir)/lib
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 ntlm_fake_auth_SOURCES = ntlm_fake_auth.cc
 ntlm_fake_auth_LDADD = \
 	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test \
+EXTRA_DIST = required.m4 \
 	ntlm_fake_auth.pl.in
 
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/fake: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,2 +1,3 @@
 DIST_SUBDIRS	= fake smb_lm SSPI
 SUBDIRS		= $(NTLM_AUTH_HELPERS)
+EXTRA_DIST	= modules.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/Makefile.in	2015-05-01 16:51:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/Makefile.in	2015-05-01 18:06:37.000000000 +0800
@@ -84,14 +84,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -234,12 +280,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -277,12 +324,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -309,27 +357,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -389,12 +440,13 @@
 target_alias = @target_alias@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 DIST_SUBDIRS = fake smb_lm SSPI
 SUBDIRS = $(NTLM_AUTH_HELPERS)
+EXTRA_DIST = modules.m4
 all: all-recursive
 
 .SUFFIXES:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth: modules.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/smb_lm: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/smb_lm/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/smb_lm/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/smb_lm/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/smb_lm/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -6,12 +6,13 @@
 ntlm_smb_lm_auth_LDADD = \
 	$(top_builddir)/lib/smblib/libsmblib.la \
 	$(top_builddir)/lib/rfcnb/librfcnb.la \
 	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
 INCLUDES += -I$(top_srcdir)/lib
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/smb_lm/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/smb_lm/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/smb_lm/Makefile.in	2015-05-01 16:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/smb_lm/Makefile.in	2015-05-01 18:06:38.000000000 +0800
@@ -91,34 +91,82 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ntlm_smb_lm_auth_OBJECTS = ntlm_smb_lm_auth.$(OBJEXT)
 ntlm_smb_lm_auth_OBJECTS = $(am_ntlm_smb_lm_auth_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 ntlm_smb_lm_auth_DEPENDENCIES =  \
 	$(top_builddir)/lib/smblib/libsmblib.la \
 	$(top_builddir)/lib/rfcnb/librfcnb.la \
 	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
-	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
+	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -441,12 +489,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -484,12 +533,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -516,27 +566,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -603,25 +656,26 @@
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) \
 	-I$(top_srcdir)/lib
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 ntlm_smb_lm_auth_SOURCES = ntlm_smb_lm_auth.cc
 ntlm_smb_lm_auth_LDADD = \
 	$(top_builddir)/lib/smblib/libsmblib.la \
 	$(top_builddir)/lib/rfcnb/librfcnb.la \
 	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/smb_lm: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/SSPI: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/SSPI/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/SSPI/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/SSPI/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/SSPI/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -4,14 +4,15 @@
 
 libexec_PROGRAMS = ntlm_sspi_auth
 
 ntlm_sspi_auth_SOURCES = ntlm_sspi_auth.cc
 
 LDADD = \
-	-L$(top_builddir)/libntlmauth -lntlmauth \
+	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	-L$(top_builddir)/lib -lsspwin32 \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = ntlm_sspi_auth.8 config.test
+EXTRA_DIST = ntlm_sspi_auth.8 required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/SSPI/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/SSPI/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/SSPI/Makefile.in	2015-05-01 16:51:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/SSPI/Makefile.in	2015-05-01 18:06:37.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -106,15 +152,18 @@
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(man8dir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_ntlm_sspi_auth_OBJECTS = ntlm_sspi_auth.$(OBJEXT)
 ntlm_sspi_auth_OBJECTS = $(am_ntlm_sspi_auth_OBJECTS)
 ntlm_sspi_auth_LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
-ntlm_sspi_auth_DEPENDENCIES = $(am__DEPENDENCIES_2) \
+ntlm_sspi_auth_DEPENDENCIES =  \
+	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
+	$(top_builddir)/lib/libmiscencoding.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
@@ -441,12 +490,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -484,12 +534,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -516,27 +567,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -602,25 +656,26 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 man_MANS = ntlm_sspi_auth.8
 ntlm_sspi_auth_SOURCES = ntlm_sspi_auth.cc
 LDADD = \
-	-L$(top_builddir)/libntlmauth -lntlmauth \
+	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	-L$(top_builddir)/lib -lsspwin32 \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = ntlm_sspi_auth.8 config.test
+EXTRA_DIST = ntlm_sspi_auth.8 required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/SSPI/ntlm_sspi_auth.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/SSPI/ntlm_sspi_auth.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/SSPI/ntlm_sspi_auth.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/SSPI/ntlm_sspi_auth.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,10 @@
 .if !'po4a'hide' .TH ntlm_sspi_auth.exe 8
 .
 .SH NAME
-.if !'po4a'hide' .B ntlm_sspi_auth.exe
-.if !'po4a'hide' \-
-Native Windows NTLM/NTLMv2 authenticator for Squid with
-automatic support for NTLM NEGOTIATE packets.
+ntlm_sspi_auth.exe \- Native Windows NTLM/NTLMv2 authenticator for Squid
 .PP
 Version 1.22
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ntlm_sspi_auth.exe
 .if !'po4a'hide' .B "[\-dhv] [\-A "
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/SSPI/ntlm_sspi_auth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/SSPI/ntlm_sspi_auth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/ntlm_auth/SSPI/ntlm_sspi_auth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/SSPI/ntlm_sspi_auth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -58,18 +58,19 @@
 /************* CONFIGURATION ***************/
 
 #define FAIL_DEBUG 0
 
 /************* END CONFIGURATION ***************/
 
-typedef unsigned char uchar;
+//typedef unsigned char uchar;
 
 #include "squid.h"
+#include "base64.h"
 #include "helpers/defines.h"
-#include "libntlmauth/ntlmauth.h"
-#include "libntlmauth/support_bits.h"
+#include "ntlmauth/ntlmauth.h"
+#include "ntlmauth/support_bits.cci"
 #include "sspwin32.h"
 #include "util.h"
 
 #include <windows.h>
 #include <sspi.h>
 #include <security.h>
@@ -79,14 +80,12 @@
 #if HAVE_GETOPT_H
 #include <getopt.h>
 #endif
 #include <lm.h>
 #include <ntsecapi.h>
 
-#define BUFFER_SIZE 10240
-
 int NTLM_packet_debug_enabled = 0;
 static int have_challenge;
 char * NTAllowedGroup;
 char * NTDisAllowedGroup;
 int UseDisallowedGroup = 0;
 int UseAllowedGroup = 0;
@@ -269,25 +268,24 @@
         LsaFreeMemory((LPVOID)ppdiDomainInfo);
     } else
         debug("NetWkstaGetInfo Error: %ld\n", netret);
     return DomainName;
 }
 
-/* returns NULL on failure, or a pointer to
- * the user's credentials (domain\\username)
- * upon success. WARNING. It's pointing to static storage.
- * In case of problem sets as side-effect ntlm_errno to one of the
+/*
+ * Fills auth with the user's credentials.
+ *
+ * In case of problem returns one of the
  * codes defined in libntlmauth/ntlmauth.h
  */
 int
 ntlm_check_auth(ntlm_authenticate * auth, char *user, char *domain, int auth_length)
 {
     int x;
     int rv;
     char credentials[DNLEN+UNLEN+2];	/* we can afford to waste */
-    lstring tmp;
 
     if (!NTLM_LocalCall) {
 
         user[0] = '\0';
         domain[0] = '\0';
         x = ntlm_unpack_auth(auth, user, domain, auth_length);
@@ -338,13 +336,13 @@
 void
 helperfail(const char *reason)
 {
 #if FAIL_DEBUG
     fail_debug_enabled =1;
 #endif
-    SEND2("BH %s", reason);
+    SEND_BH(reason);
 }
 
 /*
   options:
   -d enable debugging.
   -v enable verbose NTLM packet debugging.
@@ -408,161 +406,162 @@
 }
 
 int
 manage_request()
 {
     ntlmhdr *fast_header;
-    char buf[BUFFER_SIZE];
-    char decoded[BUFFER_SIZE];
+    char buf[HELPER_INPUT_BUFFER];
+    char decoded[HELPER_INPUT_BUFFER];
     int decodedLen;
     char helper_command[3];
-    char *c, *cred;
     int oversized = 0;
     char * ErrorMessage;
     static ntlm_negotiate local_nego;
     char domain[DNLEN+1];
     char user[UNLEN+1];
 
     /* NP: for some reason this helper sometimes needs to accept
      * from clients that send no negotiate packet. */
-    if (memcpy(local_nego.signature, "NTLMSSP", 8) != 0) {
+    if (memcpy(local_nego.hdr.signature, "NTLMSSP", 8) != 0) {
         memset(&local_nego, 0, sizeof(ntlm_negotiate));	/* reset */
-        memcpy(local_nego.signature, "NTLMSSP", 8);     /* set the signature */
-        local_nego.type = le32toh(NTLM_NEGOTIATE);      /* this is a challenge */
+        memcpy(local_nego.hdr.signature, "NTLMSSP", 8);     /* set the signature */
+        local_nego.hdr.type = le32toh(NTLM_NEGOTIATE);      /* this is a challenge */
         local_nego.flags = le32toh(NTLM_NEGOTIATE_ALWAYS_SIGN |
                                    NTLM_NEGOTIATE_USE_NTLM |
                                    NTLM_NEGOTIATE_USE_LM |
                                    NTLM_NEGOTIATE_ASCII );
     }
 
-try_again:
-    if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
-        return 0;
-
-    c = memchr(buf, '\n', BUFFER_SIZE);	/* safer against overrun than strchr */
-    if (c) {
-        if (oversized) {
-            helperfail("illegal request received");
-            fprintf(stderr, "Illegal request received: '%s'\n", buf);
-            return 1;
-        }
-        *c = '\0';
-    } else {
-        fprintf(stderr, "No newline in '%s'\n", buf);
-        oversized = 1;
-        goto try_again;
-    }
+    do {
+        if (fgets(buf, sizeof(buf), stdin) == NULL)
+            return 0;
+
+        char *c = static_cast<char*>(memchr(buf, '\n', sizeof(buf)));
+        if (c) {
+            if (oversized) {
+                helperfail("messge=\"illegal request received\"");
+                fprintf(stderr, "Illegal request received: '%s'\n", buf);
+                return 1;
+            }
+            *c = '\0';
+        } else {
+            fprintf(stderr, "No newline in '%s'\n", buf);
+            oversized = 1;
+            continue;
+        }
+    } while (false);
+
     if ((strlen(buf) > 3) && NTLM_packet_debug_enabled) {
         decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
         strncpy(helper_command, buf, 2);
         debug("Got '%s' from Squid with data:\n", helper_command);
-        hex_dump(decoded, decodedLen);
+        hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
     } else
         debug("Got '%s' from Squid\n", buf);
     if (memcmp(buf, "YR", 2) == 0) {	/* refresh-request */
         /* figure out what we got */
         if (strlen(buf) > 3)
             decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
         else {
             debug("Negotiate packet not supplied - self generated\n");
-            memcpy(decoded, local_lego, sizeof(local_nego));
-            decodedLen = sizeof(localnego);
+            memcpy(decoded, &local_nego, sizeof(local_nego));
+            decodedLen = sizeof(local_nego);
         }
         if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
-            SEND("NA Packet format error, couldn't base64-decode");
+            SEND_ERR("message=\"Packet format error, couldn't base64-decode\"");
             return 1;
         }
         /* fast-track-decode request type. */
         fast_header = (struct _ntlmhdr *) decoded;
 
         /* sanity-check: it IS a NTLMSSP packet, isn't it? */
         if (ntlm_validate_packet(fast_header, NTLM_ANY) != NTLM_ERR_NONE) {
-            SEND("NA Broken authentication packet");
+            SEND_ERR("message=\"Broken authentication packet\"");
             return 1;
         }
         switch (fast_header->type) {
-        case NTLM_NEGOTIATE:
+        case NTLM_NEGOTIATE: {
             /* Obtain challenge against SSPI */
             debug("attempting SSPI challenge retrieval\n");
-            if ((c = (char *) SSP_MakeChallenge((ntlm_negotiate *) decoded, decodedLen)) != NULL ) {
+            char *c = (char *) SSP_MakeChallenge((ntlm_negotiate *) decoded, decodedLen);
+            if (c) {
+                SEND_TT(c);
                 if (NTLM_packet_debug_enabled) {
-                    printf("TT %s\n",c);
                     decodedLen = base64_decode(decoded, sizeof(decoded), c);
-                    debug("sending 'TT' to squid with data:\n");
-                    hex_dump(decoded, decodedLen);
-                    if (NTLM_LocalCall)
+                    debug("send 'TT' to squid with data:\n");
+                    hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
+                    if (NTLM_LocalCall) {
                         debug("NTLM Local Call detected\n");
-                } else {
-                    SEND2("TT %s", c);
+                    }
                 }
                 have_challenge = 1;
             } else
-                helperfail("can't obtain challenge");
+                helperfail("message=\"can't obtain challenge\"");
 
             return 1;
-            /* notreached */
+        }
+        /* notreached */
         case NTLM_CHALLENGE:
-            SEND("NA Got a challenge. We refuse to have our authority disputed");
+            SEND_ERR("message=\"Got a challenge. We refuse to have our authority disputed\"");
             return 1;
             /* notreached */
         case NTLM_AUTHENTICATE:
-            SEND("NA Got authentication request instead of negotiate request");
+            SEND_ERR("message=\"Got authentication request instead of negotiate request\"");
             return 1;
             /* notreached */
         default:
-            helperfail("unknown refresh-request packet type");
+            helperfail("message=\"unknown refresh-request packet type\"");
             return 1;
         }
         return 1;
     }
     if (memcmp(buf, "KK ", 3) == 0) {	/* authenticate-request */
         if (!have_challenge) {
-            helperfail("invalid challenge");
+            helperfail("message=\"invalid challenge\"");
             return 1;
         }
         /* figure out what we got */
         decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
 
         if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
-            SEND("NA Packet format error, couldn't base64-decode");
+            SEND_ERR("message=\"Packet format error, couldn't base64-decode\"");
             return 1;
         }
         /* fast-track-decode request type. */
         fast_header = (struct _ntlmhdr *) decoded;
 
         /* sanity-check: it IS a NTLMSSP packet, isn't it? */
         if (ntlm_validate_packet(fast_header, NTLM_ANY) != NTLM_ERR_NONE) {
-            SEND("NA Broken authentication packet");
+            SEND_ERR("message=\"Broken authentication packet\"");
             return 1;
         }
         switch (fast_header->type) {
         case NTLM_NEGOTIATE:
-            SEND("NA Invalid negotiation request received");
+            SEND_ERR("message=\"Invalid negotiation request received\"");
             return 1;
             /* notreached */
         case NTLM_CHALLENGE:
-            SEND
-            ("NA Got a challenge. We refuse to have our authority disputed");
+            SEND_ERR("message=\"Got a challenge. We refuse to have our authority disputed\"");
             return 1;
             /* notreached */
-        case NTLM_AUTHENTICATE:
+        case NTLM_AUTHENTICATE: {
             /* check against SSPI */
-            err = ntlm_check_auth((ntlm_authenticate *) decoded, user, domain, decodedLen);
+            int err = ntlm_check_auth((ntlm_authenticate *) decoded, user, domain, decodedLen);
             have_challenge = 0;
             if (err != NTLM_ERR_NONE) {
 #if FAIL_DEBUG
                 fail_debug_enabled =1;
 #endif
-                switch (ntlm_errno) {
+                switch (err) {
                 case NTLM_ERR_NONE:
                     break;
                 case NTLM_BAD_NTGROUP:
-                    SEND("NA Incorrect Group Membership");
+                    SEND_ERR("message=\"Incorrect Group Membership\"");
                     return 1;
                 case NTLM_BAD_REQUEST:
-                    SEND("NA Incorrect Request Format");
+                    SEND_ERR("message=\"Incorrect Request Format\"");
                     return 1;
                 case NTLM_SSPI_ERROR:
                     FormatMessage(
                         FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_SYSTEM |
                         FORMAT_MESSAGE_IGNORE_INSERTS,
@@ -573,34 +572,37 @@
                         0,
                         NULL);
                     if (ErrorMessage[strlen(ErrorMessage) - 1] == '\n')
                         ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
                     if (ErrorMessage[strlen(ErrorMessage) - 1] == '\r')
                         ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
-                    SEND2("NA %s", ErrorMessage);
+                    SEND_ERR(ErrorMessage); // TODO update to new syntax
                     LocalFree(ErrorMessage);
                     return 1;
                 default:
-                    SEND("NA Unknown Error");
+                    SEND_ERR("message=\"Unknown Error\"");
                     return 1;
                 }
             }
             /* let's lowercase them for our convenience */
-            SEND3("AF %s\\%s", lc(domain), lc(user));
+            lc(domain);
+            lc(user);
+            fprintf(stdout, "OK user=\"%s\\%s\"", domain, user);
             return 1;
+        }
         default:
-            helperfail("unknown authentication packet type");
+            helperfail("message=\"unknown authentication packet type\"");
             return 1;
         }
         return 1;
     } else {	/* not an auth-request */
-        helperfail("illegal request received");
+        helperfail("message=\"illegal request received\"");
         fprintf(stderr, "Illegal request received: '%s'\n", buf);
         return 1;
     }
-    helperfail("detected protocol error");
+    helperfail("message=\"detected protocol error\"");
     return 1;
     /********* END ********/
 }
 
 int
 main(int argc, char *argv[])
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/ntlm_auth/SSPI: required.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers: ssl
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers: storeid_rewrite
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/fake: config.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/fake/fake.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/fake/fake.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/fake/fake.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/fake/fake.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,18 +1,40 @@
 /*
- * AUTHOR: Amos Jeffries <squid3@treenet.co.nz>
+ * Copyright (c) 2009-2014, Treehouse Networks Ltd. New Zealand
+ * All rights reserved.
  *
- * Example url re-writer program for Squid.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
  *
- * This code gets the url and returns it. No re-writing is done.
- * It is intended for testing use and as a base for further implementation.
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
  *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Example URL re-writer program for Squid.
  *
- * This code is copyright (C) 2009 by Treehouse Networks Ltd
- * of New Zealand. It is published and Licensed as an extension of
- * squid under the same conditions as the main squid application.
+ * This code gets the url and returns it. No re-writing is done.
+ * It is intended for testing use and as a base for further implementation.
  */
 
 #include "squid.h"
 #include "helpers/defines.h"
 
 #if HAVE_CSTRING
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/fake/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/fake/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/fake/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/fake/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -4,7 +4,7 @@
 url_fake_rewrite_SOURCES = fake.cc
 
 url_fake_rewrite_LDADD = $(COMPAT_LIB)
 
 libexec_SCRIPTS = url_fake_rewrite.sh
 
-EXTRA_DIST = url_fake_rewrite.sh config.test
+EXTRA_DIST = url_fake_rewrite.sh required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/fake/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/fake/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/fake/Makefile.in	2015-05-01 16:51:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/fake/Makefile.in	2015-05-01 18:06:40.000000000 +0800
@@ -92,27 +92,74 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am__installdirs = "$(DESTDIR)$(libexecdir)" "$(DESTDIR)$(libexecdir)"
 PROGRAMS = $(libexec_PROGRAMS)
 am_url_fake_rewrite_OBJECTS = fake.$(OBJEXT)
 url_fake_rewrite_OBJECTS = $(am_url_fake_rewrite_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 url_fake_rewrite_DEPENDENCIES = $(am__DEPENDENCIES_2)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
@@ -437,12 +484,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -480,12 +528,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -512,27 +561,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -598,18 +650,18 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 url_fake_rewrite_SOURCES = fake.cc
 url_fake_rewrite_LDADD = $(COMPAT_LIB)
 libexec_SCRIPTS = url_fake_rewrite.sh
-EXTRA_DIST = url_fake_rewrite.sh config.test
+EXTRA_DIST = url_fake_rewrite.sh required.m4
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/fake: required.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/fake/url_fake_rewrite.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/fake/url_fake_rewrite.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/fake/url_fake_rewrite.sh	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/fake/url_fake_rewrite.sh	2015-05-01 18:05:19.000000000 +0800
@@ -1,14 +1,34 @@
 #!/bin/sh
 #
-# Author: Amos Jeffries <squid3@treenet.co.nz>
+# Copyright (c) 2009-2014, Treehouse Networks Ltd. New Zealand
+# All rights reserved.
 #
-# This code is copyright (C) 2009 by Treehouse Networks Ltd
-# of New Zealand. It is published and Licensed as an extension of
-# squid under the same conditions as the main squid application.
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
 #
+# 1. Redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
 
 if test "${1}" = "-h" ; then
 	echo "Usage: $0 [-h] [-c] [-d logfile]"
 	echo "  -h           Help: this help text"
 	echo "  -c           Accept concurrent request format"
 	echo "  -d logfile   Debug: log all data received to the named file"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/helpers/url_rewrite/Makefile.in	2015-05-01 16:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite/Makefile.in	2015-05-01 18:06:39.000000000 +0800
@@ -84,14 +84,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -234,12 +280,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -277,12 +324,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -309,27 +357,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/helpers/url_rewrite: modules.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/icons/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/icons/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/icons/Makefile.in	2015-05-01 16:51:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/icons/Makefile.in	2015-05-01 18:06:40.000000000 +0800
@@ -86,14 +86,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -206,12 +252,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -249,12 +296,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -281,27 +329,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include: Array.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/autoconf.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/autoconf.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/autoconf.h.in	2015-05-01 16:50:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/autoconf.h.in	2015-05-01 18:06:01.000000000 +0800
@@ -133,12 +133,15 @@
 /* Define to 1 if you have the <climits> header file. */
 #undef HAVE_CLIMITS
 
 /* Define to 1 if you have the `closedir' function. */
 #undef HAVE_CLOSEDIR
 
+/* The system provides struct cmsghdr */
+#undef HAVE_CMSGHDR
+
 /* Define to 1 if you have the <com_err.h> header file. */
 #undef HAVE_COM_ERR_H
 
 /* Define to 1 if CMSG_SPACE is constant */
 #undef HAVE_CONSTANT_CMSG_SPACE
 
@@ -155,21 +158,27 @@
 /* Define to 1 if you have the <crypt.h> header file. */
 #undef HAVE_CRYPT_H
 
 /* Define to 1 if you have the <cstdarg> header file. */
 #undef HAVE_CSTDARG
 
+/* Define to 1 if you have the <cstdio> header file. */
+#undef HAVE_CSTDIO
+
 /* Define to 1 if you have the <cstdlib> header file. */
 #undef HAVE_CSTDLIB
 
 /* Define to 1 if you have the <cstring> header file. */
 #undef HAVE_CSTRING
 
 /* Define to 1 if you have the <ctype.h> header file. */
 #undef HAVE_CTYPE_H
 
+/* define if the compiler supports basic C++11 syntax */
+#undef HAVE_CXX11
+
 /* Define to 1 if you have the <db_185.h> header file. */
 #undef HAVE_DB_185_H
 
 /* Define to 1 if you have the <db.h> header file. */
 #undef HAVE_DB_H
 
@@ -203,12 +212,15 @@
 /* Define to 1 if you have the `drand48' function. */
 #undef HAVE_DRAND48
 
 /* Define if you have the _dyld_func_lookup function. */
 #undef HAVE_DYLD
 
+/* Define to 1 if you have the <endian.h> header file. */
+#undef HAVE_ENDIAN_H
+
 /* Define to 1 if you have the <errno.h> header file. */
 #undef HAVE_ERRNO_H
 
 /* Define to 1 if you have error_message */
 #undef HAVE_ERROR_MESSAGE
 
@@ -317,21 +329,31 @@
 /* Define to 1 if you have the <gssapi/gssapi_krb5.h> header file. */
 #undef HAVE_GSSAPI_GSSAPI_KRB5_H
 
 /* Define to 1 if you have the <gssapi.h> header file. */
 #undef HAVE_GSSAPI_H
 
+/* Define to 1 if you have the `gsskrb5_extract_authz_data_from_sec_context'
+   function. */
+#undef HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT
+
+/* Define to 1 if you have gss_map_name_to_any */
+#undef HAVE_GSS_MAP_ANY_TO_ANY
+
+/* Define to 1 if you have the `gss_map_name_to_any' function. */
+#undef HAVE_GSS_MAP_NAME_TO_ANY
+
 /* Define to 1 if you have Heimdal Kerberos */
 #undef HAVE_HEIMDAL_KERBEROS
 
-/* Define to 1 if you have the `htobe16' function. */
-#undef HAVE_HTOBE16
-
 /* Define to 1 if you have the `htole16' function. */
 #undef HAVE_HTOLE16
 
+/* Define to 1 if you have the `htole32' function. */
+#undef HAVE_HTOLE32
+
 /* Define to 1 if you have the `inet_ntop' function. */
 #undef HAVE_INET_NTOP
 
 /* Define to 1 if you have the `inet_pton' function. */
 #undef HAVE_INET_PTON
 
@@ -350,13 +372,16 @@
 /* Define to 1 if you have the <iosfwd> header file. */
 #undef HAVE_IOSFWD
 
 /* Define to 1 if you have the <iostream> header file. */
 #undef HAVE_IOSTREAM
 
-/* Define to 1 if you have the <Iphlpapi.h> header file. */
+/* The system provides struct iovec */
+#undef HAVE_IOVEC
+
+/* Define to 1 if you have the <iphlpapi.h> header file. */
 #undef HAVE_IPHLPAPI_H
 
 /* Define to 1 if you have the <ipl.h> header file. */
 #undef HAVE_IPL_H
 
 /* Define to 1 if you have the <ip_compat.h> header file. */
@@ -368,39 +393,57 @@
 /* Define to 1 if you have the <ip_fil.h> header file. */
 #undef HAVE_IP_FIL_H
 
 /* Define to 1 if you have the <ip_nat.h> header file. */
 #undef HAVE_IP_NAT_H
 
+/* Define to 1 if you have the <kerberosV/gssapi.h> header file. */
+#undef HAVE_KERBEROSV_GSSAPI_H
+
 /* Define to 1 if you have the `kqueue' function. */
 #undef HAVE_KQUEUE
 
 /* KRB5 support */
 #undef HAVE_KRB5
 
 /* Define to 1 if you have krb5_get_error_message */
 #undef HAVE_KRB5_GET_ERROR_MESSAGE
 
 /* Define to 1 if you have krb5_get_err_text */
 #undef HAVE_KRB5_GET_ERR_TEXT
 
+/* Define to 1 if you krb5_get_init_creds_free requires krb5_context */
+#undef HAVE_KRB5_GET_INIT_CREDS_FREE_CONTEXT
+
+/* Define to 1 if you have krb5_get_init_creds_opt_alloc */
+#undef HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC
+
 /* Define to 1 if you have krb5_get_max_time_skew */
 #undef HAVE_KRB5_GET_MAX_TIME_SKEW
 
 /* Define to 1 if you have krb5_get_profile */
 #undef HAVE_KRB5_GET_PROFILE
 
+/* Define to 1 if you have krb5_get_renewed_creds */
+#undef HAVE_KRB5_GET_RENEWED_CREDS
+
 /* Define to 1 if you have the <krb5.h> header file. */
 #undef HAVE_KRB5_H
 
 /* Define to 1 if you have krb5_kt_free_entry */
 #undef HAVE_KRB5_KT_FREE_ENTRY
 
 /* Define if kerberos has MEMORY: cache support */
 #undef HAVE_KRB5_MEMORY_CACHE
 
+/* Define to 1 if you have krb5_pac */
+#undef HAVE_KRB5_PAC
+
+/* Define to 1 if you have krb5_principal_get_realm */
+#undef HAVE_KRB5_PRINCIPAL_GET_REALM
+
 /* Define to 1 if you have the <lber.h> header file. */
 #undef HAVE_LBER_H
 
 /* LDAP support */
 #undef HAVE_LDAP
 
@@ -431,12 +474,18 @@
 /* Define to 1 if you have LDAPURLDesc.lud_scheme */
 #undef HAVE_LDAP_URL_LUD_SCHEME
 
 /* Define to 1 if you have ldap_url_parse */
 #undef HAVE_LDAP_URL_PARSE
 
+/* Define to 1 if you have the `le16toh' function. */
+#undef HAVE_LE16TOH
+
+/* Define to 1 if you have the `le32toh' function. */
+#undef HAVE_LE32TOH
+
 /* Define to 1 if you have the `cap' library (-lcap). */
 #undef HAVE_LIBCAP
 
 /* Define to 1 if you have the <libc.h> header file. */
 #undef HAVE_LIBC_H
 
@@ -484,12 +533,16 @@
 /* Define to 1 if you have the <limits.h> header file. */
 #undef HAVE_LIMITS_H
 
 /* Define to 1 if you have the <linux/netfilter_ipv4.h> header file. */
 #undef HAVE_LINUX_NETFILTER_IPV4_H
 
+/* Define to 1 if you have the <linux/netfilter_ipv6/ip6_tables.h> header
+   file. */
+#undef HAVE_LINUX_NETFILTER_IPV6_IP6_TABLES_H
+
 /* Define to 1 if you have the <linux/posix_types.h> header file. */
 #undef HAVE_LINUX_POSIX_TYPES_H
 
 /* Define to 1 if you have the <linux/types.h> header file. */
 #undef HAVE_LINUX_TYPES_H
 
@@ -562,12 +615,15 @@
 /* Mozilla LDAP SDK support */
 #undef HAVE_MOZILLA_LDAP_SDK
 
 /* Define to 1 if you have the <mozldap/ldap.h> header file. */
 #undef HAVE_MOZLDAP_LDAP_H
 
+/* The system provides struct msghdr */
+#undef HAVE_MSGHDR
+
 /* Define to 1 if you have the `mstats' function. */
 #undef HAVE_MSTATS
 
 /* mtyp_t is defined by the system headers */
 #undef HAVE_MTYP_T
 
@@ -613,12 +669,15 @@
 /* Define to 1 if you have the <netinet/ip_nat.h> header file. */
 #undef HAVE_NETINET_IP_NAT_H
 
 /* Define to 1 if you have the <netinet/tcp.h> header file. */
 #undef HAVE_NETINET_TCP_H
 
+/* Define to 1 if you have the <nettle/md5.h> header file. */
+#undef HAVE_NETTLE_MD5_H
+
 /* Define to 1 if you have the <net/if_arp.h> header file. */
 #undef HAVE_NET_IF_ARP_H
 
 /* Define to 1 if you have the <net/if_dl.h> header file. */
 #undef HAVE_NET_IF_DL_H
 
@@ -742,24 +801,27 @@
 /* Define to 1 if you have the `res_init' function. */
 #undef HAVE_RES_INIT
 
 /* Define to 1 if you have the `rint' function. */
 #undef HAVE_RINT
 
+/* Define to 1 if you have the <rpcsvc/yp_prot.h> header file. */
+#undef HAVE_RPCSVC_YP_PROT_H
+
+/* Define to 1 if you have the <rpc/rpc.h> header file. */
+#undef HAVE_RPC_RPC_H
+
 /* Define to 1 if Mac Darwin without sasl.h */
 #undef HAVE_SASL_DARWIN
 
 /* Define to 1 if you have the <sasl.h> header file. */
 #undef HAVE_SASL_H
 
 /* Define to 1 if you have the <sasl/sasl.h> header file. */
 #undef HAVE_SASL_SASL_H
 
-/* Define to 1 if you have the `sbrk' function. */
-#undef HAVE_SBRK
-
 /* Define to 1 if you have the `sched_getaffinity' function. */
 #undef HAVE_SCHED_GETAFFINITY
 
 /* Define to 1 if you have the <sched.h> header file. */
 #undef HAVE_SCHED_H
 
@@ -816,12 +878,15 @@
 /* Define if sockaddr_in has field sin_len */
 #undef HAVE_SIN_LEN_IN_SAI
 
 /* Define to 1 if you have the `snprintf' function. */
 #undef HAVE_SNPRINTF
 
+/* The system provides sockaddr_un */
+#undef HAVE_SOCKADDR_UN
+
 /* Define to 1 if you have the `socketpair' function. */
 #undef HAVE_SOCKETPAIR
 
 /* socklen_t is defined by the system headers */
 #undef HAVE_SOCKLEN_T
 
@@ -849,15 +914,12 @@
 /* Define to 1 if you have the <stdarg.h> header file. */
 #undef HAVE_STDARG_H
 
 /* Define to 1 if you have the <stdbool.h> header file. */
 #undef HAVE_STDBOOL_H
 
-/* Define if g++ supports C++0x features. */
-#undef HAVE_STDCXX_0X
-
 /* Define to 1 if you have the <stddef.h> header file. */
 #undef HAVE_STDDEF_H
 
 /* Define to 1 if you have the <stdexcept> header file. */
 #undef HAVE_STDEXCEPT
 
@@ -888,15 +950,12 @@
 /* Define to 1 if you have the `strlcpy' function. */
 #undef HAVE_STRLCPY
 
 /* MacOS brokenness: strnstr() can overrun on that system */
 #undef HAVE_STRNSTR
 
-/* Define to 1 if you have the `strsep' function. */
-#undef HAVE_STRSEP
-
 /* Define to 1 if you have the `strtoll' function. */
 #undef HAVE_STRTOLL
 
 /* Define to 1 if `ip_hl' is a member of `struct iphdr'. */
 #undef HAVE_STRUCT_IPHDR_IP_HL
 
@@ -955,15 +1014,21 @@
 /* Define to 1 if you have the <sys/event.h> header file. */
 #undef HAVE_SYS_EVENT_H
 
 /* Define to 1 if you have the <sys/file.h> header file. */
 #undef HAVE_SYS_FILE_H
 
+/* Define to 1 if you have the <sys/ioccom.h> header file. */
+#undef HAVE_SYS_IOCCOM_H
+
 /* Define to 1 if you have the <sys/ioctl.h> header file. */
 #undef HAVE_SYS_IOCTL_H
 
+/* Define to 1 if you have the <sys/ipc.cc> header file. */
+#undef HAVE_SYS_IPC_CC
+
 /* Define to 1 if you have the <sys/md5.h> header file. */
 #undef HAVE_SYS_MD5_H
 
 /* Define to 1 if you have the <sys/mman.h> header file. */
 #undef HAVE_SYS_MMAN_H
 
@@ -986,12 +1051,15 @@
 /* Define to 1 if you have the <sys/resource.h> header file. */
 #undef HAVE_SYS_RESOURCE_H
 
 /* Define to 1 if you have the <sys/select.h> header file. */
 #undef HAVE_SYS_SELECT_H
 
+/* Define to 1 if you have the <sys/shm.h> header file. */
+#undef HAVE_SYS_SHM_H
+
 /* Define to 1 if you have the <sys/socket.h> header file. */
 #undef HAVE_SYS_SOCKET_H
 
 /* Define to 1 if you have the <sys/sockio.h> header file. */
 #undef HAVE_SYS_SOCKIO_H
 
@@ -1055,24 +1123,33 @@
 /* Define to 1 if you have the <varargs.h> header file. */
 #undef HAVE_VARARGS_H
 
 /* The system implements a functional va_copy() */
 #undef HAVE_VA_COPY
 
+/* Define to 1 if you have the `vfork' function. */
+#undef HAVE_VFORK
+
 /* Define to 1 if you have the `vsnprintf' function. */
 #undef HAVE_VSNPRINTF
 
+/* Define to 1 if you have the <w32api/windows.h> header file. */
+#undef HAVE_W32API_WINDOWS_H
+
 /* Define to 1 if you have the <wchar.h> header file. */
 #undef HAVE_WCHAR_H
 
 /* Define if you have PSAPI.DLL on Windows systems */
 #undef HAVE_WIN32_PSAPI
 
 /* Define to 1 if you have the <windows.h> header file. */
 #undef HAVE_WINDOWS_H
 
+/* Define to 1 if you have the <winldap.h> header file. */
+#undef HAVE_WINLDAP_H
+
 /* Define to 1 if you have the <winsock2.h> header file. */
 #undef HAVE_WINSOCK2_H
 
 /* Define to 1 if you have the <winsock.h> header file. */
 #undef HAVE_WINSOCK_H
 
@@ -1082,12 +1159,24 @@
 /* Define to 1 if you have the `write' function. */
 #undef HAVE_WRITE
 
 /* Define to 1 if you have the <ws2tcpip.h> header file. */
 #undef HAVE_WS2TCPIP_H
 
+/* Define to 1 if you have the `__htole16' function. */
+#undef HAVE___HTOLE16
+
+/* Define to 1 if you have the `__htole32' function. */
+#undef HAVE___HTOLE32
+
+/* Define to 1 if you have the `__le16toh' function. */
+#undef HAVE___LE16TOH
+
+/* Define to 1 if you have the `__le32toh' function. */
+#undef HAVE___LE32TOH
+
 /* Define to 1 if you have the `__res_init' function. */
 #undef HAVE___RES_INIT
 
 /* Some systems have __va_copy instead of va_copy */
 #undef HAVE___VA_COPY
 
@@ -1181,12 +1270,15 @@
 /* Print stack traces on fatal errors */
 #undef PRINT_STACK_TRACE
 
 /* Compiler supports %zu printf macro */
 #undef PRIuSIZE
 
+/* Base type of the second argument to recv(2) */
+#undef RECV_ARG_TYPE
+
 /* The size of `int64_t', as computed by sizeof. */
 #undef SIZEOF_INT64_T
 
 /* The size of `long', as computed by sizeof. */
 #undef SIZEOF_LONG
 
@@ -1338,16 +1430,14 @@
 /* Enable support for QOS netfilter mark preservation */
 #undef USE_LIBNETFILTERCONNTRACK
 
 /* Support Loadable Modules */
 #undef USE_LOADABLE_MODULES
 
-/* Define this to make use of the OpenSSL libraries for MD5 calculation rather
-   than Squid-supplied MD5 implementation or if building with SSL encryption
-   */
-#undef USE_OPENSSL
+/* Enable support for /dev/pf NAT lookups */
+#undef USE_NAT_DEVPF
 
 /* Use poll() for the IO loop */
 #undef USE_POLL
 
 /* Enable Zero Penalty Hit QOS. When set, Squid will alter the TOS field of
    HIT responses to help policing network traffic */
@@ -1356,12 +1446,15 @@
 /* Use select() for the IO loop */
 #undef USE_SELECT
 
 /* Use Winsock select() for the IO loop */
 #undef USE_SELECT_WIN32
 
+/* Workaround IPFilter minor_t breakage */
+#undef USE_SOLARIS_IPFILTER_MINOR_T_HACK
+
 /* Compile the ESI processor and Surrogate header support */
 #undef USE_SQUID_ESI
 
 /* Define this to include code which lets you use ethernet addresses. This
    code uses API initially defined in 4.4-BSD. */
 #undef USE_SQUID_EUI
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/cache_snmp.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/cache_snmp.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/cache_snmp.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/cache_snmp.h	2015-05-01 18:05:19.000000000 +0800
@@ -8,19 +8,14 @@
 #ifndef MIN
 #define MIN(a,b) (a<b?a:b)
 #endif
 
 #include "snmp.h"
 #include "snmp_impl.h"
-#if 0
-#include "asn1.h"
-#endif
 #include "snmp_api.h"
 
-#include "snmp_vars.h"
-
 /* MIB definitions
  * SQUID-MIB
  *      .iso.org.dod.internet.private.enterprises.nlanr.squid
  *        1   3   6     1        4         1      3495    1
  *
  * PROXY-MIB
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/CbDataList.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/CbDataList.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/CbDataList.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/CbDataList.h	2015-05-01 18:05:19.000000000 +0800
@@ -36,14 +36,12 @@
 /// \ingroup POD
 template <class C>
 class CbDataList
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
     CbDataList (C const &);
     ~CbDataList();
 
     /// If element is already in the list, returns false.
     /// Otherwise, adds the element to the end of the list and returns true.
     /// Exists to avoid double iteration of find() and push() combo.
@@ -54,13 +52,13 @@
     CbDataList *tail();
     CbDataList *next;
     C element;
     bool empty() const { return this == NULL; }
 
 private:
-    CBDATA_CLASS(CbDataList);
+    CBDATA_CLASS2(CbDataList);
 };
 
 /// \ingroup POD
 template<class C>
 class CbDataListContainer
 {
@@ -100,30 +98,12 @@
 /** \cond AUTODOCS-IGNORE */
 template <class C>
 cbdata_type CbDataList<C>::CBDATA_CbDataList = CBDATA_UNKNOWN;
 /** \endcond */
 
 template <class C>
-void *
-CbDataList<C>::operator new (size_t byteCount)
-{
-    CBDATA_INIT_TYPE(CbDataList);
-
-    CbDataList<C> *result = cbdataAlloc(CbDataList);
-
-    return result;
-}
-
-template <class C>
-void
-CbDataList<C>::operator delete (void *address)
-{
-    cbdataFree(address);
-}
-
-template <class C>
 CbDataList<C>::CbDataList(C const &value) : next(NULL), element (value)
 {}
 
 template <class C>
 CbDataList<C>::~CbDataList()
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/heap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/heap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/heap.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/heap.h	2015-05-01 18:05:19.000000000 +0800
@@ -155,13 +155,13 @@
  */
 #ifdef	MACRO_DEBUG
 SQUIDCEXTERN int heap_empty(heap *);
 SQUIDCEXTERN int heap_nodes(heap *);
 #else /* MACRO_DEBUG */
 #define	heap_nodes(heap)	((heap)->last)
-#define	heap_empty(heap)	(((heap)->last <= 0) ? 1 : 0)
+#define	heap_empty(heap)	((heap)->last <= 0 ? 1 : 0)
 #endif /* MACRO_DEBUG */
 
 /*
  * Print the heap or a node in the heap.
  */
 SQUIDCEXTERN void heap_print(heap *);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/md5.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/md5.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/md5.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/md5.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,9 +1,21 @@
 #ifndef SQUID_MD5_H
 #define SQUID_MD5_H
 
+#if HAVE_NETTLE_MD5_H
+#include <nettle/md5.h>
+
+typedef struct md5_ctx SquidMD5_CTX;
+
+#define SquidMD5Init(c)       md5_init((c))
+#define SquidMD5Update(c,b,l) md5_update((c), (l), (const uint8_t *)(b))
+#define SquidMD5Final(d,c)    md5_digest((c), MD5_DIGEST_SIZE, (uint8_t *)(d))
+
+#define SQUID_MD5_DIGEST_LENGTH MD5_DIGEST_SIZE
+
+#else
 /*
  * This is the header file for the MD5 message-digest algorithm.
  * The algorithm is due to Ron Rivest.  This code was
  * written by Colin Plumb in 1993, no copyright is claimed.
  * This code is in the public domain; do with it what you wish.
  *
@@ -42,7 +54,9 @@
 SQUIDCEXTERN void SquidMD5Update(struct SquidMD5Context *context, const void *buf, unsigned len);
 SQUIDCEXTERN void SquidMD5Final(uint8_t digest[16], struct SquidMD5Context *context);
 SQUIDCEXTERN void SquidMD5Transform(uint32_t buf[4], uint32_t const in[16]);
 
 #define SQUID_MD5_DIGEST_LENGTH         16
 
+#endif /* HAVE_NETTLE_MD5_H */
+
 #endif /* SQUID_MD5_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/MemPool.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/MemPool.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/MemPool.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/MemPool.h	2015-05-01 18:05:19.000000000 +0800
@@ -201,13 +201,13 @@
      */
     virtual void freeOne(void *) = 0;
 
     virtual char const *objectType() const;
     virtual size_t objectSize() const = 0;
     virtual int getInUseCount() = 0;
-    void zeroOnPush(bool doIt);
+    void zeroBlocks(bool doIt) {doZero = doIt;}
     int inUseCount();
 
     /**
      * Allows you tune chunk size of pooling. Objects are allocated in chunks
      * instead of individually. This conserves memory, reduces fragmentation.
      * Because of that memory can be freed also only in chunks. Therefore
@@ -223,13 +223,19 @@
      \param minSize	Minimum size needed to be allocated.
      \retval n Smallest size divisible by sizeof(void*)
      */
     static size_t RoundedSize(size_t minSize);
 
 protected:
-    bool doZeroOnPush;
+    /** Whether to zero memory on initial allocation and on return to the pool.
+     *
+     * We do this on some pools because many object constructors are/were incomplete
+     * and we are afraid some code may use the object after free.
+     * These probems are becoming less common, so when possible set this to false.
+     */
+    bool doZero;
 
 private:
     const char *label;
 };
 
 /**
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include: RefCount.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/rfc1123.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/rfc1123.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/rfc1123.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/rfc1123.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,8 +1,8 @@
 #ifndef _SQUID_RFC1123_H
-#define _SQUID_RFC1123_
+#define _SQUID_RFC1123_H
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
     extern const char *mkhttpdlogtime(const time_t *);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/snmp_api_util.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/snmp_api_util.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/snmp_api_util.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/snmp_api_util.h	2015-05-01 18:05:19.000000000 +0800
@@ -54,13 +54,13 @@
     struct snmp_session *session;
     struct snmp_internal_session *internal;
 };
 
 struct snmp_internal_session {
     int sd;			/* socket descriptor for this connection */
-    ipaddr addr;		/* address of connected peer */
+    struct sockaddr_in addr;		/* address of connected peer */
     struct request_list *requests;	/* Info about outstanding requests */
 };
 
 /* Define these here, as they aren't defined normall under
  * cygnus Win32 stuff.
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/snmp.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/snmp.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/snmp.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/snmp.h	2015-05-01 18:05:19.000000000 +0800
@@ -34,21 +34,13 @@
 #endif
 #if HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
 
 /* These come first */
-#if 0
-#include "asn1.h"
-#endif
 #include "snmp_error.h"
-#if 0
-#include "mibii.h"
-#include "snmp_extra.h"
-#include "snmp_dump.h"
-#endif
 
 /* I didn't touch this */
 #include "snmp_session.h"
 
 /* The various modules */
 #include "snmp_vars.h"
@@ -60,15 +52,11 @@
 #include "version.h"
 #include "snmp_error.h"
 #include "snmp_api_error.h"
 /* Other stuff I didn't touch */
 #include "snmp_impl.h"
 #include "snmp_api.h"
-#if 0
-#include "snmp_client.h"
-#include "mib.h"
-#endif
 #include "snmp-internal.h"
 #include "parse.h"
 #include "snmp_debug.h"
 
 #endif /* SQUID_SNMP_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/snmp_pdu.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/snmp_pdu.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/snmp_pdu.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/snmp_pdu.h	2015-05-01 18:05:19.000000000 +0800
@@ -36,18 +36,16 @@
  **********************************************************************/
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-    typedef struct sockaddr_in ipaddr;
-
     /* An SNMP PDU */
     struct snmp_pdu {
         int command;		/* Type of this PDU */
-        ipaddr address;		/* Address of peer */
+        struct sockaddr_in address;		/* Address of peer */
 
         int reqid;			/* Integer32: Request id */
         int errstat;		/* INTEGER:   Error status */
         int errindex;		/* INTEGER:   Error index */
 
         /* SNMPv2 Bulk Request */
@@ -56,13 +54,13 @@
 
         struct variable_list *variables;	/* Variable Bindings */
 
         /* Trap information */
         oid *enterprise;		/* System OID */
         int enterprise_length;
-        ipaddr agent_addr;		/* address of object generating trap */
+        struct sockaddr_in agent_addr;		/* address of object generating trap */
         int trap_type;		/* generic trap type */
         int specific_type;		/* specific type */
         u_int time;			/* Uptime */
     };
 
     struct snmp_pdu *snmp_pdu_create(int);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/splay.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/splay.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/splay.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/splay.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,10 @@
 #ifndef SQUID_SPLAY_H
 #define SQUID_SPLAY_H
 
-#ifndef __cplusplus
-#else
+#if defined(__cplusplus)
 
 #include "Stack.h"
 
 template <class V>
 class SplayNode
 {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include: squid_endian.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/squid.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/squid.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/squid.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/squid.h	2015-05-01 18:05:19.000000000 +0800
@@ -100,25 +100,21 @@
 #define squid_srandom srand
 #endif
 
 /*
  * Determine if this is a leak check build or standard
  */
-#if PURIFY
-#define LEAK_CHECK_MODE 1
-#elif WITH_VALGRIND
-#define LEAK_CHECK_MODE 1
-#elif XMALLOC_TRACE
+#if PURIFY || WITH_VALGRIND
 #define LEAK_CHECK_MODE 1
 #endif
 
 /* temp hack: needs to be pre-defined for now. */
 #define SQUID_MAXPATHLEN 256
 
-// TODO: determine if this is required. OR if compat/os/mswin.h works
-#if _SQUID_WINDOWS_
+// TODO: determine if this is required. OR if compat/os/mswindows.h works
+#if _SQUID_WINDOWS_ && defined(__cplusplus)
 /** \cond AUTODOCS-IGNORE */
 using namespace Squid;
 /** \endcond */
 #endif
 
 // temporary for the definition of LOCAL_ARRAY
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/SquidNew.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/SquidNew.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/SquidNew.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/SquidNew.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,13 +28,13 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 #ifndef SQUID_NEW_H
 #define SQUID_NEW_H
 
-#ifndef __SUNPRO_CC
+#if !defined(__SUNPRO_CC) && !defined(__clang__)
 /* Any code using libstdc++ must have externally resolvable overloads
  * for void * operator new - which means in the .o for the binary,
  * or in a shared library. static libs don't propogate the symbol
  * so, look in the translation unit containing main() in squid
  * for the extern version in squid
  */
@@ -54,9 +54,9 @@
 }
 _SQUID_EXTERNNEW_ void operator delete[] (void *address) throw()
 {
     xfree(address);
 }
 
-#endif /* __SUNPRO_CC */
+#endif /* !__SUNPRO_CC && !__clang__*/
 
 #endif /* SQUID_NEW_H */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include: squid_windows.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/sspwin32.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/sspwin32.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/sspwin32.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/sspwin32.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,12 +31,16 @@
  */
 #ifndef _LIBSSPWIN32_H_
 #define _LIBSSPWIN32_H_
 
 #if _SQUID_WINDOWS_
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define SECURITY_WIN32
 #define NTLM_PACKAGE_NAME "NTLM"
 #define NEGOTIATE_PACKAGE_NAME "Negotiate"
 
 #if _SQUID_CYGWIN_
 #include <wchar.h>
@@ -46,13 +50,13 @@
 #endif
 #include <windows.h>
 #include <ntsecapi.h>
 #include <security.h>
 #include <sspi.h>
 
-typedef char * SSP_blobP;
+    typedef char * SSP_blobP;
 
 #define WINNT_SECURITY_DLL "security.dll"
 #define WIN2K_SECURITY_DLL "secur32.dll"
 
 #define SSP_BASIC 1
 #define SSP_NTLM 2
@@ -61,19 +65,23 @@
 
 #define SSP_DEBUG 0
 
 #define SSP_OK 1
 #define SSP_ERROR 2
 
-HMODULE LoadSecurityDll(int, char *);
-void UnloadSecurityDll(void);
-BOOL WINAPI SSP_LogonUser(PTSTR, PTSTR, PTSTR);
-BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID, int, char *);
-const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID, int, PBOOL, int *, char *);
-const char * WINAPI SSP_MakeChallenge(PVOID, int);
-const char * WINAPI SSP_MakeNegotiateBlob(PVOID, int, PBOOL, int *, char *);
+    HMODULE LoadSecurityDll(int, const char *);
+    void UnloadSecurityDll(void);
+    BOOL WINAPI SSP_LogonUser(PTSTR, PTSTR, PTSTR);
+    BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID, int, char *);
+    const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID, int, PBOOL, int *, char *);
+    const char * WINAPI SSP_MakeChallenge(PVOID, int);
+    const char * WINAPI SSP_MakeNegotiateBlob(PVOID, int, PBOOL, int *, char *);
 
-extern BOOL Use_Unicode;
-extern BOOL NTLM_LocalCall;
+    extern BOOL Use_Unicode;
+    extern BOOL NTLM_LocalCall;
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* _SQUID_WINDOWS_ */
 #endif /* LIBSSPWIN32_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/Stack.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/Stack.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/Stack.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/Stack.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,13 +29,13 @@
  *
  */
 
 #ifndef SQUID_STACK_H
 #define SQUID_STACK_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* RBC: 20030714 Composition might be better long-term, but for now,
  * there's no reason to do so.
  */
 
 template <class S = void *>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/util.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/util.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/util.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/util.h	2015-05-01 18:05:19.000000000 +0800
@@ -60,26 +60,12 @@
 #define _SQUID_EXTERNNEW_ extern inline
 #endif
 #endif
 #include "SquidNew.h"
 #endif
 
-#if XMALLOC_TRACE
-#define xmalloc(size) (xmalloc_func="xmalloc",xmalloc_line=__LINE__,xmalloc_file=__FILE__,xmalloc(size))
-#define xfree(ptr) (xmalloc_func="xfree",xmalloc_line=__LINE__,xmalloc_file=__FILE__,xfree(ptr))
-#define xrealloc(ptr,size) (xmalloc_func="xrealloc",xmalloc_line=__LINE__,xmalloc_file=__FILE__,xrealloc(ptr,size))
-#define xcalloc(n,size) (xmalloc_func="xcalloc",xmalloc_line=__LINE__,xmalloc_file=__FILE__,xcalloc(n,size))
-#define xstrdup(ptr) (xmalloc_func="xstrdup",xmalloc_line=__LINE__,xmalloc_file=__FILE__,xstrdup(ptr))
-extern int xmalloc_line;
-extern char *xmalloc_file;
-extern char *xmalloc_func;
-extern int xmalloc_trace;
-extern size_t xmalloc_total;
-extern void xmalloc_find_leaks(void);
-#endif
-
 SQUIDCEXTERN time_t parse_iso3307_time(const char *buf);
 
 SQUIDCEXTERN double xpercent(double part, double whole);
 SQUIDCEXTERN int xpercentInt(double part, double whole);
 SQUIDCEXTERN double xdiv(double nom, double denom);
 
@@ -106,28 +92,7 @@
  * Returns the amount of known allocated memory
  */
 int statMemoryAccounted(void);
 
 SQUIDCEXTERN unsigned int RoundTo(const unsigned int num, const unsigned int what);
 
-/* Windows Port */
-/* win32lib.c */
-#if _SQUID_WINDOWS_
-SQUIDCEXTERN int chroot (const char *);
-#if !HAVE_GETTIMEOFDAY
-SQUIDCEXTERN int gettimeofday(struct timeval * ,void *);
-#endif
-SQUIDCEXTERN int kill(pid_t, int);
-SQUIDCEXTERN int statfs(const char *, struct statfs *);
-SQUIDCEXTERN struct passwd *getpwnam(char *);
-SQUIDCEXTERN struct group *getgrnam(char *);
-SQUIDCEXTERN uid_t geteuid(void);
-SQUIDCEXTERN uid_t getuid(void);
-SQUIDCEXTERN int setuid(uid_t);
-SQUIDCEXTERN int seteuid(uid_t);
-SQUIDCEXTERN gid_t getgid(void);
-SQUIDCEXTERN gid_t getegid(void);
-SQUIDCEXTERN int setgid(gid_t);
-SQUIDCEXTERN int setegid(gid_t);
-SQUIDCEXTERN void WIN32_maperror(unsigned long);
-#endif
 #endif /* SQUID_UTIL_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/uudecode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/uudecode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/uudecode.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/uudecode.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,8 +1,8 @@
 #ifndef _SQUID_UUDECODE_H
-#define _SQUID_UUDECODE_
+#define _SQUID_UUDECODE_H
 
 #ifdef __cplusplus
 extern "C"
 #else
 extern
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/include/version.h	2015-05-01 16:52:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/include/version.h	2015-05-01 18:07:11.000000000 +0800
@@ -4,13 +4,13 @@
 
 /*
  * SQUID_VERSION is now the automake "VERSION" string.
  */
 
 #ifndef SQUID_RELEASE_TIME
-#define SQUID_RELEASE_TIME 1430470192
+#define SQUID_RELEASE_TIME 1430474712
 #endif
 
 #ifndef APP_SHORTNAME
 #define APP_SHORTNAME "squid"
 #endif
 #ifndef APP_FULLNAME
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie: acinclude.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie: aclocal.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie: cfgaux
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie: config.h.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie: configure
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie: configure.ac
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie: include
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,5 +1,17 @@
-## Process this file with automake to produce Makefile.in
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
 
-AUTOMAKE_OPTIONS = dist-bzip2 subdir-objects 1.5
-DIST_SUBDIRS = include src test
-SUBDIRS = src test
+DIST_SUBDIRS = test
+SUBDIRS = test
+
+noinst_LIBRARIES = libTrie.a
+
+noinst_HEADERS = Trie.h TrieNode.h TrieCharTransform.h
+
+libTrie_a_SOURCES = Trie.cc \
+	Trie.cci \
+	Trie.h \
+	TrieNode.cc \
+	TrieNode.cci \
+	TrieNode.h \
+	TrieCharTransform.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/Makefile.in	2015-05-01 16:52:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/Makefile.in	2015-05-01 18:06:41.000000000 +0800
@@ -74,47 +76,151 @@
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
-subdir = .
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/configure $(am__configure_deps) \
-	$(srcdir)/config.h.in AUTHORS COPYING ChangeLog INSTALL NEWS \
-	README cfgaux/compile cfgaux/config.guess cfgaux/config.sub \
-	cfgaux/install-sh cfgaux/missing cfgaux/ltmain.sh \
-	$(top_srcdir)/cfgaux/compile $(top_srcdir)/cfgaux/config.guess \
-	$(top_srcdir)/cfgaux/config.sub \
-	$(top_srcdir)/cfgaux/install-sh $(top_srcdir)/cfgaux/ltmain.sh \
-	$(top_srcdir)/cfgaux/missing
+DIST_COMMON = $(top_srcdir)/src/Common.am \
+	$(top_srcdir)/src/TestHeaders.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/cfgaux/depcomp \
+	$(noinst_HEADERS) $(top_srcdir)/cfgaux/test-driver AUTHORS \
+	COPYING ChangeLog INSTALL NEWS README
+check_PROGRAMS =
+@USE_LOADABLE_MODULES_TRUE@am__append_1 = $(INCLTDL)
+subdir = lib/libTrie
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/acinclude/init.m4 \
+	$(top_srcdir)/acinclude/squid-util.m4 \
+	$(top_srcdir)/acinclude/compiler-flags.m4 \
+	$(top_srcdir)/acinclude/os-deps.m4 \
+	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
+	$(top_srcdir)/acinclude/pkg.m4 \
+	$(top_srcdir)/acinclude/lib-checks.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
- configure.lineno config.status.lineno
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = config.h
+CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+AM_V_AR = $(am__v_AR_@AM_V@)
+am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
+am__v_AR_0 = @echo "  AR      " $@;
+am__v_AR_1 = 
+libTrie_a_AR = $(AR) $(ARFLAGS)
+libTrie_a_LIBADD =
+am_libTrie_a_OBJECTS = Trie.$(OBJEXT) TrieNode.$(OBJEXT)
+libTrie_a_OBJECTS = $(am_libTrie_a_OBJECTS)
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
 am__v_P_0 = false
 am__v_P_1 = :
 AM_V_GEN = $(am__v_GEN_@AM_V@)
 am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
 am__v_GEN_0 = @echo "  GEN     " $@;
 am__v_GEN_1 = 
 AM_V_at = $(am__v_at_@AM_V@)
 am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
 am__v_at_0 = @
 am__v_at_1 = 
-SOURCES =
-DIST_SOURCES =
+DEFAULT_INCLUDES = 
+depcomp = $(SHELL) $(top_srcdir)/cfgaux/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_CXX = $(am__v_CXX_@AM_V@)
+am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
+am__v_CXX_0 = @echo "  CXX     " $@;
+am__v_CXX_1 = 
+CXXLD = $(CXX)
+CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
+	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
+am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
+am__v_CXXLD_0 = @echo "  CXXLD   " $@;
+am__v_CXXLD_1 = 
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(libTrie_a_SOURCES)
+DIST_SOURCES = $(libTrie_a_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
 	ctags-recursive dvi-recursive html-recursive info-recursive \
 	install-data-recursive install-dvi-recursive \
 	install-exec-recursive install-html-recursive \
 	install-info-recursive install-pdf-recursive \
 	install-ps-recursive install-recursive installcheck-recursive \
@@ -122,22 +228,22 @@
 	tags-recursive uninstall-recursive
 am__can_run_installinfo = \
   case $$AM_UPDATE_INFO_DIR in \
     n|no|NO) false;; \
     *) (install-info --version) >/dev/null 2>&1;; \
   esac
+HEADERS = $(noinst_HEADERS)
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
 am__recursive_targets = \
   $(RECURSIVE_TARGETS) \
   $(RECURSIVE_CLEAN_TARGETS) \
   $(am__extra_recursive_targets)
 AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
-	cscope distdir dist dist-all distcheck
-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) \
-	$(LISP)config.h.in
+	check recheck distdir
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
 # Read a list of newline-separated strings from the standard input,
 # and print each of them once, without duplicates.  Input order is
 # *not* preserved.
 am__uniquify_input = $(AWK) '\
   BEGIN { nonempty = 0; } \
   { items[$$0] = 1; nonempty = 1; } \
@@ -150,23 +256,216 @@
   list='$(am__tagged_files)'; \
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
-CSCOPE = cscope
+am__tty_colors_dummy = \
+  mgn= red= grn= lgn= blu= brg= std=; \
+  am__color_tests=no
+am__tty_colors = { \
+  $(am__tty_colors_dummy); \
+  if test "X$(AM_COLOR_TESTS)" = Xno; then \
+    am__color_tests=no; \
+  elif test "X$(AM_COLOR_TESTS)" = Xalways; then \
+    am__color_tests=yes; \
+  elif test "X$$TERM" != Xdumb && { test -t 1; } 2>/dev/null; then \
+    am__color_tests=yes; \
+  fi; \
+  if test $$am__color_tests = yes; then \
+    red='[0;31m'; \
+    grn='[0;32m'; \
+    lgn='[1;32m'; \
+    blu='[1;34m'; \
+    mgn='[0;35m'; \
+    brg='[1m'; \
+    std='[m'; \
+  fi; \
+}
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__recheck_rx = ^[ 	]*:recheck:[ 	]*
+am__global_test_result_rx = ^[ 	]*:global-test-result:[ 	]*
+am__copy_in_global_log_rx = ^[ 	]*:copy-in-global-log:[ 	]*
+# A command that, given a newline-separated list of test names on the
+# standard input, print the name of the tests that are to be re-run
+# upon "make recheck".
+am__list_recheck_tests = $(AWK) '{ \
+  recheck = 1; \
+  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
+    { \
+      if (rc < 0) \
+        { \
+          if ((getline line2 < ($$0 ".log")) < 0) \
+	    recheck = 0; \
+          break; \
+        } \
+      else if (line ~ /$(am__recheck_rx)[nN][Oo]/) \
+        { \
+          recheck = 0; \
+          break; \
+        } \
+      else if (line ~ /$(am__recheck_rx)[yY][eE][sS]/) \
+        { \
+          break; \
+        } \
+    }; \
+  if (recheck) \
+    print $$0; \
+  close ($$0 ".trs"); \
+  close ($$0 ".log"); \
+}'
+# A command that, given a newline-separated list of test names on the
+# standard input, create the global log from their .trs and .log files.
+am__create_global_log = $(AWK) ' \
+function fatal(msg) \
+{ \
+  print "fatal: making $@: " msg | "cat >&2"; \
+  exit 1; \
+} \
+function rst_section(header) \
+{ \
+  print header; \
+  len = length(header); \
+  for (i = 1; i <= len; i = i + 1) \
+    printf "="; \
+  printf "\n\n"; \
+} \
+{ \
+  copy_in_global_log = 1; \
+  global_test_result = "RUN"; \
+  while ((rc = (getline line < ($$0 ".trs"))) != 0) \
+    { \
+      if (rc < 0) \
+         fatal("failed to read from " $$0 ".trs"); \
+      if (line ~ /$(am__global_test_result_rx)/) \
+        { \
+          sub("$(am__global_test_result_rx)", "", line); \
+          sub("[ 	]*$$", "", line); \
+          global_test_result = line; \
+        } \
+      else if (line ~ /$(am__copy_in_global_log_rx)[nN][oO]/) \
+        copy_in_global_log = 0; \
+    }; \
+  if (copy_in_global_log) \
+    { \
+      rst_section(global_test_result ": " $$0); \
+      while ((rc = (getline line < ($$0 ".log"))) != 0) \
+      { \
+        if (rc < 0) \
+          fatal("failed to read from " $$0 ".log"); \
+        print line; \
+      }; \
+      printf "\n"; \
+    }; \
+  close ($$0 ".trs"); \
+  close ($$0 ".log"); \
+}'
+# Restructured Text title.
+am__rst_title = { sed 's/.*/   &   /;h;s/./=/g;p;x;s/ *$$//;p;g' && echo; }
+# Solaris 10 'make', and several other traditional 'make' implementations,
+# pass "-e" to $(SHELL), and POSIX 2008 even requires this.  Work around it
+# by disabling -e (using the XSI extension "set +e") if it's set.
+am__sh_e_setup = case $$- in *e*) set +e;; esac
+# Default flags passed to test drivers.
+am__common_driver_flags = \
+  --color-tests "$$am__color_tests" \
+  --enable-hard-errors "$$am__enable_hard_errors" \
+  --expect-failure "$$am__expect_failure"
+# To be inserted before the command running the test.  Creates the
+# directory for the log if needed.  Stores in $dir the directory
+# containing $f, in $tst the test, in $log the log.  Executes the
+# developer- defined test setup AM_TESTS_ENVIRONMENT (if any), and
+# passes TESTS_ENVIRONMENT.  Set up options for the wrapper that
+# will run the test scripts (or their associated LOG_COMPILER, if
+# thy have one).
+am__check_pre = \
+$(am__sh_e_setup);					\
+$(am__vpath_adj_setup) $(am__vpath_adj)			\
+$(am__tty_colors);					\
+srcdir=$(srcdir); export srcdir;			\
+case "$@" in						\
+  */*) am__odir=`echo "./$@" | sed 's|/[^/]*$$||'`;;	\
+    *) am__odir=.;; 					\
+esac;							\
+test "x$$am__odir" = x"." || test -d "$$am__odir" 	\
+  || $(MKDIR_P) "$$am__odir" || exit $$?;		\
+if test -f "./$$f"; then dir=./;			\
+elif test -f "$$f"; then dir=;				\
+else dir="$(srcdir)/"; fi;				\
+tst=$$dir$$f; log='$@'; 				\
+if test -n '$(DISABLE_HARD_ERRORS)'; then		\
+  am__enable_hard_errors=no; 				\
+else							\
+  am__enable_hard_errors=yes; 				\
+fi; 							\
+case " $(XFAIL_TESTS) " in				\
+  *[\ \	]$$f[\ \	]* | *[\ \	]$$dir$$f[\ \	]*) \
+    am__expect_failure=yes;;				\
+  *)							\
+    am__expect_failure=no;;				\
+esac; 							\
+$(AM_TESTS_ENVIRONMENT) $(TESTS_ENVIRONMENT)
+# A shell command to get the names of the tests scripts with any registered
+# extension removed (i.e., equivalently, the names of the test logs, with
+# the '.log' extension removed).  The result is saved in the shell variable
+# '$bases'.  This honors runtime overriding of TESTS and TEST_LOGS.  Sadly,
+# we cannot use something simpler, involving e.g., "$(TEST_LOGS:.log=)",
+# since that might cause problem with VPATH rewrites for suffix-less tests.
+# See also 'test-harness-vpath-rewrite.sh' and 'test-trs-basic.sh'.
+am__set_TESTS_bases = \
+  bases='$(TEST_LOGS)'; \
+  bases=`for i in $$bases; do echo $$i; done | sed 's/\.log$$//'`; \
+  bases=`echo $$bases`
+RECHECK_LOGS = $(TEST_LOGS)
+TEST_SUITE_LOG = test-suite.log
+TEST_EXTENSIONS = @EXEEXT@ .test
+LOG_DRIVER = $(SHELL) $(top_srcdir)/cfgaux/test-driver
+LOG_COMPILE = $(LOG_COMPILER) $(AM_LOG_FLAGS) $(LOG_FLAGS)
+am__set_b = \
+  case '$@' in \
+    */*) \
+      case '$*' in \
+        */*) b='$*';; \
+          *) b=`echo '$@' | sed 's/\.log$$//'`; \
+       esac;; \
+    *) \
+      b='$*';; \
+  esac
+am__test_logs1 = $(TESTS:=.log)
+am__test_logs2 = $(am__test_logs1:@EXEEXT@.log=.log)
+TEST_LOGS = $(am__test_logs2:.test.log=.log)
+TEST_LOG_DRIVER = $(SHELL) $(top_srcdir)/cfgaux/test-driver
+TEST_LOG_COMPILE = $(TEST_LOG_COMPILER) $(AM_TEST_LOG_FLAGS) \
+	$(TEST_LOG_FLAGS)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-distdir = $(PACKAGE)-$(VERSION)
-top_distdir = $(distdir)
-am__remove_distdir = \
-  if test -d "$(distdir)"; then \
-    find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
-      && rm -rf "$(distdir)" \
-      || { sleep 5 && rm -rf "$(distdir)"; }; \
-  else :; fi
-am__post_remove_distdir = $(am__remove_distdir)
 am__relativize = \
   dir0=`pwd`; \
   sed_first='s,^\([^/]*\)/.*$$,\1,'; \
   sed_rest='s,^[^/]*/*,,'; \
   sed_last='s,^.*/\([^/]*\)$$,\1,'; \
   sed_butlast='s,/*[^/]*$$,,'; \
@@ -186,106 +485,181 @@
         dir0="$$dir0"/"$$first"; \
       fi; \
     fi; \
     dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
   done; \
   reldir="$$dir2"
-DIST_ARCHIVES = $(distdir).tar.gz $(distdir).tar.bz2
-GZIP_ENV = --best
-DIST_TARGETS = dist-bzip2 dist-gzip
-distuninstallcheck_listfiles = find . -type f -print
-am__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \
-  | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
-distcleancheck_listfiles = find . -type f -print
 ACLOCAL = @ACLOCAL@
+ADAPTATION_LIBS = @ADAPTATION_LIBS@
+ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
 AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AR = @AR@
+ARGZ_H = @ARGZ_H@
+AR_R = @AR_R@
+AUTH_LIBS_TO_BUILD = @AUTH_LIBS_TO_BUILD@
+AUTH_MODULES = @AUTH_MODULES@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BASIC_AUTH_HELPERS = @BASIC_AUTH_HELPERS@
+BZR = @BZR@
+CACHE_EFFECTIVE_USER = @CACHE_EFFECTIVE_USER@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
+CGIEXT = @CGIEXT@
+CHMOD = @CHMOD@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CPPUNITCONFIG = @CPPUNITCONFIG@
+CRYPTLIB = @CRYPTLIB@
 CXX = @CXX@
 CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
+DEFAULT_HOSTS = @DEFAULT_HOSTS@
+DEFAULT_LOG_DIR = @DEFAULT_LOG_DIR@
+DEFAULT_PID_FILE = @DEFAULT_PID_FILE@
+DEFAULT_SWAP_DIR = @DEFAULT_SWAP_DIR@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
+DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
+DISK_LIBS = @DISK_LIBS@
+DISK_LINKOBJS = @DISK_LINKOBJS@
+DISK_MODULES = @DISK_MODULES@
+DISK_OS_LIBS = @DISK_OS_LIBS@
+DISK_PROGRAMS = @DISK_PROGRAMS@
 DLLTOOL = @DLLTOOL@
 DSYMUTIL = @DSYMUTIL@
 DUMPBIN = @DUMPBIN@
+ECAP_LIBS = @ECAP_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+EPOLL_LIBS = @EPOLL_LIBS@
+EUILIB = @EUILIB@
 EXEEXT = @EXEEXT@
+EXPATLIB = @EXPATLIB@
+EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
+EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
+EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
+FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
+HOSTCXX = @HOSTCXX@
+ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+KRB5INCS = @KRB5INCS@
+KRB5LIBS = @KRB5LIBS@
+LBERLIB = @LBERLIB@
 LD = @LD@
+LDAPLIB = @LDAPLIB@
 LDFLAGS = @LDFLAGS@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
 LIBLTDL = @LIBLTDL@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
+LIBSASL = @LIBSASL@
 LIBTOOL = @LIBTOOL@
+LIB_DB = @LIB_DB@
 LIPO = @LIPO@
+LN = @LN@
 LN_S = @LN_S@
+LOG_DAEMON_HELPERS = @LOG_DAEMON_HELPERS@
 LTDLDEPS = @LTDLDEPS@
 LTDLINCL = @LTDLINCL@
+LTDLOPEN = @LTDLOPEN@
 LTLIBOBJS = @LTLIBOBJS@
+LT_CONFIG_H = @LT_CONFIG_H@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 MAINT = @MAINT@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MINGW_LIBS = @MINGW_LIBS@
+MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
+MV = @MV@
+NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
+NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
 OTOOL64 = @OTOOL64@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+PERL = @PERL@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+PO2HTML = @PO2HTML@
+PO2TEXT = @PO2TEXT@
+POD2MAN = @POD2MAN@
 RANLIB = @RANLIB@
+REGEXLIB = @REGEXLIB@
+REPL_LIBS = @REPL_LIBS@
+REPL_OBJS = @REPL_OBJS@
+REPL_POLICIES = @REPL_POLICIES@
+RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
+SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
+SNMPLIB = @SNMPLIB@
+SQUID_CFLAGS = @SQUID_CFLAGS@
+SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
+SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
+SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
+SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
+SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
+STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
+STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
+STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
-TRIE_CFLAGS = @TRIE_CFLAGS@
-TRIE_CXXFLAGS = @TRIE_CXXFLAGS@
+TR = @TR@
+TRUE = @TRUE@
+URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
+WIN32_PSAPI = @WIN32_PSAPI@
+XMLLIB = @XMLLIB@
+XTRA_LIBS = @XTRA_LIBS@
+XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
 abs_top_builddir = @abs_top_builddir@
 abs_top_srcdir = @abs_top_srcdir@
 ac_ct_AR = @ac_ct_AR@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
 ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+ac_krb5_config = @ac_krb5_config@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
 am__tar = @am__tar@
 am__untar = @am__untar@
 bindir = @bindir@
@@ -310,93 +684,144 @@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
 localedir = @localedir@
 localstatedir = @localstatedir@
+ltdl_LIBOBJS = @ltdl_LIBOBJS@
+ltdl_LTLIBOBJS = @ltdl_LTLIBOBJS@
+makesnmplib = @makesnmplib@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
 pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
+subdirs = @subdirs@
+sys_symbol_underscore = @sys_symbol_underscore@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-AUTOMAKE_OPTIONS = dist-bzip2 subdir-objects 1.5
-DIST_SUBDIRS = include src test
-SUBDIRS = src test
-all: config.h
-	$(MAKE) $(AM_MAKEFLAGS) all-recursive
+AM_CFLAGS = $(SQUID_CFLAGS)
+AM_CXXFLAGS = $(SQUID_CXXFLAGS)
+CLEANFILES = testHeaders
+TESTS = testHeaders
+INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
+	-I$(top_srcdir)/src -I$(top_builddir)/include \
+	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
+@ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
+@ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
+subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
+DIST_SUBDIRS = test
+SUBDIRS = test
+noinst_LIBRARIES = libTrie.a
+noinst_HEADERS = Trie.h TrieNode.h TrieCharTransform.h
+libTrie_a_SOURCES = Trie.cc \
+	Trie.cci \
+	Trie.h \
+	TrieNode.cc \
+	TrieNode.cci \
+	TrieNode.h \
+	TrieCharTransform.h
+
+all: all-recursive
 
 .SUFFIXES:
-am--refresh: Makefile
-	@:
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+.SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(top_srcdir)/src/TestHeaders.am $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
 	    *$$dep*) \
-	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
-	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
-		&& exit 0; \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign lib/libTrie/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign Makefile
+	  $(AUTOMAKE) --foreign lib/libTrie/Makefile
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
-	    echo ' $(SHELL) ./config.status'; \
-	    $(SHELL) ./config.status;; \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/src/Common.am $(top_srcdir)/src/TestHeaders.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	$(SHELL) ./config.status --recheck
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 $(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	$(am__cd) $(srcdir) && $(AUTOCONF)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(am__aclocal_m4_deps):
 
-config.h: stamp-h1
-	@test -f $@ || rm -f stamp-h1
-	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) stamp-h1
-
-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
-	@rm -f stamp-h1
-	cd $(top_builddir) && $(SHELL) ./config.status config.h
-$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) 
-	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
-	rm -f stamp-h1
-	touch $@
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
 
-distclean-hdr:
-	-rm -f config.h stamp-h1
+libTrie.a: $(libTrie_a_OBJECTS) $(libTrie_a_DEPENDENCIES) $(EXTRA_libTrie_a_DEPENDENCIES) 
+	$(AM_V_at)-rm -f libTrie.a
+	$(AM_V_AR)$(libTrie_a_AR) libTrie.a $(libTrie_a_OBJECTS) $(libTrie_a_LIBADD)
+	$(AM_V_at)$(RANLIB) libTrie.a
+
+clean-checkPROGRAMS:
+	@list='$(check_PROGRAMS)'; test -n "$$list" || exit 0; \
+	echo " rm -f" $$list; \
+	rm -f $$list || exit $$?; \
+	test -n "$(EXEEXT)" || exit 0; \
+	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
+	echo " rm -f" $$list; \
+	rm -f $$list
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Trie.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TrieNode.Po@am__quote@
+
+.cc.o:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<
+
+.cc.obj:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cc.lo:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<
 
 mostlyclean-libtool:
 	-rm -f *.lo
 
 clean-libtool:
 	-rm -rf .libs _libs
 
-distclean-libtool:
-	-rm -f libtool config.lt
-
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run 'make' without going through this Makefile.
 # To change the values of 'make' variables: instead of editing Makefiles,
 # (1) if the variable is set in 'config.status', edit 'config.status'
 #     (which will cause the Makefiles to be regenerated when you run 'make');
 # (2) otherwise, pass the desired values on the 'make' command line.
@@ -471,18 +896,12 @@
 	     $$unique
 
 GTAGS:
 	here=`$(am__cd) $(top_builddir) && pwd` \
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
-cscope: cscope.files
-	test ! -s cscope.files \
-	  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)
-clean-cscope:
-	-rm -f cscope.files
-cscope.files: clean-cscope cscopelist
 cscopelist: cscopelist-recursive
 
 cscopelist-am: $(am__tagged_files)
 	list='$(am__tagged_files)'; \
 	case "$(srcdir)" in \
 	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
@@ -495,17 +914,177 @@
 	    echo "$$sdir/$$i"; \
 	  fi; \
 	done >> $(top_builddir)/cscope.files
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
+
+# Recover from deleted '.trs' file; this should ensure that
+# "rm -f foo.log; make foo.trs" re-run 'foo.test', and re-create
+# both 'foo.log' and 'foo.trs'.  Break the recipe in two subshells
+# to avoid problems with "make -n".
+.log.trs:
+	rm -f $< $@
+	$(MAKE) $(AM_MAKEFLAGS) $<
+
+# Leading 'am--fnord' is there to ensure the list of targets does not
+# expand to empty, as could happen e.g. with make check TESTS=''.
+am--fnord $(TEST_LOGS) $(TEST_LOGS:.log=.trs): $(am__force_recheck)
+am--force-recheck:
+	@:
+
+$(TEST_SUITE_LOG): $(TEST_LOGS)
+	@$(am__set_TESTS_bases); \
+	am__f_ok () { test -f "$$1" && test -r "$$1"; }; \
+	redo_bases=`for i in $$bases; do \
+	              am__f_ok $$i.trs && am__f_ok $$i.log || echo $$i; \
+	            done`; \
+	if test -n "$$redo_bases"; then \
+	  redo_logs=`for i in $$redo_bases; do echo $$i.log; done`; \
+	  redo_results=`for i in $$redo_bases; do echo $$i.trs; done`; \
+	  if $(am__make_dryrun); then :; else \
+	    rm -f $$redo_logs && rm -f $$redo_results || exit 1; \
+	  fi; \
+	fi; \
+	if test -n "$$am__remaking_logs"; then \
+	  echo "fatal: making $(TEST_SUITE_LOG): possible infinite" \
+	       "recursion detected" >&2; \
+	else \
+	  am__remaking_logs=yes $(MAKE) $(AM_MAKEFLAGS) $$redo_logs; \
+	fi; \
+	if $(am__make_dryrun); then :; else \
+	  st=0;  \
+	  errmsg="fatal: making $(TEST_SUITE_LOG): failed to create"; \
+	  for i in $$redo_bases; do \
+	    test -f $$i.trs && test -r $$i.trs \
+	      || { echo "$$errmsg $$i.trs" >&2; st=1; }; \
+	    test -f $$i.log && test -r $$i.log \
+	      || { echo "$$errmsg $$i.log" >&2; st=1; }; \
+	  done; \
+	  test $$st -eq 0 || exit 1; \
+	fi
+	@$(am__sh_e_setup); $(am__tty_colors); $(am__set_TESTS_bases); \
+	ws='[ 	]'; \
+	results=`for b in $$bases; do echo $$b.trs; done`; \
+	test -n "$$results" || results=/dev/null; \
+	all=`  grep "^$$ws*:test-result:"           $$results | wc -l`; \
+	pass=` grep "^$$ws*:test-result:$$ws*PASS"  $$results | wc -l`; \
+	fail=` grep "^$$ws*:test-result:$$ws*FAIL"  $$results | wc -l`; \
+	skip=` grep "^$$ws*:test-result:$$ws*SKIP"  $$results | wc -l`; \
+	xfail=`grep "^$$ws*:test-result:$$ws*XFAIL" $$results | wc -l`; \
+	xpass=`grep "^$$ws*:test-result:$$ws*XPASS" $$results | wc -l`; \
+	error=`grep "^$$ws*:test-result:$$ws*ERROR" $$results | wc -l`; \
+	if test `expr $$fail + $$xpass + $$error` -eq 0; then \
+	  success=true; \
+	else \
+	  success=false; \
+	fi; \
+	br='==================='; br=$$br$$br$$br$$br; \
+	result_count () \
+	{ \
+	    if test x"$$1" = x"--maybe-color"; then \
+	      maybe_colorize=yes; \
+	    elif test x"$$1" = x"--no-color"; then \
+	      maybe_colorize=no; \
+	    else \
+	      echo "$@: invalid 'result_count' usage" >&2; exit 4; \
+	    fi; \
+	    shift; \
+	    desc=$$1 count=$$2; \
+	    if test $$maybe_colorize = yes && test $$count -gt 0; then \
+	      color_start=$$3 color_end=$$std; \
+	    else \
+	      color_start= color_end=; \
+	    fi; \
+	    echo "$${color_start}# $$desc $$count$${color_end}"; \
+	}; \
+	create_testsuite_report () \
+	{ \
+	  result_count $$1 "TOTAL:" $$all   "$$brg"; \
+	  result_count $$1 "PASS: " $$pass  "$$grn"; \
+	  result_count $$1 "SKIP: " $$skip  "$$blu"; \
+	  result_count $$1 "XFAIL:" $$xfail "$$lgn"; \
+	  result_count $$1 "FAIL: " $$fail  "$$red"; \
+	  result_count $$1 "XPASS:" $$xpass "$$red"; \
+	  result_count $$1 "ERROR:" $$error "$$mgn"; \
+	}; \
+	{								\
+	  echo "$(PACKAGE_STRING): $(subdir)/$(TEST_SUITE_LOG)" |	\
+	    $(am__rst_title);						\
+	  create_testsuite_report --no-color;				\
+	  echo;								\
+	  echo ".. contents:: :depth: 2";				\
+	  echo;								\
+	  for b in $$bases; do echo $$b; done				\
+	    | $(am__create_global_log);					\
+	} >$(TEST_SUITE_LOG).tmp || exit 1;				\
+	mv $(TEST_SUITE_LOG).tmp $(TEST_SUITE_LOG);			\
+	if $$success; then						\
+	  col="$$grn";							\
+	 else								\
+	  col="$$red";							\
+	  test x"$$VERBOSE" = x || cat $(TEST_SUITE_LOG);		\
+	fi;								\
+	echo "$${col}$$br$${std}"; 					\
+	echo "$${col}Testsuite summary for $(PACKAGE_STRING)$${std}";	\
+	echo "$${col}$$br$${std}"; 					\
+	create_testsuite_report --maybe-color;				\
+	echo "$$col$$br$$std";						\
+	if $$success; then :; else					\
+	  echo "$${col}See $(subdir)/$(TEST_SUITE_LOG)$${std}";		\
+	  if test -n "$(PACKAGE_BUGREPORT)"; then			\
+	    echo "$${col}Please report to $(PACKAGE_BUGREPORT)$${std}";	\
+	  fi;								\
+	  echo "$$col$$br$$std";					\
+	fi;								\
+	$$success || exit 1
+
+check-TESTS:
+	@list='$(RECHECK_LOGS)';           test -z "$$list" || rm -f $$list
+	@list='$(RECHECK_LOGS:.log=.trs)'; test -z "$$list" || rm -f $$list
+	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
+	@set +e; $(am__set_TESTS_bases); \
+	log_list=`for i in $$bases; do echo $$i.log; done`; \
+	trs_list=`for i in $$bases; do echo $$i.trs; done`; \
+	log_list=`echo $$log_list`; trs_list=`echo $$trs_list`; \
+	$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) TEST_LOGS="$$log_list"; \
+	exit $$?;
+recheck: all $(check_PROGRAMS)
+	@test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
+	@set +e; $(am__set_TESTS_bases); \
+	bases=`for i in $$bases; do echo $$i; done \
+	         | $(am__list_recheck_tests)` || exit 1; \
+	log_list=`for i in $$bases; do echo $$i.log; done`; \
+	log_list=`echo $$log_list`; \
+	$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) \
+	        am__force_recheck=am--force-recheck \
+	        TEST_LOGS="$$log_list"; \
+	exit $$?
+testHeaders.log: testHeaders
+	@p='testHeaders'; \
+	b='testHeaders'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+.test.log:
+	@p='$<'; \
+	$(am__set_b); \
+	$(am__check_pre) $(TEST_LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
+@am__EXEEXT_TRUE@.test$(EXEEXT).log:
+@am__EXEEXT_TRUE@	@p='$<'; \
+@am__EXEEXT_TRUE@	$(am__set_b); \
+@am__EXEEXT_TRUE@	$(am__check_pre) $(TEST_LOG_DRIVER) --test-name "$$f" \
+@am__EXEEXT_TRUE@	--log-file $$b.log --trs-file $$b.trs \
+@am__EXEEXT_TRUE@	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
+@am__EXEEXT_TRUE@	"$$tst" $(AM_TESTS_FD_REDIRECT)
 
 distdir: $(DISTFILES)
-	$(am__remove_distdir)
-	test -d "$(distdir)" || mkdir "$(distdir)"
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
 	  dist_files=`for file in $$list; do echo $$file; done | \
 	  sed -e "s|^$$srcdirstrip/||;t" \
 	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
@@ -554,145 +1133,17 @@
 		am__skip_length_check=: \
 		am__skip_mode_fix=: \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
 	done
-	-test -n "$(am__skip_mode_fix)" \
-	|| find "$(distdir)" -type d ! -perm -755 \
-		-exec chmod u+rwx,go+rx {} \; -o \
-	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
-	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
-	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
-	|| chmod -R a+r "$(distdir)"
-dist-gzip: distdir
-	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
-	$(am__post_remove_distdir)
-dist-bzip2: distdir
-	tardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2
-	$(am__post_remove_distdir)
-
-dist-lzip: distdir
-	tardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz
-	$(am__post_remove_distdir)
-
-dist-xz: distdir
-	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz
-	$(am__post_remove_distdir)
-
-dist-tarZ: distdir
-	@echo WARNING: "Support for shar distribution archives is" \
-	               "deprecated." >&2
-	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
-	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
-	$(am__post_remove_distdir)
-
-dist-shar: distdir
-	@echo WARNING: "Support for distribution archives compressed with" \
-		       "legacy program 'compress' is deprecated." >&2
-	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
-	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
-	$(am__post_remove_distdir)
-
-dist-zip: distdir
-	-rm -f $(distdir).zip
-	zip -rq $(distdir).zip $(distdir)
-	$(am__post_remove_distdir)
-
-dist dist-all:
-	$(MAKE) $(AM_MAKEFLAGS) $(DIST_TARGETS) am__post_remove_distdir='@:'
-	$(am__post_remove_distdir)
-
-# This target untars the dist file and tries a VPATH configuration.  Then
-# it guarantees that the distribution is self-contained by making another
-# tarfile.
-distcheck: dist
-	case '$(DIST_ARCHIVES)' in \
-	*.tar.gz*) \
-	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
-	*.tar.bz2*) \
-	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
-	*.tar.lz*) \
-	  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\
-	*.tar.xz*) \
-	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
-	*.tar.Z*) \
-	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
-	*.shar.gz*) \
-	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\
-	*.zip*) \
-	  unzip $(distdir).zip ;;\
-	esac
-	chmod -R a-w $(distdir)
-	chmod u+w $(distdir)
-	mkdir $(distdir)/_build $(distdir)/_inst
-	chmod a-w $(distdir)
-	test -d $(distdir)/_build || exit 0; \
-	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
-	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
-	  && am__cwd=`pwd` \
-	  && $(am__cd) $(distdir)/_build \
-	  && ../configure \
-	    $(AM_DISTCHECK_CONFIGURE_FLAGS) \
-	    $(DISTCHECK_CONFIGURE_FLAGS) \
-	    --srcdir=.. --prefix="$$dc_install_base" \
-	  && $(MAKE) $(AM_MAKEFLAGS) \
-	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
-	  && $(MAKE) $(AM_MAKEFLAGS) check \
-	  && $(MAKE) $(AM_MAKEFLAGS) install \
-	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
-	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
-	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
-	        distuninstallcheck \
-	  && chmod -R a-w "$$dc_install_base" \
-	  && ({ \
-	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
-	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
-	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
-	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
-	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
-	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
-	  && rm -rf "$$dc_destdir" \
-	  && $(MAKE) $(AM_MAKEFLAGS) dist \
-	  && rm -rf $(DIST_ARCHIVES) \
-	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
-	  && cd "$$am__cwd" \
-	  || exit 1
-	$(am__post_remove_distdir)
-	@(echo "$(distdir) archives ready for distribution: "; \
-	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
-	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
-distuninstallcheck:
-	@test -n '$(distuninstallcheck_dir)' || { \
-	  echo 'ERROR: trying to run $@ with an empty' \
-	       '$$(distuninstallcheck_dir)' >&2; \
-	  exit 1; \
-	}; \
-	$(am__cd) '$(distuninstallcheck_dir)' || { \
-	  echo 'ERROR: cannot chdir into $(distuninstallcheck_dir)' >&2; \
-	  exit 1; \
-	}; \
-	test `$(am__distuninstallcheck_listfiles) | wc -l` -eq 0 \
-	   || { echo "ERROR: files left after uninstall:" ; \
-	        if test -n "$(DESTDIR)"; then \
-	          echo "  (check DESTDIR support)"; \
-	        fi ; \
-	        $(distuninstallcheck_listfiles) ; \
-	        exit 1; } >&2
-distcleancheck: distclean
-	@if test '$(srcdir)' = . ; then \
-	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
-	  exit 1 ; \
-	fi
-	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
-	  || { echo "ERROR: files left in build directory after distclean:" ; \
-	       $(distcleancheck_listfiles) ; \
-	       exit 1; } >&2
 check-am: all-am
+	$(MAKE) $(AM_MAKEFLAGS) $(check_PROGRAMS)
+	$(MAKE) $(AM_MAKEFLAGS) check-TESTS
 check: check-recursive
-all-am: Makefile config.h
+all-am: Makefile $(LIBRARIES) $(HEADERS)
 installdirs: installdirs-recursive
 installdirs-am:
 install: install-recursive
 install-exec: install-exec-recursive
 install-data: install-data-recursive
 uninstall: uninstall-recursive
@@ -709,31 +1160,36 @@
 	else \
 	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
 	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
 	fi
 mostlyclean-generic:
+	-test -z "$(TEST_LOGS)" || rm -f $(TEST_LOGS)
+	-test -z "$(TEST_LOGS:.log=.trs)" || rm -f $(TEST_LOGS:.log=.trs)
+	-test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
 
 clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
 
 distclean-generic:
 	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
 	@echo "it deletes files that may require special tools to rebuild."
 clean: clean-recursive
 
-clean-am: clean-generic clean-libtool mostlyclean-am
+clean-am: clean-checkPROGRAMS clean-generic clean-libtool \
+	clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-recursive
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf ./$(DEPDIR)
 	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-hdr \
-	distclean-libtool distclean-tags
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-recursive
 
 dvi-am:
 
 html: html-recursive
@@ -770,48 +1226,53 @@
 
 install-ps-am:
 
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -rf ./$(DEPDIR)
 	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
 
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
 
 pdf: pdf-recursive
 
 pdf-am:
 
 ps: ps-recursive
 
 ps-am:
 
 uninstall-am:
 
-.MAKE: $(am__recursive_targets) all install-am install-strip
+.MAKE: $(am__recursive_targets) check-am install-am install-strip
+
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \
+	check-TESTS check-am clean clean-checkPROGRAMS clean-generic \
+	clean-libtool clean-noinstLIBRARIES cscopelist-am ctags \
+	ctags-am distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	recheck tags tags-am uninstall uninstall-am
+
+
+$(OBJS): $(top_srcdir)/include/version.h $(top_builddir)/include/autoconf.h
 
-.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am \
-	am--refresh check check-am clean clean-cscope clean-generic \
-	clean-libtool cscope cscopelist-am ctags ctags-am dist \
-	dist-all dist-bzip2 dist-gzip dist-lzip dist-shar dist-tarZ \
-	dist-xz dist-zip distcheck distclean distclean-generic \
-	distclean-hdr distclean-libtool distclean-tags distcleancheck \
-	distdir distuninstallcheck dvi dvi-am html html-am info \
-	info-am install install-am install-data install-data-am \
-	install-dvi install-dvi-am install-exec install-exec-am \
-	install-html install-html-am install-info install-info-am \
-	install-man install-pdf install-pdf-am install-ps \
-	install-ps-am install-strip installcheck installcheck-am \
-	installdirs installdirs-am maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-generic \
-	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
-	uninstall-am
+testHeaders: $(srcdir)/*.h
+	$(SHELL) $(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "$(srcdir)" || exit 1
 
+.PHONY: testHeaders
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie: src
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/test/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/test/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/test/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/test/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,16 +1,15 @@
-INCLUDES = -I$(top_srcdir)/include
+include $(top_srcdir)/src/Common.am
 
-AM_CFLAGS = $(TRIE_CFLAGS)
-AM_CXXFLAGS = $(TRIE_CXXFLAGS)
+INCLUDES += -I$(top_srcdir)/include
 
 # TESTS = trie trie-c
-TESTS = trie
+TESTS += trie
 
 # check_PROGRAMS = trie trie-c
-check_PROGRAMS = trie
+check_PROGRAMS += trie
 
 trie_SOURCES = trie.cc
-trie_LDADD = $(top_builddir)/src/libTrie.a
+trie_LDADD = $(top_builddir)/lib/libTrie/libTrie.a
 
 #trie_c_SOURCES = trie-c.c
-#trie_c_LDADD = $(top_builddir)/src/libTrie.a -lm
+#trie_c_LDADD = $(top_builddir)/lib/libTrie/libTrie.a -lm
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/test/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/test/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/test/Makefile.in	2015-05-01 16:52:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/test/Makefile.in	2015-05-01 18:06:42.000000000 +0800
@@ -74,29 +74,85 @@
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
-TESTS = trie$(EXEEXT)
+DIST_COMMON = $(top_srcdir)/src/Common.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/cfgaux/depcomp \
+	$(top_srcdir)/cfgaux/test-driver
 check_PROGRAMS = trie$(EXEEXT)
-subdir = test
-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/cfgaux/depcomp $(top_srcdir)/cfgaux/test-driver
+TESTS = trie$(EXEEXT)
+@USE_LOADABLE_MODULES_TRUE@am__append_1 = $(INCLTDL)
+subdir = lib/libTrie/test
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/acinclude/init.m4 \
+	$(top_srcdir)/acinclude/squid-util.m4 \
+	$(top_srcdir)/acinclude/compiler-flags.m4 \
+	$(top_srcdir)/acinclude/os-deps.m4 \
+	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
+	$(top_srcdir)/acinclude/pkg.m4 \
+	$(top_srcdir)/acinclude/lib-checks.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 am_trie_OBJECTS = trie.$(OBJEXT)
 trie_OBJECTS = $(am_trie_OBJECTS)
-trie_DEPENDENCIES = $(top_builddir)/src/libTrie.a
+trie_DEPENDENCIES = $(top_builddir)/lib/libTrie/libTrie.a
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
@@ -107,13 +163,13 @@
 am__v_GEN_0 = @echo "  GEN     " $@;
 am__v_GEN_1 = 
 AM_V_at = $(am__v_at_@AM_V@)
 am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
 am__v_at_0 = @
 am__v_at_1 = 
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = 
 depcomp = $(SHELL) $(top_srcdir)/cfgaux/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
@@ -361,98 +417,180 @@
 TEST_LOGS = $(am__test_logs2:.test.log=.log)
 TEST_LOG_DRIVER = $(SHELL) $(top_srcdir)/cfgaux/test-driver
 TEST_LOG_COMPILE = $(TEST_LOG_COMPILER) $(AM_TEST_LOG_FLAGS) \
 	$(TEST_LOG_FLAGS)
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
+ADAPTATION_LIBS = @ADAPTATION_LIBS@
+ALLOCA = @ALLOCA@
 AMTAR = @AMTAR@
 AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
 AR = @AR@
+ARGZ_H = @ARGZ_H@
+AR_R = @AR_R@
+AUTH_LIBS_TO_BUILD = @AUTH_LIBS_TO_BUILD@
+AUTH_MODULES = @AUTH_MODULES@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BASIC_AUTH_HELPERS = @BASIC_AUTH_HELPERS@
+BZR = @BZR@
+CACHE_EFFECTIVE_USER = @CACHE_EFFECTIVE_USER@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
+CGIEXT = @CGIEXT@
+CHMOD = @CHMOD@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
+CPPUNITCONFIG = @CPPUNITCONFIG@
+CRYPTLIB = @CRYPTLIB@
 CXX = @CXX@
 CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
+DEFAULT_HOSTS = @DEFAULT_HOSTS@
+DEFAULT_LOG_DIR = @DEFAULT_LOG_DIR@
+DEFAULT_PID_FILE = @DEFAULT_PID_FILE@
+DEFAULT_SWAP_DIR = @DEFAULT_SWAP_DIR@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
+DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
+DISK_LIBS = @DISK_LIBS@
+DISK_LINKOBJS = @DISK_LINKOBJS@
+DISK_MODULES = @DISK_MODULES@
+DISK_OS_LIBS = @DISK_OS_LIBS@
+DISK_PROGRAMS = @DISK_PROGRAMS@
 DLLTOOL = @DLLTOOL@
 DSYMUTIL = @DSYMUTIL@
 DUMPBIN = @DUMPBIN@
+ECAP_LIBS = @ECAP_LIBS@
 ECHO_C = @ECHO_C@
 ECHO_N = @ECHO_N@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
+EPOLL_LIBS = @EPOLL_LIBS@
+EUILIB = @EUILIB@
 EXEEXT = @EXEEXT@
+EXPATLIB = @EXPATLIB@
+EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
+EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
+EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
+FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
+HOSTCXX = @HOSTCXX@
+ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+KRB5INCS = @KRB5INCS@
+KRB5LIBS = @KRB5LIBS@
+LBERLIB = @LBERLIB@
 LD = @LD@
+LDAPLIB = @LDAPLIB@
 LDFLAGS = @LDFLAGS@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
 LIBLTDL = @LIBLTDL@
 LIBOBJS = @LIBOBJS@
 LIBS = @LIBS@
+LIBSASL = @LIBSASL@
 LIBTOOL = @LIBTOOL@
+LIB_DB = @LIB_DB@
 LIPO = @LIPO@
+LN = @LN@
 LN_S = @LN_S@
+LOG_DAEMON_HELPERS = @LOG_DAEMON_HELPERS@
 LTDLDEPS = @LTDLDEPS@
 LTDLINCL = @LTDLINCL@
+LTDLOPEN = @LTDLOPEN@
 LTLIBOBJS = @LTLIBOBJS@
+LT_CONFIG_H = @LT_CONFIG_H@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 MAINT = @MAINT@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MINGW_LIBS = @MINGW_LIBS@
+MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
+MV = @MV@
+NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
+NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
 OTOOL64 = @OTOOL64@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_URL = @PACKAGE_URL@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+PERL = @PERL@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+PO2HTML = @PO2HTML@
+PO2TEXT = @PO2TEXT@
+POD2MAN = @POD2MAN@
 RANLIB = @RANLIB@
+REGEXLIB = @REGEXLIB@
+REPL_LIBS = @REPL_LIBS@
+REPL_OBJS = @REPL_OBJS@
+REPL_POLICIES = @REPL_POLICIES@
+RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
+SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
+SNMPLIB = @SNMPLIB@
+SQUID_CFLAGS = @SQUID_CFLAGS@
+SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
+SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
+SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
+SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
+SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
+STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
+STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
+STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
-TRIE_CFLAGS = @TRIE_CFLAGS@
-TRIE_CXXFLAGS = @TRIE_CXXFLAGS@
+TR = @TR@
+TRUE = @TRUE@
+URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
+WIN32_PSAPI = @WIN32_PSAPI@
+XMLLIB = @XMLLIB@
+XTRA_LIBS = @XTRA_LIBS@
+XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
 abs_top_builddir = @abs_top_builddir@
 abs_top_srcdir = @abs_top_srcdir@
 ac_ct_AR = @ac_ct_AR@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
 ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+ac_krb5_config = @ac_krb5_config@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
 am__tar = @am__tar@
 am__untar = @am__untar@
 bindir = @bindir@
@@ -477,57 +615,71 @@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
 localedir = @localedir@
 localstatedir = @localstatedir@
+ltdl_LIBOBJS = @ltdl_LIBOBJS@
+ltdl_LTLIBOBJS = @ltdl_LTLIBOBJS@
+makesnmplib = @makesnmplib@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
 pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
 psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 srcdir = @srcdir@
+subdirs = @subdirs@
+sys_symbol_underscore = @sys_symbol_underscore@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-INCLUDES = -I$(top_srcdir)/include
-AM_CFLAGS = $(TRIE_CFLAGS)
-AM_CXXFLAGS = $(TRIE_CXXFLAGS)
+AM_CFLAGS = $(SQUID_CFLAGS)
+AM_CXXFLAGS = $(SQUID_CXXFLAGS)
+CLEANFILES = 
+INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
+	-I$(top_srcdir)/src -I$(top_builddir)/include \
+	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) \
+	-I$(top_srcdir)/include
+@ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
+@ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
+subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 trie_SOURCES = trie.cc
-trie_LDADD = $(top_builddir)/src/libTrie.a
+trie_LDADD = $(top_builddir)/lib/libTrie/libTrie.a
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
 	    *$$dep*) \
 	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
 	        && { if test -f $@; then exit 0; else break; fi; }; \
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign test/Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign lib/libTrie/test/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign test/Makefile
+	  $(AUTOMAKE) --foreign lib/libTrie/test/Makefile
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
 	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
 	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
+$(top_srcdir)/src/Common.am:
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 $(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
@@ -856,12 +1008,13 @@
 mostlyclean-generic:
 	-test -z "$(TEST_LOGS)" || rm -f $(TEST_LOGS)
 	-test -z "$(TEST_LOGS:.log=.trs)" || rm -f $(TEST_LOGS:.log=.trs)
 	-test -z "$(TEST_SUITE_LOG)" || rm -f $(TEST_SUITE_LOG)
 
 clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
 
 distclean-generic:
 	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
 
 maintainer-clean-generic:
@@ -952,12 +1105,14 @@
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
 	recheck tags tags-am uninstall uninstall-am
 
 
+$(OBJS): $(top_srcdir)/include/version.h $(top_builddir)/include/autoconf.h
+
 #trie_c_SOURCES = trie-c.c
-#trie_c_LDADD = $(top_builddir)/src/libTrie.a -lm
+#trie_c_LDADD = $(top_builddir)/lib/libTrie/libTrie.a -lm
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/test/trie.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/test/trie.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/libTrie/test/trie.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie/test/trie.cc	2015-05-01 18:05:19.000000000 +0800
@@ -14,15 +14,15 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
-#include "config.h"
-#include "Trie.h"
-#include "TrieCharTransform.h"
+#include "squid.h"
+#include "libTrie/Trie.h"
+#include "libTrie/TrieCharTransform.h"
 
 #if HAVE_IOSTREAM
 #include <iostream>
 #endif
 
 bool
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie: Trie.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie: Trie.cci
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie: TrieCharTransform.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie: Trie.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie: TrieNode.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie: TrieNode.cci
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/libTrie: TrieNode.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -22,16 +22,16 @@
 #
 # Some libraries are only available on Windows
 # and others are unable to be built.
 #
 if ENABLE_WIN32SPECIFIC
 noinst_LTLIBRARIES += libsspwin32.la
-libsspwin32_la_SOURCES = sspwin32.c
+libsspwin32_la_SOURCES = sspwin32.cc
 else
 SUBDIRS += rfcnb smblib
-EXTRA_DIST += sspwin32.c
+EXTRA_DIST += sspwin32.cc
 endif
 if ENABLE_AUTH_NTLM
 SUBDIRS += ntlmauth
 endif
 
 #
@@ -75,14 +75,12 @@
 
 TESTS += tests/testAll
 
 check_PROGRAMS += tests/testAll
 
 tests_testAll_SOURCES= \
-	tests/testArray.h \
-	tests/testArray.cc \
 	tests/testRFC1035.h \
 	tests/testRFC1035.cc \
 	tests/testRFC1738.h \
 	tests/testRFC1738.cc \
 	tests/testMain.cc
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/Makefile.in	2015-05-01 16:51:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/Makefile.in	2015-05-01 18:06:41.000000000 +0800
@@ -90,25 +90,71 @@
 #
 # Some libraries are only available on Windows
 # and others are unable to be built.
 #
 @ENABLE_WIN32SPECIFIC_TRUE@am__append_4 = libsspwin32.la
 @ENABLE_WIN32SPECIFIC_FALSE@am__append_5 = rfcnb smblib
-@ENABLE_WIN32SPECIFIC_FALSE@am__append_6 = sspwin32.c
+@ENABLE_WIN32SPECIFIC_FALSE@am__append_6 = sspwin32.cc
 @ENABLE_AUTH_NTLM_TRUE@am__append_7 = ntlmauth
 subdir = lib
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude/init.m4 \
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -129,22 +175,23 @@
 am_libmiscutil_la_OBJECTS = malloc_trace.lo MemPool.lo \
 	MemPoolChunked.lo MemPoolMalloc.lo getfullhostname.lo heap.lo \
 	iso3307.lo radix.lo rfc1035.lo rfc1123.lo rfc2671.lo \
 	rfc3596.lo Splay.lo stub_memaccount.lo util.lo xusleep.lo
 libmiscutil_la_OBJECTS = $(am_libmiscutil_la_OBJECTS)
 libsspwin32_la_LIBADD =
-am__libsspwin32_la_SOURCES_DIST = sspwin32.c
+am__libsspwin32_la_SOURCES_DIST = sspwin32.cc
 @ENABLE_WIN32SPECIFIC_TRUE@am_libsspwin32_la_OBJECTS = sspwin32.lo
 libsspwin32_la_OBJECTS = $(am_libsspwin32_la_OBJECTS)
 @ENABLE_WIN32SPECIFIC_TRUE@am_libsspwin32_la_rpath =
-am_tests_testAll_OBJECTS = testArray.$(OBJEXT) testRFC1035.$(OBJEXT) \
-	testRFC1738.$(OBJEXT) testMain.$(OBJEXT)
+am_tests_testAll_OBJECTS = testRFC1035.$(OBJEXT) testRFC1738.$(OBJEXT) \
+	testMain.$(OBJEXT)
 tests_testAll_OBJECTS = $(am_tests_testAll_OBJECTS)
 am__DEPENDENCIES_1 =
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_2 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_3 = $(am__DEPENDENCIES_2)
+am__DEPENDENCIES_3 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_2)
 tests_testAll_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la $(am__DEPENDENCIES_3)
 tests_testAll_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
 	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testAll_LDFLAGS) $(LDFLAGS) \
@@ -537,12 +584,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -580,12 +628,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -612,27 +661,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -698,21 +750,21 @@
 CLEANFILES = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 DIST_SUBDIRS = ntlmauth profiler rfcnb smblib libTrie
 SUBDIRS = $(am__append_2) $(am__append_3) $(am__append_5) \
 	$(am__append_7)
 EXTRA_DIST = $(am__append_6)
 noinst_LTLIBRARIES = libmiscencoding.la libmisccontainers.la \
 	libmiscutil.la $(am__append_4)
-@ENABLE_WIN32SPECIFIC_TRUE@libsspwin32_la_SOURCES = sspwin32.c
+@ENABLE_WIN32SPECIFIC_TRUE@libsspwin32_la_SOURCES = sspwin32.cc
 
 #
 # dirent.c, encrypt.c and getopt.c are needed for native Windows support.
 #
 EXTRA_libmiscutil_la_SOURCES = \
 	dirent.c \
@@ -748,14 +800,12 @@
 	Splay.cc \
 	stub_memaccount.c \
 	util.c \
 	xusleep.c
 
 tests_testAll_SOURCES = \
-	tests/testArray.h \
-	tests/testArray.cc \
 	tests/testRFC1035.h \
 	tests/testRFC1035.cc \
 	tests/testRFC1738.h \
 	tests/testRFC1738.cc \
 	tests/testMain.cc
 
@@ -820,13 +870,13 @@
 	$(AM_V_CCLD)$(LINK)  $(libmiscencoding_la_OBJECTS) $(libmiscencoding_la_LIBADD) $(LIBS)
 
 libmiscutil.la: $(libmiscutil_la_OBJECTS) $(libmiscutil_la_DEPENDENCIES) $(EXTRA_libmiscutil_la_DEPENDENCIES) 
 	$(AM_V_CXXLD)$(CXXLINK)  $(libmiscutil_la_OBJECTS) $(libmiscutil_la_LIBADD) $(LIBS)
 
 libsspwin32.la: $(libsspwin32_la_OBJECTS) $(libsspwin32_la_DEPENDENCIES) $(EXTRA_libsspwin32_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK) $(am_libsspwin32_la_rpath) $(libsspwin32_la_OBJECTS) $(libsspwin32_la_LIBADD) $(LIBS)
+	$(AM_V_CXXLD)$(CXXLINK) $(am_libsspwin32_la_rpath) $(libsspwin32_la_OBJECTS) $(libsspwin32_la_LIBADD) $(LIBS)
 
 clean-checkPROGRAMS:
 	@list='$(check_PROGRAMS)'; test -n "$$list" || exit 0; \
 	echo " rm -f" $$list; \
 	rm -f $$list || exit $$?; \
 	test -n "$(EXEEXT)" || exit 0; \
@@ -869,13 +919,12 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rfc1738.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rfc2617.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rfc2671.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rfc3596.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sspwin32.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stub_memaccount.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testArray.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testMain.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testRFC1035.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testRFC1738.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uudecode.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xusleep.Plo@am__quote@
@@ -919,26 +968,12 @@
 @am__fastdepCXX_TRUE@	$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
 @am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<
 
-testArray.o: tests/testArray.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT testArray.o -MD -MP -MF $(DEPDIR)/testArray.Tpo -c -o testArray.o `test -f 'tests/testArray.cc' || echo '$(srcdir)/'`tests/testArray.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/testArray.Tpo $(DEPDIR)/testArray.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='tests/testArray.cc' object='testArray.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o testArray.o `test -f 'tests/testArray.cc' || echo '$(srcdir)/'`tests/testArray.cc
-
-testArray.obj: tests/testArray.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT testArray.obj -MD -MP -MF $(DEPDIR)/testArray.Tpo -c -o testArray.obj `if test -f 'tests/testArray.cc'; then $(CYGPATH_W) 'tests/testArray.cc'; else $(CYGPATH_W) '$(srcdir)/tests/testArray.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/testArray.Tpo $(DEPDIR)/testArray.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='tests/testArray.cc' object='testArray.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o testArray.obj `if test -f 'tests/testArray.cc'; then $(CYGPATH_W) 'tests/testArray.cc'; else $(CYGPATH_W) '$(srcdir)/tests/testArray.cc'; fi`
-
 testRFC1035.o: tests/testRFC1035.cc
 @am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT testRFC1035.o -MD -MP -MF $(DEPDIR)/testRFC1035.Tpo -c -o testRFC1035.o `test -f 'tests/testRFC1035.cc' || echo '$(srcdir)/'`tests/testRFC1035.cc
 @am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/testRFC1035.Tpo $(DEPDIR)/testRFC1035.Po
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='tests/testRFC1035.cc' object='testRFC1035.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o testRFC1035.o `test -f 'tests/testRFC1035.cc' || echo '$(srcdir)/'`tests/testRFC1035.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/malloc_trace.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/malloc_trace.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/malloc_trace.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/malloc_trace.cc	2015-05-01 18:05:19.000000000 +0800
@@ -84,36 +84,17 @@
     fclose(tracefp);
     tracefp = NULL;
 }
 
 #endif
 
-#if XMALLOC_TRACE
-char *xmalloc_file = "";
-int xmalloc_line = 0;
-char *xmalloc_func = "";
-static int xmalloc_count = 0;
-int xmalloc_trace = 0;		/* Enable with -m option */
-size_t xmalloc_total = 0;
-#undef xmalloc
-#undef xfree
-#undef xrealloc
-#undef xcalloc
-#undef xstrdup
-#endif
-
 #if XMALLOC_DEBUG
 #define DBG_ARRY_SZ (1<<11)
 #define DBG_ARRY_BKTS (1<<8)
 static void *(*malloc_ptrs)[DBG_ARRY_SZ];
 static int malloc_size[DBG_ARRY_BKTS][DBG_ARRY_SZ];
-#if XMALLOC_TRACE
-static char *malloc_file[DBG_ARRY_BKTS][DBG_ARRY_SZ];
-static short malloc_line[DBG_ARRY_BKTS][DBG_ARRY_SZ];
-static int malloc_count[DBG_ARRY_BKTS][DBG_ARRY_SZ];
-#endif
 static int dbg_initd = 0;
 
 #define DBG_HASH_BUCKET(ptr)   (((((int)ptr)>>4)+(((int)ptr)>>12)+(((int)ptr)>>20))&0xFF)
 
 static void
 check_init(void)
@@ -123,19 +104,12 @@
     malloc_ptrs = calloc(DBG_ARRY_BKTS, sizeof(*malloc_ptrs));
 
     for (B = 0; B < DBG_ARRY_BKTS; ++B) {
         for (I = 0; I < DBG_ARRY_SZ; ++I) {
             malloc_ptrs[B][I] = NULL;
             malloc_size[B][I] = 0;
-#if XMALLOC_TRACE
-
-            malloc_file[B][I] = NULL;
-            malloc_line[B][I] = 0;
-            malloc_count[B][I] = 0;
-#endif
-
         }
     }
 
     dbg_initd = 1;
 }
 
@@ -147,25 +121,13 @@
 
     for (I = 0; I < DBG_ARRY_SZ; ++I) {
         if (malloc_ptrs[B][I] != s)
             continue;
 
         malloc_ptrs[B][I] = NULL;
-
         malloc_size[B][I] = 0;
-
-#if XMALLOC_TRACE
-
-        malloc_file[B][I] = NULL;
-
-        malloc_line[B][I] = 0;
-
-        malloc_count[B][I] = 0;
-
-#endif
-
         break;
     }
 
     if (I == DBG_ARRY_SZ) {
         static char msg[128];
         snprintf(msg, 128, "xfree: ERROR: s=%p not found!", s);
@@ -206,25 +168,13 @@
 
     for (I = 0; I < DBG_ARRY_SZ; ++I) {
         if (malloc_ptrs[B][I])
             continue;
 
         malloc_ptrs[B][I] = p;
-
         malloc_size[B][I] = (int) sz;
-
-#if XMALLOC_TRACE
-
-        malloc_file[B][I] = xmalloc_file;
-
-        malloc_line[B][I] = xmalloc_line;
-
-        malloc_count[B][I] = xmalloc_count;
-
-#endif
-
         break;
     }
 
     if (I == DBG_ARRY_SZ) {
         if (failure_notify)
             (*failure_notify) ("xmalloc: debug out of array space!");
@@ -232,192 +182,6 @@
             perror("xmalloc: debug out of array space!");
     }
 }
 
 #endif
 
-#if XMALLOC_TRACE && !HAVE_MALLOCBLKSIZE
-size_t
-xmallocblksize(void *p)
-{
-    int B, I;
-    B = DBG_HASH_BUCKET(p);
-
-    for (I = 0; I < DBG_ARRY_SZ; ++I) {
-        if (malloc_ptrs[B][I] == p)
-            return malloc_size[B][I];
-    }
-
-    return 0;
-}
-
-#endif
-
-#ifdef XMALLOC_TRACE
-static char *
-malloc_file_name(void *p)
-{
-    int B, I;
-    B = DBG_HASH_BUCKET(p);
-
-    for (I = 0; I < DBG_ARRY_SZ; ++I) {
-        if (malloc_ptrs[B][I] == p)
-            return malloc_file[B][I];
-    }
-
-    return 0;
-}
-
-int
-malloc_line_number(void *p)
-{
-    int B, I;
-    B = DBG_HASH_BUCKET(p);
-
-    for (I = 0; I < DBG_ARRY_SZ; ++I) {
-        if (malloc_ptrs[B][I] == p)
-            return malloc_line[B][I];
-    }
-
-    return 0;
-}
-
-int
-malloc_number(void *p)
-{
-    int B, I;
-    B = DBG_HASH_BUCKET(p);
-
-    for (I = 0; I < DBG_ARRY_SZ; ++I) {
-        if (malloc_ptrs[B][I] == p)
-            return malloc_count[B][I];
-    }
-
-    return 0;
-}
-
-static void
-xmalloc_show_trace(void *p, int sign)
-{
-    int statMemoryAccounted();
-    static size_t last_total = 0, last_accounted = 0, last_mallinfo = 0;
-    size_t accounted = statMemoryAccounted();
-    size_t mi = 0;
-    size_t sz;
-#if HAVE_MALLINFO
-
-    struct mallinfo mp = mallinfo();
-    mi = mp.uordblks + mp.usmblks + mp.hblkhd;
-#endif
-
-    sz = xmallocblksize(p) * sign;
-    xmalloc_total += sz;
-    xmalloc_count += sign > 0;
-
-    if (xmalloc_trace) {
-        fprintf(stderr, "%c%8p size=%5d/%d acc=%5d/%d mallinfo=%5d/%d %s:%d %s",
-                sign > 0 ? '+' : '-', p,
-                (int) xmalloc_total - last_total, (int) xmalloc_total,
-                (int) accounted - last_accounted, (int) accounted,
-                (int) mi - last_mallinfo, (int) mi,
-                xmalloc_file, xmalloc_line, xmalloc_func);
-
-        if (sign < 0)
-            fprintf(stderr, " (%d %s:%d)\n", malloc_number(p), malloc_file_name(p), malloc_line_number(p));
-        else
-            fprintf(stderr, " %d\n", xmalloc_count);
-    }
-
-    last_total = xmalloc_total;
-    last_accounted = accounted;
-    last_mallinfo = mi;
-}
-
-short malloc_refs[DBG_ARRY_BKTS][DBG_ARRY_SZ];
-#define XMALLOC_LEAK_ALIGN (4)
-static void
-xmalloc_scan_region(void *start, int size, int depth)
-{
-    int B, I;
-    char *ptr = start;
-    char *end = ptr + size - XMALLOC_LEAK_ALIGN;
-    static int sum = 0;
-
-    while (ptr <= end) {
-        void *p = *(void **) ptr;
-
-        if (p && p != start) {
-            B = DBG_HASH_BUCKET(p);
-
-            for (I = 0; I < DBG_ARRY_SZ; ++I) {
-                if (malloc_ptrs[B][I] == p) {
-                    if (!malloc_refs[B][I]++) {
-                        /* A new reference */
-                        fprintf(stderr, "%*s%p %s:%d size %d allocation %d\n",
-                                depth, "",
-                                malloc_ptrs[B][I], malloc_file[B][I],
-                                malloc_line[B][I], malloc_size[B][I],
-                                malloc_count[B][I]);
-                        sum += malloc_size[B][I];
-                        xmalloc_scan_region(malloc_ptrs[B][I], malloc_size[B][I], depth + 1);
-
-                        if (depth == 0) {
-                            if (sum != malloc_size[B][I])
-                                fprintf(stderr, "=== %d bytes\n", sum);
-
-                            sum = 0;
-                        }
-
-#if XMALLOC_SHOW_ALL_REFERENCES
-
-                    } else {
-                        /* We have already scanned this pointer... */
-                        fprintf(stderr, "%*s%p %s:%d size %d allocation %d ... (%d)\n",
-                                depth * 2, "",
-                                malloc_ptrs[B][I], malloc_file[B][I],
-                                malloc_line[B][I], malloc_size[B][I],
-                                malloc_count[B][I], malloc_refs[B][I]);
-#endif
-
-                    }
-                }
-            }
-        }
-
-        ptr += XMALLOC_LEAK_ALIGN;
-    }
-}
-
-void
-xmalloc_find_leaks(void)
-{
-    int B, I;
-    int leak_sum = 0;
-
-    extern void _etext;
-    fprintf(stderr, "----- Memory map ----\n");
-    xmalloc_scan_region(&_etext, (void *) sbrk(0) - (void *) &_etext, 0);
-
-    for (B = 0; B < DBG_ARRY_BKTS; ++B) {
-        for (I = 0; I < DBG_ARRY_SZ; ++I) {
-            if (malloc_ptrs[B][I] && malloc_refs[B][I] == 0) {
-                /* Found a leak... */
-                fprintf(stderr, "Leak found: %p", malloc_ptrs[B][I]);
-                fprintf(stderr, " %s", malloc_file[B][I]);
-                fprintf(stderr, ":%d", malloc_line[B][I]);
-                fprintf(stderr, " size %d", malloc_size[B][I]);
-                fprintf(stderr, " allocation %d\n", malloc_count[B][I]);
-                leak_sum += malloc_size[B][I];
-            }
-        }
-    }
-
-    if (leak_sum) {
-        fprintf(stderr, "Total leaked memory: %d\n", leak_sum);
-    } else {
-        fprintf(stderr, "No memory leaks detected\n");
-    }
-
-    fprintf(stderr, "----------------------\n");
-}
-
-#endif /* XMALLOC_TRACE */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/md5.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/md5.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/md5.c	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/md5.c	2015-05-01 18:05:19.000000000 +0800
@@ -29,12 +29,14 @@
  * Still in the public domain.
  *
  */
 #include "squid.h"
 #include "md5.h"
 
+#if !HAVE_NETTLE_MD5_H
+
 #if HAVE_STRING_H
 #include <string.h>		/* for memcpy() */
 #endif
 #if HAVE_SYS_TYPES_H
 #include <sys/types.h>		/* for stupid systems */
 #endif
@@ -249,6 +251,7 @@
     buf[1] += b;
     buf[2] += c;
     buf[3] += d;
 }
 
 #endif /* !ASM_MD5 */
+#endif /* HAVE_ETTLE_MD5_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/MemPool.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/MemPool.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/MemPool.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/MemPool.cc	2015-05-01 18:05:19.000000000 +0800
@@ -321,13 +321,13 @@
     stats->tot_overhead += pp_stats.overhead + MemPools::GetInstance().poolCount * sizeof(MemAllocator *);
     stats->mem_idle_limit = MemPools::GetInstance().mem_idle_limit;
 
     return pools_inuse;
 }
 
-MemAllocator::MemAllocator(char const *aLabel) : doZeroOnPush(true), label(aLabel)
+MemAllocator::MemAllocator(char const *aLabel) : doZero(true), label(aLabel)
 {
 }
 
 size_t MemAllocator::RoundedSize(size_t s)
 {
     return ((s + sizeof(void*) - 1) / sizeof(void*)) * sizeof(void*);
@@ -442,18 +442,12 @@
         prev_pool->next = next;
     else
         MemPools::GetInstance().pools = next;
     --MemPools::GetInstance().poolCount;
 }
 
-void
-MemAllocator::zeroOnPush(bool doIt)
-{
-    doZeroOnPush = doIt;
-}
-
 MemPoolMeter const &
 MemImplementingAllocator::getMeter() const
 {
     return meter;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/MemPoolChunked.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/MemPoolChunked.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/MemPoolChunked.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/MemPoolChunked.cc	2015-05-01 18:05:19.000000000 +0800
@@ -138,13 +138,17 @@
      * free the first chunk.
      */
     inuse_count = 0;
     next = NULL;
     pool = aPool;
 
-    objCache = xcalloc(1, pool->chunk_size);
+    if (pool->doZero)
+        objCache = xcalloc(1, pool->chunk_size);
+    else
+        objCache = xmalloc(pool->chunk_size);
+
     freeList = objCache;
     void **Free = (void **)freeList;
 
     for (int i = 1; i < pool->chunk_capacity; ++i) {
         *Free = (void *) ((char *) Free + pool->obj_size);
         void **nextFree = (void **)*Free;
@@ -193,13 +197,13 @@
     void **Free;
     /* XXX We should figure out a sane way of avoiding having to clear
      * all buffers. For example data buffers such as used by MemBuf do
      * not really need to be cleared.. There was a condition based on
      * the object size here, but such condition is not safe.
      */
-    if (doZeroOnPush)
+    if (doZero)
         memset(obj, 0, obj_size);
     Free = (void **)obj;
     *Free = freeCache;
     freeCache = obj;
     (void) VALGRIND_MAKE_MEM_NOACCESS(obj, obj_size);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/MemPoolMalloc.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/MemPoolMalloc.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/MemPoolMalloc.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/MemPoolMalloc.cc	2015-05-01 18:05:19.000000000 +0800
@@ -53,13 +53,16 @@
 {
     void *obj = freelist.pop();
     if (obj) {
         memMeterDec(meter.idle);
         ++saved_calls;
     } else {
-        obj = xcalloc(1, obj_size);
+        if (doZero)
+            obj = xcalloc(1, obj_size);
+        else
+            obj = xmalloc(obj_size);
         memMeterInc(meter.alloc);
     }
     memMeterInc(meter.inuse);
     return obj;
 }
 
@@ -68,13 +71,13 @@
 {
     memMeterDec(meter.inuse);
     if (aggressive) {
         xfree(obj);
         memMeterDec(meter.alloc);
     } else {
-        if (doZeroOnPush)
+        if (doZero)
             memset(obj, 0, obj_size);
         memMeterInc(meter.idle);
         freelist.push_back(obj);
     }
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/ntlmauth/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/ntlmauth/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/ntlmauth/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/ntlmauth/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -5,7 +5,8 @@
 
 noinst_LTLIBRARIES = libntlmauth.la
 
 libntlmauth_la_SOURCES = \
 	ntlmauth.cc \
 	ntlmauth.h \
-	support_bits.cci
+	support_bits.cci \
+	support_endian.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/ntlmauth/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/ntlmauth/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/ntlmauth/Makefile.in	2015-05-01 16:51:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/ntlmauth/Makefile.in	2015-05-01 18:06:42.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -451,12 +497,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -494,12 +541,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -526,27 +574,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -614,19 +665,20 @@
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) \
 	-I$(top_srcdir)/lib
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libntlmauth.la
 libntlmauth_la_SOURCES = \
 	ntlmauth.cc \
 	ntlmauth.h \
-	support_bits.cci
+	support_bits.cci \
+	support_endian.h
 
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(top_srcdir)/src/TestHeaders.am $(am__configure_deps)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/ntlmauth/ntlmauth.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/ntlmauth/ntlmauth.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/ntlmauth/ntlmauth.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/ntlmauth/ntlmauth.h	2015-05-01 18:05:19.000000000 +0800
@@ -51,12 +51,14 @@
  */
 
 #ifndef SQUID_NTLMAUTH_H
 #define SQUID_NTLMAUTH_H
 
 /* NP: All of this cruft is little endian */
+/* Endian functions are usualy handled by the OS but not always. */
+#include "ntlmauth/support_endian.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
     /* Used internally. Microsoft seems to think this is right, I believe them.
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/ntlmauth: support_endian.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/profiler/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/profiler/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/profiler/Makefile.in	2015-05-01 16:51:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/profiler/Makefile.in	2015-05-01 18:06:42.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -455,12 +501,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -498,12 +545,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -530,27 +578,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -617,13 +668,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 XPROFSRC = \
 	get_tick.h \
 	Profiler.cc \
 	Profiler.h \
 	xprof_type.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/profiler/xprof_type.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/profiler/xprof_type.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/profiler/xprof_type.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/profiler/xprof_type.h	2015-05-01 18:05:19.000000000 +0800
@@ -2,13 +2,13 @@
 #define _PROFILER_XPROF_TYPE_H_
 /* AUTO-GENERATED FILE */
 #if USE_XPROF_STATS
 typedef enum {
 XPROF_PROF_UNACCOUNTED,
 XPROF_aclCheckFast,
-XPROF_aclMatchAclList,
+XPROF_ACL_matches,
 XPROF_calloc,
 XPROF_clientSocketRecipient,
 XPROF_comm_accept,
 XPROF_comm_check_incoming,
 XPROF_comm_close,
 XPROF_comm_connect_addr,
@@ -45,12 +45,13 @@
 XPROF_HttpStateData_processReplyHeader,
 XPROF_HttpStateData_readReply,
 XPROF_InvokeHandlers,
 XPROF_malloc,
 XPROF_MemBuf_append,
 XPROF_MemBuf_consume,
+XPROF_MemBuf_consumeWhitespace,
 XPROF_MemBuf_grow,
 XPROF_mem_hdr_write,
 XPROF_MemObject_write,
 XPROF_parseHttpRequest,
 XPROF_PROF_OVERHEAD,
 XPROF_read,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/Makefile.in	2015-05-01 16:51:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/Makefile.in	2015-05-01 18:06:43.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -431,12 +477,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -474,12 +521,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -506,27 +554,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -593,13 +644,13 @@
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) \
 	-I$(top_srcdir)/lib
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = librfcnb.la
 librfcnb_la_SOURCES = \
 	byteorder.h \
 	rfcnb.h \
 	rfcnb-common.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-common.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-common.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-common.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-common.h	2015-05-01 18:05:19.000000000 +0800
@@ -23,13 +23,13 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #ifndef _RFCNB_RFCNB_COMMON_H
 #define _RFCNB_RFCNB_COMMON_H
 
-#ifdef __cplusplus
+#if defined(__cplusplus)
 extern "C" {
 #endif
 
     /* A data structure we need */
 
     typedef struct RFCNB_Pkt {
@@ -37,11 +37,10 @@
         char *data;             /* The data in this portion */
         int len;
         struct RFCNB_Pkt *next;
 
     } RFCNB_Pkt;
 
-#ifdef __cplusplus
+#if defined(__cplusplus)
 }
-
 #endif
-#endif                          /* _RFCNB_RFCNB_COMMON_H */
+#endif /* _RFCNB_RFCNB_COMMON_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb.h	2015-05-01 18:05:19.000000000 +0800
@@ -25,14 +25,14 @@
 
 #ifndef _RFCNB_RFCNB_H
 #define _RFCNB_RFCNB_H
 
 /* Error responses */
 
-#include "rfcnb/rfcnb-error.h"
 #include "rfcnb/rfcnb-common.h"
+#include "rfcnb/rfcnb-error.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
     /* Defines we need */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-io.c	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-io.c	2015-05-01 18:05:19.000000000 +0800
@@ -22,16 +22,16 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include "rfcnb/std-includes.h"
+#include "rfcnb/rfcnb-io.h"
 #include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-util.h"
-#include "rfcnb/rfcnb-io.h"
+#include "rfcnb/std-includes.h"
 #include <sys/uio.h>
 #include <sys/signal.h>
 
 #if HAVE_STRING_H
 #include <string.h>
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-io.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-io.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-io.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-io.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,6 +1,9 @@
+#ifndef _SQUID__LIB_RFCNB_RFCNB_IO_H
+#define _SQUID__LIB_RFCNB_RFCNB_IO_H
+
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
  *
  * Version 1.0
  * RFCNB IO Routines Defines
  *
  * Copyright (C) Richard Sharpe 1996
@@ -20,9 +23,13 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include "rfcnb/rfcnb.h"
+
 int RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len);
 
 int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len);
+
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-priv.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-priv.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-priv.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-priv.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,15 +29,19 @@
 /* Defines we need */
 
 typedef unsigned short uint16;
 
 #define GLOBAL extern
 
-#include "rfcnb/rfcnb-error.h"
-#include "rfcnb/rfcnb-common.h"
 #include "rfcnb/byteorder.h"
+#include "rfcnb/rfcnb-common.h"
+#include "rfcnb/rfcnb-error.h"
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
 
 #ifdef RFCNB_PORT
 #define RFCNB_Default_Port RFCNB_PORT
 #else
 #define RFCNB_Default_Port 139
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-util.c	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-util.c	2015-05-01 18:05:19.000000000 +0800
@@ -22,17 +22,17 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include "rfcnb/rfcnb.h"
-#include "rfcnb/std-includes.h"
+#include "rfcnb/rfcnb-io.h"
 #include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-util.h"
-#include "rfcnb/rfcnb-io.h"
+#include "rfcnb/rfcnb.h"
+#include "rfcnb/std-includes.h"
 
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 #if HAVE_STRING_H
 #include <string.h>
@@ -359,16 +359,16 @@
 
     return 0;
 }
 
 /* Disconnect the TCP connection to the server */
 int
-RFCNB_Close(int socket)
+RFCNB_Close(int fd)
 {
 
-    close(socket);
+    close(fd);
 
     /* If we want to do error recovery, here is where we put it */
 
     return 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-util.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-util.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/rfcnb-util.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/rfcnb-util.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,6 +1,9 @@
+#ifndef _RFCNB_RFCNB_UTIL_H
+#define _RFCNB_RFCNB_UTIL_H
+
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
  *
  * Version 1.0
  * RFCNB Utility Defines
  *
  * Copyright (C) Richard Sharpe 1996
@@ -20,31 +23,35 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include "rfcnb/std-includes.h"
+
 void RFCNB_CvtPad_Name(char *name1, char *name2);
 
 void RFCNB_AName_To_NBName(char *AName, char *NBName);
 
 void RFCNB_NBName_To_AName(char *NBName, char *AName);
 
 void RFCNB_Print_Hex(FILE * fd, struct RFCNB_Pkt *pkt, int Offset, int Len);
 
 void RFCNB_Print_Pkt(FILE * fd, char *dirn, struct RFCNB_Pkt *pkt, int len);
 
 int RFCNB_Name_To_IP(char *host, struct in_addr *Dest_IP);
 
-int RFCNB_Close(int socket);
+int RFCNB_Close(int fd);
 
 int RFCNB_IP_Connect(struct in_addr Dest_IP, int port);
 
 int RFCNB_Session_Req(struct RFCNB_Con *con,
                       char *Called_Name,
                       char *Calling_Name,
                       BOOL * redirect,
                       struct in_addr *Dest_IP,
                       int *port);
 
 typedef void RFCNB_Prot_Print_Routine(FILE * fd, int dir, struct RFCNB_Pkt *pkt, int header, int payload);
 extern RFCNB_Prot_Print_Routine *Prot_Print_Routine;
+
+#endif /* _RFCNB_RFCNB_UTIL_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/session.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/session.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/session.c	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/session.c	2015-05-01 18:05:19.000000000 +0800
@@ -28,16 +28,16 @@
 int RFCNB_errno = 0;
 int RFCNB_saved_errno = 0;
 #define RFCNB_ERRNO
 
 #include "rfcnb/std-includes.h"
 #include <netinet/tcp.h>
-#include "rfcnb/rfcnb.h"
-#include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-io.h"
+#include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-util.h"
+#include "rfcnb/rfcnb.h"
 
 #if HAVE_STRING_H
 #include <string.h>
 #endif
 
 int RFCNB_Stats[RFCNB_MAX_STATS];
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/std-includes.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/std-includes.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/rfcnb/std-includes.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/rfcnb/std-includes.h	2015-05-01 18:05:19.000000000 +0800
@@ -26,16 +26,22 @@
 #ifndef _RFCNB_STD_INCLUDES_H
 #define _RFCNB_STD_INCLUDES_H
 
 #define BOOL int
 typedef short int16;
 
+#if HAVE_NETDB_H
 #include <netdb.h>
+#endif
 #include <sys/types.h>
+#if HAVE_NETINET_IN_H
 #include <netinet/in.h>
+#endif
+#if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
+#endif
 #include <signal.h>
 #include <errno.h>
 #include <stdio.h>
 #include <unistd.h>
 
 #define TRUE 1
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/smblib/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/smblib/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/smblib/Makefile.in	2015-05-01 16:51:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/smblib/Makefile.in	2015-05-01 18:06:43.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -432,12 +478,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -475,12 +522,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -507,27 +555,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -594,13 +645,13 @@
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) \
 	-I$(top_srcdir)/lib
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libsmblib.la
 libsmblib_la_SOURCES = \
 	md4.c \
 	md4.h \
 	smblib.c \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/smblib/smblib-util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/smblib/smblib-util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/smblib/smblib-util.c	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib/smblib/smblib-util.c	2015-05-01 18:05:19.000000000 +0800
@@ -764,13 +764,13 @@
 /* Pick up the error message associated with an error from SMBlib  */
 
 /* Keep this table in sync with the message codes in smblib-common.h */
 
 static const char *SMBlib_Error_Messages[] = {
 
-    "Request completed sucessfully.",
+    "Request completed successfully.",
     "Server returned a non-zero SMB Error Class and Code.",
     "A lower layer protocol error occurred.",
     "Function not yet implemented.",
     "The protocol negotiated does not support the request.",
     "No space available for operation.",
     "One or more bad parameters passed.",
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib: sspwin32.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/lib: sspwin32.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/tests: testArray.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/lib/tests: testArray.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/Makefile.in	2015-05-01 16:50:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/Makefile.in	2015-05-01 18:06:21.000000000 +0800
@@ -95,14 +95,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
  configure.lineno config.status.lineno
 mkinstalldirs = $(install_sh) -d
@@ -264,12 +310,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -307,12 +354,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -339,27 +387,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/RELEASENOTES.html /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/RELEASENOTES.html
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/RELEASENOTES.html	2015-05-01 17:44:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/RELEASENOTES.html	2015-05-01 18:53:35.000000000 +0800
@@ -1,48 +1,49 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <HTML>
 <HEAD>
  <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
- <TITLE>Squid 3.3.14 release notes</TITLE>
+ <TITLE>Squid 3.4.13 release notes</TITLE>
 </HEAD>
 <BODY>
-<H1>Squid 3.3.14 release notes</H1>
+<H1>Squid 3.4.13 release notes</H1>
 
 <H2>Squid Developers</H2>
 <HR>
-<EM>This document contains the release notes for version 3.3 of Squid.
+<EM>This document contains the release notes for version 3.4 of Squid.
 Squid is a WWW Cache application developed by the National Laboratory
 for Applied Network Research and members of the Web Caching community.</EM>
 <HR>
 <P>
 <H2><A NAME="toc1">1.</A> <A HREF="#s1">Notice</A></H2>
 
 <UL>
 <LI><A NAME="toc1.1">1.1</A> <A HREF="#ss1.1">Known issues</A>
-<LI><A NAME="toc1.2">1.2</A> <A HREF="#ss1.2">Changes since earlier releases of Squid-3.3</A>
+<LI><A NAME="toc1.2">1.2</A> <A HREF="#ss1.2">Changes since earlier releases of Squid-3.4</A>
 </UL>
 <P>
-<H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.2</A></H2>
+<H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.3</A></H2>
 
 <UL>
-<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">SQL Database logging helper</A>
-<LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">Time-Quota session helper</A>
-<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">SSL-Bump Server First</A>
-<LI><A NAME="toc2.4">2.4</A> <A HREF="#ss2.4">Server Certificate Mimic</A>
-<LI><A NAME="toc2.5">2.5</A> <A HREF="#ss2.5">Custom HTTP request headers</A>
+<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Helper protocol extensions</A>
+<LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">SSL Server Certificate Validator</A>
+<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">Store-ID</A>
+<LI><A NAME="toc2.4">2.4</A> <A HREF="#ss2.4">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+<LI><A NAME="toc2.5">2.5</A> <A HREF="#ss2.5">Transaction Annotations</A>
+<LI><A NAME="toc2.6">2.6</A> <A HREF="#ss2.6">Multicast DNS</A>
 </UL>
 <P>
-<H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.2</A></H2>
+<H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.3</A></H2>
 
 <UL>
 <LI><A NAME="toc3.1">3.1</A> <A HREF="#ss3.1">New tags</A>
 <LI><A NAME="toc3.2">3.2</A> <A HREF="#ss3.2">Changes to existing tags</A>
 <LI><A NAME="toc3.3">3.3</A> <A HREF="#ss3.3">Removed tags</A>
 </UL>
 <P>
-<H2><A NAME="toc4">4.</A> <A HREF="#s4">Changes to ./configure options since Squid-3.2</A></H2>
+<H2><A NAME="toc4">4.</A> <A HREF="#s4">Changes to ./configure options since Squid-3.3</A></H2>
 
 <UL>
 <LI><A NAME="toc4.1">4.1</A> <A HREF="#ss4.1">New options</A>
 <LI><A NAME="toc4.2">4.2</A> <A HREF="#ss4.2">Changes to existing options</A>
 <LI><A NAME="toc4.3">4.3</A> <A HREF="#ss4.3">Removed options</A>
 </UL>
@@ -53,184 +54,232 @@
 <LI><A NAME="toc5.1">5.1</A> <A HREF="#ss5.1">Missing squid.conf options available in Squid-2.7</A>
 </UL>
 
 <HR>
 <H2><A NAME="s1">1.</A> <A HREF="#toc1">Notice</A></H2>
 
-<P>The Squid Team are pleased to announce the release of Squid-3.3.14.</P>
+<P>The Squid Team are pleased to announce the release of Squid-3.4.13.</P>
 <P>This new release is available for download from 
-<A HREF="http://www.squid-cache.org/Versions/v3/3.3/">http://www.squid-cache.org/Versions/v3/3.3/</A> or the 
+<A HREF="http://www.squid-cache.org/Versions/v3/3.4/">http://www.squid-cache.org/Versions/v3/3.4/</A> or the
 <A HREF="http://www.squid-cache.org/Download/http-mirrors.html">mirrors</A>.</P>
 
-<P>A large number of the design flaws in SSL-Bump feature have been fixed along with general improvements all around.
+<P>Some interesting new features adding system flexibility have been added along with general improvements all around.
 While this release is not fully bug-free we believe it is ready for use in production on many systems.</P>
 
 <P>We welcome feedback and bug reports. If you find a bug, please see 
 <A HREF="http://wiki.squid-cache.org/SquidFaq/BugReporting">http://wiki.squid-cache.org/SquidFaq/BugReporting</A>
 for how to submit a report with a stack trace.</P>
 
 <H2><A NAME="ss1.1">1.1</A> <A HREF="#toc1.1">Known issues</A>
 </H2>
 
 <P>Although this release is deemed good enough for use in many setups, please note the existence of 
-<A HREF="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.3">open bugs against Squid-3.3</A>.</P>
+<A HREF="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.4">open bugs against Squid-3.4</A>.</P>
 
-
-<H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-3.3</A>
+<H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-3.4</A>
 </H2>
 
-<P>The 3.3 change history can be 
-<A HREF="http://www.squid-cache.org/Versions/v3/3.3/changesets/">viewed here</A>.</P>
+<P>The 3.4 change history can be 
+<A HREF="http://www.squid-cache.org/Versions/v3/3.4/changesets/">viewed here</A>.</P>
+
 
-<H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.2</A></H2>
+<H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.3</A></H2>
 
-<P>Squid 3.3 represents a new feature release above 3.2.</P>
+<P>Squid 3.4 represents a new feature release above 3.3.</P>
 
 <P>The most important of these new features are:
 <UL>
-<LI>SQL Database logging helper</LI>
-<LI>Time-Quota session helper</LI>
-<LI>SSL-Bump Server First</LI>
-<LI>Server Certificate Mimic</LI>
-<LI>Custom HTTP request headers</LI>
+<LI>Helper protocol extensions</LI>
+<LI>SSL Server Certificate Validator</LI>
+<LI>Store-ID</LI>
+<LI>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</LI>
+<LI>Transaction Annotations</LI>
+<LI>Multicast DNS</LI>
 </UL>
 </P>
 <P>Most user-facing changes are reflected in squid.conf (see below).</P>
 
-<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">SQL Database logging helper</A>
+
+<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">Helper protocol extensions</A>
 </H2>
 
-<P><EM>log_db_daemon</EM> - Database logging daemon for Squid</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
+
+<P>The Squid helper protocol used to communicate with authenticators,
+URL-rewriters, Redirectors, and External ACL helpers has been updated
+and extended.</P>
 
-<P>This program writes Squid access.log entries to an SQL database.
-Written in Perl it can utilize any database supported by the Perl
-database abstraction layer.</P>
+<P><EM>BH</EM> status code is now accepted from all helpers to report
+internal error events separate from <EM>ERR</EM> rejection code.
+Permitting Squid to perform recovery operations specific to
+helper failure instead of a blanket client rejection.</P>
 
-<P>NOTE: Presently it only accepts the Squid native log format.</P>
+<P>Arbitrary key-value pairs can be returned from any helper.
+Allowing future helpers to be forward- and backward- compatible
+with this and future versions of Squid.</P>
 
 
-<H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">Time-Quota session helper</A>
+<H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">SSL Server Certificate Validator</A>
 </H2>
 
-<P><EM>ext_time_quota_acl</EM> - Time quota external ACL helper.</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/SslServerCertValidator">http://wiki.squid-cache.org/Features/SslServerCertValidator</A>.</P>
+
+<P>The helper consulted after the internal OpenSSL validation, regardless of the
+validation results. The helper will receive:</P>
+<P>
+<UL>
+<LI>the origin server certificate (chain),</LI>
+<LI>the intended domain name, and</LI>
+<LI>a list of OpenSSL validation errors (if any).</LI>
+</UL>
+</P>
 
-<P>Allows an administrator to define time budgets (quota) for the
-users of Squid to limit the time using Squid.</P>
+<P>If the helper decides to honor an OpenSSL error or report another validation 
+error(s), the helper will return:</P>
+<P>
+<UL>
+<LI>A list of certificates.</LI>
+<LI>A list of items consists the the validation error name (see <EM>%err_name</EM>
+error page macro and <EM>%err_details</EM> code for <EM>logformat</EM>), error reason
+(<EM>%ssl_lib_error macro</EM>), and the offending certificate.</LI>
+</UL>
+</P>
 
-<P>This is useful for corporate lunch time allocations, wifi portal
-pay-per-minute installations or for parental control of children.</P>
+<P>The returned information mimics what the internal OpenSSL-based validation code
+collects now. Returned errors, if any, are fed to <EM>sslproxy_cert_error</EM>,
+triggering the existing SSL error processing code.</P>
 
-<P>The administrator can define a time budget (e.g. 1 hour per day)
-which is enforced through this helper using session estimations
-of their browsing time. A 'pause' threshold is given in seconds
-and defines the period between two requests to be treated as part
-of the same session. Pauses shorter than this value will be
-counted against the quota, longer ones ignored.</P>
+<P>The helper invocation controlled by the <EM>sslcrtvalidator_program</EM> and
+<EM>sslcrtvalidator_children</EM> configurations options which are similar to the
+<EM>ssl_crtd</EM> related options. </P>
 
 
-<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">SSL-Bump Server First</A>
+<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">Store-ID</A>
 </H2>
 
 <P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/BumpSslServerFirst">http://wiki.squid-cache.org/Features/BumpSslServerFirst</A>.</P>
+<A HREF="http://wiki.squid-cache.org/Features/StoreID">http://wiki.squid-cache.org/Features/StoreID</A>.</P>
 
-<P>When an intercepted connection is received, Squid first connects
-to the server using SSL and receives the server certificate.
-Squid then uses the host name inside the true server certificate
-to generate a fake one and impersonates the server while still
-using the already established secure connection to the server.</P>
-
-<P>Bumping server first is essentially required for handling
-intercepted HTTPS connections but the same scheme should be used
-for most HTTP CONNECT requests because it offers a few advantages
-compared to the old bump-client-first approach:</P>
-<P>
-<UL>
-<LI>When Squid knows valid server certificate details, it can
-generate its fake server certificate with those details.
-With the bump-client-first scheme, all those details are lost.
-In general, browsers do not care about those details but there
-may be HTTP clients (or even human users) that require or could
-benefit from knowing them.
-</LI>
-<LI>When a server sends a bad certificate, Squid may be able to
-replicate that brokenness in its own fake certificate, giving
-the HTTP client control whether to ignore the problem or
-terminate the transaction. With bump-client-furst, it is
-difficult to support similar dynamic, user-directed opt out; 
-Squid itself has to decide what to do when the server
-certificate cannot be validated.
-</LI>
-<LI>When a server asks for a client certificate, Squid may be
-able to ask the client and then forward the client certificate
-to the server. Such client certificate handling may not be
-possible with the bump-client-first scheme because it would
-have to be done after the SSL handshake.
+<P>This feature is a redesigned equivalent to the Squid-2.7 feature known as StoreURL-rewrite.</P>
+
+<P><EM>Notice</EM> that this is not a direct portage of the Squid-2.7 feature so behaviour
+differences do exist. Although the new feature works in similar enough ways that the old
+helper scripts used for Squid-2.7 are expected to work in this and later versions of Squid.</P>
+
+<P>Squid traditionally uses the requested URL as an index key ID to locate objects in cache.
+It is not the only key possible and the Store-ID feature exposes an API for external
+helpers to provide Squid with an alternative key name for any URL.</P>
+
+<P>When any client request is received which requires a cache lookup the URL is passed to
+a helper specified with the <EM>store_id_program</EM> directive to check for an alternative
+Store ID. This allows the helper to identify URLs which refer to duplicate resources and
+de-duplicate the cache content. <EM>store_id_access</EM> is provided to allow ACL-based
+tuning of which traffic gets sent to the helper and reduce overheads.</P>
+
+<P>One subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
+this feature is that <EM>refresh_pattern</EM> applies its regex argument against the Store
+ID key and not the transaction URL. So using the Store-ID feature to alter the value
+affects which <EM>refresh_pattern</EM> directive will be matched.</P>
+
+<P>Store-ID helpers bundled with Squid can be built with the --enable-storeid-rewrite-helpers
+option which is added in this version. Currently there is a <EM>file</EM> helper
+provided.</P>
+
+
+<H2><A NAME="ss2.4">2.4</A> <A HREF="#toc2.4">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+</H2>
+
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf">http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf</A>.</P>
+
+<P>The Packet Filter (PF) firewall in OpenBSD 4.4 and later offers traffic interception
+using several very simple methods. One of which is the <EM>divert-to</EM> rule type
+which acts as a simple routing diversion instead of performing NAT packet alterations.</P>
+
+<P>The IP Firewall (IPFW) on FreeBSD 9+ contains a port of the Linux Netfilter TPROXY feature.</P>
+
+<P>This version of Squid adds support for these features through the ./configure
+options --enable-pf-transparent and --enable-ipfw-transparent when Squid is built on
+systems with the required support. No special extras are required to enable
+<EM>http_port ... tproxy</EM> configuration to work.</P>
+
+<P>NOTE: To resolve NAT lookup issues on recent PF firewall versions the code behind
+<EM>./configure --enable-pf-transparent</EM> has been altered and is expected to
+break on the version of PF firewall shipped with BSD systems such as NetBSD and FreeBSD
+which do not yet support the getsockname() API.
+These systems require <EM>--with-nat-devpf</EM> to enable /dev/pf support when using PF firewall.</P>
+
+
+<H2><A NAME="ss2.5">2.5</A> <A HREF="#toc2.5">Transaction Annotations</A>
+</H2>
+
+<P>Previously the only annotation methods available were ICAP/eCAP HTTP header insertions
+or external ACL <EM>tag=</EM> result code. Each of which had only limited possibilities
+for use and little or no correlation.</P>
+
+<P>It is now possible to add annotations to a client transaction from several sources:
+<UL>
+<LI>    Directly from squid.conf using the <EM>note</EM> directive with
+ACL-based selection of which annotation is linked to any
+particular transaction.
 </LI>
-<LI>Some clients (e.g., Rekonq browser v0.7.x) do not send host
-names in CONNECT requests. Such clients require bump-server-first
-even in forward proxying mode. Unfortunately, there are other
-problems with fully supporting such clients (i.e., Squid does
-not know whether the IP address in the CONNECT request is what
-the user have typed into the address bar) so not all features
-will work well for them until more specialized detection code
-is added.</LI>
+<LI>    By configured helper processes returning a key=value pair.
+The key name becomes the annotation name.</LI>
 </UL>
 </P>
 
-<H2><A NAME="ss2.4">2.4</A> <A HREF="#toc2.4">Server Certificate Mimic</A>
-</H2>
+<P>Annotations on the transaction can be passed to ICAP services or eCAP modules using the
+<EM>adaptation_meta</EM> directive to send them as headers.
+They can also be logged using the <EM>%note</EM> log format code in custom logs. With
+the new helper response syntax changes this means all helper response key=value details
+such as URL-rewrite or store-id changes, external ACL tag etc. are now able to be logged.</P>
 
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/MimicSslServerCert">http://wiki.squid-cache.org/Features/MimicSslServerCert</A>.</P>
+<P>Annotations which are already assigned to a transaction can be checked using an ACL test
+of the new <EM>note</EM> ACL type. This can match a particular note by name and value,
+of for any notes with a given name.</P>
 
-<P>One of the SslBump features serious drawbacks is the loss of
-information embedded in SSL server certificate.
-This certificate mimic feature passes original SSL server
-certificate information to the user. Allowing the user to
-make an informed decision on whether to trust the server
-certificate.</P>
+<P>NOTE: not all helper interfaces are yet enabled to convert key=value into annotations
+and the external ACL interface does not yet send annotations to the helper.</P>
 
 
-<H2><A NAME="ss2.5">2.5</A> <A HREF="#toc2.5">Custom HTTP request headers</A>
+<H2><A NAME="ss2.6">2.6</A> <A HREF="#toc2.6">Multicast DNS</A>
 </H2>
 
-<P>The <EM>request_header_add</EM> option is added to insert
-HTTP header fields to outgoing HTTP requests (i.e.,
-request headers sent by Squid to the next HTTP hop such as a
-cache peer or an origin server). The option has no effect on
-cache hit traffic or requests serviced by Squid and ICAP.</P>
+<P>The internal DNS component of Squid now supports multicast DNS (mDNS) resolution in
+accordance with RFC 6762.</P>
 
-<P>WARNING: If a standard HTTP header name is used, Squid does not check whether
-the new header conflicts with any existing headers or violates
-HTTP rules. If the request to be modified already contains a
-field with the same name, the old field is preserved but the
-header field values are not merged.</P>
+<P>The <EM>dns_multicast_local</EM> directive must be set to <EM>on</EM> to enable this
+feature.</P>
 
-<P>Field-value set can be either a token or a quoted string. If quoted
-string format is used, then the surrounding quotes are removed
-while escape sequences and %macros are processed.</P>
+<P>The multicast DNS group IP addresses for IPv4 and IPv6 resolving are added to the set
+of available DNS resolvers and used automatically for domain names ending in <EM>.local</EM>
+and reverse-DNS lookups before attempting a secondary resolution on the configured
+resolvers. Domains without <EM>.local</EM> are resolved using only the configured resolvers.</P>
 
-<P>In theory, all of the <EM>logformat</EM> codes can be used as %macros.
-However, unlike logging (which happens at the very end of
-transaction lifetime), the transaction may not yet have enough
-information to expand a macro when the new header value is needed.
-And some information may already be available to Squid but not yet
-committed where the macro expansion code can access it (please report
-such instances!). The macro will be expanded into a single dash
-('-') in such cases. Not all macros have been tested.</P>
+<P>Statistics for multicast DNS resolution can be found on the <EM>idns</EM> cache manager
+report.</P>
 
-<P>One or more Squid ACLs may be specified to restrict header
-injection to matching requests. As always in squid.conf, all
-ACLs in an option ACL list must be satisfied for the insertion
-to happen. The <EM>request_header_add</EM> option supports fast ACLs only.</P>
+<P><EM>NOTE</EM> that the external DNS helper interface is now deprecated and has been
+removed from future Squid versions. Any installations still using it for local hostname
+resolution need to upgrade to mDNS resolution with this Squid version.</P>
 
 
-<H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.2</A></H2>
+<H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.3</A></H2>
 
-<P>There have been changes to Squid's configuration file since Squid-3.2.</P>
+<P>There have been changes to Squid's configuration file since Squid-3.3.</P>
+
+<P>Squid supports reading configuration option parameters from external
+files using the syntax <EM>parameters("/path/filename")</EM>. For example:
+<PRE>
+    acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
+</PRE>
+</P>
+
+<P>There have also been changes to individual directives in the config file.</P>
 <P>This section gives a thorough account of those changes in three categories:</P>
 <P>
 <UL>
 <LI>
 <A HREF="#newtags">New tags</A></LI>
 <LI>
@@ -243,87 +292,174 @@
 
 <H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A>
 </H2>
 
 <P>
 <DL>
-<DT><B>cache_miss_revalidate</B><DD>
-<P>Whether Squid is to pass-through If-Modified-Since and If-None-Match headers on cache MISS.
-Revalidation requests can prevent cache gathering objects to HIT on.</P>
-<P>Based on the Squid-2.7 <EM>ignore_ims_on_miss</EM> feature.</P>
-<P><EM>IMPORTANT:</EM> the meaning for on/off values has changed along with the name since 2.7.</P>
-
-<DT><B>request_header_add</B><DD>
-<P>New directive to add custom headers on HTTP traffic sent to upstream servers.</P>
-
-<DT><B>sslproxy_cert_sign</B><DD>
-<P>New option to determine how the client certificate sent to upstream servers is signed.</P>
+<DT><B>configuration_includes_quoted_values</B><DD>
+<P>Whether Squid supports directive parameters with spaces, quotes, and other
+special characters. Surround such parameters with "double quotes" and
+also set this directive on/off around the relevant squid.conf line(s)
+making use of such quoting.</P>
+
+<DT><B>dns_multicast_local</B><DD>
+<P>Use multicast DNS for <EM>.local</EM> domains and reverse-DNS resolution.</P>
+
+<DT><B>note</B><DD>
+<P>Use ACLs to annotate a transaction with customized annotations
+which can be logged in access.log</P>
+
+<DT><B>spoof_client_ip</B><DD>
+<P>Access control to determine whether to disable the TPROXY spoofing on upstream traffic.</P>
+
+<DT><B>sslcrtvalidator_children</B><DD>
+<P>Specifies the settings for how many SSL server certificate
+validator helpers are run and when they are started.</P>
+
+<DT><B>sslcrtvalidator_program</B><DD>
+<P>Specifies the location of a SSL server certificate validator helper.</P>
+
+<DT><B>store_id_access</B><DD>
+<P>Whether the URL for a given request is passed to the Store-ID helper process.
+Used to improve StoreID performance by quickly eliminating helper delays using ACL tests.</P>
+<P>Ported equivalent to <EM>storeurl_access</EM> from 2.7</P>
+
+<DT><B>store_id_bypass</B><DD>
+<P>Whether the StoreID helper may be bypassed when overloaded.</P>
+
+<DT><B>store_id_children</B><DD>
+<P>Controls the number of StoreID helper processes.</P>
+<P>Options <EM>startup=N</EM>, <EM>idle=N</EM>, <EM>concurrency=N</EM>
+<UL>
+<LI>startup=N allow finer tuning of how many helpers are started initially.</LI>
+<LI>idle=N allow fine tuning of how many helper to retain as buffer against sudden traffic loads.</LI>
+<LI>concurrency=N was previously called url_rewrite_concurrency as a distinct directive.</LI>
+</UL>
+</P>
 
-<DT><B>sslproxy_cert_adapt</B><DD>
-<P>New option to adapt certain properties of outgoing SSL certificates generated for use when bumping SSL to an upstream server.</P>
+<DT><B>store_id_rewrite_program</B><DD>
+<P>A helper program to provide cache storage internal key ID value for a request.</P>
+<P>Ported equivalent to <EM>storeurl_rewrite_program</EM> from 2.7</P>
 
 </DL>
 </P>
 
 <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Changes to existing tags</A>
 </H2>
 
 <P>
 <DL>
-<DT><B>acl</B><DD>
-<P><EM>myport</EM> and <EM>myip</EM>ACL types replaced with <EM>localport</EM> and <EM>localip</EM> respectively.
-To reflect that it matches the TCP connection details and not the squid.conf port.
-This matters when dealing with intercepted traffic, where the Squid receiving port differs from the TCP connection IP:port.
-Always use <EM>myportname</EM> type to match the squid.conf port details.</P>
-<P>New default built-in ACLs for testing SSL certificate properties.</P>
-<P><EM>ssl::certHasExpired</EM>,
-<EM>ssl::certNotYetValid</EM>,
-<EM>ssl::certDomainMismatch</EM>,
-<EM>ssl::certUntrusted</EM>,
-<EM>ssl::certSelfSigned</EM>.</P>
+<DT><B>access_log</B><DD>
+<P>Configuration syntax extended to support name=value options.
+<EM>New Syntax:</EM> access_log module:place [option ...] [acl ...]</P>
+<P>New option <EM>logformat=</EM> to specify the logging format name.</P>
+<P>New option <EM>buffer-size=</EM> to specify how large the log buffer
+for this log is to be when <EM>buffered_logs</EM> is enabled.</P>
+<P>New option <EM>on-error=</EM> to specify what handling is to be done
+if the logging module encounters a non-recoverable error writing logs.
+With the value <EM>die</EM> (the default) Squid halts operation.
+With the value <EM>drop</EM> Squid drops log lines and continue running.</P>
 
-<DT><B>client_netmask</B><DD>
-<P>IP address 127.0.0.1 (localhost IPv4) is no longer masked.</P>
+<DT><B>acl</B><DD>
+<P>New test type <EM>server_cert_fingerprint</EM> to match against 
+server SSL certificate fingerprint.</P>
+<P>New test type <EM>note</EM> to match against transaction annotations
+by name and value, or just by name.</P>
+<P>New test type <EM>any-of</EM> to match if any one of a set of named ACLs.</P>
+<P>New test type <EM>all-of</EM> to match against all of a set of named ACLs.</P>
+
+<DT><B>auth_param</B><DD>
+<P>New result code <EM>BH</EM> to signal helper internal errors
+available in all authentication schemes.</P>
+<P>New key <EM>message=</EM> for error message details in all authentication schemes.</P>
+<P>New result code <EM>OK</EM> and key <EM>ha1=</EM> in Digest authentication.</P>
+<P>New result codes <EM>OK</EM>, <EM>ERR</EM> replace result codes <EM>AF</EM>,
+and <EM>NA</EM> in NTLM and Negotiate authentication.</P>
+<P>New key <EM>token=</EM> for NTLM and Negotiate authentication <EM>OK</EM> responses.</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
 
 <DT><B>external_acl_type</B><DD>
-<P><EM>%ACL</EM> format tag ported from 2.6.
-Sends the name of ACL being tested to the external helper.</P>
-<P><EM>%DATA</EM> format tag ported from 2.6.
-Inserts the ACL arguments into a particular location of the helper input instead of at the end of the line.</P>
+<P>Deprecated <EM>protocol=3.0</EM> option. No longer necessary.</P>
+<P>New result code <EM>BH</EM> to signal helper internal errors</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
+
+<DT><B>http_port</B><DD>
+<P>Support IPv6 for <EM>intercept</EM> mode. Requires ip6tables support on Linux,
+PF support on OpenBSD and IPFW support on FreeBSD. Squid will no longer complain
+about misconfiguration if IPv6 support is missing, we now rely on the firewall
+tools reporting misconfiguration when the NAT rules are created.</P>
+<P>Support <EM>tproxy</EM> mode traffic on BSD systems with BINDANY support
+(OpenBSD 5+, FreeBSD 9+ so far).</P>
+<P>Changed build options behind <EM>intercept</EM> traffic mode handling on BSD.
+see <EM>--enable-pf-transparent</EM> for more details.</P>
 
 <DT><B>logformat</B><DD>
-<P>New token <EM>%ssl::bump_mode</EM> to log the SSL-bump mode type performed on a request.
-Logs values of: <EM>-</EM>, <EM>none</EM>, <EM>client-first</EM>, or <EM>server-first</EM>.</P>
-<P>New token of <EM>%ssl::&gt;cert_subject</EM> to log the Subject field of a SSL certificate received from the client.</P>
-<P>New token of <EM>%ssl::&gt;cert_issuer</EM> to log the Issuer field of a SSL certificate received from the client.</P>
-
-<DT><B>ssl_bump</B><DD>
-<P>New action types <EM>none</EM>, <EM>client-first</EM>, <EM>server-first</EM>. The default is <EM>none</EM>.</P>
-<P>Use of <EM>allow</EM>/<EM>deny</EM> is now deprecated and they should be removed as soon as possible.
-To retain the exact same behaviour between 3.3 and older releases replace <EM>deny</EM> with <EM>none</EM>,
-and <EM>allow</EM> with <EM>client-first</EM>. However an upgrade to <EM>server-first</EM> is the recommended.</P>
-<P><EM>NOTE</EM>: Mixing of allow/deny with the new action types is prohibited and will cause Squid to exit with a FATAL error.</P>
+<P>New format code <EM>%note</EM> to log a transaction annotation linked to the
+transaction by ICAP, eCAP, a helper, or the <EM>note</EM> squid.conf directive.</P>
+<P>New format code <EM>%&gt;qos</EM> to log client connection TOS/DSCP value set by Squid.</P>
+<P>New format code <EM>%&lt;qos</EM> to log server connection TOS/DSCP value set by Squid.</P>
+<P>New format code <EM>%&gt;nfmark</EM> to log client connection netfilter mark set by Squid.</P>
+<P>New format code <EM>%&lt;nfmark</EM> to log server connection netfilter mark set by Squid.</P>
+
+<DT><B>pipeline_prefetch</B><DD>
+<P>Updated to take a numeric count of prefetched pipeline requests instead of ON/OFF.</P>
+
+<DT><B>refresh_pattern</B><DD>
+<P><EM>NOTE:</EM> the regular expression pattern operates on the cache Store-ID value.
+Which by default is identical to the requested URL, but may differ for some
+objects if the Store-ID feature is in use.</P>
+
+<DT><B>unlinkd_program</B><DD>
+<P>New helper response format utilizing result codes <EM>OK</EM> and <EM>BH</EM>,
+to signal helper lookup results. Also, key-value response values to return
+multiple values to Squid.</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
+
+<DT><B>url_rewrite_program</B><DD>
+<P>New helper response format utilizing result codes <EM>OK</EM>, <EM>ERR</EM>,
+and <EM>BH</EM> to signal helper lookup results. Also, key-value response
+values to return multiple values to Squid.</P>
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
 
 </DL>
 </P>
 
 <H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed tags</A>
 </H2>
 
 <P>
 <DL>
-<DT><B>ignore_ims_on_miss</B><DD>
-<P>This option has been replaced by the <EM>cache_miss_revalidate</EM> feature.</P>
+<DT><B>log_access</B><DD>
+<P>Removed. Use access_log with ACLs instead</P>
+
+<DT><B>log_icap</B><DD>
+<P>Removed. Use icap_log with ACLs instead</P>
+
+<DT><B>storeurl_access</B><DD>
+<P>Replaced by <EM>store_id_access</EM>.</P>
+
+<DT><B>storeurl_rewrite_children</B><DD>
+<P>Replaced by <EM>store_id_children</EM>.</P>
+
+<DT><B>storeurl_rewrite_concurrency</B><DD>
+<P>Replaced by <EM>store_id_children</EM> with <EM>concurrency=N</EM> option.</P>
+
+<DT><B>storeurl_rewrite_program</B><DD>
+<P>Replaced by <EM>store_id_program</EM>.</P>
 
 </DL>
 </P>
 
 
-<H2><A NAME="s4">4.</A> <A HREF="#toc4">Changes to ./configure options since Squid-3.2</A></H2>
+<H2><A NAME="s4">4.</A> <A HREF="#toc4">Changes to ./configure options since Squid-3.3</A></H2>
 
-<P>There have been some changes to Squid's build configuration since Squid-3.2.</P>
+<P>There have been some changes to Squid's build configuration since Squid-3.3.</P>
 <P>This section gives an account of those changes in three categories:</P>
 <P>
 <UL>
 <LI>
 <A HREF="#newoptions">New options</A></LI>
 <LI>
@@ -336,48 +472,73 @@
 
 <H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New options</A>
 </H2>
 
 <P>
 <DL>
-<P><EM>There are no new ./configure options in Squid-3.3.</EM></P>
+<DT><B>--enable-storeid-rewrite-helpers</B><DD>
+<P>New option to control which Store-ID helpers are built. As with other
+helper options use --disable-* to prevent any helpers building and
+omit to get all helper auto-detected.</P>
+<P>Currenly only a helper using <EM>file</EM> for backend is provided.</P>
+
+<DT><B>--disable-arch-native</B><DD>
+<P>New option to disable use of -march=native compiler flag.</P>
+<P>The new flag auto-enables CPU-specific optimizations in GCC and is
+required by Clang++ v3.2 for correct 64-bit environment detection.
+It does not always work well however, so this build option is provided
+to remove it when necessary.</P>
+
+<DT><B>--with-nat-devpf</B><DD>
+<P>New option to alter the behaviour of <EM>http_port ... intercept</EM> option
+in squid.conf.</P>
+<P>When this option is used Squid performs the /dev/pf lookups required to
+support PF <EM>rdr-to</EM> rules. Otherwise Squid will perform perform the
+getsockname() API calls to support PF <EM>divert-to</EM> rules.</P>
+<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+the getsockname() API in recent PF versions require this option.</P>
 
 </DL>
 </P>
 
 <H2><A NAME="modifiedoptions"></A> <A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Changes to existing options</A>
 </H2>
 
 <P>
 <DL>
-<DT><B>--enable-kqueue</B><DD>
-<P>kqueue network I/O module is now built by default when it is available.
-This option is no longer required to enable kqueue support,
-but if used will abort build when kqueue dependencies are missing or broken.</P>
-
-<DT><B>--disable-kqueue</B><DD>
-<P>kqueue network I/O module is now built by default when it is available.
-This configure option is now needed to disable it. Previously it did nothing.</P>
+<DT><B>--enable-pf-transparent</B><DD>
+<P>NAT table support updated to use the getsockname() API provided by the
+latest PF versions <EM>divert-to</EM>. This allows <EM>http_port</EM>
+in squid.conf to support both <EM>intercept</EM> and <EM>tproxy</EM> traffic
+and to silence NAT lookup failure messages on recent BSD.</P>
+<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+the getsockname() API in recent PF versions require <EM>--with-nat-devpf</EM>
+to re-enable /dev/pf support when using PF firewall.</P>
+
+<DT><B>--disable-translation</B><DD>
+<P>Default changed to prevent translating error page templates during build.
+Use --enable-translation to explicitly build and install the templates.</P>
+<P>The latest pre-translated templates can be downloaded from 
+<A HREF="http://www.squid-cache.org/Versions/langpack/">http://www.squid-cache.org/Versions/langpack/</A></P>
 
 </DL>
 </P>
 <H2><A NAME="removedoptions"></A> <A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">Removed options</A>
 </H2>
 
 <P>
 <DL>
-<DT><B>--enable-ntlm-fail-open</B><DD>
-<P>This has not been supported by Squid for several versions.</P>
+<P><EM>There are no removed ./configure options in Squid-3.4.</EM></P>
 
 </DL>
 </P>
 
 
 <H2><A NAME="s5">5.</A> <A HREF="#toc5">Regressions since Squid-2.7</A></H2>
 
-<P>Some squid.conf and ./configure options which were available in Squid-2.7 are not yet available in Squid-3.3</P>
+<P>Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-3.4</P>
 
 <P>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.</P>
 
 <H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options available in Squid-2.7</A>
 </H2>
 
@@ -429,22 +590,13 @@
 <P><EM>ignore-stale-while-revalidate=</EM> not yet ported from 2.7</P>
 <P><EM>negative-ttl=</EM> not yet ported from 2.7</P>
 
 <DT><B>refresh_stale_hit</B><DD>
 <P>Not yet ported from 2.7</P>
 
-<DT><B>storeurl_access</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_children</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_concurrency</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_program</B><DD>
+<DT><B>update_headers</B><DD>
 <P>Not yet ported from 2.7</P>
 
 </DL>
 </P>
 
 </BODY>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/scripts/find-alive.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/scripts/find-alive.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/scripts/find-alive.pl	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/scripts/find-alive.pl	2015-05-01 18:05:19.000000000 +0800
@@ -46,13 +46,13 @@
 	HttpStateData => [
 		'HttpStateData (\S+) created',
 		'HttpStateData (\S+) destroyed',
 	],
 	cbdata => [
 		'cbdataAlloc: (\S+)',
-		'cbdataFree: Freeing (\S+)',
+		'(?:cbdataFree|cbdataUnlock): Freeing (\S+)',
 	],
 	FD => [
 		'fd_open.*\sFD (\d+)',
 		'fd_close\s+FD (\d+)',
 	],
 );
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/scripts/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/scripts/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/scripts/Makefile.in	2015-05-01 16:51:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/scripts/Makefile.in	2015-05-01 18:06:44.000000000 +0800
@@ -86,14 +86,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -178,12 +224,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -221,12 +268,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -253,27 +301,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/scripts/trace-job.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/scripts/trace-job.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/scripts/trace-job.pl	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/scripts/trace-job.pl	2015-05-01 18:05:19.000000000 +0800
@@ -18,14 +18,14 @@
 
 my $inside = 0;
 
 my $entering;
 
 while (<>) {
-	$entering = $_ if !$inside && /\| entering\b/;
-	undef $entering if /\| leaving\b/;
+	$entering = $_ if !$inside && /[|:] entering\b/;
+	undef $entering if /[|:] leaving\b/;
 
 	# if (!$inside && /\bcalled\b.*\b$XactId\b/o) {
 	if (!$inside && /\bstatus in\b.*\b$XactId\b/o) {
 		print $entering if defined $entering;
 		$inside = 1;
 	}
@@ -36,13 +36,13 @@
 	print "\n" if $external;
 
 	next unless $inside;
 
 	# if (/\bended\b.*\b$XactId\b/o || /\bswan\s+sang\b.*\b$XactId\b/o) {
 	# if (/\bstatus out\b.*\b$XactId\b/o || /\bswan\s+sang\b.*\b$XactId\b/o ||
-	if (/\| leaving\b/) {
+	if (/[|:] leaving\b/) {
 		print "\n";
 		$inside = 0;
 	}
 }
 
 exit(0);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/scripts/trace-master.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/scripts/trace-master.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/scripts/trace-master.pl	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/scripts/trace-master.pl	2015-05-01 18:05:19.000000000 +0800
@@ -24,14 +24,14 @@
 my %Jobs = ();
 
 my $inside = 0;
 my $entering;
 
 while (<STDIN>) {
-	$entering = $_ if !$inside && /\| entering\b/;
-	undef $entering if /\| leaving\b/;
+	$entering = $_ if !$inside && /[|:] entering\b/;
+	undef $entering if /[|:] leaving\b/;
 
 	if (!$inside && /\bstatus in\b.*\b(?:async|job|icapx)(\d+)\b/o) {
 		$inside = $1;
 		&enterJob($inside);
 		&updateJob($inside, $entering) if defined $entering;
 		undef $entering;
@@ -45,13 +45,13 @@
 	&updateJob($inside, $_);
 
 	if (/AsyncJob constructed.*\[\S+?(\d+)\]/) {
 		&linkJobs($inside, $1, $_);
 	}
 	
-	if (/\| leaving\b/) {
+	if (/[|:] leaving\b/) {
 		$inside = 0;
 	}
 }
 
 foreach my $id (@InterestingJobs) {
 	# Squid uses asyncNNN, jobNNN, icapxNNN for the same job/transaction
@@ -155,9 +155,9 @@
 	my $history = $job->{history};
 	my @lines = split(/\n/, $history);
 	&reportJobParam($id, 'history', (scalar @lines) . " entries");
 
 	foreach my $line (@lines) {
 		print "$line\n";
-		print "\n" if $line =~ /\| leaving\b/;
+		print "\n" if $line =~ /[|:] leaving\b/;
 	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/snmplib/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/snmplib/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/snmplib/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/snmplib/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,14 +1,14 @@
 ## Process this file with automake to produce Makefile.in
 ##
 ## Makefile for libsnmp.
 ## 
 AM_CFLAGS = $(SQUID_CFLAGS)
 AM_CXXFLAGS = $(SQUID_CXXFLAGS)
-noinst_LIBRARIES = libsnmplib.a
-libsnmplib_a_SOURCES  = asn1.c parse.c snmp_vars.c \
+noinst_LTLIBRARIES = libsnmplib.la
+libsnmplib_la_SOURCES  = asn1.c parse.c snmp_vars.c \
 	coexistance.c snmp_api.c snmp_error.c  \
 	mib.c snmp_api_error.c   \
 	snmp_msg.c \
 	snmp_pdu.c  snmplib_debug.c
 
 INCLUDES = \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/snmplib/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/snmplib/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/snmplib/Makefile.in	2015-05-01 16:51:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/snmplib/Makefile.in	2015-05-01 18:06:44.000000000 +0800
@@ -86,34 +86,77 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-ARFLAGS = cru
-AM_V_AR = $(am__v_AR_@AM_V@)
-am__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)
-am__v_AR_0 = @echo "  AR      " $@;
-am__v_AR_1 = 
-libsnmplib_a_AR = $(AR) $(ARFLAGS)
-libsnmplib_a_LIBADD =
-am_libsnmplib_a_OBJECTS = asn1.$(OBJEXT) parse.$(OBJEXT) \
-	snmp_vars.$(OBJEXT) coexistance.$(OBJEXT) snmp_api.$(OBJEXT) \
-	snmp_error.$(OBJEXT) mib.$(OBJEXT) snmp_api_error.$(OBJEXT) \
-	snmp_msg.$(OBJEXT) snmp_pdu.$(OBJEXT) snmplib_debug.$(OBJEXT)
-libsnmplib_a_OBJECTS = $(am_libsnmplib_a_OBJECTS)
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsnmplib_la_LIBADD =
+am_libsnmplib_la_OBJECTS = asn1.lo parse.lo snmp_vars.lo \
+	coexistance.lo snmp_api.lo snmp_error.lo mib.lo \
+	snmp_api_error.lo snmp_msg.lo snmp_pdu.lo snmplib_debug.lo
+libsnmplib_la_OBJECTS = $(am_libsnmplib_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
 am__v_P_0 = false
 am__v_P_1 = :
 AM_V_GEN = $(am__v_GEN_@AM_V@)
 am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
@@ -126,16 +169,12 @@
 DEFAULT_INCLUDES = 
 depcomp = $(SHELL) $(top_srcdir)/cfgaux/depcomp
 am__depfiles_maybe = depfiles
 am__mv = mv -f
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-AM_V_lt = $(am__v_lt_@AM_V@)
-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
-am__v_lt_0 = --silent
-am__v_lt_1 = 
 LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
 	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
 	$(AM_CFLAGS) $(CFLAGS)
 AM_V_CC = $(am__v_CC_@AM_V@)
 am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
@@ -146,14 +185,14 @@
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
 am__v_CCLD_0 = @echo "  CCLD    " $@;
 am__v_CCLD_1 = 
-SOURCES = $(libsnmplib_a_SOURCES)
-DIST_SOURCES = $(libsnmplib_a_SOURCES)
+SOURCES = $(libsnmplib_la_SOURCES)
+DIST_SOURCES = $(libsnmplib_la_SOURCES)
 am__can_run_installinfo = \
   case $$AM_UPDATE_INFO_DIR in \
     n|no|NO) false;; \
     *) (install-info --version) >/dev/null 2>&1;; \
   esac
 am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
@@ -234,12 +273,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -277,12 +317,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -309,27 +350,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = 3.4
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -389,14 +433,14 @@
 target_alias = @target_alias@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 AM_CFLAGS = $(SQUID_CFLAGS)
 AM_CXXFLAGS = $(SQUID_CXXFLAGS)
-noinst_LIBRARIES = libsnmplib.a
-libsnmplib_a_SOURCES = asn1.c parse.c snmp_vars.c \
+noinst_LTLIBRARIES = libsnmplib.la
+libsnmplib_la_SOURCES = asn1.c parse.c snmp_vars.c \
 	coexistance.c snmp_api.c snmp_error.c  \
 	mib.c snmp_api_error.c   \
 	snmp_msg.c \
 	snmp_pdu.c  snmplib_debug.c
 
 INCLUDES = \
@@ -436,37 +480,43 @@
 $(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(am__aclocal_m4_deps):
 
-clean-noinstLIBRARIES:
-	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
 
-libsnmplib.a: $(libsnmplib_a_OBJECTS) $(libsnmplib_a_DEPENDENCIES) $(EXTRA_libsnmplib_a_DEPENDENCIES) 
-	$(AM_V_at)-rm -f libsnmplib.a
-	$(AM_V_AR)$(libsnmplib_a_AR) libsnmplib.a $(libsnmplib_a_OBJECTS) $(libsnmplib_a_LIBADD)
-	$(AM_V_at)$(RANLIB) libsnmplib.a
+libsnmplib.la: $(libsnmplib_la_OBJECTS) $(libsnmplib_la_DEPENDENCIES) $(EXTRA_libsnmplib_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(LINK)  $(libsnmplib_la_OBJECTS) $(libsnmplib_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asn1.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coexistance.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mib.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_api.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_api_error.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_error.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_msg.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_pdu.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_vars.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmplib_debug.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asn1.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coexistance.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mib.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_api.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_api_error.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_error.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_msg.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_pdu.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_vars.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmplib_debug.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
@@ -573,13 +623,13 @@
 	    || cp -p $$d/$$file "$(distdir)/$$file" \
 	    || exit 1; \
 	  fi; \
 	done
 check-am: all-am
 check: check-am
-all-am: Makefile $(LIBRARIES)
+all-am: Makefile $(LTLIBRARIES)
 installdirs:
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
 uninstall: uninstall-am
 
@@ -607,13 +657,13 @@
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
 	@echo "it deletes files that may require special tools to rebuild."
 clean: clean-am
 
-clean-am: clean-generic clean-libtool clean-noinstLIBRARIES \
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
 	mostlyclean-am
 
 distclean: distclean-am
 	-rm -rf ./$(DEPDIR)
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
@@ -679,13 +729,13 @@
 
 uninstall-am:
 
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstLIBRARIES cscopelist-am ctags \
+	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
 	ctags-am distclean distclean-compile distclean-generic \
 	distclean-libtool distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
 	install-data-am install-dvi install-dvi-am install-exec \
 	install-exec-am install-html install-html-am install-info \
 	install-info-am install-man install-pdf install-pdf-am \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/snmplib/parse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/snmplib/parse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/snmplib/parse.c	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/snmplib/parse.c	2015-05-01 18:05:19.000000000 +0800
@@ -687,16 +687,14 @@
          * care of here.  The name for this node is taken from the label for this
          * entry.
          * np still points to an unused entry.
          */
         if (count == (length - 2)) {
             if (op->label) {
-                strncpy(np->parent, op->label, sizeof(np->parent));
-                np->parent[sizeof(np->parent-1)] = '\0';
-                strncpy(np->label, name, sizeof(np->label));
-                np->label[sizeof(np->label-1)] = '\0';
+                strncpy(np->parent, op->label, sizeof(np->parent)-1);
+                strncpy(np->label, name, sizeof(np->label)-1);
                 if (nop->subid != -1)
                     np->subid = nop->subid;
                 else
                     print_error("Warning: This entry is pretty silly", np->label, type);
             } else {
                 free_node(np);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/snmplib/snmp_msg.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/snmplib/snmp_msg.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/snmplib/snmp_msg.c	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/snmplib/snmp_msg.c	2015-05-01 18:05:19.000000000 +0800
@@ -249,29 +249,29 @@
 {
     u_char *bufp;
     u_char type;
 
     bufp = asn_parse_header(Packet, PacketLenP, &type);
     if (bufp == NULL) {
-        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Header)!\n");
+        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Message Header (Header)!\n");
         ASN_PARSE_ERROR(NULL);
     }
     if (type != (ASN_SEQUENCE | ASN_CONSTRUCTOR)) {
-        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Header)!\n");
+        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Message Header (Header)!\n");
         ASN_PARSE_ERROR(NULL);
     }
     bufp = asn_parse_int(bufp, PacketLenP,
                          &type,
                          (int *) Version, sizeof(*Version));
     if (bufp == NULL) {
-        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Version)!\n");
+        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Message Header (Version)!\n");
         ASN_PARSE_ERROR(NULL);
     }
     bufp = asn_parse_string(bufp, PacketLenP, &type, Community, CommLenP);
     if (bufp == NULL) {
-        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Messsage Header (Community)!\n");
+        snmplib_debug(4, "snmp_msg_Decode:Error decoding SNMP Message Header (Community)!\n");
         ASN_PARSE_ERROR(NULL);
     }
     Community[*CommLenP] = '\0';
 
     if ((*Version != SNMP_VERSION_1) &&
             (*Version != SNMP_VERSION_2)) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/SPONSORS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/SPONSORS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/SPONSORS	2015-05-01 16:52:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/SPONSORS	2015-05-01 18:07:10.000000000 +0800
@@ -1,34 +1,26 @@
 In addition to the numerous volunteer developers (see CONTRIBUTORS),
 the following organizations have provided non-financial support for
 the Squid Project:
 
 
-iiNet Ltd - http://www.iinet.net.au/
-
-	iiNet Ltd contributed significant development resources to
-	Squid during its early stages and was instrumental in its
-	early adoption in the local internet community.
-	In Squid-2.6 and 3.0 iiNet supplied equipment to help develop
-	and test the WCCPv2 implementation.
-	In Squid-3.2 iiNet sponsored development time to resolve
-	authentication problems.
-
 LaunchPad - http://launchpad.net/
 
 	Provide Bazaar mirroring services and host the Squid-3 developer
 	project code.
 
 Messagenet - http://messagenet.it/
 
 	Messagenet donated hardware and bandwidth for the wiki server
 	and most continuous integration testing.
 
-Palisade Systems - http://www.palisadesys.com/
+RackSpace - http://www.rackspace.com/
 
-	Palisade Systems funded SSL Bump feature development in Squid3.
+	RackSpace donated a number of virtual machines from their cloud
+	infrastructure to support and extend the continuous integration
+	testing infrastructure.
 
 The Measurement Factory - http://www.measurement-factory.com/
 
 	Measurement Factory has constributed significant resources
 	toward Squid-3 development and server maintenance.
 
@@ -36,12 +28,39 @@
 
 	Treehouse Networks has contributed significant resources
 	toward Squid-3 development and maintenance for their customer
 	gateways and CDN.
 
 
+iCelero - http://icelero.com/
+
+	iCelero.com contributed development resources towards
+	testing and stabilization of Squid-3.3 on Windows.
+
+Netbox Blue Pty - http://netboxblue.com/
+
+	Netbox Blue Pty. contributed development resources towards
+	testing and stabilizing of authentication systems in Squid-3.2
+	and Squid-3.3.
+
+
+iiNet Ltd - http://www.iinet.net.au/
+
+	iiNet Ltd contributed significant development resources to
+	Squid during its early stages and was instrumental in its
+	early adoption in the local internet community.
+	In Squid-2.6 and 3.0 iiNet supplied equipment to help develop
+	and test the WCCPv2 implementation.
+	In Squid-3.2 iiNet sponsored development time to resolve
+	authentication problems.
+
+Palisade Systems - http://www.palisadesys.com/
+
+	Palisade Systems funded SSL Bump feature development in Squid3.
+
+
 Barefruit - http://www.barefruit.com/
 
 	Barefruit has funded Squid-3.0 and 3.1 development and maintenance,
 	with a focus on content adaptation (ICAP and eCAP) support.
 
 BBC (UK) and Siemens IT Solutions and Services (UK)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/AccessLogEntry.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/AccessLogEntry.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/AccessLogEntry.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/AccessLogEntry.cc	2015-05-01 18:05:19.000000000 +0800
@@ -21,34 +21,34 @@
     if (Config.onoff.log_uses_indirect_client && request)
         log_ip = request->indirect_client_addr;
     else
 #endif
         if (tcpClient != NULL)
             log_ip = tcpClient->remote;
-        else if (cache.caddr.IsNoAddr()) { // e.g., ICAP OPTIONS lack client
+        else if (cache.caddr.isNoAddr()) { // e.g., ICAP OPTIONS lack client
             strncpy(buf, "-", bufsz);
             return;
         } else
             log_ip = cache.caddr;
 
     // Apply so-called 'privacy masking' to IPv4 clients
     // - localhost IP is always shown in full
     // - IPv4 clients masked with client_netmask
     // - IPv6 clients use 'privacy addressing' instead.
 
-    if (!log_ip.IsLocalhost() && log_ip.IsIPv4())
-        log_ip.ApplyMask(Config.Addrs.client_netmask);
+    if (!log_ip.isLocalhost() && log_ip.isIPv4())
+        log_ip.applyMask(Config.Addrs.client_netmask);
 
-    log_ip.NtoA(buf, bufsz);
+    log_ip.toStr(buf, bufsz);
 }
 
 AccessLogEntry::~AccessLogEntry()
 {
     safe_free(headers.request);
 
-#if ICAP_CLIENT
+#if USE_ADAPTATION
     safe_free(adapt.last_meta);
 #endif
 
     safe_free(headers.reply);
 
     safe_free(headers.adapted_request);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/AccessLogEntry.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/AccessLogEntry.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/AccessLogEntry.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/AccessLogEntry.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,23 +28,25 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 #ifndef SQUID_HTTPACCESSLOGENTRY_H
 #define SQUID_HTTPACCESSLOGENTRY_H
 
 #include "anyp/PortCfg.h"
+#include "base/RefCount.h"
 #include "comm/Connection.h"
-#include "HttpVersion.h"
+#include "HttpHeader.h"
+#include "http/ProtocolVersion.h"
 #include "HttpRequestMethod.h"
 #include "HierarchyLogEntry.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
-#include "HttpRequestMethod.h"
+#include "LogTags.h"
+#include "Notes.h"
 #if ICAP_CLIENT
 #include "adaptation/icap/Elements.h"
 #endif
-#include "RefCount.h"
 #if USE_SSL
 #include "ssl/gadgets.h"
 #endif
 
 /* forward decls */
 class HttpReply;
@@ -78,19 +80,19 @@
      * \todo details of HTTP held in the parent class need moving into here.
      */
     class HttpDetails
     {
 
     public:
-        HttpDetails() : method(METHOD_NONE), code(0), content_type(NULL),
+        HttpDetails() : method(Http::METHOD_NONE), code(0), content_type(NULL),
                 timedout(false), aborted(false) {}
 
         HttpRequestMethod method;
         int code;
         const char *content_type;
-        HttpVersion version;
+        Http::ProtocolVersion version;
         bool timedout; ///< terminated due to a lifetime or I/O timeout
         bool aborted; ///< other abnormal termination (e.g., I/O error)
 
         /// compute suffix for the status access.log field
         const char *statusSfx() const {
             return timedout ? "_TIMEDOUT" : (aborted ? "_ABORTED" : "");
@@ -163,13 +165,13 @@
         int64_t requestSize;
         int64_t replySize;
         int requestHeadersSize; ///< received, including request line
         int replyHeadersSize; ///< sent, including status line
         int64_t highOffset;
         int64_t objectSize;
-        log_type code;
+        LogTags code;
         int msec;
         const char *rfc931;
         const char *extuser;
 #if USE_SSL
 
         const char *ssluser;
@@ -225,20 +227,27 @@
     } _private;
     HierarchyLogEntry hier;
     HttpReply *reply;
     HttpRequest *request; //< virgin HTTP request
     HttpRequest *adapted_request; //< HTTP request after adaptation and redirection
 
+    /// key:value pairs set by squid.conf note directive and
+    /// key=value pairs returned from URL rewrite/redirect helper
+    NotePairs::Pointer notes;
+
 #if ICAP_CLIENT
     /** \brief This subclass holds log info for ICAP part of request
      *  \todo Inner class declarations should be moved outside
      */
     class IcapLogEntry
     {
     public:
-        IcapLogEntry():bodyBytesRead(-1),request(NULL),reply(NULL),outcome(Adaptation::Icap::xoUnknown),trTime(0),ioTime(0),resStatus(HTTP_STATUS_NONE) {}
+        IcapLogEntry() : reqMethod(Adaptation::methodNone), bytesSent(0), bytesRead(0),
+                bodyBytesRead(-1), request(NULL), reply(NULL),
+                outcome(Adaptation::Icap::xoUnknown), trTime(0),
+                ioTime(0), resStatus(Http::scNone), processingTime(0) {}
 
         Ip::Address hostAddr; ///< ICAP server IP address
         String serviceName;        ///< ICAP service name
         String reqUri;             ///< ICAP Request-URI
         Adaptation::Icap::ICAP::Method reqMethod; ///< ICAP request method
         int64_t bytesSent;       ///< number of bytes sent to ICAP server so far
@@ -260,13 +269,13 @@
         /** \brief Transaction I/O time.
          * The timer starts when the first ICAP request
          * byte is scheduled for sending and stops when the lastbyte of the
          * ICAP response is received.
          */
         int ioTime;
-        http_status resStatus;   ///< ICAP response status code
+        Http::StatusCode resStatus;   ///< ICAP response status code
         int processingTime;      ///< total ICAP processing time in milliseconds
     }
     icap;
 #endif
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Acl.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Acl.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Acl.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Acl.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,9 +1,8 @@
 /*
  * DEBUG: section 28    Access Control
- * AUTHOR: Duane Wessels
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
  *
  *  Squid is the result of efforts by numerous individuals from
  *  the Internet community; see the CONTRIBUTORS file for full
@@ -29,21 +28,79 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 #include "squid.h"
 #include "acl/Acl.h"
 #include "acl/Checklist.h"
+#include "acl/Gadgets.h"
 #include "anyp/PortCfg.h"
+#include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "dlink.h"
 #include "globals.h"
+#include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
+const ACLFlag ACLFlags::NoFlags[1] = {ACL_F_END};
+
 const char *AclMatchedName = NULL;
 
+bool ACLFlags::supported(const ACLFlag f) const
+{
+    if (f == ACL_F_REGEX_CASE)
+        return true;
+    return (supported_.find(f) != std::string::npos);
+}
+
+void
+ACLFlags::parseFlags()
+{
+    char *nextToken;
+    while ((nextToken = ConfigParser::strtokFile()) != NULL && nextToken[0] == '-') {
+
+        //if token is the "--" break flag
+        if (strcmp(nextToken, "--") == 0)
+            break;
+
+        for (const char *flg = nextToken+1; *flg!='\0'; flg++ ) {
+            if (supported(*flg)) {
+                makeSet(*flg);
+            } else {
+                debugs(28, 0, HERE << "Flag '" << *flg << "' not supported");
+                self_destruct();
+            }
+        }
+    }
+
+    /*Regex code needs to parse -i file*/
+    if ( isSet(ACL_F_REGEX_CASE))
+        ConfigParser::strtokFilePutBack("-i");
+
+    if (nextToken != NULL && strcmp(nextToken, "--") != 0 )
+        ConfigParser::strtokFileUndo();
+}
+
+const char *
+ACLFlags::flagsStr() const
+{
+    static char buf[64];
+    if (flags_ == 0)
+        return "";
+
+    char *s = buf;
+    *s++ = '-';
+    for (ACLFlag f = 'A'; f <= 'z'; f++) {
+        // ACL_F_REGEX_CASE (-i) flag handled by ACLRegexData class, ignore
+        if (isSet(f) && f != ACL_F_REGEX_CASE)
+            *s++ = f;
+    }
+    *s = '\0';
+    return buf;
+}
+
 void *
 ACL::operator new (size_t byteCount)
 {
     fatal ("unusable ACL::new");
     return (void *)1;
 }
@@ -79,22 +136,63 @@
 
     return result;
 }
 
 ACL::ACL() :
         cfgline(NULL),
-        next(NULL)
+        next(NULL),
+        registered(false)
 {
     *name = 0;
 }
 
 bool ACL::valid () const
 {
     return true;
 }
 
+bool
+ACL::matches(ACLChecklist *checklist) const
+{
+    PROF_start(ACL_matches);
+    debugs(28, 5, "checking " << name);
+
+    // XXX: AclMatchedName does not contain a matched ACL name when the acl
+    // does not match. It contains the last (usually leaf) ACL name checked
+    // (or is NULL if no ACLs were checked).
+    AclMatchedName = name;
+
+    int result = 0;
+    if (!checklist->hasRequest() && requiresRequest()) {
+        debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
+               "context without an HTTP request. Assuming mismatch.");
+    } else if (!checklist->hasReply() && requiresReply()) {
+        debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
+               "context without an HTTP response. Assuming mismatch.");
+    } else {
+        // have to cast because old match() API is missing const
+        result = const_cast<ACL*>(this)->match(checklist);
+    }
+
+    const char *extra = checklist->asyncInProgress() ? " async" : "";
+    debugs(28, 3, "checked: " << name << " = " << result << extra);
+    PROF_stop(ACL_matches);
+    return result == 1; // true for match; false for everything else
+}
+
+void
+ACL::context(const char *aName, const char *aCfgLine)
+{
+    name[0] = '\0';
+    if (aName)
+        xstrncpy(name, aName, ACL_NAME_SZ-1);
+    safe_free(cfgline);
+    if (aCfgLine)
+        cfgline = xstrdup(aCfgLine);
+}
+
 void
 ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
 {
     /* we're already using strtok() to grok the line */
     char *t = NULL;
     ACL *A = NULL;
@@ -128,24 +226,24 @@
 
     // Is this ACL going to work?
     if (strcmp(theType, "myip") == 0) {
         AnyP::PortCfg *p = Config.Sockaddr.http;
         while (p) {
             // Bug 3239: not reliable when there is interception traffic coming
-            if (p->intercepted)
+            if (p->flags.natIntercept)
                 debugs(28, DBG_CRITICAL, "WARNING: 'myip' ACL is not reliable for interception proxies. Please use 'myportname' instead.");
             p = p->next;
         }
         debugs(28, DBG_IMPORTANT, "UPGRADE: ACL 'myip' type is has been renamed to 'localip' and matches the IP the client connected to.");
         theType = "localip";
     } else if (strcmp(theType, "myport") == 0) {
         AnyP::PortCfg *p = Config.Sockaddr.http;
         while (p) {
             // Bug 3239: not reliable when there is interception traffic coming
             // Bug 3239: myport - not reliable (yet) when there is interception traffic coming
-            if (p->intercepted)
+            if (p->flags.natIntercept)
                 debugs(28, DBG_CRITICAL, "WARNING: 'myport' ACL is not reliable for interception proxies. Please use 'myportname' instead.");
             p = p->next;
         }
         theType = "localport";
         debugs(28, DBG_IMPORTANT, "UPGRADE: ACL 'myport' type is has been renamed to 'localport' and matches the port the client connected to.");
     }
@@ -157,14 +255,13 @@
         return;
     }
 
     if ((A = FindByName(aclname)) == NULL) {
         debugs(28, 3, "aclParseAclLine: Creating ACL '" << aclname << "'");
         A = ACL::Factory(theType);
-        xstrncpy(A->name, aclname, ACL_NAME_SZ);
-        A->cfgline = xstrdup(config_input_line);
+        A->context(aclname, config_input_line);
         new_acl = 1;
     } else {
         if (strcmp (A->typeString(),theType) ) {
             debugs(28, DBG_CRITICAL, "aclParseAclLine: ACL '" << A->name << "' already exists with different type.");
             parser.destruct();
             return;
@@ -177,12 +274,14 @@
     /*
      * Here we set AclMatchedName in case we need to use it in a
      * warning message in aclDomainCompare().
      */
     AclMatchedName = A->name;	/* ugly */
 
+    A->flags.parseFlags();
+
     /*split the function here */
     A->parse();
 
     /*
      * Clear AclMatchedName from our temporary hack
      */
@@ -197,37 +296,27 @@
 
     if (!A->valid()) {
         fatalf("ERROR: Invalid ACL: %s\n",
                A->cfgline);
     }
 
-    /* append */
-    while (*head)
-        head = &(*head)->next;
-
+    // add to the global list for searching explicit ACLs by name
+    assert(head && *head == Config.aclList);
+    A->next = *head;
     *head = A;
+
+    // register for centralized cleanup
+    aclRegister(A);
 }
 
 bool
 ACL::isProxyAuth() const
 {
     return false;
 }
 
-ACLList::ACLList() : op (1), _acl (NULL), next (NULL)
-{}
-
-void
-ACLList::negated(bool isNegated)
-{
-    if (isNegated)
-        op = 0;
-    else
-        op = 1;
-}
-
 /* ACL result caching routines */
 
 int
 ACL::matchForCache(ACLChecklist *checklist)
 {
     /* This is a fatal to ensure that cacheMatchAcl calls are _only_
@@ -298,93 +387,29 @@
 bool
 ACL::requiresRequest() const
 {
     return false;
 }
 
-int
-ACL::checklistMatches(ACLChecklist *checklist)
-{
-    int rv;
-
-    if (!checklist->hasRequest() && requiresRequest()) {
-        debugs(28, DBG_IMPORTANT, "ACL::checklistMatches WARNING: '" << name << "' ACL is used but there is no HTTP request -- not matching.");
-        return 0;
-    }
-
-    if (!checklist->hasReply() && requiresReply()) {
-        debugs(28, DBG_IMPORTANT, "ACL::checklistMatches WARNING: '" << name << "' ACL is used but there is no HTTP reply -- not matching.");
-        return 0;
-    }
-
-    debugs(28, 3, "ACL::checklistMatches: checking '" << name << "'");
-    rv= match(checklist);
-    debugs(28, 3, "ACL::ChecklistMatches: result for '" << name << "' is " << rv);
-    return rv;
-}
-
-bool
-ACLList::matches (ACLChecklist *checklist) const
-{
-    assert (_acl);
-    // XXX: AclMatchedName does not contain a matched ACL name when the acl
-    // does not match (or contains stale name if no ACLs are checked). In
-    // either case, we get misleading debugging and possibly incorrect error
-    // messages. Unfortunately, deny_info's "when none http_access
-    // lines match" exception essentially requires this mess.
-    // TODO: Rework by using an acl-free deny_info for the no-match cases?
-    AclMatchedName = _acl->name;
-    debugs(28, 3, "ACLList::matches: checking " << (op ? null_string : "!") << _acl->name);
-
-    bool result = false;
-    if (_acl->checklistMatches(checklist) == 1) {
-        debugs(28, 5, _acl->name << " matched" << (op ? "." : ", negating."));
-        result = (op != 0);
-    } else if (checklist->finished()) {
-        debugs(28, 5, _acl->name << " failed.");
-        result = false;
-    } else if (checklist->asyncNeeded()) {
-        debugs(28, 5, _acl->name << " needs async lookup");
-        result = false;
-    } else {
-        debugs(28, 5, _acl->name << " mismatched" << (op ? "." : ", negating."));
-        result = (op == 0);
-    }
-
-    debugs(28, 4, (op ? null_string : "!") << _acl->name << " result is " <<
-           (result ? "true" : "false"));
-    return result;
-}
-
 /*********************/
 /* Destroy functions */
 /*********************/
 
 ACL::~ACL()
 {
     debugs(28, 3, "ACL::~ACL: '" << cfgline << "'");
     safe_free(cfgline);
+    AclMatchedName = NULL; // in case it was pointing to our name
 }
 
-/* to be split into separate files in the future */
-
-CBDATA_CLASS_INIT(acl_access);
-
-void *
-acl_access::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(acl_access);
-    acl_access *result = cbdataAlloc(acl_access);
-    return result;
-}
-
-void
-acl_access::operator delete (void *address)
+/// Temporary hack to allow old ACL code to handle quoted values without
+/// replacing every strtok() call.
+char *
+ACL::strtok(char *str, const char *delimiters)
 {
-    acl_access *t = static_cast<acl_access *>(address);
-    cbdataFree(t);
+    return xstrtok(str, delimiters);
 }
 
 ACL::Prototype::Prototype() : prototype (NULL), typeString (NULL) {}
 
 ACL::Prototype::Prototype (ACL const *aPrototype, char const *aType) : prototype (aPrototype), typeString (aType)
 {
@@ -433,14 +458,17 @@
 ACL *
 ACL::Prototype::Factory (char const *typeToClone)
 {
     debugs(28, 4, "ACL::Prototype::Factory: cloning an object for type '" << typeToClone << "'");
 
     for (iterator i = Registry->begin(); i != Registry->end(); ++i)
-        if (!strcmp (typeToClone, (*i)->typeString))
-            return (*i)->prototype->clone();
+        if (!strcmp (typeToClone, (*i)->typeString)) {
+            ACL *A = (*i)->prototype->clone();
+            A->flags = (*i)->prototype->flags;
+            return A;
+        }
 
     debugs(28, 4, "ACL::Prototype::Factory: cloning failed, no type '" << typeToClone << "' available");
 
     return NULL;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Acl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Acl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Acl.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Acl.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,26 +30,72 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #ifndef SQUID_ACL_H
 #define SQUID_ACL_H
 
-#include "Array.h"
+#include "acl/forward.h"
+#include "base/Vector.h"
 #include "cbdata.h"
 #include "defines.h"
 #include "dlink.h"
 #include "MemPool.h"
 
 #if HAVE_OSTREAM
 #include <ostream>
 #endif
+#if HAVE_STRING
+#include <string>
+#endif
 
 class ConfigParser;
-class ACLChecklist;
-class ACLList;
 
+typedef char ACLFlag;
+// ACLData Flags
+#define ACL_F_REGEX_CASE 'i'
+#define ACL_F_NO_LOOKUP 'n'
+#define ACL_F_STRICT 's'
+#define ACL_F_END '\0'
+
+/**
+ * \ingroup ACLAPI
+ * Used to hold a list of one-letter flags which can be passed as parameters
+ * to acls  (eg '-i', '-n' etc)
+ */
+class ACLFlags
+{
+public:
+    explicit ACLFlags(const ACLFlag flags[]) : supported_(flags), flags_(0) {}
+    ACLFlags() : flags_(0) {}
+    bool supported(const ACLFlag f) const; ///< True if the given flag supported
+    void makeSet(const ACLFlag f) { flags_ |= flagToInt(f); } ///< Set the given flag
+    /// Return true if the given flag is set
+    bool isSet(const ACLFlag f) const { return flags_ & flagToInt(f);}
+    /// Parse optional flags given in the form -[A..Z|a..z]
+    void parseFlags();
+    const char *flagsStr() const; ///< Convert the flags to a string representation
+
+private:
+    /// Convert a flag to a 64bit unsigned integer.
+    /// The characters from 'A' to 'z' represented by the values from 65 to 122.
+    /// They are 57 different characters which can be fit to the bits of an 64bit
+    /// integer.
+    uint64_t flagToInt(const ACLFlag f) const {
+        assert('A' <= f && f <= 'z');
+        return ((uint64_t)1 << (f - 'A'));
+    }
+
+    std::string supported_; ///< The supported character flags
+    uint64_t flags_; ///< The flags which is set
+public:
+    static const ACLFlag NoFlags[1]; ///< An empty flags list
+};
+
+/// A configurable condition. A node in the ACL expression tree.
+/// Can evaluate itself in FilledChecklist context.
+/// Does not change during evaluation.
 /// \ingroup ACLAPI
 class ACL
 {
 
 public:
     void *operator new(size_t);
@@ -58,33 +104,44 @@
     static ACL *Factory (char const *);
     static void ParseAclLine(ConfigParser &parser, ACL ** head);
     static void Initialize();
     static ACL* FindByName(const char *name);
 
     ACL();
+    explicit ACL(const ACLFlag flgs[]) : cfgline(NULL), next(NULL), flags(flgs) { memset(name, '\0', sizeof(name)); }
     virtual ~ACL();
+
+    /// sets user-specified ACL name and squid.conf context
+    void context(const char *name, const char *configuration);
+
+    /// Orchestrates matching checklist against the ACL using match(),
+    /// after checking preconditions and while providing debugging.
+    /// Returns true if and only if there was a successful match.
+    /// Updates the checklist state on match, async, and failure.
+    bool matches(ACLChecklist *checklist) const;
+
     virtual ACL *clone()const = 0;
+
+    /// parses node represenation in squid.conf; dies on failures
     virtual void parse() = 0;
     virtual char const *typeString() const = 0;
     virtual bool isProxyAuth() const;
-    virtual bool requiresRequest() const;
-    virtual bool requiresReply() const;
-    virtual int match(ACLChecklist * checklist) = 0;
     virtual wordlist *dump() const = 0;
     virtual bool empty () const = 0;
     virtual bool valid () const;
-    int checklistMatches(ACLChecklist *);
 
     int cacheMatchAcl(dlink_list * cache, ACLChecklist *);
     virtual int matchForCache(ACLChecklist *checklist);
 
     virtual void prepareForUse() {}
 
     char name[ACL_NAME_SZ];
     char *cfgline;
-    ACL *next;
+    ACL *next; // XXX: remove or at least use refcounting
+    ACLFlags flags; ///< The list of given ACL flags
+    bool registered; ///< added to the global list of ACLs via aclRegister()
 
 public:
 
     class Prototype
     {
 
@@ -103,12 +160,24 @@
         static Vector<Prototype const *> * Registry;
         static void *Initialized;
         typedef Vector<Prototype const*>::iterator iterator;
         typedef Vector<Prototype const*>::const_iterator const_iterator;
         void registerMe();
     };
+
+private:
+    /// Matches the actual data in checklist against this ACL.
+    virtual int match(ACLChecklist *checklist) = 0; // XXX: missing const
+
+    /// whether our (i.e. shallow) match() requires checklist to have a request
+    virtual bool requiresRequest() const;
+    /// whether our (i.e. shallow) match() requires checklist to have a reply
+    virtual bool requiresReply() const;
+
+protected:
+    static char *strtok(char *str, const char *delimiters);
 };
 
 /// \ingroup ACLAPI
 typedef enum {
     // Authorization ACL result states
     ACCESS_DENIED,
@@ -163,45 +232,12 @@
         break;
     }
     return o;
 }
 
 /// \ingroup ACLAPI
-class acl_access
-{
-
-public:
-    void *operator new(size_t);
-    void operator delete(void *);
-    allow_t allow;
-    ACLList *aclList;
-    char *cfgline;
-    acl_access *next;
-
-private:
-    CBDATA_CLASS(acl_access);
-};
-
-/// \ingroup ACLAPI
-class ACLList
-{
-
-public:
-    MEMPROXY_CLASS(ACLList);
-
-    ACLList();
-    void negated(bool isNegated);
-    bool matches (ACLChecklist *)const;
-    int op;
-    ACL *_acl;
-    ACLList *next;
-};
-
-MEMPROXY_CLASS_INLINE(ACLList);
-
-/// \ingroup ACLAPI
 class acl_proxy_auth_match_cache
 {
 
 public:
     MEMPROXY_CLASS(acl_proxy_auth_match_cache);
     dlink_node link;
@@ -209,9 +245,10 @@
     void *acl_data;
 };
 
 MEMPROXY_CLASS_INLINE(acl_proxy_auth_match_cache);
 
 /// \ingroup ACLAPI
+/// XXX: find a way to remove or at least use a refcounted ACL pointer
 extern const char *AclMatchedName;	/* NULL */
 
 #endif /* SQUID_ACL_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/AclNameList.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/AclNameList.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/AclNameList.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/AclNameList.h	2015-05-01 18:05:19.000000000 +0800
@@ -26,13 +26,13 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
-#include "defines.h"
+#include "acl/forward.h"
 
 /// list of name-based ACLs. Currently a POD.
 class AclNameList
 {
 public:
     char name[ACL_NAME_SZ];
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/AclSizeLimit.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/AclSizeLimit.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/AclSizeLimit.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/AclSizeLimit.h	2015-05-01 18:05:19.000000000 +0800
@@ -26,13 +26,14 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
-class ACLList;
+#include "acl/forward.h"
+
 /// representation of a class of Size-limit ACLs
 // a POD. TODO: convert to new ACL framework
 class AclSizeLimit
 {
 public:
     AclSizeLimit *next;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: AllOf.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: AllOf.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: AnyOf.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: AnyOf.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Arp.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Arp.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Arp.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Arp.cc	2015-05-01 18:05:19.000000000 +0800
@@ -158,13 +158,13 @@
 int
 ACLARP::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
 
     /* IPv6 does not do ARP */
-    if (!checklist->src_addr.IsIPv4()) {
+    if (!checklist->src_addr.isIPv4()) {
         debugs(14, 3, "ACLARP::match: IPv4 Required for ARP Lookups. Skipping " << checklist->src_addr );
         return 0;
     }
 
     return aclMatchArp(&data, checklist->src_addr);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Asn.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Asn.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Asn.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Asn.cc	2015-05-01 18:05:19.000000000 +0800
@@ -36,13 +36,13 @@
 #include "acl/Asn.h"
 #include "acl/Checklist.h"
 #include "acl/DestinationAsn.h"
 #include "acl/DestinationIp.h"
 #include "acl/SourceAsn.h"
 #include "cache_cf.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
 #include "mgr/Registration.h"
 #include "radix.h"
 #include "RequestFlags.h"
@@ -146,16 +146,16 @@
 
     debugs(53, 3, "asnMatchIp: Called for " << addr );
 
     if (AS_tree_head == NULL)
         return 0;
 
-    if (addr.IsNoAddr())
+    if (addr.isNoAddr())
         return 0;
 
-    if (addr.IsAnyAddr())
+    if (addr.isAnyAddr())
         return 0;
 
     m_addr.addr = addr;
 
     rn = squid_rn_match(&m_addr, AS_tree_head);
 
@@ -234,25 +234,24 @@
 
 static void
 asnCacheStart(int as)
 {
     LOCAL_ARRAY(char, asres, 4096);
     StoreEntry *e;
-    HttpRequest *req;
     ASState *asState;
     asState = cbdataAlloc(ASState);
     asState->dataRead = 0;
     debugs(53, 3, "asnCacheStart: AS " << as);
     snprintf(asres, 4096, "whois://%s/!gAS%d", Config.as_whois_server, as);
     asState->as_number = as;
-    req = HttpRequest::CreateFromUrl(asres);
-    assert(NULL != req);
-    asState->request = HTTPMSGLOCK(req);
+    asState->request = HttpRequest::CreateFromUrl(asres);
+    assert(NULL != asState->request);
+    HTTPMSGLOCK(asState->request);
 
-    if ((e = storeGetPublic(asres, METHOD_GET)) == NULL) {
-        e = storeCreateEntry(asres, asres, RequestFlags(), METHOD_GET);
+    if ((e = storeGetPublic(asres, Http::METHOD_GET)) == NULL) {
+        e = storeCreateEntry(asres, asres, RequestFlags(), Http::METHOD_GET);
         asState->sc = storeClientListAdd(e, asState);
         FwdState::fwdStart(Comm::ConnectionPointer(), e, asState->request);
     } else {
 
         e->lock();
         asState->sc = storeClientListAdd(e, asState);
@@ -294,13 +293,13 @@
         asStateFree(asState);
         return;
     } else if (result.flags.error) {
         debugs(53, DBG_IMPORTANT, "asHandleReply: Called with Error set and size=" << (unsigned int) result.length);
         asStateFree(asState);
         return;
-    } else if (HTTP_OK != e->getReply()->sline.status) {
+    } else if (e->getReply()->sline.status() != Http::scOkay) {
         debugs(53, DBG_IMPORTANT, "WARNING: AS " << asState->as_number << " whois request failed");
         asStateFree(asState);
         return;
     }
 
     /*
@@ -420,14 +419,14 @@
         bitl = 0;
 
     // INET6 TODO : find a better way of identifying the base IPA family for mask than this.
     t = strchr(as_string, '.');
 
     // generate Netbits Format Mask
-    mask.SetNoAddr();
-    mask.ApplyMask(bitl, (t!=NULL?AF_INET:AF_INET6) );
+    mask.setNoAddr();
+    mask.applyMask(bitl, (t!=NULL?AF_INET:AF_INET6) );
 
     debugs(53, 3, "asnAddNet: called for " << addr << "/" << mask );
 
     rtentry_t *e = (rtentry_t *)xcalloc(1, sizeof(rtentry_t));
 
     e->e_addr.addr = addr;
@@ -452,13 +451,13 @@
             e->e_info = asinfo;
         }
     } else {
         q = new CbDataList<int> (as_number);
         asinfo = (as_info *)xmalloc(sizeof(as_info));
         asinfo->as_number = q;
-        rn = squid_rn_addroute(&e->e_addr, &e->e_mask, AS_tree_head, e->e_nodes);
+        squid_rn_addroute(&e->e_addr, &e->e_mask, AS_tree_head, e->e_nodes);
         rn = squid_rn_match(&e->e_addr, AS_tree_head);
         assert(rn != NULL);
         e->e_info = asinfo;
     }
 
     if (rn == 0) { 		/* assert might expand to nothing */
@@ -520,14 +519,14 @@
 
     assert(e);
     assert(e->e_info);
     addr = e->e_addr.addr;
     mask = e->e_mask.addr;
     storeAppendPrintf(sentry, "%s/%d\t",
-                      addr.NtoA(buf, MAX_IPSTRLEN),
-                      mask.GetCIDR() );
+                      addr.toStr(buf, MAX_IPSTRLEN),
+                      mask.cidr() );
     asinfo = e->e_info;
     assert(asinfo->as_number);
 
     for (q = asinfo->as_number; q; q = q->next)
         storeAppendPrintf(sentry, " %d", q->element);
 
@@ -606,13 +605,13 @@
 
 ACL::Prototype ACLASN::DestinationRegistryProtoype(&ACLASN::DestinationRegistryEntry_, "dst_as");
 
 ACLStrategised<Ip::Address> ACLASN::DestinationRegistryEntry_(new ACLASN, ACLDestinationASNStrategy::Instance(), "dst_as");
 
 int
-ACLSourceASNStrategy::match (ACLData<Ip::Address> * &data, ACLFilledChecklist *checklist)
+ACLSourceASNStrategy::match (ACLData<Ip::Address> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match(checklist->src_addr);
 }
 
 ACLSourceASNStrategy *
 ACLSourceASNStrategy::Instance()
@@ -620,13 +619,13 @@
     return &Instance_;
 }
 
 ACLSourceASNStrategy ACLSourceASNStrategy::Instance_;
 
 int
-ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
         for (int k = 0; k < (int) ia->count; ++k) {
             if (data->match(ia->in_addrs[k]))
@@ -634,22 +633,20 @@
         }
 
         return 0;
 
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
-        /* XXX FIXME: allow accessing the acl name here */
-        debugs(28, 3, "asnMatchAcl: Can't yet compare '" << "unknown" /*name*/ << "' ACL for '" << checklist->request->GetHost() << "'");
-        checklist->changeState (DestinationIPLookup::Instance());
-    } else {
-        Ip::Address noaddr;
-        noaddr.SetNoAddr();
-        return data->match(noaddr);
-    }
-
-    return 0;
+        debugs(28, 3, "asnMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->request->GetHost() << "'");
+        if (checklist->goAsync(DestinationIPLookup::Instance()))
+            return -1;
+        // else fall through to noaddr match, hiding the lookup failure (XXX)
+    }
+    Ip::Address noaddr;
+    noaddr.setNoAddr();
+    return data->match(noaddr);
 }
 
 ACLDestinationASNStrategy *
 ACLDestinationASNStrategy::Instance()
 {
     return &Instance_;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: BoolOps.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: BoolOps.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Certificate.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Certificate.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Certificate.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Certificate.cc	2015-05-01 18:05:19.000000000 +0800
@@ -45,18 +45,21 @@
 #include "HttpRequest.h"
 #include "client_side.h"
 #include "fde.h"
 #include "globals.h"
 
 int
-ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLCertificateStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     const int fd = checklist->fd();
     const bool goodDescriptor = 0 <= fd && fd <= Biggest_FD;
     SSL *ssl = goodDescriptor ? fd_table[fd].ssl : 0;
-    return data->match (ssl);
+    X509 *cert = SSL_get_peer_certificate(ssl);
+    const bool res = data->match (cert);
+    X509_free(cert);
+    return res;
 }
 
 ACLCertificateStrategy *
 ACLCertificateStrategy::Instance()
 {
     return &Instance_;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/CertificateData.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/CertificateData.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/CertificateData.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/CertificateData.cc	2015-05-01 18:05:19.000000000 +0800
@@ -32,20 +32,35 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
 #include "acl/CertificateData.h"
 #include "acl/Checklist.h"
+#include "Debug.h"
 #include "cache_cf.h"
 #include "wordlist.h"
 
-ACLCertificateData::ACLCertificateData(SSLGETATTRIBUTE *sslStrategy) : attribute (NULL), values (), sslAttributeCall (sslStrategy)
-{}
+ACLCertificateData::ACLCertificateData(Ssl::GETX509ATTRIBUTE *sslStrategy, const char *attrs, bool optionalAttr) : validAttributesStr(attrs), attributeIsOptional(optionalAttr), attribute (NULL), values (), sslAttributeCall (sslStrategy)
+{
+    if (attrs) {
+        size_t current = 0;
+        size_t next = std::string::npos;
+        std::string valid(attrs);
+        do {
+            next = valid.find_first_of( "|", current);
+            validAttributes.push_back(valid.substr( current, (next == std::string::npos ? std::string::npos : next - current)));
+            current = next + 1;
+        } while (next != std::string::npos);
+    }
+}
 
 ACLCertificateData::ACLCertificateData(ACLCertificateData const &old) : attribute (NULL), values (old.values), sslAttributeCall (old.sslAttributeCall)
 {
+    validAttributesStr = old.validAttributesStr;
+    validAttributes.assign (old.validAttributes.begin(), old.validAttributes.end());
+    attributeIsOptional = old.attributeIsOptional;
     if (old.attribute)
         attribute = xstrdup (old.attribute);
 }
 
 template<class T>
 inline void
@@ -64,19 +79,19 @@
 splaystrcmp (T&l, T&r)
 {
     return strcmp ((char *)l,(char *)r);
 }
 
 bool
-ACLCertificateData::match(SSL *ssl)
+ACLCertificateData::match(X509 *cert)
 {
-    if (!ssl)
+    if (!cert)
         return 0;
 
-    char const *value = sslAttributeCall(ssl, attribute);
-
+    char const *value = sslAttributeCall(cert, attribute);
+    debugs(28, 6, (attribute ? attribute : "value") << "=" << value);
     if (value == NULL)
         return 0;
 
     return values.match(value);
 }
 
@@ -88,46 +103,75 @@
 }
 
 wordlist *
 ACLCertificateData::dump()
 {
     wordlist *wl = NULL;
-    wordlistAdd(&wl, attribute);
+    if (validAttributesStr)
+        wordlistAdd(&wl, attribute);
     /* damn this is VERY inefficient for long ACL lists... filling
      * a wordlist this way costs Sum(1,N) iterations. For instance
      * a 1000-elements list will be filled in 499500 iterations.
      */
     /* XXX FIXME: don't break abstraction */
     values.values->walk(aclDumpAttributeListWalkee, &wl);
     return wl;
 }
 
 void
 ACLCertificateData::parse()
 {
-    char *newAttribute = strtokFile();
+    if (validAttributesStr) {
+        char *newAttribute = strtokFile();
 
-    if (!newAttribute)
-        self_destruct();
+        if (!newAttribute) {
+            if (attributeIsOptional)
+                return;
 
-    /* an acl must use consistent attributes in all config lines */
-    if (attribute) {
-        if (strcasecmp(newAttribute, attribute) != 0)
+            debugs(28, DBG_CRITICAL, "FATAL: required attribute argument missing");
             self_destruct();
-    } else
-        attribute = xstrdup(newAttribute);
+        }
+
+        // Handle the cases where we have optional -x type attributes
+        if (attributeIsOptional && newAttribute[0] != '-')
+            // The read token is not an attribute/option, so add it to values list
+            values.insert(newAttribute);
+        else {
+            bool valid = false;
+            for (std::list<std::string>::const_iterator it = validAttributes.begin(); it != validAttributes.end(); ++it) {
+                if (*it == "*" || *it == newAttribute) {
+                    valid = true;
+                    break;
+                }
+            }
+
+            if (!valid) {
+                debugs(28, DBG_CRITICAL, "FATAL: Unknown option. Supported option(s) are: " << validAttributesStr);
+                self_destruct();
+            }
+
+            /* an acl must use consistent attributes in all config lines */
+            if (attribute) {
+                if (strcasecmp(newAttribute, attribute) != 0) {
+                    debugs(28, DBG_CRITICAL, "FATAL: An acl must use consistent attributes in all config lines (" << newAttribute << "!=" << attribute << ").");
+                    self_destruct();
+                }
+            } else
+                attribute = xstrdup(newAttribute);
+        }
+    }
 
     values.parse();
 }
 
 bool
 ACLCertificateData::empty() const
 {
     return values.empty();
 }
 
-ACLData<SSL *> *
+ACLData<X509 *> *
 ACLCertificateData::clone() const
 {
     /* Splay trees don't clone yet. */
     return new ACLCertificateData(*this);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/CertificateData.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/CertificateData.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/CertificateData.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/CertificateData.h	2015-05-01 18:05:19.000000000 +0800
@@ -35,34 +35,46 @@
 
 #include "splay.h"
 #include "acl/Acl.h"
 #include "acl/Data.h"
 #include "ssl/support.h"
 #include "acl/StringData.h"
+#include <string>
+#include <list>
 
 /// \ingroup ACLAPI
-class ACLCertificateData : public ACLData<SSL *>
+class ACLCertificateData : public ACLData<X509 *>
 {
 
 public:
     MEMPROXY_CLASS(ACLCertificateData);
 
-    ACLCertificateData(SSLGETATTRIBUTE *);
+    ACLCertificateData(Ssl::GETX509ATTRIBUTE *, const char *attributes, bool optionalAttr = false);
     ACLCertificateData(ACLCertificateData const &);
     ACLCertificateData &operator= (ACLCertificateData const &);
     virtual ~ACLCertificateData();
-    bool match(SSL *);
+    bool match(X509 *);
     wordlist *dump();
     void parse();
     bool empty() const;
-    virtual ACLData<SSL *> *clone() const;
+    virtual ACLData<X509 *> *clone() const;
 
+    /// A '|'-delimited list of valid ACL attributes.
+    /// A "*" item means that any attribute is acceptable.
+    /// Assumed to be a const-string and is never duped/freed.
+    /// Nil unless ACL form is: acl Name type attribute value1 ...
+    const char *validAttributesStr;
+    /// Parsed list of valid attribute names
+    std::list<std::string> validAttributes;
+    /// True if the attribute is optional (-xxx options)
+    bool attributeIsOptional;
     char *attribute;
     ACLStringData values;
 
 private:
-    SSLGETATTRIBUTE *sslAttributeCall;
+    /// The callback used to retrieve the data from X509 cert
+    Ssl::GETX509ATTRIBUTE *sslAttributeCall;
 };
 
 MEMPROXY_CLASS_INLINE(ACLCertificateData);
 
 #endif /* SQUID_ACLCERTIFICATEDATA_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Certificate.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Certificate.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Certificate.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Certificate.h	2015-05-01 18:05:19.000000000 +0800
@@ -37,17 +37,17 @@
 #include "acl/Data.h"
 #include "acl/Checklist.h"
 #include "ssl/support.h"
 #include "acl/Strategised.h"
 
 /// \ingroup ACLAPI
-class ACLCertificateStrategy : public ACLStrategy<SSL *>
+class ACLCertificateStrategy : public ACLStrategy<X509 *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLCertificateStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLCertificateStrategy(ACLCertificateStrategy const &);
 
@@ -61,12 +61,12 @@
 /// \ingroup ACLAPI
 class ACLCertificate
 {
 
 private:
     static ACL::Prototype UserRegistryProtoype;
-    static ACLStrategised<SSL*> UserRegistryEntry_;
+    static ACLStrategised<X509*> UserRegistryEntry_;
     static ACL::Prototype CARegistryProtoype;
-    static ACLStrategised<SSL *> CARegistryEntry_;
+    static ACLStrategised<X509 *> CARegistryEntry_;
 };
 
 #endif /* SQUID_ACLCERTIFICATE_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Checklist.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Checklist.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Checklist.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Checklist.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,143 +1,52 @@
 /*
  * DEBUG: section 28    Access Control
- * AUTHOR: Duane Wessels
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
 #include "acl/Checklist.h"
+#include "acl/Tree.h"
 #include "Debug.h"
 #include "profiler/Profiler.h"
 
-void
-ACLChecklist::matchNonBlocking()
+/// common parts of nonBlockingCheck() and resumeNonBlockingCheck()
+bool
+ACLChecklist::prepNonBlocking()
 {
-    if (checking())
-        return;
+    assert(accessList);
 
     if (callerGone()) {
         checkCallback(ACCESS_DUNNO); // the answer does not really matter
-        return;
-    }
-
-    /** The ACL List should NEVER be NULL when calling this method.
-     * Always caller should check for NULL and handle appropriate to its needs first.
-     * We cannot select a sensible default for all callers here. */
-    if (accessList == NULL) {
-        debugs(28, DBG_CRITICAL, "SECURITY ERROR: ACL " << this << " checked with nothing to match against!!");
-        checkCallback(ACCESS_DUNNO);
-        return;
+        return false;
     }
 
-    allow_t lastSeenKeyword = ACCESS_DUNNO;
-    /* NOTE: This holds a cbdata reference to the current access_list
-     * entry, not the whole list.
+    /** \par
+     * If the accessList is no longer valid (i.e. its been
+     * freed because of a reconfigure), then bail with ACCESS_DUNNO.
      */
-    while (accessList != NULL) {
-        /** \par
-         * If the _acl_access is no longer valid (i.e. its been
-         * freed because of a reconfigure), then bail with ACCESS_DUNNO.
-         */
-
-        if (!cbdataReferenceValid(accessList)) {
-            cbdataReferenceDone(accessList);
-            debugs(28, 4, "ACLChecklist::check: " << this << " accessList is invalid");
-            checkCallback(ACCESS_DUNNO);
-            return;
-        }
-
-        checking (true);
-        checkAccessList();
-        checking (false);
-
-        if (asyncInProgress()) {
-            return;
-        }
-
-        if (finished()) {
-            /** \par
-             * Either the request is allowed, denied, requires authentication.
-             */
-            debugs(28, 3, "ACLChecklist::check: " << this << " match found, calling back with " << currentAnswer());
-            cbdataReferenceDone(accessList); /* A */
-            checkCallback(currentAnswer());
-            /* From here on in, this may be invalid */
-            return;
-        }
-
-        lastSeenKeyword = accessList->allow;
-
-        /*
-         * Reference the next access entry
-         */
-        const acl_access *A = accessList;
 
-        assert (A);
-
-        accessList = cbdataReference(A->next);
-
-        cbdataReferenceDone(A);
+    if (!cbdataReferenceValid(accessList)) {
+        cbdataReferenceDone(accessList);
+        debugs(28, 4, "ACLChecklist::check: " << this << " accessList is invalid");
+        checkCallback(ACCESS_DUNNO);
+        return false;
     }
 
-    calcImplicitAnswer(lastSeenKeyword);
-    checkCallback(currentAnswer());
-}
-
-bool
-ACLChecklist::asyncNeeded() const
-{
-    return state_ != NullState::Instance();
-}
-
-bool
-ACLChecklist::asyncInProgress() const
-{
-    return async_;
+    return true;
 }
 
 void
-ACLChecklist::asyncInProgress(bool const newAsync)
+ACLChecklist::completeNonBlocking()
 {
-    assert (!finished() && !(asyncInProgress() && newAsync));
-    async_ = newAsync;
-    debugs(28, 3, "ACLChecklist::asyncInProgress: " << this <<
-           " async set to " << async_);
-}
+    assert(!asyncInProgress());
 
-bool
-ACLChecklist::finished() const
-{
-    return finished_;
+    if (!finished())
+        calcImplicitAnswer();
+
+    cbdataReferenceDone(accessList);
+    checkCallback(currentAnswer());
 }
 
 void
 ACLChecklist::markFinished(const allow_t &finalAnswer, const char *reason)
 {
     assert (!finished() && !asyncInProgress());
@@ -148,210 +57,152 @@
 
 /// Called first (and once) by all checks to initialize their state
 void
 ACLChecklist::preCheck(const char *what)
 {
     debugs(28, 3, HERE << this << " checking " << what);
-    finished_ = false;
-}
 
-void
-ACLChecklist::checkAccessList()
-{
-    debugs(28, 3, HERE << this << " checking '" << accessList->cfgline << "'");
-    /* does the current AND clause match */
-    if (matchAclList(accessList->aclList, false))
-        markFinished(accessList->allow, "first matching rule won");
+    // concurrent checks using the same Checklist are not supported
+    assert(!occupied_);
+    occupied_ = true;
+    asyncLoopDepth_ = 0;
 
-    // If we are not finished() here, the caller must distinguish between
-    // slow async calls and pure rule mismatches using asyncInProgress().
-}
-
-void
-ACLChecklist::checkForAsync()
-{
-    asyncState()->checkForAsync(this);
+    AclMatchedName = NULL;
+    finished_ = false;
 }
 
-// ACLFilledChecklist overwrites this to unclock something before we
-// "delete this"
-void
-ACLChecklist::checkCallback(allow_t answer)
+bool
+ACLChecklist::matchChild(const Acl::InnerNode *current, Acl::Nodes::const_iterator pos, const ACL *child)
 {
-    ACLCB *callback_;
-    void *cbdata_;
-    debugs(28, 3, "ACLChecklist::checkCallback: " << this << " answer=" << answer);
+    assert(current && child);
 
-    callback_ = callback;
-    callback = NULL;
-
-    if (cbdataReferenceValidDone(callback_data, &cbdata_))
-        callback_(answer, cbdata_);
+    // Remember the current tree location to prevent "async loop" cases where
+    // the same child node wants to go async more than once.
+    matchLoc_ = Breadcrumb(current, pos);
+    asyncLoopDepth_ = 0;
+
+    // if there are any breadcrumbs left, then follow them on the way down
+    bool result = false;
+    if (matchPath.empty()) {
+        result = child->matches(this);
+    } else {
+        const Breadcrumb top(matchPath.top());
+        assert(child == top.parent);
+        matchPath.pop();
+        result = top.parent->resumeMatchingAt(this, top.position);
+    }
 
-    delete this;
-}
+    if (asyncInProgress()) {
+        // We get here for node N that called goAsync() and then, as the call
+        // stack unwinds, for the nodes higher in the ACL tree that led to N.
+        matchPath.push(Breadcrumb(current, pos));
+    } else {
+        asyncLoc_.clear();
+    }
 
-/// An ACLChecklist::matchNodes() wrapper to simplify profiling.
-bool
-ACLChecklist::matchAclList(const ACLList * head, bool const fast)
-{
-    // TODO: remove by using object con/destruction-based PROF_* macros.
-    PROF_start(aclMatchAclList);
-    const bool result = matchNodes(head, fast);
-    PROF_stop(aclMatchAclList);
+    matchLoc_.clear();
     return result;
 }
 
-/** Returns true if and only if there was a match. If false is returned:
-    finished() indicates an error or exception of some kind, while
-    !finished() means there was a mismatch or an allowed slow async call.
-    If async calls are allowed (i.e. 'fast' was false), then those last
-    two cases can be distinguished using asyncInProgress().
-*/
 bool
-ACLChecklist::matchNodes(const ACLList * head, bool const fast)
+ACLChecklist::goAsync(AsyncState *state)
 {
-    assert(!finished());
-
-    for (const ACLList *node = head; node; node = node->next) {
-
-        const NodeMatchingResult resultBeforeAsync = matchNode(*node, fast);
-
-        if (resultBeforeAsync == nmrMatch)
-            continue;
+    assert(state);
+    assert(!asyncInProgress());
+    assert(matchLoc_.parent);
+
+    // TODO: add a once-in-a-while WARNING about fast directive using slow ACL?
+    if (!asyncCaller_) {
+        debugs(28, 2, this << " a fast-only directive uses a slow ACL!");
+        return false;
+    }
 
-        if (resultBeforeAsync == nmrMismatch || resultBeforeAsync == nmrFinished)
+    // TODO: add a once-in-a-while WARNING about async loops?
+    if (matchLoc_ == asyncLoc_) {
+        debugs(28, 2, this << " a slow ACL resumes by going async again! (loop #" << asyncLoopDepth_ << ")");
+        // external_acl_type may cause async auth lookup plus its own async check
+        // which has the appearance of a loop. Allow some retries.
+        // TODO: make it configurable and check BH retry attempts vs this check?
+        if (asyncLoopDepth_ > 5)
             return false;
+    }
 
-        assert(resultBeforeAsync == nmrNeedsAsync);
-
-        // Ideally, this should be inside match() itself, but that requires
-        // prohibiting slow ACLs in options that do not support them.
-        // TODO: rename to maybeStartAsync()?
-        checkForAsync();
-
-        // Some match() code claims that an async lookup is needed, but then
-        // fails to start an async lookup when given a chance. We catch such
-        // cases here and call matchNode() again, hoping that some cached data
-        // prevents us from going async again.
-        // This is inefficient and ugly, but fixing all match() code, including
-        // the code it calls, such as ipcache_nbgethostbyname(), takes time.
-        if (!asyncInProgress()) { // failed to start an async operation
-
-            if (finished()) {
-                debugs(28, 3, HERE << this << " finished after failing to go async: " << currentAnswer());
-                return false; // an exceptional case
-            }
-
-            const NodeMatchingResult resultAfterAsync = matchNode(*node, true);
-            // the second call disables slow checks so we cannot go async again
-            assert(resultAfterAsync != nmrNeedsAsync);
-            if (resultAfterAsync == nmrMatch)
-                continue;
+    asyncLoc_ = matchLoc_; // prevent async loops
+    ++asyncLoopDepth_;
 
-            assert(resultAfterAsync == nmrMismatch || resultAfterAsync == nmrFinished);
-            return false;
-        }
-
-        assert(!finished()); // async operation is truly asynchronous
-        debugs(28, 3, HERE << this << " awaiting async operation");
+    asyncStage_ = asyncStarting;
+    changeState(state);
+    state->checkForAsync(this); // this is supposed to go async
+
+    // Did AsyncState object actually go async? If not, tell the caller.
+    if (asyncStage_ != asyncStarting) {
+        assert(asyncStage_ == asyncFailed);
+        asyncStage_ = asyncNone; // sanity restored
         return false;
     }
 
-    debugs(28, 3, HERE << this << " success: all ACLs matched");
+    // yes, we must pause until the async callback calls resumeNonBlockingCheck
+    asyncStage_ = asyncRunning;
     return true;
 }
 
-/// Check whether a single ACL matches, returning NodeMatchingResult
-ACLChecklist::NodeMatchingResult
-ACLChecklist::matchNode(const ACLList &node, bool const fast)
-{
-    const bool nodeMatched = node.matches(this);
-    const bool needsAsync = asyncNeeded();
-    const bool matchFinished = finished();
-
-    debugs(28, 3, HERE << this <<
-           " matched=" << nodeMatched <<
-           " async=" << needsAsync <<
-           " finished=" << matchFinished);
-
-    /* There are eight possible outcomes of the matches() call based on
-       (matched, async, finished) permutations. We support these four:
-       matched,!async,!finished: a match (must check next rule node)
-       !matched,!async,!finished: a mismatch (whole rule fails to match)
-       !matched,!async,finished: error or special condition (propagate)
-       !matched,async,!finished: ACL needs to make an async call (pause)
-     */
-
-    if (nodeMatched) {
-        // matches() should return false in all special cases
-        assert(!needsAsync && !matchFinished);
-        return nmrMatch;
-    }
-
-    if (matchFinished) {
-        // we cannot be done and need an async call at the same time
-        assert(!needsAsync);
-        debugs(28, 3, HERE << this << " exception: " << currentAnswer());
-        return nmrFinished;
-    }
+// ACLFilledChecklist overwrites this to unclock something before we
+// "delete this"
+void
+ACLChecklist::checkCallback(allow_t answer)
+{
+    ACLCB *callback_;
+    void *cbdata_;
+    debugs(28, 3, "ACLChecklist::checkCallback: " << this << " answer=" << answer);
 
-    if (!needsAsync) {
-        debugs(28, 3, HERE << this << " simple mismatch");
-        return nmrMismatch;
-    }
+    callback_ = callback;
+    callback = NULL;
 
-    /* we need an async call */
+    if (cbdataReferenceValidDone(callback_data, &cbdata_))
+        callback_(answer, cbdata_);
 
-    if (fast) {
-        changeState(NullState::Instance()); // disable async checks
-        markFinished(ACCESS_DUNNO, "async required but prohibited");
-        debugs(28, 3, HERE << this << " DUNNO because cannot async");
-        return nmrFinished;
-    }
+    // not really meaningful just before delete, but here for completeness sake
+    occupied_ = false;
 
-    debugs(28, 3, HERE << this << " going async");
-    return nmrNeedsAsync;
+    delete this;
 }
 
 ACLChecklist::ACLChecklist() :
         accessList (NULL),
         callback (NULL),
         callback_data (NULL),
-        async_(false),
+        asyncCaller_(false),
+        occupied_(false),
         finished_(false),
         allow_(ACCESS_DENIED),
+        asyncStage_(asyncNone),
         state_(NullState::Instance()),
-        checking_(false)
+        asyncLoopDepth_(0)
 {
 }
 
 ACLChecklist::~ACLChecklist()
 {
     assert (!asyncInProgress());
 
     cbdataReferenceDone(accessList);
 
     debugs(28, 4, "ACLChecklist::~ACLChecklist: destroyed " << this);
 }
 
-void
-ACLChecklist::AsyncState::changeState (ACLChecklist *checklist, AsyncState *newState) const
-{
-    checklist->changeState(newState);
-}
-
 ACLChecklist::NullState *
 ACLChecklist::NullState::Instance()
 {
     return &_instance;
 }
 
 void
 ACLChecklist::NullState::checkForAsync(ACLChecklist *) const
-{}
+{
+    assert(false); // or the Checklist will never get out of the async state
+}
 
 ACLChecklist::NullState ACLChecklist::NullState::_instance;
 
 void
 ACLChecklist::changeState (AsyncState *newState)
 {
@@ -378,27 +229,100 @@
 void
 ACLChecklist::nonBlockingCheck(ACLCB * callback_, void *callback_data_)
 {
     preCheck("slow rules");
     callback = callback_;
     callback_data = cbdataReference(callback_data_);
-    matchNonBlocking();
+    asyncCaller_ = true;
+
+    /** The ACL List should NEVER be NULL when calling this method.
+     * Always caller should check for NULL and handle appropriate to its needs first.
+     * We cannot select a sensible default for all callers here. */
+    if (accessList == NULL) {
+        debugs(28, DBG_CRITICAL, "SECURITY ERROR: ACL " << this << " checked with nothing to match against!!");
+        checkCallback(ACCESS_DUNNO);
+        return;
+    }
+
+    if (prepNonBlocking()) {
+        matchAndFinish(); // calls markFinished() on success
+        if (!asyncInProgress())
+            completeNonBlocking();
+    } // else checkCallback() has been called
+}
+
+void
+ACLChecklist::resumeNonBlockingCheck(AsyncState *state)
+{
+    assert(asyncState() == state);
+    changeState(NullState::Instance());
+
+    if (asyncStage_ == asyncStarting) { // oops, we did not really go async
+        asyncStage_ = asyncFailed; // goAsync() checks for that
+        // Do not fall through to resume checks from the async callback. Let
+        // the still-pending(!) goAsync() notice and notify its caller instead.
+        return;
+    }
+    assert(asyncStage_ == asyncRunning);
+    asyncStage_ = asyncNone;
+
+    assert(!matchPath.empty());
+
+    if (!prepNonBlocking())
+        return; // checkCallback() has been called
+
+    if (!finished())
+        matchAndFinish();
+
+    if (asyncInProgress())
+        assert(!matchPath.empty()); // we have breadcrumbs to resume matching
+    else
+        completeNonBlocking();
+}
+
+/// performs (or resumes) an ACL tree match and, if successful, sets the action
+void
+ACLChecklist::matchAndFinish()
+{
+    bool result = false;
+    if (matchPath.empty()) {
+        result = accessList->matches(this);
+    } else {
+        const Breadcrumb top(matchPath.top());
+        matchPath.pop();
+        result = top.parent->resumeMatchingAt(this, top.position);
+    }
+
+    if (result) // the entire tree matched
+        markFinished(accessList->winningAction(), "match");
 }
 
 allow_t const &
-ACLChecklist::fastCheck(const ACLList * list)
+ACLChecklist::fastCheck(const Acl::Tree * list)
 {
     PROF_start(aclCheckFast);
 
     preCheck("fast ACLs");
+    asyncCaller_ = false;
+
+    // Concurrent checks are not supported, but sequential checks are, and they
+    // may use a mixture of fastCheck(void) and fastCheck(list) calls.
+    const Acl::Tree * const savedList = accessList;
+
+    accessList = cbdataReference(list);
+
+    // assume DENY/ALLOW on mis/matches due to action-free accessList
+    // matchAndFinish() takes care of the ALLOW case
+    if (accessList && cbdataReferenceValid(accessList))
+        matchAndFinish(); // calls markFinished() on success
+    if (!finished())
+        markFinished(ACCESS_DENIED, "ACLs failed to match");
 
-    // assume DENY/ALLOW on mis/matches due to not having acl_access object
-    if (matchAclList(list, true))
-        markFinished(ACCESS_ALLOWED, "all ACLs matched");
-    else if (!finished())
-        markFinished(ACCESS_DENIED, "ACL mismatched");
+    cbdataReferenceDone(accessList);
+    accessList = savedList;
+    occupied_ = false;
     PROF_stop(aclCheckFast);
     return currentAnswer();
 }
 
 /* Warning: do not cbdata lock this here - it
  * may be static or on the stack
@@ -406,71 +330,57 @@
 allow_t const &
 ACLChecklist::fastCheck()
 {
     PROF_start(aclCheckFast);
 
     preCheck("fast rules");
+    asyncCaller_ = false;
 
-    allow_t lastSeenKeyword = ACCESS_DUNNO;
     debugs(28, 5, "aclCheckFast: list: " << accessList);
-    const acl_access *acl = cbdataReference(accessList);
-    while (acl != NULL && cbdataReferenceValid(acl)) {
-        // on a match, finish
-        if (matchAclList(acl->aclList, true))
-            markFinished(acl->allow, "first matching rule won");
+    const Acl::Tree *acl = cbdataReference(accessList);
+    if (acl != NULL && cbdataReferenceValid(acl)) {
+        matchAndFinish(); // calls markFinished() on success
 
         // if finished (on a match or in exceptional cases), stop
         if (finished()) {
             cbdataReferenceDone(acl);
+            occupied_ = false;
             PROF_stop(aclCheckFast);
             return currentAnswer();
         }
 
-        // on a mismatch, try the next access rule
-        lastSeenKeyword = acl->allow;
-        const acl_access *A = acl;
-        acl = cbdataReference(acl->next);
-        cbdataReferenceDone(A);
+        // fall through for mismatch handling
     }
 
     // There were no rules to match or no rules matched
-    calcImplicitAnswer(lastSeenKeyword);
+    calcImplicitAnswer();
+    cbdataReferenceDone(acl);
+    occupied_ = false;
     PROF_stop(aclCheckFast);
 
     return currentAnswer();
 }
 
-/// When no rules matched, the answer is the inversion of the last seen rule
-/// action (or ACCESS_DUNNO if the reversal is not possible). The caller
-/// should set lastSeenAction to ACCESS_DUNNO if there were no rules to see.
+/// When no rules matched, the answer is the inversion of the last rule
+/// action (or ACCESS_DUNNO if the reversal is not possible).
 void
-ACLChecklist::calcImplicitAnswer(const allow_t &lastSeenAction)
+ACLChecklist::calcImplicitAnswer()
 {
+    const allow_t lastAction = (accessList && cbdataReferenceValid(accessList)) ?
+                               accessList->lastAction() : allow_t(ACCESS_DUNNO);
     allow_t implicitRuleAnswer = ACCESS_DUNNO;
-    if (lastSeenAction == ACCESS_DENIED) // reverse last seen "deny"
+    if (lastAction == ACCESS_DENIED) // reverse last seen "deny"
         implicitRuleAnswer = ACCESS_ALLOWED;
-    else if (lastSeenAction == ACCESS_ALLOWED) // reverse last seen "allow"
+    else if (lastAction == ACCESS_ALLOWED) // reverse last seen "allow"
         implicitRuleAnswer = ACCESS_DENIED;
     // else we saw no rules and will respond with ACCESS_DUNNO
 
     debugs(28, 3, HERE << this << " NO match found, last action " <<
-           lastSeenAction << " so returning " << implicitRuleAnswer);
+           lastAction << " so returning " << implicitRuleAnswer);
     markFinished(implicitRuleAnswer, "implicit rule won");
 }
 
 bool
-ACLChecklist::checking() const
-{
-    return checking_;
-}
-
-void
-ACLChecklist::checking (bool const newValue)
-{
-    checking_ = newValue;
-}
-
-bool
 ACLChecklist::callerGone()
 {
     return !cbdataReferenceValid(callback_data);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Checklist.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Checklist.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Checklist.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Checklist.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,13 +28,14 @@
  *
  */
 
 #ifndef SQUID_ACLCHECKLIST_H
 #define SQUID_ACLCHECKLIST_H
 
-#include "acl/Acl.h"
+#include "acl/InnerNode.h"
+#include <stack>
 
 /// ACL checklist callback
 typedef void ACLCB(allow_t, void *);
 
 /** \ingroup ACLAPI
     Base class for maintaining Squid and transaction state for access checks.
@@ -64,15 +65,12 @@
     class AsyncState
     {
 
     public:
         virtual void checkForAsync(ACLChecklist *) const = 0;
         virtual ~AsyncState() {}
-
-    protected:
-        void changeState (ACLChecklist *, AsyncState *) const;
     };
 
     class NullState : public AsyncState
     {
 
     public:
@@ -150,78 +148,97 @@
      * Some ACLs may require an async lookup which is prohibited by this
      * method. In this case, the exceptional check result of ACCESS_DUNNO is
      * immediately returned.
      *
      * If there are no ACLs to check at all, the result becomes ACCESS_ALLOWED.
      */
-    allow_t const & fastCheck(const ACLList * list);
+    allow_t const & fastCheck(const Acl::Tree *list);
+
+    /// If slow lookups are allowed, switches into "async in progress" state.
+    /// Otherwise, returns false; the caller is expected to handle the failure.
+    bool goAsync(AsyncState *);
+
+    /// Matches (or resumes matching of) a child node while maintaning
+    /// resumption breadcrumbs if a [grand]child node goes async.
+    bool matchChild(const Acl::InnerNode *parent, Acl::Nodes::const_iterator pos, const ACL *child);
 
-    // whether the last checked ACL of the current rule needs
-    // an async operation to determine whether there was a match
-    bool asyncNeeded() const;
-    bool asyncInProgress() const;
-    void asyncInProgress(bool const);
+    /// Whether we should continue to match tree nodes or stop/pause.
+    bool keepMatching() const { return !finished() && !asyncInProgress(); }
 
     /// whether markFinished() was called
-    bool finished() const;
+    bool finished() const { return finished_; }
+    /// async call has been started and has not finished (or failed) yet
+    bool asyncInProgress() const { return asyncStage_ != asyncNone; }
     /// called when no more ACLs should be checked; sets the final answer and
     /// prints a debugging message explaining the reason for that answer
     void markFinished(const allow_t &newAnswer, const char *reason);
 
     const allow_t &currentAnswer() const { return allow_; }
 
-    void changeState(AsyncState *);
-    AsyncState *asyncState() const;
-
     // XXX: ACLs that need request or reply have to use ACLFilledChecklist and
     // should do their own checks so that we do not have to povide these two
     // for ACL::checklistMatches to use
     virtual bool hasRequest() const = 0;
     virtual bool hasReply() const = 0;
 
 private:
     /// Calls non-blocking check callback with the answer and destroys self.
     void checkCallback(allow_t answer);
 
-    void checkAccessList();
-    void checkForAsync();
+    void matchAndFinish();
+
+    void changeState(AsyncState *);
+    AsyncState *asyncState() const;
 
 public:
-    const acl_access *accessList;
+    const Acl::Tree *accessList;
 
     ACLCB *callback;
     void *callback_data;
 
-    /**
-     * Performs non-blocking check starting with the current rule.
-     * Used by nonBlockingCheck() to initiate the checks and by
-     * async operation callbacks to resume checks after the async
-     * operation updates the current Squid state. See nonBlockingCheck()
-     * for details on final result determination.
-     */
-    void matchNonBlocking();
+    /// Resumes non-blocking check started by nonBlockingCheck() and
+    /// suspended until some async operation updated Squid state.
+    void resumeNonBlockingCheck(AsyncState *state);
 
 private: /* internal methods */
+    /// Position of a child node within an ACL tree.
+    class Breadcrumb
+    {
+    public:
+        Breadcrumb(): parent(NULL) {}
+        Breadcrumb(const Acl::InnerNode *aParent, Acl::Nodes::const_iterator aPos): parent(aParent), position(aPos) {}
+        bool operator ==(const Breadcrumb &b) const { return parent == b.parent && (!parent || position == b.position); }
+        bool operator !=(const Breadcrumb &b) const { return !this->operator ==(b); }
+        void clear() { parent = NULL; }
+        const Acl::InnerNode *parent; ///< intermediate node in the ACL tree
+        Acl::Nodes::const_iterator position; ///< child position inside parent
+    };
+
     /// possible outcomes when trying to match a single ACL node in a list
     typedef enum { nmrMatch, nmrMismatch, nmrFinished, nmrNeedsAsync }
     NodeMatchingResult;
 
     /// prepare for checking ACLs; called once per check
     void preCheck(const char *what);
-    bool matchAclList(const ACLList * list, bool const fast);
-    bool matchNodes(const ACLList * head, bool const fast);
-    NodeMatchingResult matchNode(const ACLList &node, bool const fast);
-    void calcImplicitAnswer(const allow_t &lastSeenAction);
+    bool prepNonBlocking();
+    void completeNonBlocking();
+    void calcImplicitAnswer();
 
-    bool async_;
+    bool asyncCaller_; ///< whether the caller supports async/slow ACLs
+    bool occupied_; ///< whether a check (fast or non-blocking) is in progress
     bool finished_;
     allow_t allow_;
-    AsyncState *state_;
 
-    bool checking_;
-    bool checking() const;
-    void checking (bool const);
+    enum AsyncStage { asyncNone, asyncStarting, asyncRunning, asyncFailed };
+    AsyncStage asyncStage_;
+    AsyncState *state_;
+    Breadcrumb matchLoc_; ///< location of the node running matches() now
+    Breadcrumb asyncLoc_; ///< currentNode_ that called goAsync()
+    unsigned asyncLoopDepth_; ///< how many times the current async state has resumed
 
     bool callerGone();
+
+    /// suspended (due to an async lookup) matches() in the ACL tree
+    std::stack<Breadcrumb> matchPath;
 };
 
 #endif /* SQUID_ACLCHECKLIST_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Data.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Data.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Data.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Data.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,12 +30,13 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 #ifndef SQUID_ACLDATA_H
 #define SQUID_ACLDATA_H
 
 class wordlist;
+extern char *xstrtok(char *str, const char *delimiters);
 
 /// \ingroup ACLAPI
 template <class M>
 class ACLData
 {
 
@@ -47,9 +48,13 @@
     virtual wordlist *dump() =0;
     virtual void parse() =0;
     virtual ACLData *clone() const =0;
     virtual void prepareForUse() {}
 
     virtual bool empty() const =0;
+
+    /// XXX: Temporary hack to allow old ACL code to handle quoted values without
+    /// replacing every strtok() call.
+    char *strtok(char *str, const char *dels) { return xstrtok(str, dels); }
 };
 
 #endif /* SQUID_ACLDATA_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationAsn.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationAsn.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationAsn.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationAsn.h	2015-05-01 18:05:19.000000000 +0800
@@ -38,13 +38,13 @@
 
 /// \ingroup ACLAPI
 class ACLDestinationASNStrategy : public ACLStrategy<Ip::Address>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLDestinationASNStrategy *Instance();
 
     /**
      * Not implemented to prevent copies of the instance.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationDomain.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationDomain.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationDomain.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationDomain.cc	2015-05-01 18:05:19.000000000 +0800
@@ -50,38 +50,38 @@
 }
 
 void
 DestinationDomainLookup::checkForAsync(ACLChecklist *cl) const
 {
     ACLFilledChecklist *checklist = Filled(cl);
-    checklist->asyncInProgress(true);
     fqdncache_nbgethostbyaddr(checklist->dst_addr, LookupDone, checklist);
 }
 
 void
 DestinationDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
-    assert (checklist->asyncState() == DestinationDomainLookup::Instance());
-
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
     checklist->markDestinationDomainChecked();
     checklist->request->recordLookup(details);
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(DestinationDomainLookup::Instance());
 }
 
 int
-ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &flags)
 {
     assert(checklist != NULL && checklist->request != NULL);
 
     if (data->match(checklist->request->GetHost())) {
         return 1;
     }
 
+    if (flags.isSet(ACL_F_NO_LOOKUP)) {
+        debugs(28, 3, "aclMatchAcl:  No-lookup DNS ACL '" << AclMatchedName << "' for '" << checklist->request->GetHost() << "'");
+        return 0;
+    }
+
     /* numeric IPA? no, trust the above result. */
     if (checklist->request->GetHostIsNumeric() == 0) {
         return 0;
     }
 
     /* do we already have the rDNS? match on it if we do. */
@@ -104,14 +104,15 @@
     if (fqdn) {
         checklist->dst_rdns = xstrdup(fqdn);
         return data->match(fqdn);
     } else if (!checklist->destinationDomainChecked()) {
         /* FIXME: Using AclMatchedName here is not OO correct. Should find a way to the current acl */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->request->GetHost() << "'");
-        checklist->changeState(DestinationDomainLookup::Instance());
-        return 0;
+        if (checklist->goAsync(DestinationDomainLookup::Instance()))
+            return -1;
+        // else fall through to "none" match, hiding the lookup failure (XXX)
     }
 
     return data->match("none");
 }
 
 ACLDestinationDomainStrategy *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationDomain.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationDomain.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationDomain.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationDomain.h	2015-05-01 18:05:19.000000000 +0800
@@ -40,13 +40,13 @@
 
 /// \ingroup ACLAPI
 class ACLDestinationDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLDestinationDomainStrategy *Instance();
     virtual bool requiresRequest() const {return true;}
 
     /**
      * Not implemented to prevent copies of the instance.
      \par
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationIp.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationIp.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationIp.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationIp.cc	2015-05-01 18:05:19.000000000 +0800
@@ -36,32 +36,49 @@
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 
+ACLFlag ACLDestinationIP::SupportedFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
+
 char const *
 ACLDestinationIP::typeString() const
 {
     return "dst";
 }
 
 int
 ACLDestinationIP::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
 
+    // if there is no HTTP request details fallback to the dst_addr
+    if (!checklist->request)
+        return ACLIP::match(checklist->dst_addr);
+
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we will force DIRECT and only to the original client destination.
     // In which case, we also need this ACL to accurately match the destination
-    if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.spoofClientIp)) {
+    if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.interceptTproxy)) {
         assert(checklist->conn() && checklist->conn()->clientConnection != NULL);
         return ACLIP::match(checklist->conn()->clientConnection->local);
     }
 
+    if (flags.isSet(ACL_F_NO_LOOKUP)) {
+        if (!checklist->request->GetHostIsNumeric()) {
+            debugs(28, 3, "aclMatchAcl:  No-lookup DNS ACL '" << AclMatchedName << "' for '" << checklist->request->GetHost() << "'");
+            return 0;
+        }
+
+        if (ACLIP::match(checklist->request->host_addr))
+            return 1;
+        return 0;
+    }
+
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
         /* Entry in cache found */
 
         for (int k = 0; k < (int) ia->count; ++k) {
@@ -70,17 +87,18 @@
         }
 
         return 0;
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << name << "' ACL for '" << checklist->request->GetHost() << "'");
-        checklist->changeState (DestinationIPLookup::Instance());
-        return 0;
-    } else {
-        return 0;
+        if (checklist->goAsync(DestinationIPLookup::Instance()))
+            return -1;
+        // else fall through to mismatch, hiding the lookup failure (XXX)
     }
+
+    return 0;
 }
 
 DestinationIPLookup DestinationIPLookup::instance_;
 
 DestinationIPLookup *
 DestinationIPLookup::Instance()
@@ -89,26 +107,22 @@
 }
 
 void
 DestinationIPLookup::checkForAsync(ACLChecklist *cl)const
 {
     ACLFilledChecklist *checklist = Filled(cl);
-    checklist->asyncInProgress(true);
     ipcache_nbgethostbyname(checklist->request->GetHost(), LookupDone, checklist);
 }
 
 void
 DestinationIPLookup::LookupDone(const ipcache_addrs *, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
-    assert (checklist->asyncState() == DestinationIPLookup::Instance());
-    checklist->request->flags.destinationIpLookedUp=true;
+    checklist->request->flags.destinationIpLookedUp = true;
     checklist->request->recordLookup(details);
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(DestinationIPLookup::Instance());
 }
 
 ACL *
 ACLDestinationIP::clone() const
 {
     return new ACLDestinationIP(*this);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationIp.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationIp.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/DestinationIp.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/DestinationIp.h	2015-05-01 18:05:19.000000000 +0800
@@ -52,18 +52,19 @@
 class ACLDestinationIP : public ACLIP
 {
 
 public:
     MEMPROXY_CLASS(ACLDestinationIP);
 
+    ACLDestinationIP(): ACLIP(ACLDestinationIP::SupportedFlags) {}
     virtual char const *typeString() const;
     virtual int match(ACLChecklist *checklist);
-    virtual bool requiresRequest() const {return true;}
 
     virtual ACL *clone()const;
 
+    static ACLFlag SupportedFlags[];
 private:
     static Prototype RegistryProtoype;
     static ACLDestinationIP RegistryEntry_;
 };
 
 MEMPROXY_CLASS_INLINE(ACLDestinationIP);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Eui64.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Eui64.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Eui64.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Eui64.cc	2015-05-01 18:05:19.000000000 +0800
@@ -132,13 +132,13 @@
 int
 ACLEui64::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
 
     /* IPv4 does not do EUI-64 (yet) */
-    if (!checklist->src_addr.IsIPv6()) {
+    if (!checklist->src_addr.isIPv6()) {
         debugs(14, 3, "ACLEui64::match: IPv6 Required for EUI-64 Lookups. Skipping " << checklist->src_addr );
         return 0;
     }
 
     return aclMatchEui(&data, checklist->src_addr);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/FilledChecklist.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/FilledChecklist.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/FilledChecklist.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/FilledChecklist.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,37 +1,22 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "comm/forward.h"
+#include "ExternalACLEntry.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #include "auth/AclProxyAuth.h"
 #endif
 
 CBDATA_CLASS_INIT(ACLFilledChecklist);
 
-void *
-ACLFilledChecklist::operator new (size_t size)
-{
-    assert (size == sizeof(ACLFilledChecklist));
-    CBDATA_INIT_TYPE(ACLFilledChecklist);
-    ACLFilledChecklist *result = cbdataAlloc(ACLFilledChecklist);
-    return result;
-}
-
-void
-ACLFilledChecklist::operator delete (void *address)
-{
-    ACLFilledChecklist *t = static_cast<ACLFilledChecklist *>(address);
-    cbdataFree(t);
-}
-
 ACLFilledChecklist::ACLFilledChecklist() :
         dst_peer(NULL),
         dst_rdns(NULL),
         request (NULL),
         reply (NULL),
 #if USE_AUTH
@@ -40,33 +25,29 @@
 #if SQUID_SNMP
         snmp_community(NULL),
 #endif
 #if USE_SSL
         sslErrors(NULL),
 #endif
-        extacl_entry (NULL),
         conn_(NULL),
         fd_(-1),
         destinationDomainChecked_(false),
         sourceDomainChecked_(false)
 {
-    my_addr.SetEmpty();
-    src_addr.SetEmpty();
-    dst_addr.SetEmpty();
+    my_addr.setEmpty();
+    src_addr.setEmpty();
+    dst_addr.setEmpty();
     rfc931[0] = '\0';
 }
 
 ACLFilledChecklist::~ACLFilledChecklist()
 {
     assert (!asyncInProgress());
 
     safe_free(dst_rdns); // created by xstrdup().
 
-    if (extacl_entry)
-        cbdataReferenceDone(extacl_entry);
-
     HTTPMSGUNLOCK(request);
 
     HTTPMSGUNLOCK(reply);
 
     cbdataReferenceDone(conn_);
 
@@ -156,29 +137,29 @@
 #if SQUID_SNMP
         snmp_community(NULL),
 #endif
 #if USE_SSL
         sslErrors(NULL),
 #endif
-        extacl_entry (NULL),
         conn_(NULL),
         fd_(-1),
         destinationDomainChecked_(false),
         sourceDomainChecked_(false)
 {
-    my_addr.SetEmpty();
-    src_addr.SetEmpty();
-    dst_addr.SetEmpty();
+    my_addr.setEmpty();
+    src_addr.setEmpty();
+    dst_addr.setEmpty();
     rfc931[0] = '\0';
 
     // cbdataReferenceDone() is in either fastCheck() or the destructor
     if (A)
         accessList = cbdataReference(A);
 
     if (http_request != NULL) {
-        request = HTTPMSGLOCK(http_request);
+        request = http_request;
+        HTTPMSGLOCK(request);
 #if FOLLOW_X_FORWARDED_FOR
         if (Config.onoff.acl_uses_indirect_client)
             src_addr = request->indirect_client_addr;
         else
 #endif /* FOLLOW_X_FORWARDED_FOR */
             src_addr = request->client_addr;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/FilledChecklist.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/FilledChecklist.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/FilledChecklist.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/FilledChecklist.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,33 +1,31 @@
 #ifndef SQUID_ACLFILLED_CHECKLIST_H
 #define SQUID_ACLFILLED_CHECKLIST_H
 
 #include "acl/Checklist.h"
+#include "acl/forward.h"
+#include "base/CbcPointer.h"
 #include "ip/Address.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
 #if USE_SSL
 #include "ssl/support.h"
 #endif
 
 class CachePeer;
 class ConnStateData;
-class ExternalACLEntry;
 class HttpRequest;
 class HttpReply;
 
 /** \ingroup ACLAPI
     ACLChecklist filled with specific data, representing Squid and transaction
     state for access checks along with some data-specific checking methods */
 class ACLFilledChecklist: public ACLChecklist
 {
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
-
     ACLFilledChecklist();
     ACLFilledChecklist(const acl_access *, HttpRequest *, const char *ident);
     ~ACLFilledChecklist();
 
 public:
     /// The client connection manager
@@ -69,28 +67,30 @@
 #if SQUID_SNMP
     char *snmp_community;
 #endif
 
 #if USE_SSL
     /// SSL [certificate validation] errors, in undefined order
-    Ssl::Errors *sslErrors;
+    Ssl::CertErrors *sslErrors;
+    /// The peer certificate
+    Ssl::X509_Pointer serverCert;
 #endif
 
-    ExternalACLEntry *extacl_entry;
+    ExternalACLEntryPointer extacl_entry;
 
 private:
     ConnStateData * conn_;          /**< hack for ident and NTLM */
     int fd_;                        /**< may be available when conn_ is not */
     bool destinationDomainChecked_;
     bool sourceDomainChecked_;
     /// not implemented; will cause link failures if used
     ACLFilledChecklist(const ACLFilledChecklist &);
     /// not implemented; will cause link failures if used
     ACLFilledChecklist &operator=(const ACLFilledChecklist &);
 
-    CBDATA_CLASS(ACLFilledChecklist);
+    CBDATA_CLASS2(ACLFilledChecklist);
 };
 
 /// convenience and safety wrapper for dynamic_cast<ACLFilledChecklist*>
 inline
 ACLFilledChecklist *Filled(ACLChecklist *checklist)
 {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: forward.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Gadgets.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Gadgets.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Gadgets.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Gadgets.cc	2015-05-01 18:05:19.000000000 +0800
@@ -38,20 +38,28 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
 #include "acl/AclNameList.h"
 #include "acl/AclDenyInfoList.h"
 #include "acl/Checklist.h"
+#include "acl/Tree.h"
 #include "acl/Strategised.h"
 #include "acl/Gadgets.h"
 #include "ConfigParser.h"
 #include "errorpage.h"
 #include "globals.h"
 #include "HttpRequest.h"
 #include "Mem.h"
 
+#include <set>
+#include <algorithm>
+
+typedef std::set<ACL*> AclSet;
+/// Accumulates all ACLs to facilitate their clean deletion despite reuse.
+static AclSet *RegisteredAcls; // TODO: Remove when ACLs are refcounted
+
 /* does name lookup, returns page_id */
 err_type
 aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed)
 {
     if (!name) {
         debugs(28, 3, "ERR_NONE due to a NULL name");
@@ -138,13 +146,13 @@
     A->next = (AclDenyInfoList *) NULL;
     /* next expect a list of ACL names */
     Tail = &A->acl_list;
 
     while ((t = strtok(NULL, w_space))) {
         L = (AclNameList *)memAllocate(MEM_ACL_NAME_LIST);
-        xstrncpy(L->name, t, ACL_NAME_SZ);
+        xstrncpy(L->name, t, ACL_NAME_SZ-1);
         *Tail = L;
         Tail = &L->next;
     }
 
     if (A->acl_list == NULL) {
         debugs(28, DBG_CRITICAL, "aclParseDenyInfoLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
@@ -157,137 +165,157 @@
 
         ;	/* find the tail */
     *T = A;
 }
 
 void
-aclParseAccessLine(ConfigParser &parser, acl_access ** head)
+aclParseAccessLine(const char *directive, ConfigParser &, acl_access **treep)
 {
-    char *t = NULL;
-    acl_access *A = NULL;
-    acl_access *B = NULL;
-    acl_access **T = NULL;
-
     /* first expect either 'allow' or 'deny' */
+    const char *t = ConfigParser::strtokFile();
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if (!t) {
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: missing 'allow' or 'deny'.");
         return;
     }
 
-    A = new acl_access;
-
+    allow_t action = ACCESS_DUNNO;
     if (!strcmp(t, "allow"))
-        A->allow = ACCESS_ALLOWED;
+        action = ACCESS_ALLOWED;
     else if (!strcmp(t, "deny"))
-        A->allow = ACCESS_DENIED;
+        action = ACCESS_DENIED;
     else {
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: expecting 'allow' or 'deny', got '" << t << "'.");
-        delete A;
         return;
     }
 
-    aclParseAclList(parser, &A->aclList);
-
-    if (A->aclList == NULL) {
-        debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+    const int ruleId = ((treep && *treep) ? (*treep)->childrenCount() : 0) + 1;
+    MemBuf ctxBuf;
+    ctxBuf.init();
+    ctxBuf.Printf("%s#%d", directive, ruleId);
+    ctxBuf.terminate();
+
+    Acl::AndNode *rule = new Acl::AndNode;
+    rule->context(ctxBuf.content(), config_input_line);
+    rule->lineParse();
+    if (rule->empty()) {
+        debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: Access line contains no ACL's, skipping");
-        delete A;
+        delete rule;
         return;
     }
 
-    A->cfgline = xstrdup(config_input_line);
     /* Append to the end of this list */
 
-    for (B = *head, T = head; B; T = &B->next, B = B->next);
-    *T = A;
+    assert(treep);
+    if (!*treep) {
+        *treep = new Acl::Tree;
+        (*treep)->context(directive, config_input_line);
+    }
+
+    (*treep)->add(rule, action);
 
     /* We lock _acl_access structures in ACLChecklist::matchNonBlocking() */
 }
 
+// aclParseAclList does not expect or set actions (cf. aclParseAccessLine)
 void
-aclParseAclList(ConfigParser &parser, ACLList ** head)
+aclParseAclList(ConfigParser &, Acl::Tree **treep, const char *label)
 {
-    ACLList **Tail = head;	/* sane name in the use below */
-    ACL *a = NULL;
-    char *t;
-
-    /* next expect a list of ACL names, possibly preceeded
-     * by '!' for negation */
-
-    while ((t = strtok(NULL, w_space))) {
-        ACLList *L = new ACLList;
-
-        if (*t == '!') {
-            L->negated (true);
-            ++t;
-        }
-
-        debugs(28, 3, "aclParseAclList: looking for ACL name '" << t << "'");
-        a = ACL::FindByName(t);
+    // accomodate callers unable to convert their ACL list context to string
+    if (!label)
+        label = "...";
+
+    MemBuf ctxLine;
+    ctxLine.init();
+    ctxLine.Printf("(%s %s line)", cfg_directive, label);
+    ctxLine.terminate();
+
+    Acl::AndNode *rule = new Acl::AndNode;
+    rule->context(ctxLine.content(), config_input_line);
+    rule->lineParse();
+
+    MemBuf ctxTree;
+    ctxTree.init();
+    ctxTree.Printf("%s %s", cfg_directive, label);
+    ctxTree.terminate();
+
+    // We want a cbdata-protected Tree (despite giving it only one child node).
+    Acl::Tree *tree = new Acl::Tree;
+    tree->add(rule);
+    tree->context(ctxTree.content(), config_input_line);
+
+    assert(treep);
+    assert(!*treep);
+    *treep = tree;
+}
 
-        if (a == NULL) {
-            debugs(28, DBG_CRITICAL, "aclParseAclList: ACL name '" << t << "' not found.");
-            delete L;
-            parser.destruct();
-            continue;
-        }
+void
+aclRegister(ACL *acl)
+{
+    if (!acl->registered) {
+        if (!RegisteredAcls)
+            RegisteredAcls = new AclSet;
+        RegisteredAcls->insert(acl);
+        acl->registered = true;
+    }
+}
 
-        L->_acl = a;
-        *Tail = L;
-        Tail = &L->next;
+/// remove registered acl from the centralized deletion set
+static
+void
+aclDeregister(ACL *acl)
+{
+    if (acl->registered) {
+        if (RegisteredAcls)
+            RegisteredAcls->erase(acl);
+        acl->registered = false;
     }
 }
 
 /*********************/
 /* Destroy functions */
 /*********************/
 
+/// called to delete ALL Acls.
 void
 aclDestroyAcls(ACL ** head)
 {
-    ACL *next = NULL;
-
-    debugs(28, 8, "aclDestroyACLs: invoked");
-
-    for (ACL *a = *head; a; a = next) {
-        next = a->next;
-        delete a;
+    *head = NULL; // Config.aclList
+    if (AclSet *acls = RegisteredAcls) {
+        debugs(28, 8, "deleting all " << acls->size() << " ACLs");
+        while (!acls->empty()) {
+            ACL *acl = *acls->begin();
+            // We use centralized deletion (this function) so ~ACL should not
+            // delete other ACLs, but we still deregister first to prevent any
+            // accesses to the being-deleted ACL via RegisteredAcls.
+            assert(acl->registered); // make sure we are making progress
+            aclDeregister(acl);
+            delete acl;
+        }
     }
-
-    *head = NULL;
 }
 
 void
-aclDestroyAclList(ACLList ** head)
+aclDestroyAclList(ACLList **list)
 {
-    ACLList *l;
     debugs(28, 8, "aclDestroyAclList: invoked");
-
-    for (l = *head; l; l = *head) {
-        *head = l->next;
-        delete l;
-    }
+    assert(list);
+    delete *list;
+    *list = NULL;
 }
 
 void
 aclDestroyAccessList(acl_access ** list)
 {
-    acl_access *l = NULL;
-    acl_access *next = NULL;
-
-    for (l = *list; l; l = next) {
-        debugs(28, 3, "aclDestroyAccessList: '" << l->cfgline << "'");
-        next = l->next;
-        aclDestroyAclList(&l->aclList);
-        safe_free(l->cfgline);
-        cbdataFree(l);
-    }
-
+    assert(list);
+    if (*list)
+        debugs(28, 3, "destroying: " << *list << ' ' << (*list)->name);
+    delete *list;
     *list = NULL;
 }
 
 /* maex@space.net (06.09.1996)
  *    destroy an AclDenyInfoList */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Gadgets.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Gadgets.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Gadgets.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Gadgets.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,30 +1,47 @@
 #ifndef SQUID_ACL_GADGETS_H
 #define SQUID_ACL_GADGETS_H
 
 #include "err_type.h"
+#include "acl/forward.h"
+
+#if HAVE_SSTREAM
+#include <sstream>
+#endif
 
-class acl_access;
-class ACL;
-class AclDenyInfoList;
-class ACLList;
 class ConfigParser;
 class dlink_list;
 class StoreEntry;
 class wordlist;
 
+/// Register an ACL object for future deletion. Repeated registrations are OK.
+/// \ingroup ACLAPI
+void aclRegister(ACL *acl);
 /// \ingroup ACLAPI
 void aclDestroyAccessList(acl_access **list);
 /// \ingroup ACLAPI
 void aclDestroyAcls(ACL **);
 /// \ingroup ACLAPI
 void aclDestroyAclList(ACLList **);
+/// Parses a single line of a "action followed by acls" directive (e.g., http_access).
 /// \ingroup ACLAPI
-void aclParseAccessLine(ConfigParser &parser, acl_access **);
-/// \ingroup ACLAPI
-void aclParseAclList(ConfigParser &parser, ACLList **);
+void aclParseAccessLine(const char *directive, ConfigParser &parser, Acl::Tree **);
+/// Parses a single line of a "some context followed by acls" directive (e.g., note n v).
+/// The label parameter identifies the context (for debugging).
+/// \ingroup ACLAPI
+void aclParseAclList(ConfigParser &parser, Acl::Tree **, const char *label);
+/// Template to convert various context lables to strings. \ingroup ACLAPI
+template <class Any>
+inline
+void aclParseAclList(ConfigParser &parser, Acl::Tree **tree, const Any any)
+{
+    std::ostringstream buf;
+    buf << any;
+    aclParseAclList(parser, tree, buf.str().c_str());
+}
+
 /// \ingroup ACLAPI
 int aclIsProxyAuth(const char *name);
 /// \ingroup ACLAPI
 err_type aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed);
 /// \ingroup ACLAPI
 void aclParseDenyInfoLine(AclDenyInfoList **);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HierCode.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HierCode.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HierCode.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HierCode.cc	2015-05-01 18:05:19.000000000 +0800
@@ -6,13 +6,13 @@
 
 /* explicit template instantiation required for some systems */
 
 template class ACLStrategised<hier_code>;
 
 int
-ACLHierCodeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLHierCodeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->request->hier.code);
 }
 
 ACLHierCodeStrategy *
 ACLHierCodeStrategy::Instance()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HierCode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HierCode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HierCode.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HierCode.h	2015-05-01 18:05:19.000000000 +0800
@@ -7,13 +7,13 @@
 
 /// \ingroup ACLAPI
 class ACLHierCodeStrategy : public ACLStrategy<hier_code>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLHierCodeStrategy *Instance();
 
     /**
      * Not implemented to prevent copies of the instance.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpRepHeader.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpRepHeader.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpRepHeader.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpRepHeader.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,13 @@
 #include "acl/HttpRepHeader.h"
 #include "acl/HttpHeaderData.h"
 #include "acl/Checklist.h"
 #include "HttpReply.h"
 
 int
-ACLHTTPRepHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLHTTPRepHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (&checklist->reply->header);
 }
 
 ACLHTTPRepHeaderStrategy *
 ACLHTTPRepHeaderStrategy::Instance()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpRepHeader.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpRepHeader.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpRepHeader.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpRepHeader.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 
 /// \ingroup ACLAPI
 class ACLHTTPRepHeaderStrategy : public ACLStrategy<HttpHeader*>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresReply() const { return true; }
 
     static ACLHTTPRepHeaderStrategy *Instance();
     /**
      * Not implemented to prevent copies of the instance.
      \par
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpReqHeader.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpReqHeader.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpReqHeader.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpReqHeader.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,13 @@
 #include "acl/HttpReqHeader.h"
 #include "acl/HttpHeaderData.h"
 #include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 int
-ACLHTTPReqHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLHTTPReqHeaderStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (&checklist->request->header);
 }
 
 ACLHTTPReqHeaderStrategy *
 ACLHTTPReqHeaderStrategy::Instance()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpReqHeader.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpReqHeader.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpReqHeader.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpReqHeader.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 
 /// \ingroup ACLAPI
 class ACLHTTPReqHeaderStrategy : public ACLStrategy<HttpHeader*>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const { return true; }
 
     static ACLHTTPReqHeaderStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpStatus.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpStatus.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/HttpStatus.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/HttpStatus.cc	2015-05-01 18:05:19.000000000 +0800
@@ -43,13 +43,13 @@
 #if HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 static void aclParseHTTPStatusList(SplayNode<acl_httpstatus_data *> **curlist);
 static int aclHTTPStatusCompare(acl_httpstatus_data * const &a, acl_httpstatus_data * const &b);
-static int aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, http_status status);
+static int aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, Http::StatusCode status);
 
 acl_httpstatus_data::acl_httpstatus_data(int x) : status1(x), status2(x) { ; }
 
 acl_httpstatus_data::acl_httpstatus_data(int x, int y) : status1(x), status2(y) { ; }
 
 void acl_httpstatus_data::toStr(char* buf, int len) const
@@ -153,17 +153,17 @@
     }
 }
 
 int
 ACLHTTPStatus::match(ACLChecklist *checklist)
 {
-    return aclMatchHTTPStatus(&data, Filled(checklist)->reply->sline.status);
+    return aclMatchHTTPStatus(&data, Filled(checklist)->reply->sline.status());
 }
 
 int
-aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, http_status status)
+aclMatchHTTPStatus(SplayNode<acl_httpstatus_data*> **dataptr, const Http::StatusCode status)
 {
 
     acl_httpstatus_data X(status);
     SplayNode<acl_httpstatus_data*> **Top = dataptr;
     *Top = Top[0]->splay(&X, aclHTTPStatusCompare);
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: InnerNode.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: InnerNode.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Ip.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Ip.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Ip.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Ip.cc	2015-05-01 18:05:19.000000000 +0800
@@ -89,30 +89,30 @@
 {
     char *b1 = buf;
     char *b2 = NULL;
     char *b3 = NULL;
     int rlen = 0;
 
-    addr1.NtoA(b1, len - rlen );
+    addr1.toStr(b1, len - rlen );
     rlen = strlen(buf);
     b2 = buf + rlen;
 
-    if (!addr2.IsAnyAddr()) {
+    if (!addr2.isAnyAddr()) {
         b2[0] = '-';
         ++rlen;
-        addr2.NtoA(&(b2[1]), len - rlen );
+        addr2.toStr(&(b2[1]), len - rlen );
         rlen = strlen(buf);
     } else
         b2[0] = '\0';
 
     b3 = buf + rlen;
 
-    if (!mask.IsNoAddr()) {
+    if (!mask.isNoAddr()) {
         b3[0] = '/';
         ++rlen;
-        int cidr =  mask.GetCIDR() - (addr1.IsIPv4()?96:0);
+        int cidr =  mask.cidr() - (addr1.isIPv4()?96:0);
         snprintf(&(b3[1]), (len-rlen), "%u", (unsigned int)(cidr<0?0:cidr) );
     } else
         b3[0] = '\0';
 }
 
 /*
@@ -125,18 +125,18 @@
 int
 aclIpAddrNetworkCompare(acl_ip_data * const &p, acl_ip_data * const &q)
 {
     Ip::Address A = p->addr1;
 
     /* apply netmask */
-    A.ApplyMask(q->mask);
+    A.applyMask(q->mask);
 
     debugs(28,9, "aclIpAddrNetworkCompare: compare: " << p->addr1 << "/" << q->mask << " (" << A << ")  vs " <<
            q->addr1 << "-" << q->addr2 << "/" << q->mask);
 
-    if (q->addr2.IsAnyAddr()) {       /* single address check */
+    if (q->addr2.isAnyAddr()) {       /* single address check */
 
         return A.matchIPAddr( q->addr1 );
 
     } else {                   /* range address check */
 
         if ( (A >= q->addr1) && (A <= q->addr2) )
@@ -194,40 +194,40 @@
 acl_ip_data::DecodeMask(const char *asc, Ip::Address &mask, int ctype)
 {
     char junk;
     int a1 = 0;
 
     /* default is a mask that doesn't change any IP */
-    mask.SetNoAddr();
+    mask.setNoAddr();
 
     if (!asc || !*asc) {
         return true;
     }
 
     /* An int mask 128, 32 */
     if ((sscanf(asc, "%d%c", &a1, &junk)==1) &&
             (a1 <= 128) && (a1  >= 0)
        ) {
-        return mask.ApplyMask(a1, ctype);
+        return mask.applyMask(a1, ctype);
     }
 
     /* dotted notation */
     /* assignment returns true if asc contained an IP address as text */
     if ((mask = asc)) {
         /* HACK: IPv4 netmasks don't cleanly map to IPv6 masks. */
         debugs(28, DBG_CRITICAL, "WARNING: Netmasks are deprecated. Please use CIDR masks instead.");
-        if (mask.IsIPv4()) {
+        if (mask.isIPv4()) {
             /* locate what CIDR mask was _probably_ meant to be in its native protocol format. */
             /* this will completely crap out with a security fail-open if the admin is playing mask tricks */
             /* however, thats their fault, and we do warn. see bug 2601 for the effects if we don't do this. */
-            unsigned int m = mask.GetCIDR();
+            unsigned int m = mask.cidr();
             debugs(28, DBG_CRITICAL, "WARNING: IPv4 netmasks are particularly nasty when used to compare IPv6 to IPv4 ranges.");
             debugs(28, DBG_CRITICAL, "WARNING: For now we will assume you meant to write /" << m);
             /* reset the mask completely, and crop to the CIDR boundary back properly. */
-            mask.SetNoAddr();
-            return mask.ApplyMask(m,AF_INET);
+            mask.setNoAddr();
+            return mask.applyMask(m,AF_INET);
         }
         return true;
     }
 
     return false;
 }
@@ -257,104 +257,104 @@
     acl_ip_data *q = new acl_ip_data;
     int iptype = AF_UNSPEC;
 
     debugs(28, 5, "aclIpParseIpData: " << t);
 
     /* Special ACL RHS "all" matches entire Internet */
-    if (strcasecmp(t, "all") == 0) {
+    if (strcmp(t, "all") == 0) {
         debugs(28, 9, "aclIpParseIpData: magic 'all' found.");
-        q->addr1.SetAnyAddr();
-        q->addr2.SetEmpty();
-        q->mask.SetAnyAddr();
+        q->addr1.setAnyAddr();
+        q->addr2.setEmpty();
+        q->mask.setAnyAddr();
         return q;
     }
 
     /* Detect some old broken strings equivalent to 'all'.
      * treat them nicely. But be loud until its fixed.  */
-    if (strcasecmp(t, "0/0") == 0 || strcasecmp(t, "0.0.0.0/0") == 0 || strcasecmp(t, "0.0.0.0/0.0.0.0") == 0 ||
-            strcasecmp(t, "0.0.0.0-255.255.255.255") == 0 || strcasecmp(t, "0.0.0.0-0.0.0.0/0") == 0) {
+    if (strcmp(t, "0/0") == 0 || strcmp(t, "0.0.0.0/0") == 0 || strcmp(t, "0.0.0.0/0.0.0.0") == 0 ||
+            strcmp(t, "0.0.0.0-255.255.255.255") == 0 || strcmp(t, "0.0.0.0-0.0.0.0/0") == 0) {
 
         debugs(28,DBG_CRITICAL, "ERROR: '" << t << "' needs to be replaced by the term 'all'.");
         debugs(28,DBG_CRITICAL, "SECURITY NOTICE: Overriding config setting. Using 'all' instead.");
-        q->addr1.SetAnyAddr();
-        q->addr2.SetEmpty();
-        q->mask.SetAnyAddr();
+        q->addr1.setAnyAddr();
+        q->addr2.setEmpty();
+        q->mask.setAnyAddr();
         return q;
     }
 
     /* Special ACL RHS "ipv4" matches IPv4 Internet
      * A nod to IANA; we include the entire class space in case
      * they manage to find a way to recover and use it */
-    if (strcasecmp(t, "ipv4") == 0) {
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(0, AF_INET);
+    if (strcmp(t, "ipv4") == 0) {
+        q->mask.setNoAddr();
+        q->mask.applyMask(0, AF_INET);
         return q;
     }
 
     /* Special ACL RHS "ipv6" matches IPv6-Unicast Internet */
-    if (strcasecmp(t, "ipv6") == 0) {
+    if (strcmp(t, "ipv6") == 0) {
         debugs(28, 9, "aclIpParseIpData: magic 'ipv6' found.");
         r = q; // save head of the list for result.
 
         /* 0000::/4 is a mix of localhost and obsolete IPv4-mapping space. Not valid outside this host. */
 
         /* Future global unicast space: 1000::/4 */
         q->addr1 = "1000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(4, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(4, AF_INET6);
 
         /* Current global unicast space: 2000::/4 = (2000::/4 - 3000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "2000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(3, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(3, AF_INET6);
 
         /* Future global unicast space: 4000::/2 = (4000::/4 - 7000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "4000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(2, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(2, AF_INET6);
 
         /* Future global unicast space: 8000::/2 = (8000::/4 - B000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "8000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(2, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(2, AF_INET6);
 
         /* Future global unicast space: C000::/3 = (C000::/4 - D000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "C000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(3, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(3, AF_INET6);
 
         /* Future global unicast space: E000::/4 */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "E000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(4, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(4, AF_INET6);
 
         /* F000::/4 is mostly reserved non-unicast. With some exceptions ... */
 
         /* RFC 4193 Unique-Local unicast space: FC00::/7 */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "FC00::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(7, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(7, AF_INET6);
 
         /* Link-Local unicast space: FE80::/10 */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "FE80::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(10, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(10, AF_INET6);
 
         return r;
     }
 
 // IPv4
     if (sscanf(t, SCAN_ACL1_4, addr1, addr2, mask) == 3) {
@@ -408,16 +408,21 @@
         Ip::Address *prev_addr = NULL;
 
         memset(&hints, 0, sizeof(struct addrinfo));
 
         int errcode = getaddrinfo(addr1,NULL,&hints,&hp);
         if (hp == NULL) {
-            debugs(28, DBG_CRITICAL, "aclIpParseIpData: Bad host/IP: '" << addr1 <<
-                   "' in '" << t << "', flags=" << hints.ai_flags <<
-                   " : (" << errcode << ") " << gai_strerror(errcode) );
-            self_destruct();
+            if (strcmp(addr1, "::1") == 0) {
+                debugs(28, DBG_IMPORTANT, "aclIpParseIpData: IPv6 has not been enabled in host DNS resolver.");
+                delete q;
+            } else {
+                debugs(28, DBG_CRITICAL, "aclIpParseIpData: Bad host/IP: '" << addr1 <<
+                       "' in '" << t << "', flags=" << hints.ai_flags <<
+                       " : (" << errcode << ") " << gai_strerror(errcode) );
+                self_destruct();
+            }
             return NULL;
         }
 
         Q = &q;
 
         for (x = hp; x != NULL;) {
@@ -435,14 +440,14 @@
                 continue;
             } else
                 prev_addr = &r->addr1;
 
             debugs(28, 3, "aclIpParseIpData: Located host/IP: '" << r->addr1 << "'");
 
-            r->addr2.SetAnyAddr();
-            r->mask.SetNoAddr();
+            r->addr2.setAnyAddr();
+            r->mask.setNoAddr();
 
             Q = &r->next;
 
             debugs(28, 3, "" << addr1 << " --> " << r->addr1 );
         }
 
@@ -471,13 +476,13 @@
         self_destruct();
         return NULL;
     }
 
     /* Decode addr2 */
     if (!*addr2)
-        q->addr2.SetAnyAddr();
+        q->addr2.setAnyAddr();
     else if (!(q->addr2=addr2) ) {
         debugs(28, DBG_CRITICAL, "aclIpParseIpData: unknown second address in '" << t << "'");
         delete q;
         self_destruct();
         return NULL;
     }
@@ -488,31 +493,31 @@
         delete q;
         self_destruct();
         return NULL;
     }
 
     changed = 0;
-    changed += q->addr1.ApplyMask(q->mask);
-    changed += q->addr2.ApplyMask(q->mask);
+    changed += q->addr1.applyMask(q->mask);
+    changed += q->addr2.applyMask(q->mask);
 
     if (changed)
         debugs(28, DBG_CRITICAL, "aclIpParseIpData: WARNING: Netmask masks away part of the specified IP in '" << t << "'");
 
-    debugs(28,9, HERE << "Parsed: " << q->addr1 << "-" << q->addr2 << "/" << q->mask << "(/" << q->mask.GetCIDR() <<")");
+    debugs(28,9, HERE << "Parsed: " << q->addr1 << "-" << q->addr2 << "/" << q->mask << "(/" << q->mask.cidr() <<")");
 
     /* 1.2.3.4/255.255.255.0  --> 1.2.3.0 */
     /* Same as IPv6 (not so trivial to depict) */
     return q;
 }
 
 void
 ACLIP::parse()
 {
-    char *t = NULL;
+    flags.parseFlags();
 
-    while ((t = strtokFile())) {
+    while (char *t = strtokFile()) {
         acl_ip_data *q = acl_ip_data::FactoryParse(t);
 
         while (q != NULL) {
             /* pop each result off the list and add it to the data tree individually */
             acl_ip_data *next_node = q->next;
             q->next = NULL;
@@ -550,14 +555,14 @@
      * aclIpAddrNetworkCompare() takes two acl_ip_data pointers as
      * arguments, so we must create a fake one for the client's IP
      * address. Since we are scanning for a single IP mask and addr2
      * MUST be set to empty.
      */
     ClientAddress.addr1 = clientip;
-    ClientAddress.addr2.SetEmpty();
-    ClientAddress.mask.SetEmpty();
+    ClientAddress.addr2.setEmpty();
+    ClientAddress.mask.setEmpty();
 
     data = data->splay(&ClientAddress, aclIpAddrNetworkCompare);
     debugs(28, 3, "aclIpMatchIp: '" << clientip << "' " << (splayLastResult ? "NOT found" : "found"));
     return !splayLastResult;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Ip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Ip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Ip.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Ip.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,12 +30,13 @@
  */
 
 #ifndef SQUID_ACLIP_H
 #define SQUID_ACLIP_H
 
 #include "acl/Acl.h"
+#include "acl/Data.h"
 #include "splay.h"
 #include "ip/Address.h"
 
 /// \ingroup ACLAPI
 class acl_ip_data
 {
@@ -71,12 +72,13 @@
 
 public:
     void *operator new(size_t);
     void operator delete(void *);
 
     ACLIP() : data(NULL) {}
+    explicit ACLIP(const ACLFlag flgs[]) : ACL(flgs), data(NULL) {}
 
     ~ACLIP();
 
     typedef SplayNode<acl_ip_data *> IPSplay;
 
     virtual char const *typeString() const = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/LocalPort.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/LocalPort.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/LocalPort.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/LocalPort.cc	2015-05-01 18:05:19.000000000 +0800
@@ -34,15 +34,15 @@
 #include "squid.h"
 #include "acl/LocalPort.h"
 #include "acl/IntRange.h"
 #include "acl/Checklist.h"
 
 int
-ACLLocalPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLLocalPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    return data->match (checklist->my_addr.GetPort());
+    return data->match (checklist->my_addr.port());
 }
 
 ACLLocalPortStrategy *
 ACLLocalPortStrategy::Instance()
 {
     return &Instance_;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/LocalPort.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/LocalPort.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/LocalPort.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/LocalPort.h	2015-05-01 18:05:19.000000000 +0800
@@ -38,13 +38,13 @@
 
 /// \ingroup ACLAPI
 class ACLLocalPortStrategy : public ACLStrategy<int>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLLocalPortStrategy *Instance();
     /**
      * Not implemented to prevent copies of the instance.
      \par
      * Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -4,14 +4,21 @@
 noinst_LTLIBRARIES = libapi.la libstate.la libacls.la
 
 ## General data-independent ACL API
 libapi_la_SOURCES = \
 	Acl.cc \
 	Acl.h \
+	BoolOps.cc \
+	BoolOps.h \
 	Checklist.cc \
-	Checklist.h
+	Checklist.h \
+	forward.h \
+	InnerNode.cc \
+	InnerNode.h \
+	Tree.cc \
+	Tree.h
 
 ## Data-dependent Squid/transaction state used by specific ACLs.
 ## Does not refer to specific ACLs to avoid circular dependencies.
 libstate_la_SOURCES = \
 	Data.h \
 	Strategy.h \
@@ -31,12 +38,16 @@
 	StringData.cc \
 	StringData.h \
 	Time.cc \
 	Time.h \
 	TimeData.cc \
 	TimeData.h \
+	AllOf.cc \
+	AllOf.h \
+	AnyOf.cc \
+	AnyOf.h \
 	Asn.cc \
 	Asn.h \
 	Browser.cc \
 	Browser.h \
 	DestinationAsn.h \
 	DestinationDomain.cc \
@@ -70,12 +81,16 @@
 	Method.cc \
 	MethodData.cc \
 	MethodData.h \
 	Method.h \
 	MyPortName.cc \
 	MyPortName.h \
+	Note.h \
+	Note.cc \
+	NoteData.h \
+	NoteData.cc \
 	PeerName.cc \
 	PeerName.h \
 	Protocol.cc \
 	ProtocolData.cc \
 	ProtocolData.h \
 	Protocol.h \
@@ -119,12 +134,14 @@
 
 SSL_ACLS = \
         CertificateData.cc \
         CertificateData.h  \
         Certificate.cc \
         Certificate.h  \
+	ServerCertificate.cc \
+	ServerCertificate.h \
         SslError.cc \
         SslError.h \
         SslErrorData.cc \
         SslErrorData.h
 
 if ENABLE_SSL
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Makefile.in	2015-05-01 16:51:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Makefile.in	2015-05-01 18:06:47.000000000 +0800
@@ -92,68 +92,117 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LTLIBRARIES = $(noinst_LTLIBRARIES)
 libacls_la_LIBADD =
 am__libacls_la_SOURCES_DIST = IntRange.cc IntRange.h RegexData.cc \
 	RegexData.h StringData.cc StringData.h Time.cc Time.h \
-	TimeData.cc TimeData.h Asn.cc Asn.h Browser.cc Browser.h \
-	DestinationAsn.h DestinationDomain.cc DestinationDomain.h \
-	DestinationIp.cc DestinationIp.h DomainData.cc DomainData.h \
-	ExtUser.cc ExtUser.h HierCodeData.cc HierCodeData.h \
-	HierCode.cc HierCode.h HttpHeaderData.cc HttpHeaderData.h \
-	HttpRepHeader.cc HttpRepHeader.h HttpReqHeader.cc \
-	HttpReqHeader.h HttpStatus.cc HttpStatus.h Ip.cc Ip.h \
-	LocalIp.cc LocalIp.h LocalPort.cc LocalPort.h MaxConnection.cc \
-	MaxConnection.h Method.cc MethodData.cc MethodData.h Method.h \
-	MyPortName.cc MyPortName.h PeerName.cc PeerName.h Protocol.cc \
-	ProtocolData.cc ProtocolData.h Protocol.h Random.cc Random.h \
-	Referer.cc Referer.h ReplyHeaderStrategy.h ReplyMimeType.cc \
-	ReplyMimeType.h RequestHeaderStrategy.h RequestMimeType.cc \
-	RequestMimeType.h SourceAsn.h SourceDomain.cc SourceDomain.h \
-	SourceIp.cc SourceIp.h Tag.cc Tag.h Url.cc Url.h UrlLogin.cc \
-	UrlLogin.h UrlPath.cc UrlPath.h UrlPort.cc UrlPort.h \
-	UserData.cc UserData.h AclNameList.h AclDenyInfoList.h \
-	Gadgets.cc Gadgets.h AclSizeLimit.h CertificateData.cc \
-	CertificateData.h Certificate.cc Certificate.h SslError.cc \
-	SslError.h SslErrorData.cc SslErrorData.h Arp.cc Arp.h \
-	Eui64.cc Eui64.h
-am__objects_1 = CertificateData.lo Certificate.lo SslError.lo \
-	SslErrorData.lo
+	TimeData.cc TimeData.h AllOf.cc AllOf.h AnyOf.cc AnyOf.h \
+	Asn.cc Asn.h Browser.cc Browser.h DestinationAsn.h \
+	DestinationDomain.cc DestinationDomain.h DestinationIp.cc \
+	DestinationIp.h DomainData.cc DomainData.h ExtUser.cc \
+	ExtUser.h HierCodeData.cc HierCodeData.h HierCode.cc \
+	HierCode.h HttpHeaderData.cc HttpHeaderData.h HttpRepHeader.cc \
+	HttpRepHeader.h HttpReqHeader.cc HttpReqHeader.h HttpStatus.cc \
+	HttpStatus.h Ip.cc Ip.h LocalIp.cc LocalIp.h LocalPort.cc \
+	LocalPort.h MaxConnection.cc MaxConnection.h Method.cc \
+	MethodData.cc MethodData.h Method.h MyPortName.cc MyPortName.h \
+	Note.h Note.cc NoteData.h NoteData.cc PeerName.cc PeerName.h \
+	Protocol.cc ProtocolData.cc ProtocolData.h Protocol.h \
+	Random.cc Random.h Referer.cc Referer.h ReplyHeaderStrategy.h \
+	ReplyMimeType.cc ReplyMimeType.h RequestHeaderStrategy.h \
+	RequestMimeType.cc RequestMimeType.h SourceAsn.h \
+	SourceDomain.cc SourceDomain.h SourceIp.cc SourceIp.h Tag.cc \
+	Tag.h Url.cc Url.h UrlLogin.cc UrlLogin.h UrlPath.cc UrlPath.h \
+	UrlPort.cc UrlPort.h UserData.cc UserData.h AclNameList.h \
+	AclDenyInfoList.h Gadgets.cc Gadgets.h AclSizeLimit.h \
+	CertificateData.cc CertificateData.h Certificate.cc \
+	Certificate.h ServerCertificate.cc ServerCertificate.h \
+	SslError.cc SslError.h SslErrorData.cc SslErrorData.h Arp.cc \
+	Arp.h Eui64.cc Eui64.h
+am__objects_1 = CertificateData.lo Certificate.lo ServerCertificate.lo \
+	SslError.lo SslErrorData.lo
 @ENABLE_SSL_TRUE@am__objects_2 = $(am__objects_1)
 am__objects_3 = Arp.lo Eui64.lo
 @USE_SQUID_EUI_TRUE@am__objects_4 = $(am__objects_3)
 am_libacls_la_OBJECTS = IntRange.lo RegexData.lo StringData.lo Time.lo \
-	TimeData.lo Asn.lo Browser.lo DestinationDomain.lo \
-	DestinationIp.lo DomainData.lo ExtUser.lo HierCodeData.lo \
-	HierCode.lo HttpHeaderData.lo HttpRepHeader.lo \
+	TimeData.lo AllOf.lo AnyOf.lo Asn.lo Browser.lo \
+	DestinationDomain.lo DestinationIp.lo DomainData.lo ExtUser.lo \
+	HierCodeData.lo HierCode.lo HttpHeaderData.lo HttpRepHeader.lo \
 	HttpReqHeader.lo HttpStatus.lo Ip.lo LocalIp.lo LocalPort.lo \
-	MaxConnection.lo Method.lo MethodData.lo MyPortName.lo \
-	PeerName.lo Protocol.lo ProtocolData.lo Random.lo Referer.lo \
-	ReplyMimeType.lo RequestMimeType.lo SourceDomain.lo \
+	MaxConnection.lo Method.lo MethodData.lo MyPortName.lo Note.lo \
+	NoteData.lo PeerName.lo Protocol.lo ProtocolData.lo Random.lo \
+	Referer.lo ReplyMimeType.lo RequestMimeType.lo SourceDomain.lo \
 	SourceIp.lo Tag.lo Url.lo UrlLogin.lo UrlPath.lo UrlPort.lo \
 	UserData.lo Gadgets.lo $(am__objects_2) $(am__objects_4)
 libacls_la_OBJECTS = $(am_libacls_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 libapi_la_LIBADD =
-am_libapi_la_OBJECTS = Acl.lo Checklist.lo
+am_libapi_la_OBJECTS = Acl.lo BoolOps.lo Checklist.lo InnerNode.lo \
+	Tree.lo
 libapi_la_OBJECTS = $(am_libapi_la_OBJECTS)
 libstate_la_LIBADD =
 am_libstate_la_OBJECTS = Strategised.lo FilledChecklist.lo \
 	AclAddress.lo
 libstate_la_OBJECTS = $(am_libstate_la_OBJECTS)
 AM_V_P = $(am__v_P_@AM_V@)
@@ -500,12 +549,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -543,12 +593,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -575,27 +626,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -662,20 +716,27 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libapi.la libstate.la libacls.la
 libapi_la_SOURCES = \
 	Acl.cc \
 	Acl.h \
+	BoolOps.cc \
+	BoolOps.h \
 	Checklist.cc \
-	Checklist.h
+	Checklist.h \
+	forward.h \
+	InnerNode.cc \
+	InnerNode.h \
+	Tree.cc \
+	Tree.h
 
 libstate_la_SOURCES = \
 	Data.h \
 	Strategy.h \
 	Strategised.cc \
 	Strategised.h \
@@ -683,37 +744,40 @@
 	FilledChecklist.h \
 	AclAddress.h \
 	AclAddress.cc
 
 libacls_la_SOURCES = IntRange.cc IntRange.h RegexData.cc RegexData.h \
 	StringData.cc StringData.h Time.cc Time.h TimeData.cc \
-	TimeData.h Asn.cc Asn.h Browser.cc Browser.h DestinationAsn.h \
-	DestinationDomain.cc DestinationDomain.h DestinationIp.cc \
-	DestinationIp.h DomainData.cc DomainData.h ExtUser.cc \
-	ExtUser.h HierCodeData.cc HierCodeData.h HierCode.cc \
-	HierCode.h HttpHeaderData.cc HttpHeaderData.h HttpRepHeader.cc \
+	TimeData.h AllOf.cc AllOf.h AnyOf.cc AnyOf.h Asn.cc Asn.h \
+	Browser.cc Browser.h DestinationAsn.h DestinationDomain.cc \
+	DestinationDomain.h DestinationIp.cc DestinationIp.h \
+	DomainData.cc DomainData.h ExtUser.cc ExtUser.h \
+	HierCodeData.cc HierCodeData.h HierCode.cc HierCode.h \
+	HttpHeaderData.cc HttpHeaderData.h HttpRepHeader.cc \
 	HttpRepHeader.h HttpReqHeader.cc HttpReqHeader.h HttpStatus.cc \
 	HttpStatus.h Ip.cc Ip.h LocalIp.cc LocalIp.h LocalPort.cc \
 	LocalPort.h MaxConnection.cc MaxConnection.h Method.cc \
 	MethodData.cc MethodData.h Method.h MyPortName.cc MyPortName.h \
-	PeerName.cc PeerName.h Protocol.cc ProtocolData.cc \
-	ProtocolData.h Protocol.h Random.cc Random.h Referer.cc \
-	Referer.h ReplyHeaderStrategy.h ReplyMimeType.cc \
-	ReplyMimeType.h RequestHeaderStrategy.h RequestMimeType.cc \
-	RequestMimeType.h SourceAsn.h SourceDomain.cc SourceDomain.h \
-	SourceIp.cc SourceIp.h Tag.cc Tag.h Url.cc Url.h UrlLogin.cc \
-	UrlLogin.h UrlPath.cc UrlPath.h UrlPort.cc UrlPort.h \
-	UserData.cc UserData.h AclNameList.h AclDenyInfoList.h \
-	Gadgets.cc Gadgets.h AclSizeLimit.h $(am__append_2) \
-	$(am__append_3)
+	Note.h Note.cc NoteData.h NoteData.cc PeerName.cc PeerName.h \
+	Protocol.cc ProtocolData.cc ProtocolData.h Protocol.h \
+	Random.cc Random.h Referer.cc Referer.h ReplyHeaderStrategy.h \
+	ReplyMimeType.cc ReplyMimeType.h RequestHeaderStrategy.h \
+	RequestMimeType.cc RequestMimeType.h SourceAsn.h \
+	SourceDomain.cc SourceDomain.h SourceIp.cc SourceIp.h Tag.cc \
+	Tag.h Url.cc Url.h UrlLogin.cc UrlLogin.h UrlPath.cc UrlPath.h \
+	UrlPort.cc UrlPort.h UserData.cc UserData.h AclNameList.h \
+	AclDenyInfoList.h Gadgets.cc Gadgets.h AclSizeLimit.h \
+	$(am__append_2) $(am__append_3)
 EXTRA_libacls_la_SOURCES = $(SSL_ACLS) $(ARP_ACLS)
 SSL_ACLS = \
         CertificateData.cc \
         CertificateData.h  \
         Certificate.cc \
         Certificate.h  \
+	ServerCertificate.cc \
+	ServerCertificate.h \
         SslError.cc \
         SslError.h \
         SslErrorData.cc \
         SslErrorData.h
 
 ARP_ACLS = Arp.cc Arp.h Eui64.cc Eui64.h
@@ -787,14 +851,17 @@
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Acl.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/AclAddress.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/AllOf.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/AnyOf.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Arp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Asn.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/BoolOps.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Browser.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Certificate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/CertificateData.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Checklist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DestinationDomain.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DestinationIp.Plo@am__quote@
@@ -806,37 +873,42 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HierCode.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HierCodeData.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHeaderData.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpRepHeader.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpReqHeader.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpStatus.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/InnerNode.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/IntRange.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ip.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LocalIp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LocalPort.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MaxConnection.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Method.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MethodData.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MyPortName.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Note.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/NoteData.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/PeerName.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Protocol.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ProtocolData.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Random.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Referer.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/RegexData.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ReplyMimeType.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/RequestMimeType.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ServerCertificate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/SourceDomain.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/SourceIp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/SslError.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/SslErrorData.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Strategised.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StringData.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Tag.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Time.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TimeData.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Tree.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Url.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/UrlLogin.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/UrlPath.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/UrlPort.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/UserData.Plo@am__quote@
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Method.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Method.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Method.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Method.cc	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 
 /* explicit template instantiation required for some systems */
 
 template class ACLStrategised<HttpRequestMethod>;
 
 int
-ACLMethodStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLMethodStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->request->method);
 }
 
 ACLMethodStrategy *
 ACLMethodStrategy::Instance()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Method.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Method.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Method.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Method.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 
 /// \ingroup ACLAPI
 class ACLMethodStrategy : public ACLStrategy<HttpRequestMethod>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLMethodStrategy *Instance();
 
     /**
      * Not implemented to prevent copies of the instance.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/MyPortName.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/MyPortName.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/MyPortName.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/MyPortName.cc	2015-05-01 18:05:19.000000000 +0800
@@ -29,23 +29,23 @@
  *
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
+#include "acl/Checklist.h"
 #include "acl/MyPortName.h"
 #include "acl/StringData.h"
-#include "acl/Checklist.h"
 #include "anyp/PortCfg.h"
 #include "HttpRequest.h"
 
 /* for ConnStateData */
 #include "client_side.h"
 
 int
-ACLMyPortNameStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLMyPortNameStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     if (checklist->conn() != NULL && checklist->conn()->port != NULL)
         return data->match(checklist->conn()->port->name);
     if (checklist->request != NULL)
         return data->match(checklist->request->myportname.termedBuf());
     return 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/MyPortName.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/MyPortName.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/MyPortName.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/MyPortName.h	2015-05-01 18:05:19.000000000 +0800
@@ -37,13 +37,13 @@
 #include "acl/Strategised.h"
 
 class ACLMyPortNameStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLMyPortNameStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLMyPortNameStrategy(ACLMyPortNameStrategy const &);
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: Note.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: NoteData.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: NoteData.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: Note.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/PeerName.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/PeerName.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/PeerName.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/PeerName.cc	2015-05-01 18:05:19.000000000 +0800
@@ -3,13 +3,13 @@
 #include "acl/RegexData.h"
 #include "acl/StringData.h"
 #include "acl/Checklist.h"
 #include "CachePeer.h"
 
 int
-ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     if (checklist->dst_peer != NULL && checklist->dst_peer->name != NULL)
         return data->match(checklist->dst_peer->name);
     return 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/PeerName.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/PeerName.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/PeerName.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/PeerName.h	2015-05-01 18:05:19.000000000 +0800
@@ -5,13 +5,13 @@
 #include "acl/Strategised.h"
 
 class ACLPeerNameStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLPeerNameStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLPeerNameStrategy(ACLPeerNameStrategy const &);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Protocol.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Protocol.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Protocol.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Protocol.cc	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 
 /* explicit template instantiation required for some systems */
 
 template class ACLStrategised<AnyP::ProtocolType>;
 
 int
-ACLProtocolStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLProtocolStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->request->protocol);
 }
 
 ACLProtocolStrategy *
 ACLProtocolStrategy::Instance()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Protocol.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Protocol.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Protocol.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Protocol.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 #include "anyp/ProtocolType.h"
 
 class ACLProtocolStrategy : public ACLStrategy<AnyP::ProtocolType>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLProtocolStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/ReplyHeaderStrategy.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/ReplyHeaderStrategy.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/ReplyHeaderStrategy.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/ReplyHeaderStrategy.h	2015-05-01 18:05:19.000000000 +0800
@@ -42,13 +42,13 @@
 
 template <http_hdr_type header>
 class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresReply() const {return true;}
 
     static ACLReplyHeaderStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
@@ -60,13 +60,13 @@
 
     ACLReplyHeaderStrategy&operator=(ACLReplyHeaderStrategy const &);
 };
 
 template <http_hdr_type header>
 int
-ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLReplyHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char const *theHeader = checklist->reply->header.getStr(header);
 
     if (NULL == theHeader)
         return 0;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/ReplyMimeType.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/ReplyMimeType.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/ReplyMimeType.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/ReplyMimeType.h	2015-05-01 18:05:19.000000000 +0800
@@ -48,13 +48,13 @@
 #include "acl/Data.h"
 #include "acl/ReplyHeaderStrategy.h"
 #include "acl/Checklist.h"
 
 template <>
 inline int
-ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char const *theHeader = checklist->reply->header.getStr(HDR_CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/RequestHeaderStrategy.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/RequestHeaderStrategy.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/RequestHeaderStrategy.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/RequestHeaderStrategy.h	2015-05-01 18:05:19.000000000 +0800
@@ -42,13 +42,13 @@
 template <http_hdr_type header>
 
 class ACLRequestHeaderStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLRequestHeaderStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
@@ -60,13 +60,13 @@
 
     ACLRequestHeaderStrategy&operator=(ACLRequestHeaderStrategy const &);
 };
 
 template <http_hdr_type header>
 int
-ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLRequestHeaderStrategy<header>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char const *theHeader = checklist->request->header.getStr(header);
 
     if (NULL == theHeader)
         return 0;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/RequestMimeType.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/RequestMimeType.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/RequestMimeType.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/RequestMimeType.h	2015-05-01 18:05:19.000000000 +0800
@@ -48,13 +48,13 @@
 #include "acl/Data.h"
 #include "acl/RequestHeaderStrategy.h"
 #include "acl/Checklist.h"
 
 template <>
 inline int
-ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char const *theHeader = checklist->request->header.getStr(HDR_CONTENT_TYPE);
 
     if (NULL == theHeader)
         theHeader = "";
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: ServerCertificate.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: ServerCertificate.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SourceAsn.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SourceAsn.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SourceAsn.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SourceAsn.h	2015-05-01 18:05:19.000000000 +0800
@@ -25,29 +25,25 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-#ifndef SQUID_ACLSOURCEASN_H
-#define SQUID_ACLSOURCEASN_H
-
-#if 0
-#include "acl/Asn.h"
-#endif
-
-class ACLChecklist;
+#ifndef SQUID_ACL_SOURCEASN_H
+#define SQUID_ACL_SOURCEASN_H
 
 #include "acl/Strategy.h"
 #include "ip/Address.h"
 
+class ACLChecklist;
+
 class ACLSourceASNStrategy : public ACLStrategy<Ip::Address>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLSourceASNStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLSourceASNStrategy(ACLSourceASNStrategy const &);
 
@@ -55,7 +51,7 @@
     static ACLSourceASNStrategy Instance_;
     ACLSourceASNStrategy() {}
 
     ACLSourceASNStrategy&operator=(ACLSourceASNStrategy const &);
 };
 
-#endif /* SQUID_ACLSOURCEASN_H */
+#endif /* SQUID_ACL_SOURCEASN_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SourceDomain.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SourceDomain.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SourceDomain.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SourceDomain.cc	2015-05-01 18:05:19.000000000 +0800
@@ -48,42 +48,38 @@
     return &instance_;
 }
 
 void
 SourceDomainLookup::checkForAsync(ACLChecklist *checklist) const
 {
-    checklist->asyncInProgress(true);
     fqdncache_nbgethostbyaddr(Filled(checklist)->src_addr, LookupDone, checklist);
 }
 
 void
 SourceDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
-    assert (checklist->asyncState() == SourceDomainLookup::Instance());
-
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
     checklist->markSourceDomainChecked();
     checklist->request->recordLookup(details);
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(SourceDomainLookup::Instance());
 }
 
 int
-ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     const char *fqdn = NULL;
     fqdn = fqdncache_gethostbyaddr(checklist->src_addr, FQDN_LOOKUP_IF_MISS);
 
     if (fqdn) {
         return data->match(fqdn);
     } else if (!checklist->sourceDomainChecked()) {
         /* FIXME: Using AclMatchedName here is not OO correct. Should find a way to the current acl */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->src_addr << "'");
-        checklist->changeState(SourceDomainLookup::Instance());
-        return 0;
+        if (checklist->goAsync(SourceDomainLookup::Instance()))
+            return -1;
+        // else fall through to "none" match, hiding the lookup failure (XXX)
     }
 
     return data->match("none");
 }
 
 ACLSourceDomainStrategy *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SourceDomain.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SourceDomain.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SourceDomain.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SourceDomain.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 #include "acl/Strategised.h"
 
 class ACLSourceDomainStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLSourceDomainStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLSourceDomainStrategy(ACLSourceDomainStrategy const &);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SslError.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SslError.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SslError.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SslError.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,13 @@
 #include "squid.h"
 #include "acl/SslError.h"
 #include "acl/SslErrorData.h"
 #include "acl/Checklist.h"
 
 int
-ACLSslErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLSslErrorStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->sslErrors);
 }
 
 ACLSslErrorStrategy *
 ACLSslErrorStrategy::Instance()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SslErrorData.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SslErrorData.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SslErrorData.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SslErrorData.cc	2015-05-01 18:05:19.000000000 +0800
@@ -49,16 +49,16 @@
 {
     if (values)
         delete values;
 }
 
 bool
-ACLSslErrorData::match(const Ssl::Errors *toFind)
+ACLSslErrorData::match(const Ssl::CertErrors *toFind)
 {
-    for (const Ssl::Errors *err = toFind; err; err = err->next ) {
-        if (values->findAndTune(err->element))
+    for (const Ssl::CertErrors *err = toFind; err; err = err->next ) {
+        if (values->findAndTune(err->element.code))
             return true;
     }
     return false;
 }
 
 /* explicit instantiation required for some systems */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SslErrorData.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SslErrorData.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SslErrorData.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SslErrorData.h	2015-05-01 18:05:19.000000000 +0800
@@ -4,23 +4,23 @@
 #include "acl/Data.h"
 #include "CbDataList.h"
 #include "ssl/support.h"
 #include "ssl/ErrorDetail.h"
 #include <vector>
 
-class ACLSslErrorData : public ACLData<const Ssl::Errors *>
+class ACLSslErrorData : public ACLData<const Ssl::CertErrors *>
 {
 
 public:
     MEMPROXY_CLASS(ACLSslErrorData);
 
     ACLSslErrorData();
     ACLSslErrorData(ACLSslErrorData const &);
     ACLSslErrorData &operator= (ACLSslErrorData const &);
     virtual ~ACLSslErrorData();
-    bool match(const Ssl::Errors *);
+    bool match(const Ssl::CertErrors *);
     wordlist *dump();
     void parse();
     bool empty() const;
     virtual  ACLSslErrorData *clone() const;
 
     Ssl::Errors *values;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SslError.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SslError.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/SslError.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/SslError.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,17 +1,17 @@
 #ifndef SQUID_ACLSSL_ERROR_H
 #define SQUID_ACLSSL_ERROR_H
 #include "acl/Strategy.h"
 #include "acl/Strategised.h"
 #include "ssl/support.h"
 
-class ACLSslErrorStrategy : public ACLStrategy<const Ssl::Errors *>
+class ACLSslErrorStrategy : public ACLStrategy<const Ssl::CertErrors *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLSslErrorStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLSslErrorStrategy(ACLSslErrorStrategy const &);
 
@@ -24,10 +24,10 @@
 
 class ACLSslError
 {
 
 private:
     static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<const Ssl::Errors *> RegistryEntry_;
+    static ACLStrategised<const Ssl::CertErrors *> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLSSL_ERROR_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Strategised.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Strategised.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Strategised.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Strategised.h	2015-05-01 18:05:19.000000000 +0800
@@ -46,13 +46,13 @@
 public:
     typedef M MatchType;
     void *operator new(size_t);
     void operator delete(void *);
 
     ~ACLStrategised();
-    ACLStrategised(ACLData<MatchType> *, ACLStrategy<MatchType> *, char const *);
+    ACLStrategised(ACLData<MatchType> *, ACLStrategy<MatchType> *, char const *, const ACLFlag flags[] = ACLFlags::NoFlags);
     ACLStrategised (ACLStrategised const &);
     ACLStrategised &operator= (ACLStrategised const &);
 
     virtual char const *typeString() const;
     virtual bool requiresRequest() const {return matcher->requiresRequest();}
 
@@ -104,13 +104,13 @@
 ACLStrategised<MatchType>::~ACLStrategised()
 {
     delete data;
 }
 
 template <class MatchType>
-ACLStrategised<MatchType>::ACLStrategised(ACLData<MatchType> *newData, ACLStrategy<MatchType> *theStrategy, char const *theType) : data (newData), type_(theType), matcher(theStrategy) {}
+ACLStrategised<MatchType>::ACLStrategised(ACLData<MatchType> *newData, ACLStrategy<MatchType> *theStrategy, char const *theType, const ACLFlag flgs[]) : ACL(flgs), data (newData), type_(theType), matcher(theStrategy) {}
 
 template <class MatchType>
 ACLStrategised<MatchType>::ACLStrategised (ACLStrategised const &old) : data (old.data->clone()), type_(old.type_), matcher (old.matcher)
 {}
 
 template <class MatchType>
@@ -147,13 +147,13 @@
 template <class MatchType>
 int
 ACLStrategised<MatchType>::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = dynamic_cast<ACLFilledChecklist*>(cl);
     assert(checklist);
-    return matcher->match(data, checklist);
+    return matcher->match(data, checklist, flags);
 }
 
 template <class MatchType>
 int
 ACLStrategised<MatchType>::match(MatchType const &toFind)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Strategy.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Strategy.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Strategy.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Strategy.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,24 +31,25 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #ifndef SQUID_ACLSTRATEGY_H
 #define SQUID_ACLSTRATEGY_H
 
+#include "acl/Acl.h"
 #include "acl/Data.h"
 
 class ACLFilledChecklist;
 
 template<class M>
 
 class ACLStrategy
 {
 
 public:
     typedef M MatchType;
-    virtual int match (ACLData<M> * &, ACLFilledChecklist *) = 0;
+    virtual int match (ACLData<M> * &, ACLFilledChecklist *, ACLFlags &) = 0;
     virtual bool requiresRequest() const {return false;}
 
     virtual bool requiresReply() const {return false;}
 
     virtual bool valid() const {return true;}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/StringData.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/StringData.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/StringData.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/StringData.cc	2015-05-01 18:05:19.000000000 +0800
@@ -63,12 +63,18 @@
 static int
 splaystrcmp (char * const &l, char * const &r)
 {
     return strcmp (l,r);
 }
 
+void
+ACLStringData::insert(const char *value)
+{
+    values = values->insert(xstrdup(value), splaystrcmp);
+}
+
 bool
 ACLStringData::match(char const *toFind)
 {
     if (!values || !toFind)
         return 0;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/StringData.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/StringData.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/StringData.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/StringData.h	2015-05-01 18:05:19.000000000 +0800
@@ -49,12 +49,14 @@
     virtual ~ACLStringData();
     bool match(char const *);
     wordlist *dump();
     void parse();
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
+    /// Insert a string data value
+    void insert(const char *);
 
     SplayNode<char *> *values;
 };
 
 /* TODO move into .cci files */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Tag.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Tag.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Tag.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Tag.cc	2015-05-01 18:05:19.000000000 +0800
@@ -38,13 +38,13 @@
 #include "acl/Tag.h"
 #include "acl/StringData.h"
 #include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 int
-ACLTagStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLTagStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     if (checklist->request != NULL)
         return data->match (checklist->request->tag.termedBuf());
     return 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Tag.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Tag.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Tag.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Tag.h	2015-05-01 18:05:19.000000000 +0800
@@ -38,13 +38,13 @@
 #include "acl/Strategised.h"
 
 class ACLTagStrategy : public ACLStrategy<const char *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLTagStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLTagStrategy(ACLTagStrategy const &);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Time.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Time.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Time.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Time.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,13 @@
 #include "squid.h"
 #include "acl/Time.h"
 #include "acl/TimeData.h"
 #include "SquidTime.h"
 
 int
-ACLTimeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLTimeStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (squid_curtime);
 }
 
 ACLTimeStrategy *
 ACLTimeStrategy::Instance()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Time.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Time.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Time.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Time.h	2015-05-01 18:05:19.000000000 +0800
@@ -40,13 +40,13 @@
 class ACLChecklist; // XXX: we do not need it
 
 class ACLTimeStrategy : public ACLStrategy<time_t>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLTimeStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
     ACLTimeStrategy(ACLTimeStrategy const &);
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: Tree.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl: Tree.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Url.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Url.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Url.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Url.cc	2015-05-01 18:05:19.000000000 +0800
@@ -37,13 +37,13 @@
 #include "acl/Checklist.h"
 #include "acl/RegexData.h"
 #include "rfc1738.h"
 #include "src/URL.h"
 
 int
-ACLUrlStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLUrlStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char *esc_buf = xstrdup(urlCanonical(checklist->request));
     rfc1738_unescape(esc_buf);
     int result = data->match(esc_buf);
     safe_free(esc_buf);
     return result;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Url.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Url.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/Url.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/Url.h	2015-05-01 18:05:19.000000000 +0800
@@ -38,13 +38,13 @@
 #include "acl/Strategised.h"
 
 class ACLUrlStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlLogin.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlLogin.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlLogin.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlLogin.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,13 @@
 #include "acl/Checklist.h"
 #include "acl/RegexData.h"
 #include "HttpRequest.h"
 #include "rfc1738.h"
 
 int
-ACLUrlLoginStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLUrlLoginStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     char *esc_buf = xstrdup(checklist->request->login);
     rfc1738_unescape(esc_buf);
     int result = data->match(esc_buf);
     safe_free(esc_buf);
     return result;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlLogin.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlLogin.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlLogin.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlLogin.h	2015-05-01 18:05:19.000000000 +0800
@@ -42,13 +42,13 @@
 #include "acl/Strategised.h"
 
 class ACLUrlLoginStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlLoginStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlPath.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlPath.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlPath.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlPath.cc	2015-05-01 18:05:19.000000000 +0800
@@ -37,14 +37,17 @@
 #include "acl/Checklist.h"
 #include "acl/RegexData.h"
 #include "HttpRequest.h"
 #include "rfc1738.h"
 
 int
-ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
+    if (!checklist->request->urlpath.size())
+        return -1;
+
     char *esc_buf = xstrdup(checklist->request->urlpath.termedBuf());
     rfc1738_unescape(esc_buf);
     int result = data->match(esc_buf);
     safe_free(esc_buf);
     return result;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlPath.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlPath.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlPath.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlPath.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 #include "acl/Strategised.h"
 
 class ACLUrlPathStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlPathStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlPort.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlPort.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlPort.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlPort.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,13 @@
 #include "acl/UrlPort.h"
 #include "acl/IntRange.h"
 #include "acl/Checklist.h"
 #include "HttpRequest.h"
 
 int
-ACLUrlPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLUrlPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->request->port);
 }
 
 ACLUrlPortStrategy *
 ACLUrlPortStrategy::Instance()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlPort.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlPort.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UrlPort.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UrlPort.h	2015-05-01 18:05:19.000000000 +0800
@@ -37,13 +37,13 @@
 #include "acl/Strategised.h"
 
 class ACLUrlPortStrategy : public ACLStrategy<int>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     virtual bool requiresRequest() const {return true;}
 
     static ACLUrlPortStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g+++ warnings about
      * private constructors with no friends */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UserData.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UserData.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UserData.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UserData.cc	2015-05-01 18:05:19.000000000 +0800
@@ -129,16 +129,16 @@
 
     if ((t = ConfigParser::strtokFile())) {
         debugs(28, 5, "aclParseUserList: First token is " << t);
 
         if (strcmp("-i", t) == 0) {
             debugs(28, 5, "aclParseUserList: Going case-insensitive");
-            flags.case_insensitive = 1;
+            flags.case_insensitive = true;
         } else if (strcmp("REQUIRED", t) == 0) {
             debugs(28, 5, "aclParseUserList: REQUIRED-type enabled");
-            flags.required = 1;
+            flags.required = true;
         } else {
             if (flags.case_insensitive)
                 Tolower(t);
 
             names = names->insert(xstrdup(t), splaystrcmp);
         }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UserData.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UserData.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/acl/UserData.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/acl/UserData.h	2015-05-01 18:05:19.000000000 +0800
@@ -50,14 +50,14 @@
     bool empty() const;
     virtual ACLData<char const *> *clone() const;
 
     SplayNode<char *> *names;
 
     struct {
-        unsigned int case_insensitive:1;
-        unsigned int required:1;
+        bool case_insensitive;
+        bool required;
     } flags;
 };
 
 MEMPROXY_CLASS_INLINE(ACLUserData);
 
 #endif /* SQUID_ACLUSERDATA_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/AclRegs.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/AclRegs.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/AclRegs.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/AclRegs.cc	2015-05-01 18:05:19.000000000 +0800
@@ -2,13 +2,14 @@
 
 /** This file exists to provide satic registration code to executables
     that need ACLs. We cannot place this code in acl/lib*.la because it
     does not get linked in, because nobody is using these classes by name.
 */
 
-#include "acl/Acl.h"
+#include "acl/AllOf.h"
+#include "acl/AnyOf.h"
 #if USE_SQUID_EUI
 #include "acl/Arp.h"
 #include "acl/Eui64.h"
 #endif
 #include "acl/Asn.h"
 #include "acl/Browser.h"
@@ -34,12 +35,14 @@
 #include "acl/LocalIp.h"
 #include "acl/LocalPort.h"
 #include "acl/MaxConnection.h"
 #include "acl/MethodData.h"
 #include "acl/Method.h"
 #include "acl/MyPortName.h"
+#include "acl/Note.h"
+#include "acl/NoteData.h"
 #include "acl/PeerName.h"
 #include "acl/ProtocolData.h"
 #include "acl/Protocol.h"
 #include "acl/Random.h"
 #include "acl/Referer.h"
 #include "acl/RegexData.h"
@@ -56,12 +59,15 @@
 #include "acl/CertificateData.h"
 #include "acl/Certificate.h"
 #endif
 #include "acl/Strategised.h"
 #include "acl/Strategy.h"
 #include "acl/StringData.h"
+#if USE_SSL
+#include "acl/ServerCertificate.h"
+#endif
 #include "acl/Tag.h"
 #include "acl/TimeData.h"
 #include "acl/Time.h"
 #include "acl/Url.h"
 #include "acl/UrlLogin.h"
 #include "acl/UrlPath.h"
@@ -74,16 +80,18 @@
 #if USE_IDENT
 #include "ident/AclIdent.h"
 #endif
 
 ACL::Prototype ACLBrowser::RegistryProtoype(&ACLBrowser::RegistryEntry_, "browser");
 ACLStrategised<char const *> ACLBrowser::RegistryEntry_(new ACLRegexData, ACLRequestHeaderStrategy<HDR_USER_AGENT>::Instance(), "browser");
+ACLFlag  DestinationDomainFlags[] = {ACL_F_NO_LOOKUP, ACL_F_END};
 ACL::Prototype ACLDestinationDomain::LiteralRegistryProtoype(&ACLDestinationDomain::LiteralRegistryEntry_, "dstdomain");
-ACLStrategised<char const *> ACLDestinationDomain::LiteralRegistryEntry_(new ACLDomainData, ACLDestinationDomainStrategy::Instance(), "dstdomain");
+ACLStrategised<char const *> ACLDestinationDomain::LiteralRegistryEntry_(new ACLDomainData, ACLDestinationDomainStrategy::Instance(), "dstdomain", DestinationDomainFlags);
 ACL::Prototype ACLDestinationDomain::RegexRegistryProtoype(&ACLDestinationDomain::RegexRegistryEntry_, "dstdom_regex");
-ACLStrategised<char const *> ACLDestinationDomain::RegexRegistryEntry_(new ACLRegexData,ACLDestinationDomainStrategy::Instance() ,"dstdom_regex");
+ACLFlag  DestinationDomainRegexFlags[] = {ACL_F_NO_LOOKUP, ACL_F_REGEX_CASE, ACL_F_END};
+ACLStrategised<char const *> ACLDestinationDomain::RegexRegistryEntry_(new ACLRegexData,ACLDestinationDomainStrategy::Instance() ,"dstdom_regex", DestinationDomainRegexFlags);
 ACL::Prototype ACLDestinationIP::RegistryProtoype(&ACLDestinationIP::RegistryEntry_, "dst");
 ACLDestinationIP ACLDestinationIP::RegistryEntry_;
 #if USE_AUTH
 ACL::Prototype ACLExtUser::UserRegistryProtoype(&ACLExtUser::UserRegistryEntry_, "ext_user");
 ACLExtUser ACLExtUser::UserRegistryEntry_(new ACLUserData, "ext_user");
 ACL::Prototype ACLExtUser::RegexRegistryProtoype(&ACLExtUser::RegexRegistryEntry_, "ext_user_regex" );
@@ -138,17 +146,19 @@
 ACLStrategised<char const *> ACLUrlPath::RegistryEntry_(new ACLRegexData, ACLUrlPathStrategy::Instance(), "urlpath_regex");
 ACL::Prototype ACLUrlPort::RegistryProtoype(&ACLUrlPort::RegistryEntry_, "port");
 ACLStrategised<int> ACLUrlPort::RegistryEntry_(new ACLIntRange, ACLUrlPortStrategy::Instance(), "port");
 
 #if USE_SSL
 ACL::Prototype ACLSslError::RegistryProtoype(&ACLSslError::RegistryEntry_, "ssl_error");
-ACLStrategised<const Ssl::Errors *> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
+ACLStrategised<const Ssl::CertErrors *> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
 ACL::Prototype ACLCertificate::UserRegistryProtoype(&ACLCertificate::UserRegistryEntry_, "user_cert");
-ACLStrategised<SSL *> ACLCertificate::UserRegistryEntry_(new ACLCertificateData (sslGetUserAttribute), ACLCertificateStrategy::Instance(), "user_cert");
+ACLStrategised<X509 *> ACLCertificate::UserRegistryEntry_(new ACLCertificateData (Ssl::GetX509UserAttribute, "*"), ACLCertificateStrategy::Instance(), "user_cert");
 ACL::Prototype ACLCertificate::CARegistryProtoype(&ACLCertificate::CARegistryEntry_, "ca_cert");
-ACLStrategised<SSL *> ACLCertificate::CARegistryEntry_(new ACLCertificateData (sslGetCAAttribute), ACLCertificateStrategy::Instance(), "ca_cert");
+ACLStrategised<X509 *> ACLCertificate::CARegistryEntry_(new ACLCertificateData (Ssl::GetX509CAAttribute, "*"), ACLCertificateStrategy::Instance(), "ca_cert");
+ACL::Prototype ACLServerCertificate::X509FingerprintRegistryProtoype(&ACLServerCertificate::X509FingerprintRegistryEntry_, "server_cert_fingerprint");
+ACLStrategised<X509 *> ACLServerCertificate::X509FingerprintRegistryEntry_(new ACLCertificateData(Ssl::GetX509Fingerprint, "-sha1", true), ACLServerCertificateStrategy::Instance(), "server_cert_fingerprint");
 #endif
 
 #if USE_SQUID_EUI
 ACL::Prototype ACLARP::RegistryProtoype(&ACLARP::RegistryEntry_, "arp");
 ACLARP ACLARP::RegistryEntry_("arp");
 ACL::Prototype ACLEui64::RegistryProtoype(&ACLEui64::RegistryEntry_, "eui64");
@@ -171,6 +181,15 @@
 ACL::Prototype ACLMaxUserIP::RegistryProtoype(&ACLMaxUserIP::RegistryEntry_, "max_user_ip");
 ACLMaxUserIP ACLMaxUserIP::RegistryEntry_("max_user_ip");
 #endif
 
 ACL::Prototype ACLTag::RegistryProtoype(&ACLTag::RegistryEntry_, "tag");
 ACLStrategised<const char *> ACLTag::RegistryEntry_(new ACLStringData, ACLTagStrategy::Instance(), "tag");
+
+ACL::Prototype Acl::AnyOf::RegistryProtoype(&Acl::AnyOf::RegistryEntry_, "any-of");
+Acl::AnyOf Acl::AnyOf::RegistryEntry_;
+
+ACL::Prototype Acl::AllOf::RegistryProtoype(&Acl::AllOf::RegistryEntry_, "all-of");
+Acl::AllOf Acl::AllOf::RegistryEntry_;
+
+ACL::Prototype ACLNote::RegistryProtoype(&ACLNote::RegistryEntry_, "note");
+ACLStrategised<HttpRequest *> ACLNote::RegistryEntry_(new ACLNoteData, ACLNoteStrategy::Instance(), "note");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/AccessCheck.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/AccessCheck.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/AccessCheck.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/AccessCheck.cc	2015-05-01 18:05:19.000000000 +0800
@@ -119,13 +119,14 @@
 
     while (!candidates.empty()) {
         if (AccessRule *r = FindRule(topCandidate())) {
             /* BUG 2526: what to do when r->acl is empty?? */
             // XXX: we do not have access to conn->rfc931 here.
             acl_checklist = new ACLFilledChecklist(r->acl, filter.request, dash_str);
-            acl_checklist->reply = filter.reply ? HTTPMSGLOCK(filter.reply) : NULL;
+            if ((acl_checklist->reply = filter.reply))
+                HTTPMSGLOCK(acl_checklist->reply);
             acl_checklist->nonBlockingCheck(AccessCheckCallbackWrapper, this);
             return;
         }
 
         candidates.shift(); // the rule apparently went away (reconfigure)
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/AccessRule.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/AccessRule.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/AccessRule.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/AccessRule.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,8 +1,9 @@
 #include "squid.h"
 #include "acl/Gadgets.h"
+#include "acl/Tree.h"
 #include "adaptation/AccessRule.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 
@@ -11,19 +12,19 @@
 Adaptation::AccessRule::AccessRule(const String &aGroupId): id(++LastId), groupId(aGroupId), acl(NULL)
 {
 }
 
 Adaptation::AccessRule::~AccessRule()
 {
-    // XXX: leaking acls here?
+    delete acl;
 }
 
 void
 Adaptation::AccessRule::parse(ConfigParser &parser)
 {
-    aclParseAccessLine(parser, &acl);
+    aclParseAccessLine("adaptation_access", parser, &acl);
 }
 
 void
 Adaptation::AccessRule::finalize()
 {
     if (!group()) { // no explicit group
@@ -48,14 +49,14 @@
     return FindGroup(groupId);
 }
 
 Adaptation::AccessRules &
 Adaptation::AllRules()
 {
-    static AccessRules TheRules;
-    return TheRules;
+    static AccessRules *TheRules = new AccessRules;
+    return *TheRules;
 }
 
 // TODO: make AccessRules::find work
 Adaptation::AccessRule *
 Adaptation::FindRule(const AccessRule::Id &id)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/AccessRule.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/AccessRule.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/AccessRule.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/AccessRule.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,13 @@
 #ifndef SQUID_ADAPTATION__ACCESS_RULE_H
 #define SQUID_ADAPTATION__ACCESS_RULE_H
 
-#include "SquidString.h"
+#include "acl/forward.h"
 #include "adaptation/forward.h"
+#include "SquidString.h"
 
-class acl_access;
 class ConfigParser;
 
 namespace Adaptation
 {
 
 // manages adaptation_access configuration by associating an acl with
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Answer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Answer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Answer.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Answer.h	2015-05-01 18:05:19.000000000 +0800
@@ -24,13 +24,13 @@
     static Answer Forward(HttpMsg *aMsg); ///< create an akForward answer
     static Answer Block(const String &aRule); ///< create an akBlock answer
 
     std::ostream &print(std::ostream &os) const;
 
 public:
-    HttpMsgPointerT<HttpMsg> message; ///< HTTP request or response to forward
+    HttpMsg::Pointer message; ///< HTTP request or response to forward
     String ruleId; ///< ACL (or similar rule) name that blocked forwarding
     bool final; ///< whether the error, if any, cannot be bypassed
     Kind kind; ///< the type of the answer
 
 private:
     explicit Answer(Kind aKind); ///< use static creators instead
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Config.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Config.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Config.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Config.cc	2015-05-01 18:05:19.000000000 +0800
@@ -33,72 +33,43 @@
 #include "acl/Gadgets.h"
 #include "adaptation/AccessRule.h"
 #include "adaptation/Config.h"
 #include "adaptation/History.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "ConfigParser.h"
 #include "globals.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "Store.h"
 
 bool Adaptation::Config::Enabled = false;
 char *Adaptation::Config::masterx_shared_name = NULL;
 int Adaptation::Config::service_iteration_limit = 16;
 int Adaptation::Config::send_client_ip = false;
 int Adaptation::Config::send_username = false;
 int Adaptation::Config::use_indirect_client = true;
-Adaptation::Config::MetaHeaders Adaptation::Config::metaHeaders;
-
-Adaptation::Config::MetaHeader::Value::~Value()
-{
-    aclDestroyAclList(&aclList);
-}
-
-Adaptation::Config::MetaHeader::Value::Pointer
-Adaptation::Config::MetaHeader::addValue(const String &value)
-{
-    Value::Pointer v = new Value(value);
-    values.push_back(v);
-    return v;
-}
-
-const char *
-Adaptation::Config::MetaHeader::match(HttpRequest *request, HttpReply *reply)
-{
-
-    typedef Values::iterator VLI;
-    ACLFilledChecklist ch(NULL, request, NULL);
-    if (reply)
-        ch.reply = HTTPMSGLOCK(reply);
-
-    for (VLI i = values.begin(); i != values.end(); ++i ) {
-        const int ret= ch.fastCheck((*i)->aclList);
-        debugs(93, 5, HERE << "Check for header name: " << name << ": " << (*i)->value
-               <<", HttpRequest: " << request << " HttpReply: " << reply << " matched: " << ret);
-        if (ret == ACCESS_ALLOWED)
-            return (*i)->value.termedBuf();
-    }
-    return NULL;
-}
-
-Adaptation::Config::MetaHeader::Pointer
-Adaptation::Config::addMetaHeader(const String &headerName)
-{
-    typedef MetaHeaders::iterator AMLI;
-    for (AMLI i = metaHeaders.begin(); i != metaHeaders.end(); ++i) {
-        if ((*i)->name == headerName)
-            return (*i);
-    }
-
-    MetaHeader::Pointer meta = new MetaHeader(headerName);
-    metaHeaders.push_back(meta);
-    return meta;
-}
+const char *metasBlacklist[] = {
+    "Methods",
+    "Service",
+    "ISTag",
+    "Encapsulated",
+    "Opt-body-type",
+    "Max-Connections",
+    "Options-TTL",
+    "Date",
+    "Service-ID",
+    "Allow",
+    "Preview",
+    "Transfer-Preview",
+    "Transfer-Ignore",
+    "Transfer-Complete",
+    NULL
+};
+Notes Adaptation::Config::metaHeaders("ICAP header", metasBlacklist);
 
 Adaptation::ServiceConfig*
 Adaptation::Config::newServiceConfig() const
 {
     return new ServiceConfig();
 }
@@ -177,14 +148,12 @@
     FreeAccess();
     FreeServiceGroups();
 
     DetachServices();
 
     serviceConfigs.clean();
-
-    FreeMetaHeader();
 }
 
 void
 Adaptation::Config::dumpService(StoreEntry *entry, const char *name) const
 {
     typedef Services::iterator SCI;
@@ -253,70 +222,12 @@
     FinalizeEach(AllServices(), "message adaptation services");
     FinalizeEach(AllGroups(), "message adaptation service groups");
     FinalizeEach(AllRules(), "message adaptation access rules");
 }
 
 void
-Adaptation::Config::ParseMetaHeader(ConfigParser &parser)
-{
-    String name, value;
-    const char *warnFor[] = {
-        "Methods",
-        "Service",
-        "ISTag",
-        "Encapsulated",
-        "Opt-body-type",
-        "Max-Connections",
-        "Options-TTL",
-        "Date",
-        "Service-ID",
-        "Allow",
-        "Preview",
-        "Transfer-Preview",
-        "Transfer-Ignore",
-        "Transfer-Complete",
-        NULL
-    };
-    ConfigParser::ParseString(&name);
-    ConfigParser::ParseQuotedString(&value);
-
-    // TODO: Find a way to move this check to ICAP
-    for (int i = 0; warnFor[i] != NULL; ++i) {
-        if (name.caseCmp(warnFor[i]) == 0) {
-            fatalf("%s:%d: meta name \"%s\" is a reserved ICAP header name",
-                   cfg_filename, config_lineno, name.termedBuf());
-        }
-    }
-
-    MetaHeader::Pointer meta = addMetaHeader(name);
-    MetaHeader::Value::Pointer headValue = meta->addValue(value);
-    aclParseAclList(parser, &headValue->aclList);
-}
-
-void
-Adaptation::Config::DumpMetaHeader(StoreEntry *entry, const char *name)
-{
-    typedef MetaHeaders::iterator AMLI;
-    for (AMLI m = metaHeaders.begin(); m != metaHeaders.end(); ++m) {
-        typedef MetaHeader::Values::iterator VLI;
-        for (VLI v =(*m)->values.begin(); v != (*m)->values.end(); ++v ) {
-            storeAppendPrintf(entry, "%s " SQUIDSTRINGPH " %s",
-                              name, SQUIDSTRINGPRINT((*m)->name), ConfigParser::QuoteString((*v)->value));
-            dump_acl_list(entry, (*v)->aclList);
-            storeAppendPrintf(entry, "\n");
-        }
-    }
-}
-
-void
-Adaptation::Config::FreeMetaHeader()
-{
-    metaHeaders.clean();
-}
-
-void
 Adaptation::Config::ParseServiceSet()
 {
     Adaptation::Config::ParseServiceGroup(new ServiceSet);
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Config.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Config.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Config.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Config.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,17 +1,17 @@
 #ifndef SQUID_ADAPTATION__CONFIG_H
 #define SQUID_ADAPTATION__CONFIG_H
 
 #include "event.h"
-#include "acl/Gadgets.h"
+#include "acl/forward.h"
 #include "base/AsyncCall.h"
 #include "adaptation/forward.h"
 #include "adaptation/Elements.h"
+#include "Notes.h"
 #include "SquidString.h"
 
-class acl_access;
 class ConfigParser;
 class HttpRequest;
 class HttpReply;
 
 namespace Adaptation
 {
@@ -20,15 +20,12 @@
 {
 public:
     static void Finalize(bool enable);
 
     static void ParseServiceSet(void);
     static void ParseServiceChain(void);
-    static void ParseMetaHeader(ConfigParser &parser);
-    static void FreeMetaHeader();
-    static void DumpMetaHeader(StoreEntry *, const char *);
 
     static void ParseAccess(ConfigParser &parser);
     static void FreeAccess(void);
     static void DumpAccess(StoreEntry *, const char *);
 
     friend class AccessCheck;
@@ -47,59 +44,13 @@
     // TODO: move ICAP-specific options to Icap::Config and add TheConfig
     int onoff;
     int service_failure_limit;
     time_t oldest_service_failure;
     int service_revival_delay;
 
-    /**
-     * Used to store meta headers. The meta headers are custom
-     * ICAP request headers or ECAP options used to pass custom
-     * transaction-state related meta information to a service.
-     */
-    class MetaHeader: public RefCountable
-    {
-    public:
-        typedef RefCount<MetaHeader> Pointer;
-        /// Stores a value for the meta header.
-        class Value: public RefCountable
-        {
-        public:
-            typedef RefCount<Value> Pointer;
-            String value; ///< a header value
-            ACLList *aclList; ///< The access list used to determine if this value is valid for a request
-            explicit Value(const String &aVal) : value(aVal), aclList(NULL) {}
-            ~Value();
-        };
-        typedef Vector<Value::Pointer> Values;
-
-        explicit MetaHeader(const String &aName): name(aName) {}
-
-        /**
-         * Adds a value to the meta header and returns a  pointer to the
-         * related Value object.
-         */
-        Value::Pointer addValue(const String &value);
-
-        /**
-         * Walks through the  possible values list of the  meta and selects
-         * the first value which matches the given HttpRequest and HttpReply
-         * or NULL if none matches.
-         */
-        const char *match(HttpRequest *request, HttpReply *reply);
-        String name; ///< The meta header name
-        Values values; ///< The possible values list for the meta header
-    };
-    typedef Vector<MetaHeader::Pointer> MetaHeaders;
-    static MetaHeaders metaHeaders; ///< The list of configured meta headers
-
-    /**
-     * Adds a header to the meta headers list and returns a pointer to the
-     * related metaHeaders object. If the header name already exists in list,
-     * returns a pointer to the existing object.
-     */
-    static MetaHeader::Pointer addMetaHeader(const String &header);
+    static Notes metaHeaders; ///< The list of configured meta headers
 
     typedef Vector<ServiceConfigPointer> ServiceConfigs;
     ServiceConfigs serviceConfigs;
 
     Config();
     virtual ~Config();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/DynamicGroupCfg.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/DynamicGroupCfg.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/DynamicGroupCfg.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/DynamicGroupCfg.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,10 @@
 #ifndef SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 #define SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "SquidString.h"
 
 namespace Adaptation
 {
 
 /// DynamicServiceGroup configuration to remember future dynamic chains
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ecap/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ecap/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ecap/Makefile.in	2015-05-01 16:51:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ecap/Makefile.in	2015-05-01 18:06:48.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -458,12 +504,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -501,12 +548,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -533,27 +581,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -620,13 +671,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libsquid-ecap.la
 libsquid_ecap_la_SOURCES = \
 	Config.h \
 	Config.cc \
 	Host.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ecap/MessageRep.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ecap/MessageRep.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ecap/MessageRep.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ecap/MessageRep.cc	2015-05-01 18:05:19.000000000 +0800
@@ -96,13 +96,13 @@
 void
 Adaptation::Ecap::HeaderRep::parse(const Area &buf)
 {
     MemBuf mb;
     mb.init();
     mb.append(buf.start, buf.size);
-    http_status error;
+    Http::StatusCode error;
     Must(theMessage.parse(&mb, true, &error));
 }
 
 http_hdr_type
 Adaptation::Ecap::HeaderRep::TranslateHeaderId(const Name &name)
 {
@@ -222,39 +222,39 @@
 
 void
 Adaptation::Ecap::RequestLineRep::method(const Name &aMethod)
 {
     if (aMethod.assignedHostId()) {
         const int id = aMethod.hostId();
-        Must(METHOD_NONE < id && id < METHOD_ENUM_END);
-        Must(id != METHOD_OTHER);
-        theMessage.method = HttpRequestMethod(static_cast<_method_t>(id));
+        Must(Http::METHOD_NONE < id && id < Http::METHOD_ENUM_END);
+        Must(id != Http::METHOD_OTHER);
+        theMessage.method = HttpRequestMethod(static_cast<Http::MethodType>(id));
     } else {
         const std::string &image = aMethod.image();
         theMessage.method = HttpRequestMethod(image.data(),
                                               image.data() + image.size());
     }
 }
 
 Adaptation::Ecap::RequestLineRep::Name
 Adaptation::Ecap::RequestLineRep::method() const
 {
     switch (theMessage.method.id()) {
-    case METHOD_GET:
+    case Http::METHOD_GET:
         return libecap::methodGet;
-    case METHOD_POST:
+    case Http::METHOD_POST:
         return libecap::methodPost;
-    case METHOD_PUT:
+    case Http::METHOD_PUT:
         return libecap::methodPut;
-    case METHOD_HEAD:
+    case Http::METHOD_HEAD:
         return libecap::methodHead;
-    case METHOD_CONNECT:
+    case Http::METHOD_CONNECT:
         return libecap::methodConnect;
-    case METHOD_DELETE:
+    case Http::METHOD_DELETE:
         return libecap::methodDelete;
-    case METHOD_TRACE:
+    case Http::METHOD_TRACE:
         return libecap::methodTrace;
     default:
         return Name(theMessage.method.image());
     }
 }
 
@@ -289,35 +289,32 @@
 {
 }
 
 void
 Adaptation::Ecap::StatusLineRep::statusCode(int code)
 {
-    // TODO: why is .status a enum? Do we not support unknown statuses?
-    theMessage.sline.status = static_cast<http_status>(code);
+    theMessage.sline.set(theMessage.sline.version, static_cast<Http::StatusCode>(code), theMessage.sline.reason());
 }
 
 int
 Adaptation::Ecap::StatusLineRep::statusCode() const
 {
-    // TODO: see statusCode(code) TODO above
-    return static_cast<int>(theMessage.sline.status);
+    // TODO: remove cast when possible
+    return static_cast<int>(theMessage.sline.status());
 }
 
 void
-Adaptation::Ecap::StatusLineRep::reasonPhrase(const Area &)
+Adaptation::Ecap::StatusLineRep::reasonPhrase(const Area &str)
 {
-    // Squid does not support custom reason phrases
-    theMessage.sline.reason = NULL;
+    theMessage.sline.set(theMessage.sline.version, theMessage.sline.status(), str.toString().c_str());
 }
 
 Adaptation::Ecap::StatusLineRep::Area
 Adaptation::Ecap::StatusLineRep::reasonPhrase() const
 {
-    return theMessage.sline.reason ?
-           Area::FromTempString(std::string(theMessage.sline.reason)) : Area();
+    return Area::FromTempString(std::string(theMessage.sline.reason()));
 }
 
 libecap::Version
 Adaptation::Ecap::StatusLineRep::version() const
 {
     return FirstLineRep::version();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ecap/XactionRep.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ecap/XactionRep.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ecap/XactionRep.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ecap/XactionRep.cc	2015-05-01 18:05:19.000000000 +0800
@@ -121,15 +121,15 @@
 #if FOLLOW_X_FORWARDED_FOR
         if (TheConfig.use_indirect_client) {
             client_addr = request->indirect_client_addr;
         } else
 #endif
             client_addr = request->client_addr;
-        if (!client_addr.IsAnyAddr() && !client_addr.IsNoAddr()) {
+        if (!client_addr.isAnyAddr() && !client_addr.isNoAddr()) {
             char ntoabuf[MAX_IPSTRLEN] = "";
-            client_addr.NtoA(ntoabuf,MAX_IPSTRLEN);
+            client_addr.toStr(ntoabuf,MAX_IPSTRLEN);
             return libecap::Area::FromTempBuffer(ntoabuf, strlen(ntoabuf));
         }
     }
     return libecap::Area();
 }
 
@@ -174,15 +174,15 @@
     HttpRequest *request = dynamic_cast<HttpRequest*>(theCauseRep ?
                            theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
     HttpReply *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
 
     if (name.known()) { // must check to avoid empty names matching unset cfg
-        typedef Adaptation::Config::MetaHeaders::iterator ACAMLI;
+        typedef Notes::iterator ACAMLI;
         for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
-            if (name == (*i)->name.termedBuf()) {
+            if (name == (*i)->key.termedBuf()) {
                 if (const char *value = (*i)->match(request, reply))
                     return libecap::Area::FromTempString(value);
                 else
                     return libecap::Area();
             }
         }
@@ -196,17 +196,17 @@
 {
     HttpRequest *request = dynamic_cast<HttpRequest*>(theCauseRep ?
                            theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
     HttpReply *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
 
-    typedef Adaptation::Config::MetaHeaders::iterator ACAMLI;
+    typedef Notes::iterator ACAMLI;
     for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
         const char *v = (*i)->match(request, reply);
         if (v) {
-            const libecap::Name name((*i)->name.termedBuf());
+            const libecap::Name name((*i)->key.termedBuf());
             const libecap::Area value = libecap::Area::FromTempString(v);
             visitor.visit(name, value);
         }
     }
 }
 
@@ -215,19 +215,32 @@
 {
     Must(theMaster);
 
     if (!theVirginRep.raw().body_pipe)
         makingVb = opNever; // there is nothing to deliver
 
-    const HttpRequest *request = dynamic_cast<const HttpRequest*> (theCauseRep ?
-                                 theCauseRep->raw().header : theVirginRep.raw().header);
+    HttpRequest *request = dynamic_cast<HttpRequest*> (theCauseRep ?
+                           theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
+
+    HttpReply *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
+
     Adaptation::History::Pointer ah = request->adaptLogHistory();
     if (ah != NULL) {
         // retrying=false because ecap never retries transactions
         adaptHistoryId = ah->recordXactStart(service().cfg().key, current_time, false);
+        typedef Notes::iterator ACAMLI;
+        for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
+            const char *v = (*i)->match(request, reply);
+            if (v) {
+                if (ah->metaHeaders == NULL)
+                    ah->metaHeaders = new NotePairs();
+                if (!ah->metaHeaders->hasPair((*i)->key.termedBuf(), v))
+                    ah->metaHeaders->add((*i)->key.termedBuf(), v);
+            }
+        }
     }
 
     theMaster->start();
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/History.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/History.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/History.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/History.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,14 @@
 #ifndef SQUID_ADAPT_HISTORY_H
 #define SQUID_ADAPT_HISTORY_H
 
 #include "adaptation/DynamicGroupCfg.h"
-#include "Array.h"
+#include "base/Vector.h"
+#include "base/RefCount.h"
 #include "HttpHeader.h"
-#include "RefCount.h"
+#include "Notes.h"
 #include "SquidString.h"
 
 namespace Adaptation
 {
 
 /// collects information about adaptations related to a master transaction
@@ -47,12 +48,15 @@
 
 public:
     /// Last received meta header (REQMOD or RESPMOD, whichever comes last).
     HttpHeader lastMeta;
     /// All REQMOD and RESPMOD meta headers merged. Last field wins conflicts.
     HttpHeader allMeta;
+    /// key:value pairs set by adaptation_meta, to be added to
+    /// AccessLogEntry::notes when ALE becomes available
+    NotePairs::Pointer metaHeaders;
 
     /// sets future services for the Adaptation::AccessCheck to notice
     void setFutureServices(const DynamicGroupCfg &services);
 
     /// returns true, fills the value, and resets iff future services were set
     bool extractFutureServices(DynamicGroupCfg &services);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Config.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Config.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Config.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Config.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,13 +30,13 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
 #include "ConfigParser.h"
 #include "Store.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/ServiceRep.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "SquidConfig.h"
 #include "wordlist.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Config.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Config.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Config.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Config.h	2015-05-01 18:05:19.000000000 +0800
@@ -33,17 +33,16 @@
 
 #ifndef SQUID_ICAPCONFIG_H
 #define SQUID_ICAPCONFIG_H
 
 #include "event.h"
 #include "base/AsyncCall.h"
+#include "acl/forward.h"
 #include "adaptation/Config.h"
 #include "adaptation/icap/ServiceRep.h"
 
-class acl_access;
-
 namespace Adaptation
 {
 namespace Icap
 {
 
 class ConfigParser;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/History.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/History.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/History.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/History.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,12 @@
 #ifndef SQUID_ICAPHISTORY_H
 #define SQUID_ICAPHISTORY_H
 
+#include "base/RefCount.h"
 #include "enums.h"
-#include "RefCount.h"
+#include "LogTags.h"
 #include "SquidString.h"
 
 namespace Adaptation
 {
 namespace Icap
 {
@@ -27,13 +28,13 @@
     int processingTime() const;
 
     String rfc931; ///< the username from ident
 #if USE_SSL
     String ssluser; ///< the username from SSL
 #endif
-    log_type logType; ///< the squid request status (TCP_MISS etc)
+    LogTags logType; ///< the squid request status (TCP_MISS etc)
 
     String log_uri; ///< the request uri
     size_t req_sz; ///< the request size
 
 private:
     int currentTime() const; ///< time since current start or zero
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/icap_log.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/icap_log.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/icap_log.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/icap_log.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,9 +1,12 @@
 #include "squid.h"
 #include "icap_log.h"
 #include "AccessLogEntry.h"
+#include "acl/FilledChecklist.h"
+#include "HttpReply.h"
+#include "globals.h"
 #include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
 #include "SquidConfig.h"
 
 int IcapLogfileStatus = LOG_DISABLE;
@@ -14,13 +17,13 @@
     CustomLog *log;
 
     for (log = Config.Log.icaplogs; log; log = log->next) {
         if (log->type == Log::Format::CLF_NONE)
             continue;
 
-        log->logfile = logfileOpen(log->filename, MAX_URL << 1, 1);
+        log->logfile = logfileOpen(log->filename, log->bufferSize, log->fatal);
 
         IcapLogfileStatus = LOG_ENABLE;
     }
 }
 
 void
@@ -43,11 +46,17 @@
         if (log->logfile) {
             logfileRotate(log->logfile);
         }
     }
 }
 
-void icapLogLog(AccessLogEntry::Pointer &al, ACLChecklist * checklist)
+void icapLogLog(AccessLogEntry::Pointer &al)
 {
-    if (IcapLogfileStatus == LOG_ENABLE)
-        accessLogLogTo(Config.Log.icaplogs, al, checklist);
+    if (IcapLogfileStatus == LOG_ENABLE) {
+        ACLFilledChecklist checklist(NULL, al->adapted_request, NULL);
+        if (al->reply) {
+            checklist.reply = al->reply;
+            HTTPMSGLOCK(checklist.reply);
+        }
+        accessLogLogTo(Config.Log.icaplogs, al, &checklist);
+    }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/icap_log.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/icap_log.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/icap_log.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/icap_log.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,18 +1,18 @@
 #ifndef ICAP_LOG_H_
 #define ICAP_LOG_H_
 
 #include "AccessLogEntry.h"
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class AccessLogEntry;
 class ACLChecklist;
 
 void icapLogClose();
 void icapLogOpen();
 void icapLogRotate();
-void icapLogLog(AccessLogEntryPointer &al, ACLChecklist * checklist);
+void icapLogLog(AccessLogEntryPointer &al);
 
 extern int IcapLogfileStatus;
 
 #endif /*ICAP_LOG_H_*/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/InOut.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/InOut.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/InOut.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/InOut.h	2015-05-01 18:05:19.000000000 +0800
@@ -59,21 +59,23 @@
         HTTPMSGUNLOCK(header);
     }
 
     void setCause(HttpRequest *r) {
         if (r) {
             HTTPMSGUNLOCK(cause);
-            cause = HTTPMSGLOCK(r);
+            cause = r;
+            HTTPMSGLOCK(cause);
         } else {
             assert(!cause);
         }
     }
 
     void setHeader(Header *h) {
         HTTPMSGUNLOCK(header);
-        header = HTTPMSGLOCK(h);
+        header = h;
+        HTTPMSGLOCK(header);
         body_pipe = header->body_pipe;
     }
 
 public:
     // virgin or adapted message being worked on
     Header *header;   // parsed HTTP status/request line and headers
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Launcher.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Launcher.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Launcher.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Launcher.cc	2015-05-01 18:05:19.000000000 +0800
@@ -127,40 +127,53 @@
         return false;
 
     debugs(93,9, HERE << info.icapReply);
     if (!info.icapReply) // did not get to read an ICAP reply; a timeout?
         return true;
 
-    debugs(93,9, HERE << info.icapReply->sline.status);
-    if (!info.icapReply->sline.status) // failed to parse the reply; I/O err
+    debugs(93,9, info.icapReply->sline.status());
+    // XXX: Http::scNone is not the only sign of parse error
+    // XXX: if there is a specific HTTP error code describing the problem, that may be set
+    if (info.icapReply->sline.status() == Http::scNone) // failed to parse the reply; I/O err
         return true;
 
     ACLFilledChecklist *cl =
         new ACLFilledChecklist(TheConfig.repeat, info.icapRequest, dash_str);
-    cl->reply = HTTPMSGLOCK(info.icapReply);
+    cl->reply = info.icapReply;
+    HTTPMSGLOCK(cl->reply);
 
     bool result = cl->fastCheck() == ACCESS_ALLOWED;
     delete cl;
     return result;
 }
 
 /* ICAPXactAbortInfo */
 
 Adaptation::Icap::XactAbortInfo::XactAbortInfo(HttpRequest *anIcapRequest,
         HttpReply *anIcapReply, bool beRetriable, bool beRepeatable):
-        icapRequest(anIcapRequest ? HTTPMSGLOCK(anIcapRequest) : NULL),
-        icapReply(anIcapReply ? HTTPMSGLOCK(anIcapReply) : NULL),
-        isRetriable(beRetriable), isRepeatable(beRepeatable)
+        icapRequest(anIcapRequest),
+        icapReply(anIcapReply),
+        isRetriable(beRetriable),
+        isRepeatable(beRepeatable)
 {
+    if (icapRequest)
+        HTTPMSGLOCK(icapRequest);
+    if (icapReply)
+        HTTPMSGLOCK(icapReply);
 }
 
 Adaptation::Icap::XactAbortInfo::XactAbortInfo(const Adaptation::Icap::XactAbortInfo &i):
-        icapRequest(i.icapRequest ? HTTPMSGLOCK(i.icapRequest) : NULL),
-        icapReply(i.icapReply ? HTTPMSGLOCK(i.icapReply) : NULL),
-        isRetriable(i.isRetriable), isRepeatable(i.isRepeatable)
+        icapRequest(i.icapRequest),
+        icapReply(i.icapReply),
+        isRetriable(i.isRetriable),
+        isRepeatable(i.isRepeatable)
 {
+    if (icapRequest)
+        HTTPMSGLOCK(icapRequest);
+    if (icapReply)
+        HTTPMSGLOCK(icapReply);
 }
 
 Adaptation::Icap::XactAbortInfo::~XactAbortInfo()
 {
     HTTPMSGUNLOCK(icapRequest);
     HTTPMSGUNLOCK(icapReply);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Makefile.in	2015-05-01 16:51:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Makefile.in	2015-05-01 18:06:49.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -453,12 +499,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -496,12 +543,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -528,27 +576,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -615,13 +666,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libicap.la
 libicap_la_SOURCES = \
 	Client.cc \
 	Client.h \
 	InOut.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/ModXact.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/ModXact.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/ModXact.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/ModXact.cc	2015-05-01 18:05:19.000000000 +0800
@@ -768,47 +768,47 @@
 }
 
 void Adaptation::Icap::ModXact::parseIcapHead()
 {
     Must(state.sending == State::sendingUndecided);
 
-    if (!parseHead(icapReply))
+    if (!parseHead(icapReply.getRaw()))
         return;
 
     if (httpHeaderHasConnDir(&icapReply->header, "close")) {
         debugs(93, 5, HERE << "found connection close");
         reuseConnection = false;
     }
 
-    switch (icapReply->sline.status) {
+    switch (icapReply->sline.status()) {
 
-    case 100:
+    case Http::scContinue:
         handle100Continue();
         break;
 
-    case 200:
-    case 201: // Symantec Scan Engine 5.0 and later when modifying HTTP msg
+    case Http::scOkay:
+    case Http::scCreated: // Symantec Scan Engine 5.0 and later when modifying HTTP msg
 
         if (!validate200Ok()) {
             throw TexcHere("Invalid ICAP Response");
         } else {
             handle200Ok();
         }
 
         break;
 
-    case 204:
+    case Http::scNoContent:
         handle204NoContent();
         break;
 
-    case 206:
+    case Http::scPartialContent:
         handle206PartialContent();
         break;
 
     default:
-        debugs(93, 5, HERE << "ICAP status " << icapReply->sline.status);
+        debugs(93, 5, "ICAP status " << icapReply->sline.status());
         handleUnknownScode();
         break;
     }
 
     const HttpRequest *request = dynamic_cast<HttpRequest*>(adapted.header);
     if (!request)
@@ -943,26 +943,25 @@
 
     // allocate the adapted message and copy metainfo
     Must(!adapted.header);
     {
         HttpMsg::Pointer newHead;
         if (dynamic_cast<const HttpRequest*>(oldHead)) {
-            HttpRequest::Pointer newR(new HttpRequest);
-            newHead = newR;
+            newHead = new HttpRequest;
         } else if (dynamic_cast<const HttpReply*>(oldHead)) {
             newHead = new HttpReply;
         }
         Must(newHead != NULL);
 
         newHead->inheritProperties(oldHead);
 
-        adapted.setHeader(newHead);
+        adapted.setHeader(newHead.getRaw());
     }
 
     // parse the buffer back
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
 
     Must(adapted.header->parse(&httpBuf, true, &error));
 
     if (HttpRequest *r = dynamic_cast<HttpRequest*>(adapted.header))
         urlCanonical(r); // parse does not set HttpRequest::canonical
 
@@ -1069,13 +1068,13 @@
 bool Adaptation::Icap::ModXact::parseHead(HttpMsg *head)
 {
     Must(head);
     debugs(93, 5, HERE << "have " << readBuf.contentSize() << " head bytes to parse" <<
            "; state: " << state.parsing);
 
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
     const bool parsed = head->parse(&readBuf, commEof, &error);
     Must(parsed || !error); // success or need more data
 
     if (!parsed) { // need more data
         debugs(93, 5, HERE << "parse failed, need more data, return false");
         head->reset();
@@ -1268,18 +1267,21 @@
     al.url = h->log_uri.termedBuf();
     const Adaptation::Icap::ServiceRep  &s = service();
     al.icap.reqMethod = s.cfg().method;
 
     al.cache.caddr = request_->client_addr;
 
-    al.request = HTTPMSGLOCK(request_);
-    al.adapted_request = HTTPMSGLOCK(adapted_request_);
+    al.request = request_;
+    HTTPMSGLOCK(al.request);
+    al.adapted_request = adapted_request_;
+    HTTPMSGLOCK(al.adapted_request);
 
-    if (reply_)
-        al.reply = HTTPMSGLOCK(reply_);
-    else
+    if (reply_) {
+        al.reply = reply_;
+        HTTPMSGLOCK(al.reply);
+    } else
         al.reply = NULL;
 
     if (h->rfc931.size())
         al.cache.rfc931 = h->rfc931.termedBuf();
 
 #if USE_SSL
@@ -1294,13 +1296,13 @@
         const int64_t zero = 0; // to make max() argument types the same
         al.icap.bodyBytesRead =
             max(zero, replyHttpHeaderSize) + max(zero, replyHttpBodySize);
     }
 
     if (reply_) {
-        al.http.code = reply_->sline.status;
+        al.http.code = reply_->sline.status();
         al.http.content_type = reply_->content_type.termedBuf();
         if (replyHttpBodySize >= 0) {
             al.cache.replySize = replyHttpBodySize + reply_->hdr_sz;
             al.cache.highOffset = replyHttpBodySize;
         }
         //don't set al.cache.objectSize because it hasn't exist yet
@@ -1413,30 +1415,38 @@
 #if FOLLOW_X_FORWARDED_FOR
         if (TheConfig.use_indirect_client) {
             client_addr = request->indirect_client_addr;
         } else
 #endif
             client_addr = request->client_addr;
-        if (!client_addr.IsAnyAddr() && !client_addr.IsNoAddr())
-            buf.Printf("X-Client-IP: %s\r\n", client_addr.NtoA(ntoabuf,MAX_IPSTRLEN));
+        if (!client_addr.isAnyAddr() && !client_addr.isNoAddr())
+            buf.Printf("X-Client-IP: %s\r\n", client_addr.toStr(ntoabuf,MAX_IPSTRLEN));
     }
 
     if (TheConfig.send_username && request)
         makeUsernameHeader(request, buf);
 
     // Adaptation::Config::metaHeaders
-    typedef Adaptation::Config::MetaHeaders::iterator ACAMLI;
+    typedef Notes::iterator ACAMLI;
     for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
         HttpRequest *r = virgin.cause ?
                          virgin.cause : dynamic_cast<HttpRequest*>(virgin.header);
         Must(r);
 
         HttpReply *reply = dynamic_cast<HttpReply*>(virgin.header);
 
-        if (const char *value = (*i)->match(r, reply))
-            buf.Printf("%s: %s\r\n", (*i)->name.termedBuf(), value);
+        if (const char *value = (*i)->match(r, reply)) {
+            buf.Printf("%s: %s\r\n", (*i)->key.termedBuf(), value);
+            Adaptation::History::Pointer ah = request->adaptHistory(false);
+            if (ah != NULL) {
+                if (ah->metaHeaders == NULL)
+                    ah->metaHeaders = new NotePairs;
+                if (!ah->metaHeaders->hasPair((*i)->key.termedBuf(), value))
+                    ah->metaHeaders->add((*i)->key.termedBuf(), value);
+            }
+        }
     }
 
     // fprintf(stderr, "%s\n", buf.content());
 
     buf.append(ICAP::crlf, 2); // terminate ICAP header
 
@@ -1511,19 +1521,19 @@
     // begin cloning
     HttpMsg::Pointer headClone;
 
     if (const HttpRequest* old_request = dynamic_cast<const HttpRequest*>(head)) {
         HttpRequest::Pointer new_request(new HttpRequest);
         Must(old_request->canonical);
-        urlParse(old_request->method, old_request->canonical, new_request);
+        urlParse(old_request->method, old_request->canonical, new_request.getRaw());
         new_request->http_ver = old_request->http_ver;
-        headClone = new_request;
+        headClone = new_request.getRaw();
     } else if (const HttpReply *old_reply = dynamic_cast<const HttpReply*>(head)) {
         HttpReply::Pointer new_reply(new HttpReply);
         new_reply->sline = old_reply->sline;
-        headClone = new_reply;
+        headClone = new_reply.getRaw();
     }
     Must(headClone != NULL);
     headClone->inheritProperties(head);
 
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry* p_head_entry = NULL;
@@ -1534,13 +1544,13 @@
 
     // remove all hop-by-hop headers from the clone
     headClone->header.delById(HDR_PROXY_AUTHENTICATE);
     headClone->header.removeHopByHopEntries();
 
     // pack polished HTTP header
-    packHead(httpBuf, headClone);
+    packHead(httpBuf, headClone.getRaw());
 
     // headClone unlocks and, hence, deletes the message we packed
 }
 
 void Adaptation::Icap::ModXact::packHead(MemBuf &httpBuf, const HttpMsg *head)
 {
@@ -1747,18 +1757,18 @@
 
     if (virgin.cause)
         method = virgin.cause->method;
     else if (HttpRequest *req = dynamic_cast<HttpRequest*>(msg))
         method = req->method;
     else
-        method = METHOD_NONE;
+        method = Http::METHOD_NONE;
 
     int64_t size;
     // expectingBody returns true for zero-sized bodies, but we will not
     // get a pipe for that body, so we treat the message as bodyless
-    if (method != METHOD_NONE && msg->expectingBody(method, size) && size) {
+    if (method != Http::METHOD_NONE && msg->expectingBody(method, size) && size) {
         debugs(93, 6, HERE << "expects virgin body from " <<
                virgin.body_pipe << "; size: " << size);
 
         virginBody.expect(size);
         virginBodyWriting.plan();
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Options.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Options.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Options.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Options.cc	2015-05-01 18:05:19.000000000 +0800
@@ -72,13 +72,13 @@
 void Adaptation::Icap::Options::configure(const HttpReply *reply)
 {
     error = NULL; // reset initial "unconfigured" value (or an old error?)
 
     const HttpHeader *h = &reply->header;
 
-    if (reply->sline.status != 200)
+    if (reply->sline.status() != Http::scOkay)
         error = "unsupported status code of OPTIONS response";
 
     // Methods
     if (h->hasByNameListMember("Methods", "REQMOD", ','))
         cfgMethod(ICAP::methodReqmod);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/OptXact.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/OptXact.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/OptXact.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/OptXact.cc	2015-05-01 18:05:19.000000000 +0800
@@ -57,13 +57,13 @@
 
     if (TheConfig.allow206_enable)
         buf.Printf("Allow: 206\r\n");
     buf.append(ICAP::crlf, 2);
 
     // XXX: HttpRequest cannot fully parse ICAP Request-Line
-    http_status reqStatus;
+    Http::StatusCode reqStatus;
     Must(icapRequest->parse(&buf, true, &reqStatus) > 0);
 }
 
 void Adaptation::Icap::OptXact::handleCommWrote(size_t size)
 {
     debugs(93, 9, HERE << "finished writing " << size <<
@@ -80,13 +80,13 @@
         // we leave readAll false which forces connection closure.
         readAll = !icapReply->header.getByNameListMember("Encapsulated",
                   "opt-body", ',').size();
         debugs(93, 7, HERE << "readAll=" << readAll);
         icap_tio_finish = current_time;
         setOutcome(xoOpt);
-        sendAnswer(Answer::Forward(icapReply));
+        sendAnswer(Answer::Forward(icapReply.getRaw()));
         Must(done()); // there should be nothing else to do
         return;
     }
 
     scheduleRead();
 }
@@ -97,13 +97,13 @@
            status());
     debugs(93, 5, HERE << "\n" << readBuf.content());
 
     HttpReply::Pointer r(new HttpReply);
     r->protoPrefix = "ICAP/"; // TODO: make an IcapReply class?
 
-    if (!parseHttpMsg(r)) // throws on errors
+    if (!parseHttpMsg(r.getRaw())) // throws on errors
         return false;
 
     if (httpHeaderHasConnDir(&r->header, "close"))
         reuseConnection = false;
 
     icapReply = r;
@@ -117,13 +117,13 @@
 
 void Adaptation::Icap::OptXact::finalizeLogInfo()
 {
     //    al.cache.caddr = 0;
     al.icap.reqMethod = Adaptation::methodOptions;
 
-    if (icapReply && al.icap.bytesRead > icapReply->hdr_sz)
+    if (icapReply != NULL && al.icap.bytesRead > icapReply->hdr_sz)
         al.icap.bodyBytesRead = al.icap.bytesRead - icapReply->hdr_sz;
 
     Adaptation::Icap::Xaction::finalizeLogInfo();
 }
 
 /* Adaptation::Icap::OptXactLauncher */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/ServiceRep.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/ServiceRep.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/ServiceRep.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/ServiceRep.cc	2015-05-01 18:05:19.000000000 +0800
@@ -527,19 +527,19 @@
         debugs(93,3, HERE << "failed to fetch options " << status());
         handleNewOptions(0);
         return;
     }
 
     Must(answer.kind == Answer::akForward); // no akBlock for OPTIONS requests
-    HttpMsg *msg = answer.message;
+    const HttpMsg *msg = answer.message.getRaw();
     Must(msg);
 
     debugs(93,5, HERE << "is interpreting new options " << status());
 
     Adaptation::Icap::Options *newOptions = NULL;
-    if (HttpReply *r = dynamic_cast<HttpReply*>(msg)) {
+    if (const HttpReply *r = dynamic_cast<const HttpReply*>(msg)) {
         newOptions = new Adaptation::Icap::Options;
         newOptions->configure(r);
     } else {
         debugs(93, DBG_IMPORTANT, "ICAP service got wrong options message " << status());
     }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Xaction.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Xaction.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/icap/Xaction.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/icap/Xaction.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,25 +1,23 @@
 /*
  * DEBUG: section 93    ICAP (RFC 3507) Client
  */
 
 #include "squid.h"
-#include "acl/FilledChecklist.h"
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/Launcher.h"
 #include "adaptation/icap/Xaction.h"
 #include "base/TextException.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "comm/Write.h"
 #include "CommCalls.h"
 #include "err_detail_type.h"
 #include "fde.h"
-#include "forward.h"
-#include "globals.h"
+#include "FwdState.h"
 #include "HttpMsg.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "icap_log.h"
 #include "ipcache.h"
 #include "Mem.h"
@@ -47,13 +45,14 @@
         alep(new AccessLogEntry),
         al(*alep),
         cs(NULL)
 {
     debugs(93,3, typeName << " constructed, this=" << this <<
            " [icapx" << id << ']'); // we should not call virtual status() here
-    icapRequest = HTTPMSGLOCK(new HttpRequest);
+    icapRequest = new HttpRequest;
+    HTTPMSGLOCK(icapRequest);
     icap_tr_start = current_time;
 }
 
 Adaptation::Icap::Xaction::~Xaction()
 {
     debugs(93,3, typeName << " destructed, this=" << this <<
@@ -162,13 +161,13 @@
     }
 
     assert(ia->cur < ia->count);
 
     connection = new Comm::Connection;
     connection->remote = ia->in_addrs[ia->cur];
-    connection->remote.SetPort(s.cfg().port);
+    connection->remote.port(s.cfg().port);
     getOutgoingAddress(NULL, connection);
 
     // TODO: service bypass status may differ from that of a transaction
     typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommConnectCbParams> ConnectDialer;
     connector = JobCallback(93,3, ConnectDialer, this, Adaptation::Icap::Xaction::noteCommConnected);
     cs = new Comm::ConnOpener(connection, connector, TheConfig.connect_timeout(service().cfg().bypass));
@@ -435,13 +434,13 @@
 }
 
 bool Adaptation::Icap::Xaction::parseHttpMsg(HttpMsg *msg)
 {
     debugs(93, 5, HERE << "have " << readBuf.contentSize() << " head bytes to parse");
 
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
     const bool parsed = msg->parse(&readBuf, commEof, &error);
     Must(parsed || !error); // success or need more data
 
     if (!parsed) {	// need more data
         Must(mayReadMore());
         msg->reset();
@@ -533,35 +532,27 @@
     Adaptation::Initiate::swanSong();
 }
 
 void Adaptation::Icap::Xaction::tellQueryAborted()
 {
     if (theInitiator.set()) {
-        Adaptation::Icap::XactAbortInfo abortInfo(icapRequest, icapReply,
+        Adaptation::Icap::XactAbortInfo abortInfo(icapRequest, icapReply.getRaw(),
                 retriable(), repeatable());
         Launcher *launcher = dynamic_cast<Launcher*>(theInitiator.get());
         // launcher may be nil if initiator is invalid
         CallJobHere1(91,5, CbcPointer<Launcher>(launcher),
                      Launcher, noteXactAbort, abortInfo);
         clearInitiator();
     }
 }
 
 void Adaptation::Icap::Xaction::maybeLog()
 {
     if (IcapLogfileStatus == LOG_ENABLE) {
-        ACLFilledChecklist *checklist = new ACLFilledChecklist(::Config.accessList.icap, al.request, dash_str);
-        if (al.reply) {
-            checklist->reply = al.reply;
-            HTTPMSGLOCK(checklist->reply);
-        }
-        if (!::Config.accessList.icap || checklist->fastCheck() == ACCESS_ALLOWED) {
-            finalizeLogInfo();
-            icapLogLog(alep, checklist);
-        }
-        delete checklist;
+        finalizeLogInfo();
+        icapLogLog(alep);
     }
 }
 
 void Adaptation::Icap::Xaction::finalizeLogInfo()
 {
     //prepare log data
@@ -572,16 +563,18 @@
     al.icap.serviceName = s.cfg().key;
     al.icap.reqUri = s.cfg().uri;
 
     al.icap.ioTime = tvSubMsec(icap_tio_start, icap_tio_finish);
     al.icap.trTime = tvSubMsec(icap_tr_start, current_time);
 
-    al.icap.request = HTTPMSGLOCK(icapRequest);
-    if (icapReply) {
-        al.icap.reply = HTTPMSGLOCK(icapReply);
-        al.icap.resStatus = icapReply->sline.status;
+    al.icap.request = icapRequest;
+    HTTPMSGLOCK(al.icap.request);
+    if (icapReply != NULL) {
+        al.icap.reply = icapReply.getRaw();
+        HTTPMSGLOCK(al.icap.reply);
+        al.icap.resStatus = icapReply->sline.status();
     }
 }
 
 // returns a temporary string depicting transaction status, for debugging
 const char *Adaptation::Icap::Xaction::status() const
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Iterator.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Iterator.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Iterator.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Iterator.cc	2015-05-01 18:05:19.000000000 +0800
@@ -17,18 +17,23 @@
 Adaptation::Iterator::Iterator(
     HttpMsg *aMsg, HttpRequest *aCause,
     const ServiceGroupPointer &aGroup):
         AsyncJob("Iterator"),
         Adaptation::Initiate("Iterator"),
         theGroup(aGroup),
-        theMsg(HTTPMSGLOCK(aMsg)),
-        theCause(aCause ? HTTPMSGLOCK(aCause) : NULL),
+        theMsg(aMsg),
+        theCause(aCause),
         theLauncher(0),
         iterations(0),
         adapted(false)
 {
+    if (theCause != NULL)
+        HTTPMSGLOCK(theCause);
+
+    if (theMsg != NULL)
+        HTTPMSGLOCK(theMsg);
 }
 
 Adaptation::Iterator::~Iterator()
 {
     assert(!theLauncher);
     HTTPMSGUNLOCK(theMsg);
@@ -82,13 +87,13 @@
 
 void
 Adaptation::Iterator::noteAdaptationAnswer(const Answer &answer)
 {
     switch (answer.kind) {
     case Answer::akForward:
-        handleAdaptedHeader(answer.message);
+        handleAdaptedHeader(const_cast<HttpMsg*>(answer.message.getRaw()));
         break;
 
     case Answer::akBlock:
         handleAdaptationBlock(answer);
         break;
 
@@ -112,13 +117,14 @@
             }
         }
     }
 
     Must(aMsg);
     HTTPMSGUNLOCK(theMsg);
-    theMsg = HTTPMSGLOCK(aMsg);
+    theMsg = aMsg;
+    HTTPMSGLOCK(theMsg);
     adapted = true;
 
     clearAdaptation(theLauncher);
     if (!updatePlan(true)) // do not immediatelly advance the new plan
         thePlan.next(filter());
     step();
@@ -212,24 +218,24 @@
         debugs(85,3, HERE << "rejecting service-proposed plan");
         return false;
     }
 
     debugs(85,3, HERE << "retiring old plan: " << thePlan);
 
-    Adaptation::ServiceFilter filter = this->filter();
+    Adaptation::ServiceFilter f = this->filter();
     DynamicGroupCfg current, future;
-    DynamicServiceChain::Split(filter, services, current, future);
+    DynamicServiceChain::Split(f, services, current, future);
 
     if (!future.empty()) {
         ah->setFutureServices(future);
         debugs(85,3, HERE << "noted future service-proposed plan: " << future);
     }
 
     // use the current config even if it is empty; we must replace the old plan
-    theGroup = new DynamicServiceChain(current, filter); // refcounted
-    thePlan = ServicePlan(theGroup, filter);
+    theGroup = new DynamicServiceChain(current, f); // refcounted
+    thePlan = ServicePlan(theGroup, f);
     debugs(85,3, HERE << "adopted service-proposed plan: " << thePlan);
     return true;
 }
 
 Adaptation::ServiceFilter Adaptation::Iterator::filter() const
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Makefile.in	2015-05-01 16:51:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Makefile.in	2015-05-01 18:06:47.000000000 +0800
@@ -92,14 +92,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -497,12 +543,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -540,12 +587,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -572,27 +620,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -659,13 +710,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 SUBDIRS = $(am__append_2) $(am__append_3)
 noinst_LTLIBRARIES = libadaptation.la
 libadaptation_la_SOURCES = \
 	AccessCheck.cc \
 	AccessCheck.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Message.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Message.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Message.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Message.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,13 +30,14 @@
 
 void
 Adaptation::Message::set(Header *aHeader)
 {
     clear();
     if (aHeader) {
-        header = HTTPMSGLOCK(aHeader);
+        header = aHeader;
+        HTTPMSGLOCK(header);
         body_pipe = header->body_pipe;
     }
 }
 
 void
 Adaptation::Message::ShortCircuit(Message &src, Message &dest)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Message.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Message.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Message.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Message.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,10 @@
 #ifndef SQUID__ADAPTATION__MESSAGE_H
 #define SQUID__ADAPTATION__MESSAGE_H
 
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 class HttpMsg;
 class BodyPipe;
 typedef RefCount<BodyPipe> BodyPipePointer;
 
 namespace Adaptation
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Service.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Service.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Service.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Service.cc	2015-05-01 18:05:19.000000000 +0800
@@ -51,14 +51,14 @@
     return true;
 }
 
 Adaptation::Services &
 Adaptation::AllServices()
 {
-    static Services TheServices;
-    return TheServices;
+    static Services *TheServices = new Services;
+    return *TheServices;
 }
 
 Adaptation::ServicePointer
 Adaptation::FindService(const Service::Id& key)
 {
     typedef Services::iterator SI;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceConfig.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceConfig.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceConfig.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceConfig.cc	2015-05-01 18:05:19.000000000 +0800
@@ -46,16 +46,16 @@
     const char *t = service_configConfig;
     const char *q = strchr(t, '_');
 
     if (q)
         t = q + 1;
 
-    if (!strcasecmp(t, "precache"))
+    if (!strcmp(t, "precache"))
         return Adaptation::pointPreCache;
 
-    if (!strcasecmp(t, "postcache"))
+    if (!strcmp(t, "postcache"))
         return Adaptation::pointPostCache;
 
     return Adaptation::pointNone;
 }
 
 bool
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceConfig.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceConfig.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceConfig.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceConfig.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,11 @@
 #ifndef SQUID_ADAPTATION__SERVICE_CONFIG_H
 #define SQUID_ADAPTATION__SERVICE_CONFIG_H
 
 #include "SquidString.h"
-#include "RefCount.h"
+#include "base/RefCount.h"
 #include "adaptation/Elements.h"
 
 namespace Adaptation
 {
 
 // manages adaptation service configuration in squid.conf
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceFilter.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceFilter.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceFilter.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceFilter.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,25 +1,36 @@
 #include "squid.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "adaptation/ServiceFilter.h"
 
-Adaptation::ServiceFilter::ServiceFilter(Method aMethod, VectPoint aPoint,
-        HttpRequest *aReq, HttpReply *aRep): method(aMethod), point(aPoint),
-        request(HTTPMSGLOCK(aReq)),
-        reply(aRep ? HTTPMSGLOCK(aRep) : NULL)
+Adaptation::ServiceFilter::ServiceFilter(Method aMethod, VectPoint aPoint, HttpRequest *aReq, HttpReply *aRep):
+        method(aMethod),
+        point(aPoint),
+        request(aReq),
+        reply(aRep)
 {
+    if (reply)
+        HTTPMSGLOCK(reply);
+
     // a lot of code assumes that there is always a virgin request or cause
     assert(request);
+    HTTPMSGLOCK(request);
 }
 
 Adaptation::ServiceFilter::ServiceFilter(const ServiceFilter &f):
-        method(f.method), point(f.point),
-        request(HTTPMSGLOCK(f.request)),
-        reply(f.reply ? HTTPMSGLOCK(f.reply) : NULL)
+        method(f.method),
+        point(f.point),
+        request(f.request),
+        reply(f.reply)
 {
+    if (request)
+        HTTPMSGLOCK(request);
+
+    if (reply)
+        HTTPMSGLOCK(reply);
 }
 
 Adaptation::ServiceFilter::~ServiceFilter()
 {
     HTTPMSGUNLOCK(request);
     HTTPMSGUNLOCK(reply);
@@ -29,11 +40,14 @@
 {
     if (this != &f) {
         method = f.method;
         point = f.point;
         HTTPMSGUNLOCK(request);
         HTTPMSGUNLOCK(reply);
-        request = HTTPMSGLOCK(f.request);
-        reply = f.reply ? HTTPMSGLOCK(f.reply) : NULL;
+        request = f.request;
+        HTTPMSGLOCK(request);
+        reply = f.reply;
+        if (reply)
+            HTTPMSGLOCK(reply);
     }
     return *this;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceGroups.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceGroups.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceGroups.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceGroups.cc	2015-05-01 18:05:19.000000000 +0800
@@ -312,14 +312,14 @@
 
 /* globals */
 
 Adaptation::Groups &
 Adaptation::AllGroups()
 {
-    static Groups TheGroups;
-    return TheGroups;
+    static Groups *TheGroups = new Groups;
+    return *TheGroups;
 }
 
 Adaptation::ServiceGroupPointer
 Adaptation::FindGroup(const ServiceGroup::Id &id)
 {
     typedef Groups::iterator GI;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceGroups.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceGroups.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/ServiceGroups.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/ServiceGroups.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,14 +1,14 @@
 #ifndef SQUID_ADAPTATION__SERVICE_GROUPS_H
 #define SQUID_ADAPTATION__SERVICE_GROUPS_H
 
 #include "SquidString.h"
-#include "Array.h"
-#include "RefCount.h"
+#include "base/Vector.h"
 #include "adaptation/Elements.h"
 #include "adaptation/forward.h"
+#include "base/RefCount.h"
 
 namespace Adaptation
 {
 
 // Interface for grouping adaptation services together.
 // Specific groups differ in how the first and the next services are selected
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Service.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Service.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/adaptation/Service.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/adaptation/Service.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,14 +1,14 @@
 #ifndef SQUID_ADAPTATION__SERVICE_H
 #define SQUID_ADAPTATION__SERVICE_H
 
 #include "SquidString.h"
-#include "RefCount.h"
 #include "adaptation/forward.h"
 #include "adaptation/Elements.h"
 #include "adaptation/ServiceConfig.h"
+#include "base/RefCount.h"
 
 // TODO: Move src/ICAP/ICAPServiceRep.h API comments here and update them
 
 class HttpMsg;
 class HttpRequest;
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp: forward.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -1,16 +1,18 @@
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
 noinst_LTLIBRARIES = libanyp.la
 
 libanyp_la_SOURCES = \
+	forward.h \
 	PortCfg.cc \
 	PortCfg.h \
 	ProtocolType.cc \
 	ProtocolType.h \
-	ProtocolVersion.h
+	ProtocolVersion.h \
+	TrafficMode.h
 
 ProtocolType.cc: ProtocolType.h $(top_srcdir)/src/mk-string-arrays.awk
 	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk <$(srcdir)/ProtocolType.h | sed -e 's%PROTO_%%' >$@) || ($(RM) -f $@ && exit 1)
 
 CLEANFILES += ProtocolType.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/Makefile.in	2015-05-01 16:51:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/Makefile.in	2015-05-01 18:06:49.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -451,12 +497,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -494,12 +541,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -526,27 +574,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -613,21 +664,23 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libanyp.la
 libanyp_la_SOURCES = \
+	forward.h \
 	PortCfg.cc \
 	PortCfg.h \
 	ProtocolType.cc \
 	ProtocolType.h \
-	ProtocolVersion.h
+	ProtocolVersion.h \
+	TrafficMode.h
 
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(top_srcdir)/src/TestHeaders.am $(am__configure_deps)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/PortCfg.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/PortCfg.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/PortCfg.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/PortCfg.cc	2015-05-01 18:05:19.000000000 +0800
@@ -10,20 +10,21 @@
 
 CBDATA_NAMESPACED_CLASS_INIT(AnyP, PortCfg);
 
 int NHttpSockets = 0;
 int HttpSockets[MAXTCPLISTENPORTS];
 
-AnyP::PortCfg::PortCfg(const char *aProtocol)
+AnyP::PortCfg::PortCfg(const char *aProtocol) :
+        next(NULL),
+        protocol(xstrdup(aProtocol)),
+        name(NULL),
+        defaultsite(NULL)
 #if USE_SSL
-        :
-        dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
+        ,dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
 #endif
-{
-    protocol = xstrdup(aProtocol);
-}
+{}
 
 AnyP::PortCfg::~PortCfg()
 {
     if (Comm::IsConnOpen(listenConn)) {
         listenConn->close();
         listenConn = NULL;
@@ -54,68 +55,77 @@
     b->s = s;
     if (name)
         b->name = xstrdup(name);
     if (defaultsite)
         b->defaultsite = xstrdup(defaultsite);
 
-    b->intercepted = intercepted;
-    b->spoof_client_ip = spoof_client_ip;
-    b->accel = accel;
+    b->flags = flags;
     b->allow_direct = allow_direct;
     b->vhost = vhost;
-    b->sslBump = sslBump;
     b->vport = vport;
     b->connection_auth_disabled = connection_auth_disabled;
     b->disable_pmtu_discovery = disable_pmtu_discovery;
+    b->tcp_keepalive = tcp_keepalive;
 
-    memcpy( &(b->tcp_keepalive), &(tcp_keepalive), sizeof(tcp_keepalive));
+#if USE_SSL
+    if (cert)
+        b->cert = xstrdup(cert);
+    if (key)
+        b->key = xstrdup(key);
+    b->version = version;
+    if (cipher)
+        b->cipher = xstrdup(cipher);
+    if (options)
+        b->options = xstrdup(options);
+    if (clientca)
+        b->clientca = xstrdup(clientca);
+    if (cafile)
+        b->cafile = xstrdup(cafile);
+    if (capath)
+        b->capath = xstrdup(capath);
+    if (crlfile)
+        b->crlfile = xstrdup(crlfile);
+    if (dhfile)
+        b->dhfile = xstrdup(dhfile);
+    if (sslflags)
+        b->sslflags = xstrdup(sslflags);
+    if (sslContextSessionId)
+        b->sslContextSessionId = xstrdup(sslContextSessionId);
 
 #if 0
-    // AYJ: 2009-07-18: for now SSL does not clone. Configure separate ports with IPs and SSL settings
-
-#if USE_SSL
-    char *cert;
-    char *key;
-    int version;
-    char *cipher;
-    char *options;
-    char *clientca;
-    char *cafile;
-    char *capath;
-    char *crlfile;
-    char *dhfile;
-    char *sslflags;
-    char *sslContextSessionId;
+    // TODO: AYJ: 2015-01-15: for now SSL does not clone the context object.
+    // cloning should only be done before the PortCfg is post-configure initialized and opened
     SSL_CTX *sslContext;
 #endif
 
 #endif /*0*/
 
     return b;
 }
 
 #if USE_SSL
-void AnyP::PortCfg::configureSslServerContext()
+void
+AnyP::PortCfg::configureSslServerContext()
 {
     if (cert)
         Ssl::readCertChainAndPrivateKeyFromFiles(signingCert, signPkey, certsToChain, cert, key);
 
     if (!signingCert) {
         char buf[128];
-        fatalf("No valid signing SSL certificate configured for %s_port %s", protocol,  s.ToURL(buf, sizeof(buf)));
+        fatalf("No valid signing SSL certificate configured for %s_port %s", protocol,  s.toUrl(buf, sizeof(buf)));
     }
 
     if (!signPkey)
         debugs(3, DBG_IMPORTANT, "No SSL private key configured for  " <<  protocol << "_port " << s);
 
     Ssl::generateUntrustedCert(untrustedSigningCert, untrustedSignPkey,
                                signingCert, signPkey);
 
     if (!untrustedSigningCert) {
         char buf[128];
-        fatalf("Unable to generate  signing SSL certificate for untrusted sites for %s_port %s", protocol, s.ToURL(buf, sizeof(buf)));
+        fatalf("Unable to generate  signing SSL certificate for untrusted sites for %s_port %s", protocol, s.toUrl(buf, sizeof(buf)));
     }
 
     if (crlfile)
         clientVerifyCrls.reset(Ssl::loadCrl(crlfile, sslContextFlags));
 
     if (clientca) {
@@ -138,11 +148,11 @@
     sslOptions = Ssl::parse_options(options);
 
     staticSslContext.reset(sslCreateServerContext(*this));
 
     if (!staticSslContext) {
         char buf[128];
-        fatalf("%s_port %s initialization error", protocol,  s.ToURL(buf, sizeof(buf)));
+        fatalf("%s_port %s initialization error", protocol,  s.toUrl(buf, sizeof(buf)));
     }
 }
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/PortCfg.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/PortCfg.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/PortCfg.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/PortCfg.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,11 @@
 #ifndef SQUID_ANYP_PORTCFG_H
 #define SQUID_ANYP_PORTCFG_H
 
-#include "cbdata.h"
+#include "anyp/forward.h"
+#include "anyp/TrafficMode.h"
 #include "comm/Connection.h"
 
 #if USE_SSL
 #include "ssl/gadgets.h"
 #endif
 
@@ -26,30 +27,29 @@
 
     Ip::Address s;
     char *protocol;            /* protocol name */
     char *name;                /* visible name */
     char *defaultsite;         /* default web site */
 
-    unsigned int intercepted:1;        /**< intercepting proxy port */
-    unsigned int spoof_client_ip:1;    /**< spoof client ip if possible */
-    unsigned int accel:1;              /**< HTTP accelerator */
-    unsigned int allow_direct:1;       /**< Allow direct forwarding in accelerator mode */
-    unsigned int vhost:1;              /**< uses host header */
-    unsigned int sslBump:1;            /**< intercepts CONNECT requests */
-    unsigned int actAsOrigin:1;        ///< update replies to conform with RFC 2616
-    unsigned int ignore_cc:1;          /**< Ignore request Cache-Control directives */
+    TrafficMode flags;  ///< flags indicating what type of traffic to expect via this port.
 
-    int vport;                 /* virtual port support, -1 for dynamic, >0 static*/
-    bool connection_auth_disabled;     /* Don't support connection oriented auth */
+    bool allow_direct;       ///< Allow direct forwarding in accelerator mode
+    bool vhost;              ///< uses host header
+    bool actAsOrigin;        ///< update replies to conform with RFC 2616
+    bool ignore_cc;          ///< Ignore request Cache-Control directives
+
+    bool connection_auth_disabled; ///< Don't support connection oriented auth
+
+    int vport;               ///< virtual port support. -1 if dynamic, >0 static
     int disable_pmtu_discovery;
 
     struct {
-        unsigned int enabled;
         unsigned int idle;
         unsigned int interval;
         unsigned int timeout;
+        bool enabled;
     } tcp_keepalive;
 
     /**
      * The listening socket details.
      * If Comm::ConnIsOpen() we are actively listening for client requests.
      * use listenConn->close() to stop.
@@ -89,14 +89,16 @@
 
     CBDATA_CLASS2(PortCfg); // namespaced
 };
 
 } // namespace AnyP
 
+#if !defined(MAXTCPLISTENPORTS)
 // Max number of TCP listening ports
 #define MAXTCPLISTENPORTS 128
+#endif
 
 // TODO: kill this global array. Need to check performance of array vs list though.
 extern int NHttpSockets;
 extern int HttpSockets[MAXTCPLISTENPORTS];
 
 #endif /* SQUID_ANYP_PORTCFG_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/ProtocolVersion.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/ProtocolVersion.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/anyp/ProtocolVersion.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp/ProtocolVersion.h	2015-05-01 18:05:19.000000000 +0800
@@ -7,12 +7,16 @@
 #include <ostream>
 #endif
 
 namespace AnyP
 {
 
+/**
+ * Stores a protocol version label.
+ * For example HTTP/1.1 or ICY/1.0 or FTP/2.0
+ */
 class ProtocolVersion
 {
 
 public:
     // BUG: major() and minor() are macros.
     //      we can't use a fast constructor syntax without renaming them globally
@@ -23,15 +27,15 @@
 
     ProtocolVersion(ProtocolType which, unsigned int aMajor, unsigned int aMinor) : protocol(which) {
         major = aMajor;
         minor = aMinor;
     }
 
-    ProtocolType protocol;
-    unsigned int major;
-    unsigned int minor;
+    ProtocolType protocol; ///< which protocol this version is for
+    unsigned int major;    ///< major version number
+    unsigned int minor;    ///< minor version number
 
     bool operator==(const ProtocolVersion& that) const {
         if (this->protocol != that.protocol)
             return false;
 
         if (this->major != that.major)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/anyp: TrafficMode.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/Acl.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/Acl.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/Acl.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/Acl.cc	2015-05-01 18:05:19.000000000 +0800
@@ -23,21 +23,21 @@
 
     if (NULL == request) {
         fatal ("requiresRequest SHOULD have been true for this ACL!!");
         return ACCESS_DENIED;
     } else if (request->flags.sslBumped) {
         debugs(28, 5, "SslBumped request: It is an encapsulated request do not authenticate");
-        checklist->auth_user_request = checklist->conn() != NULL ? checklist->conn()->auth_user_request : request->auth_user_request;
+        checklist->auth_user_request = checklist->conn() != NULL ? checklist->conn()->getAuth() : request->auth_user_request;
         if (checklist->auth_user_request != NULL)
             return ACCESS_ALLOWED;
         else
             return ACCESS_DENIED;
     } else if (request->flags.accelerated) {
         /* WWW authorization on accelerated requests */
         headertype = HDR_AUTHORIZATION;
-    } else if (request->flags.intercepted || request->flags.spoofClientIp) {
+    } else if (request->flags.intercepted || request->flags.interceptTproxy) {
         debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
         return ACCESS_DENIED;
     } else {
         /* Proxy authorization on proxy requests */
         headertype = HDR_PROXY_AUTHORIZATION;
     }
@@ -55,14 +55,16 @@
 
     case AUTH_AUTHENTICATED:
         return ACCESS_ALLOWED;
         break;
 
     case AUTH_ACL_HELPER:
-        debugs(28, 4, HERE << "returning " << ACCESS_DUNNO << " sending credentials to helper.");
-        checklist->changeState(ProxyAuthLookup::Instance());
+        if (checklist->goAsync(ProxyAuthLookup::Instance()))
+            debugs(28, 4, "returning " << ACCESS_DUNNO << " sending credentials to helper.");
+        else
+            debugs(28, 2, "cannot go async; returning " << ACCESS_DUNNO);
         return ACCESS_DUNNO; // XXX: break this down into DUNNO, EXPIRED_OK, EXPIRED_BAD states
 
     case AUTH_ACL_CHALLENGE:
         debugs(28, 4, HERE << "returning " << ACCESS_AUTH_REQUIRED << " sending authentication challenge.");
         /* Client is required to resend the request with correct authentication
          * credentials. (This may be part of a stateful auth protocol.)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/AclMaxUserIp.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/AclMaxUserIp.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/AclMaxUserIp.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/AclMaxUserIp.cc	2015-05-01 18:05:19.000000000 +0800
@@ -10,23 +10,28 @@
 #include "auth/UserRequest.h"
 #include "Debug.h"
 #include "wordlist.h"
 #include "ConfigParser.h"
 #include "Parsing.h"
 
+ACLFlag
+ACLMaxUserIP::SupportedFlags[] = {ACL_F_STRICT, ACL_F_END};
+
 ACL *
 ACLMaxUserIP::clone() const
 {
     return new ACLMaxUserIP(*this);
 }
 
-ACLMaxUserIP::ACLMaxUserIP (char const *theClass) : class_ (theClass), maximum(0)
+ACLMaxUserIP::ACLMaxUserIP (char const *theClass) : ACL(SupportedFlags), class_ (theClass), maximum(0)
 {}
 
-ACLMaxUserIP::ACLMaxUserIP (ACLMaxUserIP const & old) :class_ (old.class_), maximum (old.maximum), flags (old.flags)
-{}
+ACLMaxUserIP::ACLMaxUserIP (ACLMaxUserIP const & old) : class_ (old.class_), maximum (old.maximum)
+{
+    flags = old.flags;
+}
 
 ACLMaxUserIP::~ACLMaxUserIP()
 {}
 
 char const *
 ACLMaxUserIP::typeString() const
@@ -58,21 +63,12 @@
 
     if (!t)
         return;
 
     debugs(28, 5, "aclParseUserMaxIP: First token is " << t);
 
-    if (strcmp("-s", t) == 0) {
-        debugs(28, 5, "aclParseUserMaxIP: Going strict");
-        flags.strict = 1;
-        t = ConfigParser::strtokFile();
-    }
-
-    if (!t)
-        return;
-
     maximum = xatoi(t);
 
     debugs(28, 5, "aclParseUserMaxIP: Max IP address's " << maximum);
 
     return;
 }
@@ -94,13 +90,13 @@
     if (authenticateAuthUserRequestIPCount(auth_user_request) <= maximum)
         return 0;
 
     debugs(28, DBG_IMPORTANT, "aclMatchUserMaxIP: user '" << auth_user_request->username() << "' tries to use too many IP addresses (max " << maximum << " allowed)!");
 
     /* this is a match */
-    if (flags.strict) {
+    if (flags.isSet(ACL_F_STRICT)) {
         /*
          * simply deny access - the user name is already associated with
          * the request
          */
         /* remove _this_ ip, as it is the culprit for going over the limit */
         authenticateAuthUserRequestRemoveIp(auth_user_request, src_addr);
@@ -136,14 +132,14 @@
         return 0; // non-match
 
     case ACCESS_DUNNO:
     case ACCESS_AUTH_REQUIRED:
     default:
         // If the answer is not allowed or denied (matches/not matches) and
-        // async authentication is not needed (asyncNeeded), then we are done.
-        if (!checklist->asyncNeeded())
+        // async authentication is not in progress, then we are done.
+        if (checklist->keepMatching())
             checklist->markFinished(answer, "AuthenticateAcl exception");
         return -1; // other
     }
 }
 
 wordlist *
@@ -151,15 +147,12 @@
 {
     if (!maximum)
         return NULL;
 
     wordlist *W = NULL;
 
-    if (flags.strict)
-        wordlistAdd(&W, "-s");
-
     char buf[128];
 
     snprintf(buf, sizeof(buf), "%lu", (unsigned long int) maximum);
 
     wordlistAdd(&W, buf);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/AclMaxUserIp.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/AclMaxUserIp.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/AclMaxUserIp.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/AclMaxUserIp.h	2015-05-01 18:05:19.000000000 +0800
@@ -59,27 +59,22 @@
     virtual bool empty () const;
     virtual bool valid () const;
     virtual bool requiresRequest() const {return true;}
 
     int getMaximum() const {return maximum;}
 
-    int getStrict() const {return flags.strict;}
+    bool getStrict() const {return flags.isSet(ACL_F_STRICT);}
 
 private:
     static Prototype RegistryProtoype;
     static ACLMaxUserIP RegistryEntry_;
+    static ACLFlag  SupportedFlags[];
 
     int match(Auth::UserRequest::Pointer, Ip::Address const &);
     char const *class_;
     int maximum;
-
-    struct Flags {
-        Flags() : strict(0) {}
-
-        unsigned int strict:1;
-    } flags;
 };
 
 MEMPROXY_CLASS_INLINE(ACLMaxUserIP);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_ACLMAXUSERIP_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/AclProxyAuth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/AclProxyAuth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/AclProxyAuth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/AclProxyAuth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -89,14 +89,14 @@
         return 0; // non-match
 
     case ACCESS_DUNNO:
     case ACCESS_AUTH_REQUIRED:
     default:
         // If the answer is not allowed or denied (matches/not matches) and
-        // async authentication is not needed (asyncNeeded), then we are done.
-        if (!checklist->asyncNeeded())
+        // async authentication is not in progress, then we are done.
+        if (checklist->keepMatching())
             checklist->markFinished(answer, "AuthenticateAcl exception");
         return -1; // other
     }
 }
 
 wordlist *
@@ -133,17 +133,16 @@
 ProxyAuthLookup::Instance()
 {
     return &instance_;
 }
 
 void
-ProxyAuthLookup::checkForAsync(ACLChecklist *cl)const
+ProxyAuthLookup::checkForAsync(ACLChecklist *cl) const
 {
     ACLFilledChecklist *checklist = Filled(cl);
 
-    checklist->asyncInProgress(true);
     debugs(28, 3, HERE << "checking password via authenticator");
 
     /* make sure someone created auth_user_request for us */
     assert(checklist->auth_user_request != NULL);
     assert(checklist->auth_user_request->valid());
     checklist->auth_user_request->start(LookupDone, checklist);
@@ -151,28 +150,24 @@
 
 void
 ProxyAuthLookup::LookupDone(void *data)
 {
     ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
 
-    assert (checklist->asyncState() == ProxyAuthLookup::Instance());
-
     if (checklist->auth_user_request == NULL || !checklist->auth_user_request->valid() || checklist->conn() == NULL) {
         /* credentials could not be checked either way
          * restart the whole process */
         /* OR the connection was closed, there's no way to continue */
         checklist->auth_user_request = NULL;
 
         if (checklist->conn() != NULL) {
-            checklist->conn()->auth_user_request = NULL;
+            checklist->conn()->setAuth(NULL, "proxy_auth ACL failure");
         }
     }
 
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(ProxyAuthLookup::Instance());
 }
 
 ACL *
 ACLProxyAuth::clone() const
 {
     return new ACLProxyAuth(*this);
@@ -191,12 +186,14 @@
  * 1 : Authorisation OK. (Matched)
  */
 int
 ACLProxyAuth::matchProxyAuth(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
+    if (checklist->request->flags.sslBumped)
+        return 1; // AuthenticateAcl() already handled this bumped request
     if (!authenticateUserAuthenticated(Filled(checklist)->auth_user_request)) {
         return 0;
     }
     /* check to see if we have matched the user-acl before */
     int result = cacheMatchAcl(&checklist->auth_user_request->user()->proxy_match_cache, checklist);
     checklist->auth_user_request = NULL;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/auth_basic.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/auth_basic.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/auth_basic.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/auth_basic.cc	2015-05-01 18:05:19.000000000 +0800
@@ -164,28 +164,28 @@
     safe_free(basicAuthRealm);
 }
 
 void
 Auth::Basic::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
 {
-    if (strcasecmp(param_str, "program") == 0) {
+    if (strcmp(param_str, "program") == 0) {
         if (authenticateProgram)
             wordlistDestroy(&authenticateProgram);
 
         parse_wordlist(&authenticateProgram);
 
         requirePathnameExists("auth_param basic program", authenticateProgram->key);
-    } else if (strcasecmp(param_str, "children") == 0) {
+    } else if (strcmp(param_str, "children") == 0) {
         authenticateChildren.parseConfig();
-    } else if (strcasecmp(param_str, "realm") == 0) {
+    } else if (strcmp(param_str, "realm") == 0) {
         parse_eol(&basicAuthRealm);
-    } else if (strcasecmp(param_str, "credentialsttl") == 0) {
+    } else if (strcmp(param_str, "credentialsttl") == 0) {
         parse_time_t(&credentialsTTL);
-    } else if (strcasecmp(param_str, "casesensitive") == 0) {
+    } else if (strcmp(param_str, "casesensitive") == 0) {
         parse_onoff(&casesensitive);
-    } else if (strcasecmp(param_str, "utf8") == 0) {
+    } else if (strcmp(param_str, "utf8") == 0) {
         parse_onoff(&utf8);
     } else {
         debugs(29, DBG_CRITICAL, HERE << "unrecognised basic auth scheme parameter '" << param_str << "'");
     }
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/auth_basic.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/auth_basic.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/auth_basic.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/auth_basic.h	2015-05-01 18:05:19.000000000 +0800
@@ -10,23 +10,12 @@
 #include "auth/UserRequest.h"
 #include "auth/Config.h"
 #include "helper.h"
 
 #define DefaultAuthenticateChildrenMax  32	/* 32 processes */
 
-/** queue of auth requests waiting for verification to occur */
-class BasicAuthQueueNode
-{
-
-public:
-    BasicAuthQueueNode *next;
-    Auth::UserRequest::Pointer auth_user_request;
-    AUTHCB *handler;
-    void *data;
-};
-
 namespace Auth
 {
 namespace Basic
 {
 
 /** Basic authentication configuration data */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/Makefile.in	2015-05-01 16:51:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/Makefile.in	2015-05-01 18:06:50.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -452,12 +498,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -495,12 +542,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -527,27 +575,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -614,13 +665,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libbasic.la
 libbasic_la_SOURCES = \
 	Scheme.cc \
 	Scheme.h \
 	auth_basic.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/User.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/User.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/User.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/User.cc	2015-05-01 18:05:19.000000000 +0800
@@ -5,13 +5,13 @@
 #include "SquidConfig.h"
 #include "SquidTime.h"
 
 Auth::Basic::User::User(Auth::Config *aConfig) :
         Auth::User(aConfig),
         passwd(NULL),
-        auth_queue(NULL),
+        queue(NULL),
         currentRequest(NULL)
 {}
 
 Auth::Basic::User::~User()
 {
     safe_free(passwd);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/User.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/User.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/User.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/User.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,18 +1,17 @@
 #ifndef _SQUID_AUTH_BASIC_USER_H
 #define _SQUID_AUTH_BASIC_USER_H
 
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 
-class BasicAuthQueueNode;
-
 namespace Auth
 {
 
 class Config;
+class QueueNode;
 
 namespace Basic
 {
 
 /** User credentials for the Basic authentication protocol */
 class User : public Auth::User
@@ -28,13 +27,13 @@
     /** Update the cached password for a username. */
     void updateCached(User *from);
     virtual int32_t ttl() const;
 
     char *passwd;
 
-    BasicAuthQueueNode *auth_queue;
+    QueueNode *queue;
 
 private:
     Auth::UserRequest::Pointer currentRequest;
 };
 
 MEMPROXY_CLASS_INLINE(Auth::Basic::User);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/UserRequest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/UserRequest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/UserRequest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/UserRequest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,15 @@
 #include "squid.h"
 #include "auth/basic/auth_basic.h"
 #include "auth/basic/User.h"
 #include "auth/basic/UserRequest.h"
+#include "auth/QueueNode.h"
 #include "auth/State.h"
 #include "charset.h"
 #include "Debug.h"
+#include "HelperReply.h"
 #include "rfc1738.h"
 #include "SquidTime.h"
 
 #if !defined(HELPER_INPUT_BUFFER)
 #define HELPER_INPUT_BUFFER  8192
 #endif
@@ -92,102 +94,90 @@
     }
 
     /* check to see if the auth_user already has a request outstanding */
     if (user()->credentials() == Auth::Pending) {
         /* there is a request with the same credentials already being verified */
 
-        BasicAuthQueueNode *node = static_cast<BasicAuthQueueNode *>(xcalloc(1, sizeof(BasicAuthQueueNode)));
-        assert(node);
-        node->auth_user_request = this;
-        node->handler = handler;
-        node->data = cbdataReference(data);
+        Auth::QueueNode *node = new Auth::QueueNode(this, handler, data);
 
         /* queue this validation request to be infored of the pending lookup results */
-        node->next = basic_auth->auth_queue;
-        basic_auth->auth_queue = node;
+        node->next = basic_auth->queue;
+        basic_auth->queue = node;
         return;
     }
     // otherwise submit this request to the auth helper(s) for validation
 
     /* mark this user as having verification in progress */
     user()->credentials(Auth::Pending);
     char buf[HELPER_INPUT_BUFFER];
-    static char username[HELPER_INPUT_BUFFER];
+    static char usern[HELPER_INPUT_BUFFER];
     static char pass[HELPER_INPUT_BUFFER];
     if (static_cast<Auth::Basic::Config*>(user()->config)->utf8) {
-        latin1_to_utf8(username, sizeof(username), user()->username());
+        latin1_to_utf8(usern, sizeof(usern), user()->username());
         latin1_to_utf8(pass, sizeof(pass), basic_auth->passwd);
-        xstrncpy(username, rfc1738_escape(username), sizeof(username));
+        xstrncpy(usern, rfc1738_escape(usern), sizeof(usern));
         xstrncpy(pass, rfc1738_escape(pass), sizeof(pass));
     } else {
-        xstrncpy(username, rfc1738_escape(user()->username()), sizeof(username));
+        xstrncpy(usern, rfc1738_escape(user()->username()), sizeof(usern));
         xstrncpy(pass, rfc1738_escape(basic_auth->passwd), sizeof(pass));
     }
-    int sz = snprintf(buf, sizeof(buf), "%s %s\n", username, pass);
+    int sz = snprintf(buf, sizeof(buf), "%s %s\n", usern, pass);
     if (sz<=0) {
         debugs(9, DBG_CRITICAL, "ERROR: Basic Authentication Failure. Can not build helper validation request.");
         handler(data);
     } else if (static_cast<size_t>(sz) >= sizeof(buf)) {
         debugs(9, DBG_CRITICAL, "ERROR: Basic Authentication Failure. user:password exceeds " << sizeof(buf) << " bytes.");
         handler(data);
     } else
         helperSubmit(basicauthenticators, buf, Auth::Basic::UserRequest::HandleReply,
                      new Auth::StateData(this, handler, data));
 }
 
 void
-Auth::Basic::UserRequest::HandleReply(void *data, char *reply)
+Auth::Basic::UserRequest::HandleReply(void *data, const HelperReply &reply)
 {
     Auth::StateData *r = static_cast<Auth::StateData *>(data);
-    BasicAuthQueueNode *tmpnode;
-    char *t = NULL;
     void *cbdata;
-    debugs(29, 5, HERE << "{" << (reply ? reply : "<NULL>") << "}");
-
-    if (reply) {
-        if ((t = strchr(reply, ' '))) {
-            *t = '\0';
-            ++t;
-        }
-
-        if (*reply == '\0')
-            reply = NULL;
-    }
+    debugs(29, 5, HERE << "reply=" << reply);
 
     assert(r->auth_user_request != NULL);
     assert(r->auth_user_request->user()->auth_type == Auth::AUTH_BASIC);
 
+    // add new helper kv-pair notes to the credentials object
+    // so that any transaction using those credentials can access them
+    r->auth_user_request->user()->notes.appendNewOnly(&reply.notes);
+
     /* this is okay since we only play with the Auth::Basic::User child fields below
      * and dont pass the pointer itself anywhere */
     Auth::Basic::User *basic_auth = dynamic_cast<Auth::Basic::User *>(r->auth_user_request->user().getRaw());
 
     assert(basic_auth != NULL);
 
-    if (reply && (strncasecmp(reply, "OK", 2) == 0))
+    if (reply.result == HelperReply::Okay)
         basic_auth->credentials(Auth::Ok);
     else {
         basic_auth->credentials(Auth::Failed);
 
-        if (t && *t)
-            r->auth_user_request->setDenyMessage(t);
+        if (reply.other().hasContent())
+            r->auth_user_request->setDenyMessage(reply.other().content());
     }
 
     basic_auth->expiretime = squid_curtime;
 
     if (cbdataReferenceValidDone(r->data, &cbdata))
         r->handler(cbdata);
 
     cbdataReferenceDone(r->data);
 
-    while (basic_auth->auth_queue) {
-        tmpnode = basic_auth->auth_queue->next;
-
-        if (cbdataReferenceValidDone(basic_auth->auth_queue->data, &cbdata))
-            basic_auth->auth_queue->handler(cbdata);
-
-        xfree(basic_auth->auth_queue);
+    while (basic_auth->queue) {
+        if (cbdataReferenceValidDone(basic_auth->queue->data, &cbdata))
+            basic_auth->queue->handler(cbdata);
+
+        Auth::QueueNode *tmpnode = basic_auth->queue->next;
+        basic_auth->queue->next = NULL;
+        delete basic_auth->queue;
 
-        basic_auth->auth_queue = tmpnode;
+        basic_auth->queue = tmpnode;
     }
 
     delete r;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/UserRequest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/UserRequest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/basic/UserRequest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/basic/UserRequest.h	2015-05-01 18:05:19.000000000 +0800
@@ -18,13 +18,13 @@
 class UserRequest : public Auth::UserRequest
 {
 public:
     MEMPROXY_CLASS(Auth::Basic::UserRequest);
 
     UserRequest() {}
-    virtual ~UserRequest() { assert(RefCountCount()==0); }
+    virtual ~UserRequest() { assert(LockCount()==0); }
 
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData *conn, http_hdr_type type);
     virtual Auth::Direction module_direction();
     virtual void module_start(AUTHCB *, void *);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/auth_digest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/auth_digest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/auth_digest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/auth_digest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -99,16 +99,14 @@
  * Nonce Functions
  *
  */
 
 static void authenticateDigestNonceCacheCleanup(void *data);
 static digest_nonce_h *authenticateDigestNonceFindNonce(const char *nonceb64);
-static digest_nonce_h *authenticateDigestNonceNew(void);
 static void authenticateDigestNonceDelete(digest_nonce_h * nonce);
 static void authenticateDigestNonceSetup(void);
-static int authDigestNonceIsStale(digest_nonce_h * nonce);
 static void authDigestNonceEncode(digest_nonce_h * nonce);
 static void authDigestNonceLink(digest_nonce_h * nonce);
 #if NOT_USED
 static int authDigestNonceLinks(digest_nonce_h * nonce);
 #endif
 static void authDigestNonceUserUnlink(digest_nonce_h * nonce);
@@ -122,17 +120,16 @@
     if (nonce->key)
         xfree(nonce->key);
 
     nonce->key = xstrdup(base64_encode_bin((char *) &(nonce->noncedata), sizeof(digest_nonce_data)));
 }
 
-static digest_nonce_h *
+digest_nonce_h *
 authenticateDigestNonceNew(void)
 {
     digest_nonce_h *newnonce = static_cast < digest_nonce_h * >(digest_nonce_pool->alloc());
-    digest_nonce_h *temp;
 
     /* NONCE CREATION - NOTES AND REASONING. RBC 20010108
      * === EXCERPT FROM RFC 2617 ===
      * The contents of the nonce are implementation dependent. The quality
      * of the implementation depends on a good choice. A nonce might, for
      * example, be constructed as the base 64 encoding of
@@ -169,35 +166,35 @@
      * memory pointer also guarantee local uniqueness in the input to the hash
      * function.
      */
 
     /* create a new nonce */
     newnonce->nc = 0;
-    newnonce->flags.valid = 1;
+    newnonce->flags.valid = true;
     newnonce->noncedata.self = newnonce;
     newnonce->noncedata.creationtime = current_time.tv_sec;
     newnonce->noncedata.randomdata = squid_random();
 
     authDigestNonceEncode(newnonce);
     /*
      * loop until we get a unique nonce. The nonce creation must
      * have a random factor
      */
 
-    while ((temp = authenticateDigestNonceFindNonce((char const *) (newnonce->key)))) {
+    while (authenticateDigestNonceFindNonce((char const *) (newnonce->key))) {
         /* create a new nonce */
         newnonce->noncedata.randomdata = squid_random();
         /* Bug 3526 high performance fix: add 1 second to creationtime to avoid duplication */
         ++newnonce->noncedata.creationtime;
         authDigestNonceEncode(newnonce);
     }
 
     hash_join(digest_nonce_cache, newnonce);
     /* the cache's link */
     authDigestNonceLink(newnonce);
-    newnonce->flags.incache = 1;
+    newnonce->flags.incache = true;
     debugs(29, 5, "authenticateDigestNonceNew: created nonce " << newnonce << " at " << newnonce->noncedata.creationtime);
     return newnonce;
 }
 
 static void
 authenticateDigestNonceDelete(digest_nonce_h * nonce)
@@ -208,13 +205,13 @@
 
         if (nonce->flags.incache)
             hash_remove_link(digest_nonce_cache, nonce);
 
 #endif
 
-        assert(nonce->flags.incache == 0);
+        assert(!nonce->flags.incache);
 
         safe_free(nonce->key);
 
         digest_nonce_pool->freeOne(nonce);
     }
 }
@@ -279,13 +276,13 @@
         debugs(29, 4, "authenticateDigestNonceCacheCleanup: Creation time: " << nonce->noncedata.creationtime);
 
         if (authDigestNonceIsStale(nonce)) {
             debugs(29, 4, "authenticateDigestNonceCacheCleanup: Removing nonce " << (char *) nonce->key << " from cache due to timeout.");
             assert(nonce->flags.incache);
             /* invalidate nonce so future requests fail */
-            nonce->flags.valid = 0;
+            nonce->flags.valid = false;
             /* if it is tied to a auth_user, remove the tie */
             authDigestNonceUserUnlink(nonce);
             authDigestNoncePurge(nonce);
         }
     }
 
@@ -377,60 +374,63 @@
         debugs(29, 4, "authDigestNonceIsValid: Nonce already invalidated");
         return 0;
     }
 
     /* is the nonce-count ok ? */
     if (!static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->CheckNonceCount) {
-        ++nonce->nc;
-        return -1;              /* forced OK by configuration */
+        /* Ignore client supplied NC */
+        intnc = nonce->nc + 1;
     }
 
     if ((static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->NonceStrictness && intnc != nonce->nc + 1) ||
             intnc < nonce->nc + 1) {
         debugs(29, 4, "authDigestNonceIsValid: Nonce count doesn't match");
-        nonce->flags.valid = 0;
+        nonce->flags.valid = false;
         return 0;
     }
 
-    /* seems ok */
     /* increment the nonce count - we've already checked that intnc is a
      *  valid representation for us, so we don't need the test here.
      */
     nonce->nc = intnc;
 
-    return -1;
+    return !authDigestNonceIsStale(nonce);
 }
 
-static int
+int
 authDigestNonceIsStale(digest_nonce_h * nonce)
 {
     /* do we have a nonce ? */
 
     if (!nonce)
         return -1;
 
+    /* Is it already invalidated? */
+    if (!nonce->flags.valid)
+        return -1;
+
     /* has it's max duration expired? */
     if (nonce->noncedata.creationtime + static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->noncemaxduration < current_time.tv_sec) {
         debugs(29, 4, "authDigestNonceIsStale: Nonce is too old. " <<
                nonce->noncedata.creationtime << " " <<
                static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->noncemaxduration << " " <<
                current_time.tv_sec);
 
-        nonce->flags.valid = 0;
+        nonce->flags.valid = false;
         return -1;
     }
 
     if (nonce->nc > 99999998) {
         debugs(29, 4, "authDigestNonceIsStale: Nonce count overflow");
-        nonce->flags.valid = 0;
+        nonce->flags.valid = false;
         return -1;
     }
 
     if (nonce->nc > static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->noncemaxuses) {
         debugs(29, 4, "authDigestNoncelastRequest: Nonce count over user limit");
-        nonce->flags.valid = 0;
+        nonce->flags.valid = false;
         return -1;
     }
 
     /* seems ok */
     return 0;
 }
@@ -467,13 +467,13 @@
 
     if (!nonce->flags.incache)
         return;
 
     hash_remove_link(digest_nonce_cache, nonce);
 
-    nonce->flags.incache = 0;
+    nonce->flags.incache = false;
 
     /* the cache's link */
     authDigestNonceUnlink(nonce);
 }
 
 void
@@ -528,23 +528,29 @@
 void
 Auth::Digest::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, HttpReply *rep, http_hdr_type hdrType, HttpRequest * request)
 {
     if (!authenticateProgram)
         return;
 
-    int stale = 0;
+    bool stale = false;
+    digest_nonce_h *nonce = NULL;
 
+    /* on a 407 or 401 we always use a new nonce */
     if (auth_user_request != NULL) {
-        Auth::Digest::UserRequest *digest_request = dynamic_cast<Auth::Digest::UserRequest*>(auth_user_request.getRaw());
-        assert (digest_request != NULL);
+        Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
 
-        stale = !digest_request->flags.invalid_password;
+        if (digest_user) {
+            stale = digest_user->credentials() == Auth::Handshake;
+            if (stale) {
+                nonce = digest_user->currentNonce();
+            }
+        }
+    }
+    if (!nonce) {
+        nonce = authenticateDigestNonceNew();
     }
-
-    /* on a 407 or 401 we always use a new nonce */
-    digest_nonce_h *nonce = authenticateDigestNonceNew();
 
     debugs(29, 9, HERE << "Sending type:" << hdrType <<
            " header: 'Digest realm=\"" << digestAuthRealm << "\", nonce=\"" <<
            authenticateDigestNonceNonceb64(nonce) << "\", qop=\"" << QOP_AUTH <<
            "\", stale=" << (stale ? "true" : "false"));
 
@@ -620,36 +626,36 @@
         utf8(0)
 {}
 
 void
 Auth::Digest::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
 {
-    if (strcasecmp(param_str, "program") == 0) {
+    if (strcmp(param_str, "program") == 0) {
         if (authenticateProgram)
             wordlistDestroy(&authenticateProgram);
 
         parse_wordlist(&authenticateProgram);
 
         requirePathnameExists("auth_param digest program", authenticateProgram->key);
-    } else if (strcasecmp(param_str, "children") == 0) {
+    } else if (strcmp(param_str, "children") == 0) {
         authenticateChildren.parseConfig();
-    } else if (strcasecmp(param_str, "realm") == 0) {
+    } else if (strcmp(param_str, "realm") == 0) {
         parse_eol(&digestAuthRealm);
-    } else if (strcasecmp(param_str, "nonce_garbage_interval") == 0) {
+    } else if (strcmp(param_str, "nonce_garbage_interval") == 0) {
         parse_time_t(&nonceGCInterval);
-    } else if (strcasecmp(param_str, "nonce_max_duration") == 0) {
+    } else if (strcmp(param_str, "nonce_max_duration") == 0) {
         parse_time_t(&noncemaxduration);
-    } else if (strcasecmp(param_str, "nonce_max_count") == 0) {
+    } else if (strcmp(param_str, "nonce_max_count") == 0) {
         parse_int((int *) &noncemaxuses);
-    } else if (strcasecmp(param_str, "nonce_strictness") == 0) {
+    } else if (strcmp(param_str, "nonce_strictness") == 0) {
         parse_onoff(&NonceStrictness);
-    } else if (strcasecmp(param_str, "check_nonce_count") == 0) {
+    } else if (strcmp(param_str, "check_nonce_count") == 0) {
         parse_onoff(&CheckNonceCount);
-    } else if (strcasecmp(param_str, "post_workaround") == 0) {
+    } else if (strcmp(param_str, "post_workaround") == 0) {
         parse_onoff(&PostWorkaround);
-    } else if (strcasecmp(param_str, "utf8") == 0) {
+    } else if (strcmp(param_str, "utf8") == 0) {
         parse_onoff(&utf8);
     } else {
         debugs(29, DBG_CRITICAL, "unrecognised digest auth scheme parameter '" << param_str << "'");
     }
 }
 
@@ -701,14 +707,14 @@
     /* this reference to user was not locked because freeeing the user frees
      * the nonce too.
      */
     nonce->user = NULL;
 }
 
-/* authDigestUserLinkNonce: add a nonce to a given user's struct */
-static void
+/* authDigesteserLinkNonce: add a nonce to a given user's struct */
+void
 authDigestUserLinkNonce(Auth::Digest::User * user, digest_nonce_h * nonce)
 {
     dlink_node *node;
 
     if (!user || !nonce || !nonce->user)
         return;
@@ -830,15 +836,15 @@
         } else {
             debugs(29, 9, HERE << "Failed to parse attribute '" << item << "' in '" << temp << "'");
             continue;
         }
 
         /* find type */
-        http_digest_attr_type type = (http_digest_attr_type)httpHeaderIdByName(item, nlen, DigestFieldsInfo, DIGEST_ENUM_END);
+        http_digest_attr_type t = (http_digest_attr_type)httpHeaderIdByName(item, nlen, DigestFieldsInfo, DIGEST_ENUM_END);
 
-        switch (type) {
+        switch (t) {
         case DIGEST_USERNAME:
             safe_free(username);
             if (value.size() != 0)
                 username = xstrndup(value.rawBuf(), value.size() + 1);
             debugs(29, 9, HERE << "Found Username '" << username << "'");
             break;
@@ -1024,20 +1030,25 @@
     }
 
     /** below nonce state dependent **/
 
     /* now the nonce */
     nonce = authenticateDigestNonceFindNonce(digest_request->nonceb64);
+    /* check that we're not being hacked / the username hasn't changed */
+    if (nonce && nonce->user && strcmp(username, nonce->user->username())) {
+        debugs(29, 2, "Username for the nonce does not equal the username for the request");
+        nonce = NULL;
+    }
+
     if (!nonce) {
         /* we couldn't find a matching nonce! */
-        debugs(29, 2, "Unexpected or invalid nonce received");
-        if (digest_request->user() != NULL)
-            digest_request->user()->credentials(Auth::Failed);
-        rv = authDigestLogUsername(username, digest_request);
+        debugs(29, 2, "Unexpected or invalid nonce received from " << username);
+        Auth::UserRequest::Pointer auth_request = authDigestLogUsername(username, digest_request);
+        auth_request->user()->credentials(Auth::Handshake);
         safe_free(username);
-        return rv;
+        return auth_request;
     }
 
     digest_request->nonce = nonce;
     authDigestNonceLink(nonce);
 
     /* check that we're not being hacked / the username hasn't changed */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/auth_digest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/auth_digest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/auth_digest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/auth_digest.h	2015-05-01 18:05:19.000000000 +0800
@@ -42,23 +42,26 @@
     short references;
     /* the auth_user this nonce has been tied to */
     Auth::Digest::User *user;
     /* has this nonce been invalidated ? */
 
     struct {
-        unsigned int valid:1;
-        unsigned int incache:1;
+        bool valid;
+        bool incache;
     } flags;
 };
 
 void authDigestNonceUnlink(digest_nonce_h * nonce);
 int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
+int authDigestNonceIsStale(digest_nonce_h * nonce);
 const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
 int authDigestNonceLastRequest(digest_nonce_h * nonce);
 void authenticateDigestNonceShutdown(void);
 void authDigestNoncePurge(digest_nonce_h * nonce);
+void authDigestUserLinkNonce(Auth::Digest::User * user, digest_nonce_h * nonce);
+digest_nonce_h *authenticateDigestNonceNew(void);
 
 namespace Auth
 {
 namespace Digest
 {
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/Makefile.in	2015-05-01 16:51:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/Makefile.in	2015-05-01 18:06:51.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -452,12 +498,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -495,12 +542,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -527,27 +575,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -614,13 +665,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libdigest.la
 libdigest_la_SOURCES = \
 	Scheme.cc \
 	Scheme.h \
 	auth_digest.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/User.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/User.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/User.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/User.cc	2015-05-01 18:05:19.000000000 +0800
@@ -47,6 +47,19 @@
         return min(-1, global_ttl);
 
     int32_t nonce_ttl = latest_nonce - current_time.tv_sec + static_cast<Config*>(Auth::Config::Find("digest"))->noncemaxduration;
 
     return min(nonce_ttl, global_ttl);
 }
+
+digest_nonce_h *
+Auth::Digest::User::currentNonce()
+{
+    digest_nonce_h *nonce = NULL;
+    dlink_node *link = nonces.tail;
+    if (link) {
+        nonce = static_cast<digest_nonce_h *>(link->data);
+        if (authDigestNonceIsStale(nonce))
+            nonce = NULL;
+    }
+    return nonce;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/User.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/User.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/User.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/User.h	2015-05-01 18:05:19.000000000 +0800
@@ -22,12 +22,14 @@
 
     HASH HA1;
     int HA1created;
 
     /* what nonces have been allocated to this user */
     dlink_list nonces;
+
+    digest_nonce_h * currentNonce();
 };
 
 MEMPROXY_CLASS_INLINE(Auth::Digest::User);
 
 } // namespace Digest
 } // namespace Auth
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/UserRequest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/UserRequest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/UserRequest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/UserRequest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -28,13 +28,13 @@
 /**
  * Delete the digest request structure.
  * Does NOT delete related AuthUser structures
  */
 Auth::Digest::UserRequest::~UserRequest()
 {
-    assert(RefCountCount()==0);
+    assert(LockCount()==0);
 
     safe_free(nonceb64);
     safe_free(cnonce);
     safe_free(realm);
     safe_free(pszPass);
     safe_free(algorithm);
@@ -99,41 +99,41 @@
 
     debugs(29, 9, "\nResponse = '" << digest_request->response << "'\nsquid is = '" << Response << "'");
 
     if (strcasecmp(digest_request->response, Response) != 0) {
         if (!digest_request->flags.helper_queried) {
             /* Query the helper in case the password has changed */
-            digest_request->flags.helper_queried = 1;
+            digest_request->flags.helper_queried = true;
             auth_user->credentials(Auth::Pending);
             return;
         }
 
-        if (static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->PostWorkaround && request->method != METHOD_GET) {
+        if (static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->PostWorkaround && request->method != Http::METHOD_GET) {
             /* Ugly workaround for certain very broken browsers using the
              * wrong method to calculate the request-digest on POST request.
              * This should be deleted once Digest authentication becomes more
              * widespread and such broken browsers no longer are commonly
              * used.
              */
             DigestCalcResponse(SESSIONKEY, authenticateDigestNonceNonceb64(digest_request->nonce),
                                digest_request->nc, digest_request->cnonce, digest_request->qop,
-                               RequestMethodStr(METHOD_GET), digest_request->uri, HA2, Response);
+                               RequestMethodStr(Http::METHOD_GET), digest_request->uri, HA2, Response);
 
             if (strcasecmp(digest_request->response, Response)) {
                 auth_user->credentials(Auth::Failed);
-                digest_request->flags.invalid_password = 1;
+                digest_request->flags.invalid_password = true;
                 digest_request->setDenyMessage("Incorrect password");
                 return;
             } else {
                 const char *useragent = request->header.getStr(HDR_USER_AGENT);
 
                 static Ip::Address last_broken_addr;
                 static int seen_broken_client = 0;
 
                 if (!seen_broken_client) {
-                    last_broken_addr.SetNoAddr();
+                    last_broken_addr.setNoAddr();
                     seen_broken_client = 1;
                 }
 
                 if (last_broken_addr != request->client_addr) {
                     debugs(29, DBG_IMPORTANT, "Digest POST bug detected from " <<
                            request->client_addr << " using '" <<
@@ -142,23 +142,27 @@
 
                     last_broken_addr = request->client_addr;
                 }
             }
         } else {
             auth_user->credentials(Auth::Failed);
-            digest_request->flags.invalid_password = 1;
+            digest_request->flags.invalid_password = true;
             digest_request->setDenyMessage("Incorrect password");
             return;
         }
     }
 
     /* check for stale nonce */
-    if (!authDigestNonceIsValid(digest_request->nonce, digest_request->nc)) {
-        debugs(29, 3, "user '" << auth_user->username() << "' validated OK but nonce stale");
-        auth_user->credentials(Auth::Failed);
-        digest_request->setDenyMessage("Stale nonce");
+    /* check Auth::Pending to avoid loop */
+
+    if (!authDigestNonceIsValid(digest_request->nonce, digest_request->nc) && user()->credentials() != Auth::Pending) {
+        debugs(29, 3, auth_user->username() << "' validated OK but nonce stale: " << digest_request->nonceb64);
+        /* Pending prevent banner and makes a ldap control */
+        auth_user->credentials(Auth::Pending);
+        nonce->flags.valid = false;
+        authDigestNoncePurge(nonce);
         return;
     }
 
     auth_user->credentials(Auth::Ok);
 
     /* password was checked and did match */
@@ -178,12 +182,13 @@
 
     switch (user()->credentials()) {
 
     case Auth::Ok:
         return Auth::CRED_VALID;
 
+    case Auth::Handshake:
     case Auth::Failed:
         /* send new challenge */
         return Auth::CRED_CHALLENGE;
 
     case Auth::Unchecked:
     case Auth::Pending:
@@ -197,29 +202,34 @@
 void
 Auth::Digest::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int accel)
 {
     http_hdr_type type;
 
     /* don't add to authentication error pages */
-
-    if ((!accel && rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-            || (accel && rep->sline.status == HTTP_UNAUTHORIZED))
+    if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
+            || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
     type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
 
 #if WAITING_FOR_TE
     /* test for http/1.1 transfer chunked encoding */
     if (chunkedtest)
         return;
 #endif
 
     if ((static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->authenticateProgram) && authDigestNonceLastRequest(nonce)) {
-        flags.authinfo_sent = 1;
-        debugs(29, 9, HERE << "Sending type:" << type << " header: 'nextnonce=\"" << authenticateDigestNonceNonceb64(nonce) << "\"");
-        httpHeaderPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(nonce));
+        flags.authinfo_sent = true;
+        Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(user().getRaw());
+        digest_nonce_h *nextnonce = digest_user->currentNonce();
+        if (!nextnonce || authDigestNonceLastRequest(nonce)) {
+            nextnonce = authenticateDigestNonceNew();
+            authDigestUserLinkNonce(digest_user, nextnonce);
+        }
+        debugs(29, 9, "Sending type:" << type << " header: 'nextnonce=\"" << authenticateDigestNonceNonceb64(nextnonce) << "\"");
+        httpHeaderPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(nextnonce));
     }
 }
 
 #if WAITING_FOR_TE
 void
 Auth::Digest::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int accel)
@@ -231,20 +241,26 @@
 
     /* has the header already been send? */
     if (flags.authinfo_sent)
         return;
 
     /* don't add to authentication error pages */
-    if ((!accel && rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-            || (accel && rep->sline.status == HTTP_UNAUTHORIZED))
+    if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
+            || (accel && rep->sline.status() == Http::scUnauthorized))
         return;
 
     type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
 
     if ((static_cast<Auth::Digest::Config*>(digestScheme::GetInstance()->getConfig())->authenticate) && authDigestNonceLastRequest(nonce)) {
-        debugs(29, 9, HERE << "Sending type:" << type << " header: 'nextnonce=\"" << authenticateDigestNonceNonceb64(nonce) << "\"");
+        Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
+        nonce = digest_user->currentNonce();
+        if (!nonce) {
+            nonce = authenticateDigestNonceNew();
+            authDigestUserLinkNonce(digest_user, nonce);
+        }
+        debugs(29, 9, "Sending type:" << type << " header: 'nextnonce=\"" << authenticateDigestNonceNonceb64(nonce) << "\"");
         httpTrailerPutStrf(&rep->header, type, "nextnonce=\"%s\"", authenticateDigestNonceNonceb64(nonce));
     }
 }
 #endif
 
 /* send the initial data to a digest authenticator module */
@@ -272,50 +288,91 @@
 
     helperSubmit(digestauthenticators, buf, Auth::Digest::UserRequest::HandleReply,
                  new Auth::StateData(this, handler, data));
 }
 
 void
-Auth::Digest::UserRequest::HandleReply(void *data, char *reply)
+Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
 {
     Auth::StateData *replyData = static_cast<Auth::StateData *>(data);
-    char *t = NULL;
-    void *cbdata;
-    debugs(29, 9, HERE << "{" << (reply ? reply : "<NULL>") << "}");
-
-    if (reply) {
-        if ((t = strchr(reply, ' '))) {
-            *t = '\0';
-            ++t;
-        }
-
-        if (*reply == '\0' || *reply == '\n')
-            reply = NULL;
-    }
+    debugs(29, 9, HERE << "reply=" << reply);
 
     assert(replyData->auth_user_request != NULL);
     Auth::UserRequest::Pointer auth_user_request = replyData->auth_user_request;
 
-    if (reply && (strncasecmp(reply, "ERR", 3) == 0)) {
+    // add new helper kv-pair notes to the credentials object
+    // so that any transaction using those credentials can access them
+    auth_user_request->user()->notes.appendNewOnly(&reply.notes);
+    // remove any private credentials detail which got added.
+    auth_user_request->user()->notes.remove("ha1");
+
+    static bool oldHelperWarningDone = false;
+    switch (reply.result) {
+    case HelperReply::Unknown: {
+        // Squid 3.3 and older the digest helper only returns a HA1 hash (no "OK")
+        // the HA1 will be found in content() for these responses.
+        if (!oldHelperWarningDone) {
+            debugs(29, DBG_IMPORTANT, "WARNING: Digest auth helper returned old format HA1 response. It needs to be upgraded.");
+            oldHelperWarningDone=true;
+        }
+
         /* allow this because the digest_request pointer is purely local */
-        Auth::Digest::UserRequest *digest_request = dynamic_cast<Auth::Digest::UserRequest *>(auth_user_request.getRaw());
-        assert(digest_request);
+        Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
+        assert(digest_user != NULL);
 
-        digest_request->user()->credentials(Auth::Failed);
-        digest_request->flags.invalid_password = 1;
+        CvtBin(reply.other().content(), digest_user->HA1);
+        digest_user->HA1created = 1;
+    }
+    break;
 
-        if (t && *t)
-            digest_request->setDenyMessage(t);
-    } else if (reply) {
+    case HelperReply::Okay: {
         /* allow this because the digest_request pointer is purely local */
         Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
         assert(digest_user != NULL);
 
-        CvtBin(reply, digest_user->HA1);
-        digest_user->HA1created = 1;
+        const char *ha1Note = reply.notes.findFirst("ha1");
+        if (ha1Note != NULL) {
+            CvtBin(ha1Note, digest_user->HA1);
+            digest_user->HA1created = 1;
+        } else {
+            debugs(29, DBG_IMPORTANT, "ERROR: Digest auth helper did not produce a HA1. Using the wrong helper program? received: " << reply);
+        }
+    }
+    break;
+
+    case HelperReply::TT:
+        debugs(29, DBG_IMPORTANT, "ERROR: Digest auth does not support the result code received. Using the wrong helper program? received: " << reply);
+        // fall through to next case. Handle this as an ERR response.
+
+    case HelperReply::BrokenHelper:
+        // TODO retry the broken lookup on another helper?
+        // fall through to next case for now. Handle this as an ERR response silently.
+
+    case HelperReply::Error: {
+        /* allow this because the digest_request pointer is purely local */
+        Auth::Digest::UserRequest *digest_request = dynamic_cast<Auth::Digest::UserRequest *>(auth_user_request.getRaw());
+        assert(digest_request);
+
+        digest_request->user()->credentials(Auth::Failed);
+        digest_request->flags.invalid_password = true;
+
+        const char *msgNote = reply.notes.find("message");
+        if (msgNote != NULL) {
+            digest_request->setDenyMessage(msgNote);
+        } else if (reply.other().hasContent()) {
+            // old helpers did send ERR result but a bare message string instead of message= key name.
+            digest_request->setDenyMessage(reply.other().content());
+            if (!oldHelperWarningDone) {
+                debugs(29, DBG_IMPORTANT, "WARNING: Digest auth helper returned old format ERR response. It needs to be upgraded.");
+                oldHelperWarningDone=true;
+            }
+        }
+    }
+    break;
     }
 
+    void *cbdata = NULL;
     if (cbdataReferenceValidDone(replyData->data, &cbdata))
         replyData->handler(cbdata);
 
     delete replyData;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/UserRequest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/UserRequest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/digest/UserRequest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/digest/UserRequest.h	2015-05-01 18:05:19.000000000 +0800
@@ -45,15 +45,15 @@
     char *pszMethod;            /* = "GET" */
     char *qop;                  /* = "auth" */
     char *uri;                  /* = "/dir/index.html" */
     char *response;
 
     struct {
-        unsigned int authinfo_sent:1;
-        unsigned int invalid_password:1;
-        unsigned int helper_queried:1;
+        bool authinfo_sent;
+        bool invalid_password;
+        bool helper_queried;
     } flags;
     digest_nonce_h *nonce;
 
 private:
     static HLPCB HandleReply;
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -15,12 +15,13 @@
 	Config.cc \
 	Config.h \
 	CredentialState.cc \
 	CredentialState.h \
 	Gadgets.cc \
 	Gadgets.h \
+	QueueNode.h \
 	Scheme.cc \
 	Scheme.h \
 	State.h \
 	State.cc \
 	User.h \
 	User.cci \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/Makefile.in	2015-05-01 16:51:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/Makefile.in	2015-05-01 18:06:50.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -495,12 +541,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -538,12 +585,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -570,27 +618,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -657,13 +708,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 SUBDIRS = $(AUTH_MODULES)
 DIST_SUBDIRS = basic digest negotiate ntlm
 noinst_LTLIBRARIES = libauth.la libacls.la
 libauth_la_SOURCES = \
 	Type.h \
@@ -671,12 +722,13 @@
 	Config.cc \
 	Config.h \
 	CredentialState.cc \
 	CredentialState.h \
 	Gadgets.cc \
 	Gadgets.h \
+	QueueNode.h \
 	Scheme.cc \
 	Scheme.h \
 	State.h \
 	State.cc \
 	User.h \
 	User.cci \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/negotiate/auth_negotiate.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/negotiate/auth_negotiate.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/negotiate/auth_negotiate.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/negotiate/auth_negotiate.cc	2015-05-01 18:05:19.000000000 +0800
@@ -126,22 +126,22 @@
 Auth::Negotiate::Config::Config() : keep_alive(1)
 { }
 
 void
 Auth::Negotiate::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
 {
-    if (strcasecmp(param_str, "program") == 0) {
+    if (strcmp(param_str, "program") == 0) {
         if (authenticateProgram)
             wordlistDestroy(&authenticateProgram);
 
         parse_wordlist(&authenticateProgram);
 
         requirePathnameExists("auth_param negotiate program", authenticateProgram->key);
-    } else if (strcasecmp(param_str, "children") == 0) {
+    } else if (strcmp(param_str, "children") == 0) {
         authenticateChildren.parseConfig();
-    } else if (strcasecmp(param_str, "keep_alive") == 0) {
+    } else if (strcmp(param_str, "keep_alive") == 0) {
         parse_onoff(&keep_alive);
     } else {
         debugs(29, DBG_CRITICAL, "ERROR: unrecognised Negotiate auth scheme parameter '" << param_str << "'");
     }
 }
 
@@ -223,25 +223,25 @@
         debugs(29, 9, HERE << "Sending type:" << reqType << " header: 'Negotiate'");
         httpHeaderPutStrf(&rep->header, reqType, "Negotiate");
 
         if (!keep_alive) {
             /* drop the connection */
             rep->header.delByName("keep-alive");
-            request->flags.proxyKeepalive = 0;
+            request->flags.proxyKeepalive = false;
         }
     } else {
         Auth::Negotiate::UserRequest *negotiate_request = dynamic_cast<Auth::Negotiate::UserRequest *>(auth_user_request.getRaw());
         assert(negotiate_request != NULL);
 
         switch (negotiate_request->user()->credentials()) {
 
         case Auth::Failed:
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
             rep->header.delByName("keep-alive");
-            request->flags.proxyKeepalive = 0;
+            request->flags.proxyKeepalive = false;
             /* fall through */
 
         case Auth::Ok:
             /* Special case: authentication finished OK but disallowed by ACL.
              * Need to start over to give the client another chance.
              */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/negotiate/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/negotiate/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/negotiate/Makefile.in	2015-05-01 16:51:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/negotiate/Makefile.in	2015-05-01 18:06:51.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -452,12 +498,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -495,12 +542,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -527,27 +575,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -614,13 +665,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libnegotiate.la
 libnegotiate_la_SOURCES = \
 	Scheme.cc \
 	Scheme.h \
 	auth_negotiate.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/negotiate/UserRequest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/negotiate/UserRequest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/negotiate/UserRequest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/negotiate/UserRequest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -19,13 +19,13 @@
     authserver=NULL;
     request=NULL;
 }
 
 Auth::Negotiate::UserRequest::~UserRequest()
 {
-    assert(RefCountCount()==0);
+    assert(LockCount()==0);
     safe_free(server_blob);
     safe_free(client_blob);
 
     releaseAuthServer();
 
     if (request) {
@@ -126,33 +126,12 @@
         helperStatefulReleaseServer(authserver);
         authserver = NULL;
     } else
         debugs(29, 6, HERE << "No Negotiate auth server to release.");
 }
 
-/* clear any connection related authentication details */
-void
-Auth::Negotiate::UserRequest::onConnectionClose(ConnStateData *conn)
-{
-    assert(conn != NULL);
-
-    debugs(29, 8, HERE << "closing connection '" << conn << "' (this is '" << this << "')");
-
-    if (conn->auth_user_request == NULL) {
-        debugs(29, 8, HERE << "no auth_user_request");
-        return;
-    }
-
-    releaseAuthServer();
-
-    /* unlock the connection based lock */
-    debugs(29, 9, HERE << "Unlocking auth_user from the connection '" << conn << "'.");
-
-    conn->auth_user_request = NULL;
-}
-
 void
 Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
 {
     assert(this);
 
     /* Check that we are in the client side, where we can generate
@@ -196,14 +175,14 @@
     case Auth::Unchecked:
         /* we've received a negotiate request. pass to a helper */
         debugs(29, 9, HERE << "auth state negotiate none. Received blob: '" << proxy_auth << "'");
         user()->credentials(Auth::Pending);
         safe_free(client_blob);
         client_blob=xstrdup(blob);
-        assert(conn->auth_user_request == NULL);
-        conn->auth_user_request = this;
+        assert(conn->getAuth() == NULL);
+        conn->setAuth(this, "new Negotiate handshake request");
         request = aRequest;
         HTTPMSGLOCK(request);
         break;
 
     case Auth::Pending:
         debugs(29, DBG_IMPORTANT, HERE << "need to ask helper");
@@ -229,88 +208,80 @@
         debugs(29, 9, HERE << "auth state negotiate failed. " << proxy_auth);
         break;
     }
 }
 
 void
-Auth::Negotiate::UserRequest::HandleReply(void *data, void *lastserver, char *reply)
+Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
 {
     Auth::StateData *r = static_cast<Auth::StateData *>(data);
 
-    char *blob, *arg = NULL;
-
-    debugs(29, 8, HERE << "helper: '" << lastserver << "' sent us '" << (reply ? reply : "<NULL>") << "'");
+    debugs(29, 8, HERE << "helper: '" << reply.whichServer << "' sent us reply=" << reply);
 
     if (!cbdataReferenceValid(r->data)) {
-        debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication invalid callback data. helper '" << lastserver << "'.");
+        debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication invalid callback data. helper '" << reply.whichServer << "'.");
         delete r;
         return;
     }
 
-    if (!reply) {
-        debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication Helper '" << lastserver << "' crashed!.");
-        reply = (char *)"BH Internal error";
-    }
-
     Auth::UserRequest::Pointer auth_user_request = r->auth_user_request;
     assert(auth_user_request != NULL);
 
+    // add new helper kv-pair notes to the credentials object
+    // so that any transaction using those credentials can access them
+    auth_user_request->user()->notes.appendNewOnly(&reply.notes);
+    // remove any private credentials detail which got added.
+    auth_user_request->user()->notes.remove("token");
+
     Auth::Negotiate::UserRequest *lm_request = dynamic_cast<Auth::Negotiate::UserRequest *>(auth_user_request.getRaw());
     assert(lm_request != NULL);
     assert(lm_request->waiting);
 
     lm_request->waiting = 0;
     safe_free(lm_request->client_blob);
 
     assert(auth_user_request->user() != NULL);
     assert(auth_user_request->user()->auth_type == Auth::AUTH_NEGOTIATE);
 
     if (lm_request->authserver == NULL)
-        lm_request->authserver = static_cast<helper_stateful_server*>(lastserver);
+        lm_request->authserver = reply.whichServer.get(); // XXX: no locking?
     else
-        assert(lm_request->authserver == lastserver);
-
-    /* seperate out the useful data */
-    blob = strchr(reply, ' ');
+        assert(reply.whichServer == lm_request->authserver);
 
-    if (blob) {
-        ++blob;
-        arg = strchr(blob + 1, ' ');
-    } else {
-        arg = NULL;
-    }
-
-    if (strncasecmp(reply, "TT ", 3) == 0) {
+    switch (reply.result) {
+    case HelperReply::TT:
         /* we have been given a blob to send to the client */
-        if (arg) {
-            *arg = '\0';
-            ++arg;
-        }
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.mustKeepalive = 1;
+        lm_request->request->flags.mustKeepalive = true;
         if (lm_request->request->flags.proxyKeepalive) {
-            lm_request->server_blob = xstrdup(blob);
+            const char *tokenNote = reply.notes.findFirst("token");
+            lm_request->server_blob = xstrdup(tokenNote);
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
-            debugs(29, 4, HERE << "Need to challenge the client with a server blob '" << blob << "'");
+            debugs(29, 4, HERE << "Need to challenge the client with a server token: '" << tokenNote << "'");
         } else {
             auth_user_request->user()->credentials(Auth::Failed);
-            auth_user_request->denyMessage("NTLM authentication requires a persistent connection");
+            auth_user_request->denyMessage("Negotiate authentication requires a persistent connection");
         }
-    } else if (strncasecmp(reply, "AF ", 3) == 0 && arg != NULL) {
-        /* we're finished, release the helper */
+        break;
 
-        if (arg) {
-            *arg = '\0';
-            ++arg;
+    case HelperReply::Okay: {
+        const char *userNote = reply.notes.findFirst("user");
+        const char *tokenNote = reply.notes.findFirst("token");
+        if (userNote == NULL || tokenNote == NULL) {
+            // XXX: handle a success with no username better
+            /* protocol error */
+            fatalf("authenticateNegotiateHandleReply: *** Unsupported helper response ***, '%s'\n", reply.other().content());
+            break;
         }
 
-        auth_user_request->user()->username(arg);
+        /* we're finished, release the helper */
+        auth_user_request->user()->username(userNote);
         auth_user_request->denyMessage("Login successful");
         safe_free(lm_request->server_blob);
-        lm_request->server_blob = xstrdup(blob);
+        lm_request->server_blob = xstrdup(tokenNote);
         lm_request->releaseAuthServer();
 
         /* connection is authenticated */
         debugs(29, 4, HERE << "authenticated user " << auth_user_request->user()->username());
         /* see if this is an existing user with a different proxy_auth
          * string */
@@ -333,64 +304,60 @@
             local_auth_user->addToNameCache();
         }
         /* set these to now because this is either a new login from an
          * existing user or a new user */
         local_auth_user->expiretime = current_time.tv_sec;
         auth_user_request->user()->credentials(Auth::Ok);
-        debugs(29, 4, HERE << "Successfully validated user via Negotiate. Username '" << blob << "'");
+        debugs(29, 4, HERE << "Successfully validated user via Negotiate. Username '" << auth_user_request->user()->username() << "'");
+    }
+    break;
 
-    } else if (strncasecmp(reply, "NA ", 3) == 0 && arg != NULL) {
-        /* authentication failure (wrong password, etc.) */
+    case HelperReply::Error: {
+        const char *messageNote = reply.notes.find("message");
+        const char *tokenNote = reply.notes.findFirst("token");
 
-        if (arg) {
-            *arg = '\0';
-            ++arg;
-        }
-
-        auth_user_request->denyMessage(arg);
+        /* authentication failure (wrong password, etc.) */
+        if (messageNote != NULL)
+            auth_user_request->denyMessage(messageNote);
+        else
+            auth_user_request->denyMessage("Negotiate Authentication denied with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
-        lm_request->server_blob = xstrdup(blob);
+        if (tokenNote != NULL)
+            lm_request->server_blob = xstrdup(tokenNote);
         lm_request->releaseAuthServer();
-        debugs(29, 4, HERE << "Failed validating user via Negotiate. Error returned '" << blob << "'");
-    } else if (strncasecmp(reply, "BH ", 3) == 0) {
+        debugs(29, 4, "Failed validating user via Negotiate. Result: " << reply);
+    }
+    break;
+
+    case HelperReply::Unknown:
+        debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication Helper '" << reply.whichServer << "' crashed!.");
+        /* continue to the next case */
+
+    case HelperReply::BrokenHelper: {
         /* TODO kick off a refresh process. This can occur after a YR or after
          * a KK. If after a YR release the helper and resubmit the request via
          * Authenticate Negotiate start.
          * If after a KK deny the user's request w/ 407 and mark the helper as
          * Needing YR. */
-        auth_user_request->denyMessage(blob);
+        const char *errNote = reply.notes.find("message");
+        if (reply.result == HelperReply::Unknown)
+            auth_user_request->denyMessage("Internal Error");
+        else if (errNote != NULL)
+            auth_user_request->denyMessage(errNote);
+        else
+            auth_user_request->denyMessage("Negotiate Authentication failed with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
-        debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication validating user. Error returned '" << reply << "'");
-    } else {
-        /* protocol error */
-        fatalf("authenticateNegotiateHandleReply: *** Unsupported helper response ***, '%s'\n", reply);
+        debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication validating user. Result: " << reply);
+    } // break;
     }
 
     if (lm_request->request) {
         HTTPMSGUNLOCK(lm_request->request);
         lm_request->request = NULL;
     }
     r->handler(r->data);
     delete r;
 }
 
-void
-Auth::Negotiate::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int accel)
-{
-    http_hdr_type type;
-
-    if (!server_blob)
-        return;
-
-    /* don't add to authentication error pages */
-    if ((!accel && rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-            || (accel && rep->sline.status == HTTP_UNAUTHORIZED))
-        return;
-
-    type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
-    httpHeaderPutStrf(&rep->header, type, "Negotiate %s", server_blob);
-
-    safe_free(server_blob);
-}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/negotiate/UserRequest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/negotiate/UserRequest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/negotiate/UserRequest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/negotiate/UserRequest.h	2015-05-01 18:05:19.000000000 +0800
@@ -23,17 +23,14 @@
 
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Direction module_direction();
-    virtual void onConnectionClose(ConnStateData *);
     virtual void module_start(AUTHCB *, void *);
 
-    virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
-
     virtual const char * connLastHeader();
 
     /* we need to store the helper server between requests */
     helper_stateful_server *authserver;
     void releaseAuthServer(void); ///< Release the authserver helper server properly.
 
@@ -49,13 +46,13 @@
     unsigned char waiting;
 
     /* need access to the request flags to mess around on pconn failure */
     HttpRequest *request;
 
 private:
-    static HLPSCB HandleReply;
+    static HLPCB HandleReply;
 };
 
 } // namespace Negotiate
 } // namespace Auth
 
 MEMPROXY_CLASS_INLINE(Auth::Negotiate::UserRequest);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/ntlm/auth_ntlm.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/ntlm/auth_ntlm.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/ntlm/auth_ntlm.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/ntlm/auth_ntlm.cc	2015-05-01 18:05:19.000000000 +0800
@@ -118,22 +118,22 @@
 Auth::Ntlm::Config::Config() : keep_alive(1)
 { }
 
 void
 Auth::Ntlm::Config::parse(Auth::Config * scheme, int n_configured, char *param_str)
 {
-    if (strcasecmp(param_str, "program") == 0) {
+    if (strcmp(param_str, "program") == 0) {
         if (authenticateProgram)
             wordlistDestroy(&authenticateProgram);
 
         parse_wordlist(&authenticateProgram);
 
         requirePathnameExists("auth_param ntlm program", authenticateProgram->key);
-    } else if (strcasecmp(param_str, "children") == 0) {
+    } else if (strcmp(param_str, "children") == 0) {
         authenticateChildren.parseConfig();
-    } else if (strcasecmp(param_str, "keep_alive") == 0) {
+    } else if (strcmp(param_str, "keep_alive") == 0) {
         parse_onoff(&keep_alive);
     } else {
         debugs(29, DBG_CRITICAL, "ERROR unrecognised NTLM auth scheme parameter '" << param_str << "'");
     }
 }
 
@@ -212,24 +212,24 @@
     if (auth_user_request == NULL) {
         debugs(29, 9, HERE << "Sending type:" << hdrType << " header: 'NTLM'");
         httpHeaderPutStrf(&rep->header, hdrType, "NTLM");
 
         if (!keep_alive) {
             /* drop the connection */
-            request->flags.proxyKeepalive = 0;
+            request->flags.proxyKeepalive = false;
         }
     } else {
         Auth::Ntlm::UserRequest *ntlm_request = dynamic_cast<Auth::Ntlm::UserRequest *>(auth_user_request.getRaw());
         assert(ntlm_request != NULL);
 
         switch (ntlm_request->user()->credentials()) {
 
         case Auth::Failed:
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
-            request->flags.proxyKeepalive = 0;
+            request->flags.proxyKeepalive = false;
             /* fall through */
 
         case Auth::Ok:
             /* Special case: authentication finished OK but disallowed by ACL.
              * Need to start over to give the client another chance.
              */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/ntlm/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/ntlm/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/ntlm/Makefile.in	2015-05-01 16:51:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/ntlm/Makefile.in	2015-05-01 18:06:52.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -451,12 +497,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -494,12 +541,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -526,27 +574,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -613,13 +664,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libntlm.la
 libntlm_la_SOURCES = \
 	Scheme.cc \
 	Scheme.h \
 	auth_ntlm.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/ntlm/UserRequest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/ntlm/UserRequest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/ntlm/UserRequest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/ntlm/UserRequest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -16,13 +16,13 @@
     authserver=NULL;
     request=NULL;
 }
 
 Auth::Ntlm::UserRequest::~UserRequest()
 {
-    assert(RefCountCount()==0);
+    assert(LockCount()==0);
     safe_free(server_blob);
     safe_free(client_blob);
 
     releaseAuthServer();
 
     if (request) {
@@ -120,32 +120,12 @@
         authserver = NULL;
     } else
         debugs(29, 6, HERE << "No NTLM auth server to release.");
 }
 
 void
-Auth::Ntlm::UserRequest::onConnectionClose(ConnStateData *conn)
-{
-    assert(conn != NULL);
-
-    debugs(29, 8, HERE << "closing connection '" << conn << "' (this is '" << this << "')");
-
-    if (conn->auth_user_request == NULL) {
-        debugs(29, 8, HERE << "no auth_user_request");
-        return;
-    }
-
-    releaseAuthServer();
-
-    /* unlock the connection based lock */
-    debugs(29, 9, HERE << "Unlocking auth_user from the connection '" << conn << "'.");
-
-    conn->auth_user_request = NULL;
-}
-
-void
 Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * conn, http_hdr_type type)
 {
     assert(this);
 
     /* Check that we are in the client side, where we can generate
      * auth challenges */
@@ -189,14 +169,14 @@
     case Auth::Unchecked:
         /* we've received a ntlm request. pass to a helper */
         debugs(29, 9, HERE << "auth state ntlm none. Received blob: '" << proxy_auth << "'");
         user()->credentials(Auth::Pending);
         safe_free(client_blob);
         client_blob=xstrdup(blob);
-        assert(conn->auth_user_request == NULL);
-        conn->auth_user_request = this;
+        assert(conn->getAuth() == NULL);
+        conn->setAuth(this, "new NTLM handshake request");
         request = aRequest;
         HTTPMSGLOCK(request);
         break;
 
     case Auth::Pending:
         debugs(29, DBG_IMPORTANT, HERE << "need to ask helper");
@@ -222,74 +202,81 @@
         debugs(29, 9, HERE << "auth state ntlm failed. " << proxy_auth);
         break;
     }
 }
 
 void
-Auth::Ntlm::UserRequest::HandleReply(void *data, void *lastserver, char *reply)
+Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
 {
     Auth::StateData *r = static_cast<Auth::StateData *>(data);
-    char *blob;
 
-    debugs(29, 8, HERE << "helper: '" << lastserver << "' sent us '" << (reply ? reply : "<NULL>") << "'");
+    debugs(29, 8, HERE << "helper: '" << reply.whichServer << "' sent us reply=" << reply);
 
     if (!cbdataReferenceValid(r->data)) {
-        debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication invalid callback data. helper '" << lastserver << "'.");
+        debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication invalid callback data. helper '" << reply.whichServer << "'.");
         delete r;
         return;
     }
 
-    if (!reply) {
-        debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication Helper '" << lastserver << "' crashed!.");
-        reply = (char *)"BH Internal error";
-    }
-
     Auth::UserRequest::Pointer auth_user_request = r->auth_user_request;
     assert(auth_user_request != NULL);
 
+    // add new helper kv-pair notes to the credentials object
+    // so that any transaction using those credentials can access them
+    auth_user_request->user()->notes.appendNewOnly(&reply.notes);
+    // remove any private credentials detail which got added.
+    auth_user_request->user()->notes.remove("token");
+
     Auth::Ntlm::UserRequest *lm_request = dynamic_cast<Auth::Ntlm::UserRequest *>(auth_user_request.getRaw());
     assert(lm_request != NULL);
     assert(lm_request->waiting);
 
     lm_request->waiting = 0;
     safe_free(lm_request->client_blob);
 
     assert(auth_user_request->user() != NULL);
     assert(auth_user_request->user()->auth_type == Auth::AUTH_NTLM);
 
     if (lm_request->authserver == NULL)
-        lm_request->authserver = static_cast<helper_stateful_server*>(lastserver);
+        lm_request->authserver = reply.whichServer.get(); // XXX: no locking?
     else
-        assert(lm_request->authserver == lastserver);
+        assert(reply.whichServer == lm_request->authserver);
 
-    /* seperate out the useful data */
-    blob = strchr(reply, ' ');
-    if (blob)
-        ++blob;
-
-    if (strncasecmp(reply, "TT ", 3) == 0) {
+    switch (reply.result) {
+    case HelperReply::TT:
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.mustKeepalive = 1;
+        lm_request->request->flags.mustKeepalive = true;
         if (lm_request->request->flags.proxyKeepalive) {
-            lm_request->server_blob = xstrdup(blob);
+            const char *serverBlob = reply.notes.findFirst("token");
+            lm_request->server_blob = xstrdup(serverBlob);
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
-            debugs(29, 4, HERE << "Need to challenge the client with a server blob '" << blob << "'");
+            debugs(29, 4, HERE << "Need to challenge the client with a server token: '" << serverBlob << "'");
         } else {
             auth_user_request->user()->credentials(Auth::Failed);
             auth_user_request->denyMessage("NTLM authentication requires a persistent connection");
         }
-    } else if (strncasecmp(reply, "AF ", 3) == 0) {
+        break;
+
+    case HelperReply::Okay: {
         /* we're finished, release the helper */
-        auth_user_request->user()->username(blob);
+        const char *userLabel = reply.notes.findFirst("user");
+        if (!userLabel) {
+            auth_user_request->user()->credentials(Auth::Failed);
+            safe_free(lm_request->server_blob);
+            lm_request->releaseAuthServer();
+            debugs(29, DBG_CRITICAL, "ERROR: NTLM Authentication helper returned no username. Result: " << reply);
+            break;
+        }
+        auth_user_request->user()->username(userLabel);
         auth_user_request->denyMessage("Login successful");
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
 
-        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << blob << "'");
+        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << userLabel << "'");
         /* connection is authenticated */
         debugs(29, 4, HERE << "authenticated user " << auth_user_request->user()->username());
         /* see if this is an existing user with a different proxy_auth
          * string */
         AuthUserHashPointer *usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, auth_user_request->user()->username()));
         Auth::User::Pointer local_auth_user = lm_request->user();
@@ -310,35 +297,53 @@
             local_auth_user->addToNameCache();
         }
         /* set these to now because this is either a new login from an
          * existing user or a new user */
         local_auth_user->expiretime = current_time.tv_sec;
         auth_user_request->user()->credentials(Auth::Ok);
-        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << blob << "'");
+        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << auth_user_request->user()->username() << "'");
+    }
+    break;
 
-    } else if (strncasecmp(reply, "NA ", 3) == 0) {
+    case HelperReply::Error: {
         /* authentication failure (wrong password, etc.) */
-        auth_user_request->denyMessage(blob);
+        const char *errNote = reply.notes.find("message");
+        if (errNote != NULL)
+            auth_user_request->denyMessage(errNote);
+        else
+            auth_user_request->denyMessage("NTLM Authentication denied with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
-        debugs(29, 4, HERE << "Failed validating user via NTLM. Error returned '" << blob << "'");
-    } else if (strncasecmp(reply, "BH ", 3) == 0) {
+        debugs(29, 4, "Failed validating user via NTLM. Result: " << reply);
+    }
+    break;
+
+    case HelperReply::Unknown:
+        debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication Helper '" << reply.whichServer << "' crashed!.");
+        /* continue to the next case */
+
+    case HelperReply::BrokenHelper: {
         /* TODO kick off a refresh process. This can occur after a YR or after
          * a KK. If after a YR release the helper and resubmit the request via
          * Authenticate NTLM start.
          * If after a KK deny the user's request w/ 407 and mark the helper as
          * Needing YR. */
-        auth_user_request->denyMessage(blob);
+        const char *errNote = reply.notes.find("message");
+        if (reply.result == HelperReply::Unknown)
+            auth_user_request->denyMessage("Internal Error");
+        else if (errNote != NULL)
+            auth_user_request->denyMessage(errNote);
+        else
+            auth_user_request->denyMessage("NTLM Authentication failed with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
-        debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication validating user. Error returned '" << reply << "'");
-    } else {
-        /* protocol error */
-        fatalf("authenticateNTLMHandleReply: *** Unsupported helper response ***, '%s'\n", reply);
+        debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication validating user. Result: " << reply);
+    }
+    break;
     }
 
     if (lm_request->request) {
         HTTPMSGUNLOCK(lm_request->request);
         lm_request->request = NULL;
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/ntlm/UserRequest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/ntlm/UserRequest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/ntlm/UserRequest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/ntlm/UserRequest.h	2015-05-01 18:05:19.000000000 +0800
@@ -23,20 +23,19 @@
 
     UserRequest();
     virtual ~UserRequest();
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Auth::Direction module_direction();
-    virtual void onConnectionClose(ConnStateData *);
     virtual void module_start(AUTHCB *, void *);
 
     virtual const char * connLastHeader();
 
     /* we need to store the helper server between requests */
     helper_stateful_server *authserver;
-    void releaseAuthServer(void); ///< Release authserver NTLM helpers properly when finished or abandoning.
+    virtual void releaseAuthServer(); ///< Release authserver NTLM helpers properly when finished or abandoning.
 
     /* our current blob to pass to the client */
     char *server_blob;
 
     /* our current blob to pass to the server */
     char *client_blob;
@@ -45,13 +44,13 @@
     unsigned char waiting;
 
     /* need access to the request flags to mess around on pconn failure */
     HttpRequest *request;
 
 private:
-    static HLPSCB HandleReply;
+    static HLPCB HandleReply;
 };
 
 } // namespace Ntlm
 } // namespace Auth
 
 MEMPROXY_CLASS_INLINE(Auth::Ntlm::UserRequest);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth: QueueNode.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/Scheme.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/Scheme.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/Scheme.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/Scheme.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,14 +30,14 @@
 
 #ifndef SQUID_AUTH_SCHEME_H
 #define SQUID_AUTH_SCHEME_H
 
 #if USE_AUTH
 
-#include "Array.h"
-#include "RefCount.h"
+#include "base/Vector.h"
+#include "base/RefCount.h"
 
 /**
  \defgroup AuthSchemeAPI	Authentication Scheme API
  \ingroup AuthAPI
  */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/State.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/State.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/State.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/State.h	2015-05-01 18:05:19.000000000 +0800
@@ -2,12 +2,13 @@
 #define __AUTH_AUTHENTICATE_STATE_T__
 
 #if USE_AUTH
 
 #include "auth/UserRequest.h"
 #include "cbdata.h"
+#include "helper.h"
 
 namespace Auth
 {
 
 /**
  * CBDATA state for NTLM, Negotiate, and Digest stateful authentication.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/User.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/User.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/User.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/User.cc	2015-05-01 18:05:19.000000000 +0800
@@ -55,12 +55,13 @@
 
 Auth::User::User(Auth::Config *aConfig) :
         auth_type(Auth::AUTH_UNKNOWN),
         config(aConfig),
         ipcount(0),
         expiretime(0),
+        notes(),
         credentials_state(Auth::Unchecked),
         username_(NULL)
 {
     proxy_auth_list.head = proxy_auth_list.tail = NULL;
     proxy_match_cache.head = proxy_match_cache.tail = NULL;
     ip_list.head = ip_list.tail = NULL;
@@ -96,19 +97,22 @@
      *  dlink_list proxy_auth_list;
      *  dlink_list proxy_match_cache;
      */
 
     debugs(29, 5, HERE << "auth_user '" << from << "' into auth_user '" << this << "'.");
 
+    // combine the helper response annotations. Ensuring no duplicates are copied.
+    notes.appendNewOnly(&from->notes);
+
     /* absorb the list of IP address sources (for max_user_ip controls) */
     AuthUserIP *new_ipdata;
     while (from->ip_list.head != NULL) {
         new_ipdata = static_cast<AuthUserIP *>(from->ip_list.head->data);
 
         /* If this IP has expired - ignore the expensive merge actions. */
-        if (new_ipdata->ip_expiretime + ::Config.authenticateIpTTL < squid_curtime) {
+        if (new_ipdata->ip_expiretime <= squid_curtime) {
             /* This IP has expired - remove from the source list */
             dlinkDelete(&new_ipdata->node, &(from->ip_list));
             cbdataFree(new_ipdata);
             /* catch incipient underflow */
             -- from->ipcount;
         } else {
@@ -121,13 +125,13 @@
                 if (ipdata->ipaddr == new_ipdata->ipaddr) {
                     /* This IP has already been seen. */
                     found = true;
                     /* update IP ttl and stop searching. */
                     ipdata->ip_expiretime = max(ipdata->ip_expiretime, new_ipdata->ip_expiretime);
                     break;
-                } else if (ipdata->ip_expiretime + ::Config.authenticateIpTTL < squid_curtime) {
+                } else if (ipdata->ip_expiretime <= squid_curtime) {
                     /* This IP has expired - cleanup the destination list */
                     dlinkDelete(&ipdata->node, &ip_list);
                     cbdataFree(ipdata);
                     /* catch incipient underflow */
                     assert(ipcount);
                     -- ipcount;
@@ -148,13 +152,13 @@
     }
 }
 
 Auth::User::~User()
 {
     debugs(29, 5, HERE << "Freeing auth_user '" << this << "'.");
-    assert(RefCountCount() == 0);
+    assert(LockCount() == 0);
 
     /* free cached acl results */
     aclCacheMatchFlush(&proxy_match_cache);
 
     /* free seen ip address's */
     clearIp();
@@ -220,13 +224,13 @@
         /* if we need to have indedendent expiry clauses, insert a module call
          * here */
         debugs(29, 4, HERE << "Cache entry:\n\tType: " <<
                auth_user->auth_type << "\n\tUsername: " << username <<
                "\n\texpires: " <<
                (long int) (auth_user->expiretime + ::Config.authenticateTTL) <<
-               "\n\treferences: " << (long int) auth_user->RefCountCount());
+               "\n\treferences: " << auth_user->LockCount());
 
         if (auth_user->expiretime + ::Config.authenticateTTL <= current_time.tv_sec) {
             debugs(29, 5, HERE << "Removing user " << username << " from cache due to timeout.");
 
             /* Old credentials are always removed. Existing users must hold their own
              * Auth::User::Pointer to the credentials. Cache exists only for finding
@@ -306,13 +310,13 @@
 
         if (ipdata->ipaddr == ipaddr) {
             /* This ip has already been seen. */
             found = 1;
             /* update IP ttl */
             ipdata->ip_expiretime = squid_curtime;
-        } else if (ipdata->ip_expiretime + ::Config.authenticateIpTTL < squid_curtime) {
+        } else if (ipdata->ip_expiretime <= squid_curtime) {
             /* This IP has expired - remove from the seen list */
             dlinkDelete(&ipdata->node, &ip_list);
             cbdataFree(ipdata);
             /* catch incipient underflow */
             assert(ipcount);
             -- ipcount;
@@ -324,13 +328,13 @@
     if (found)
         return;
 
     /* This ip is not in the seen list */
     ipdata = cbdataAlloc(AuthUserIP);
 
-    ipdata->ip_expiretime = squid_curtime;
+    ipdata->ip_expiretime = squid_curtime + ::Config.authenticateIpTTL;
 
     ipdata->ipaddr = ipaddr;
 
     dlinkAddTail(ipdata, &ipdata->node, &ip_list);
 
     ++ipcount;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/User.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/User.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/User.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/User.h	2015-05-01 18:05:19.000000000 +0800
@@ -33,15 +33,16 @@
 #define SQUID_AUTH_USER_H
 
 #if USE_AUTH
 
 #include "auth/CredentialState.h"
 #include "auth/Type.h"
+#include "base/RefCount.h"
 #include "dlink.h"
 #include "ip/Address.h"
-#include "RefCount.h"
+#include "Notes.h"
 
 class AuthUserHashPointer;
 class StoreEntry;
 
 namespace Auth
 {
@@ -72,12 +73,15 @@
     /** we may have many proxy-authenticate strings that decode to the same user */
     dlink_list proxy_auth_list;
     dlink_list proxy_match_cache;
     size_t ipcount;
     long expiretime;
 
+    /// list of key=value pairs the helper produced
+    NotePairs notes;
+
 public:
     static void cacheInit();
     static void CachedACLsReset();
 
     void absorb(Auth::User::Pointer from);
     virtual ~User();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/UserRequest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/UserRequest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/UserRequest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/UserRequest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -114,13 +114,13 @@
 {
     debugs(29, 5, HERE << "initialised request " << this);
 }
 
 Auth::UserRequest::~UserRequest()
 {
-    assert(RefCountCount()==0);
+    assert(LockCount()==0);
     debugs(29, 5, HERE << "freeing request " << this);
 
     if (user() != NULL) {
         /* release our references to the user credentials */
         user(NULL);
     }
@@ -218,13 +218,13 @@
 
 void
 Auth::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int accelerated)
 {}
 
 void
-Auth::UserRequest::onConnectionClose(ConnStateData *)
+Auth::UserRequest::releaseAuthServer()
 {}
 
 const char *
 Auth::UserRequest::connLastHeader()
 {
     fatal("Auth::UserRequest::connLastHeader should always be overridden by conn based auth schemes");
@@ -245,20 +245,33 @@
     auth_user_request->authenticate(request, conn, type);
 }
 
 static Auth::UserRequest::Pointer
 authTryGetUser(Auth::UserRequest::Pointer auth_user_request, ConnStateData * conn, HttpRequest * request)
 {
+    Auth::UserRequest::Pointer res;
+
     if (auth_user_request != NULL)
-        return auth_user_request;
+        res = auth_user_request;
     else if (request != NULL && request->auth_user_request != NULL)
-        return request->auth_user_request;
+        res = request->auth_user_request;
     else if (conn != NULL)
-        return conn->auth_user_request;
-    else
-        return NULL;
+        res = conn->getAuth();
+
+    // attach the credential notes from helper to the transaction
+    if (request != NULL && res != NULL && res->user() != NULL) {
+        // XXX: we have no access to the transaction / AccessLogEntry so cant SyncNotes().
+        // workaround by using anything already set in HttpRequest
+        // OR use new and rely on a later Sync copying these to AccessLogEntry
+        if (!request->notes)
+            request->notes = new NotePairs;
+
+        request->notes->appendNewOnly(&res->user()->notes);
+    }
+
+    return res;
 }
 
 /* returns one of
  * AUTH_ACL_CHALLENGE,
  * AUTH_ACL_HELPER,
  * AUTH_ACL_CANNOT_AUTHENTICATE,
@@ -300,65 +313,65 @@
         debugs(29, 4, HERE << "No Proxy-Auth header and no working alternative. Requesting auth header.");
 
         /* something wrong with the AUTH credentials. Force a new attempt */
 
         /* connection auth we must reset on auth errors */
         if (conn != NULL) {
-            conn->auth_user_request = NULL;
+            conn->setAuth(NULL, "HTTP request missing credentials");
         }
 
         *auth_user_request = NULL;
         return AUTH_ACL_CHALLENGE;
     }
 
     /*
      * Is this an already authenticated connection with a new auth header?
      * No check for function required in the if: its compulsory for conn based
      * auth modules
      */
-    if (proxy_auth && conn != NULL && conn->auth_user_request != NULL &&
-            authenticateUserAuthenticated(conn->auth_user_request) &&
-            conn->auth_user_request->connLastHeader() != NULL &&
-            strcmp(proxy_auth, conn->auth_user_request->connLastHeader())) {
+    if (proxy_auth && conn != NULL && conn->getAuth() != NULL &&
+            authenticateUserAuthenticated(conn->getAuth()) &&
+            conn->getAuth()->connLastHeader() != NULL &&
+            strcmp(proxy_auth, conn->getAuth()->connLastHeader())) {
         debugs(29, 2, "WARNING: DUPLICATE AUTH - authentication header on already authenticated connection!. AU " <<
-               conn->auth_user_request << ", Current user '" <<
-               conn->auth_user_request->username() << "' proxy_auth " <<
+               conn->getAuth() << ", Current user '" <<
+               conn->getAuth()->username() << "' proxy_auth " <<
                proxy_auth);
 
         /* remove this request struct - the link is already authed and it can't be to reauth. */
 
         /* This should _only_ ever occur on the first pass through
          * authenticateAuthenticate
          */
         assert(*auth_user_request == NULL);
-        conn->auth_user_request = NULL;
+        conn->setAuth(NULL, "changed credentials token");
     }
 
     /* we have a proxy auth header and as far as we know this connection has
      * not had bungled connection oriented authentication happen on it. */
     debugs(29, 9, HERE << "header " << (proxy_auth ? proxy_auth : "-") << ".");
 
     if (*auth_user_request == NULL) {
         if (conn != NULL) {
             debugs(29, 9, HERE << "This is a new checklist test on:" << conn->clientConnection);
         }
 
-        if (proxy_auth && request->auth_user_request == NULL && conn != NULL && conn->auth_user_request != NULL) {
+        if (proxy_auth && request->auth_user_request == NULL && conn != NULL && conn->getAuth() != NULL) {
             Auth::Config * scheme = Auth::Config::Find(proxy_auth);
 
-            if (conn->auth_user_request->user() == NULL || conn->auth_user_request->user()->config != scheme) {
+            if (conn->getAuth()->user() == NULL || conn->getAuth()->user()->config != scheme) {
                 debugs(29, DBG_IMPORTANT, "WARNING: Unexpected change of authentication scheme from '" <<
-                       conn->auth_user_request->user()->config->type() <<
+                       (conn->getAuth()->user()!=NULL?conn->getAuth()->user()->config->type():"[no user]") <<
                        "' to '" << proxy_auth << "' (client " <<
                        src_addr << ")");
 
-                conn->auth_user_request = NULL;
+                conn->setAuth(NULL, "changed auth scheme");
             }
         }
 
-        if (request->auth_user_request == NULL && (conn == NULL || conn->auth_user_request == NULL)) {
+        if (request->auth_user_request == NULL && (conn == NULL || conn->getAuth() == NULL)) {
             /* beginning of a new request check */
             debugs(29, 4, HERE << "No connection authentication type");
 
             *auth_user_request = Auth::Config::CreateAuthUser(proxy_auth);
             if (*auth_user_request == NULL)
                 return AUTH_ACL_CHALLENGE;
@@ -375,21 +388,17 @@
             }
 
         } else if (request->auth_user_request != NULL) {
             *auth_user_request = request->auth_user_request;
         } else {
             assert (conn != NULL);
-            if (conn->auth_user_request != NULL) {
-                *auth_user_request = conn->auth_user_request;
+            if (conn->getAuth() != NULL) {
+                *auth_user_request = conn->getAuth();
             } else {
                 /* failed connection based authentication */
-                debugs(29, 4, HERE << "Auth user request " <<
-                       *auth_user_request << " conn-auth user request " <<
-                       conn->auth_user_request << " conn type " <<
-                       conn->auth_user_request->user()->auth_type << " authentication failed.");
-
+                debugs(29, 4, HERE << "Auth user request " << *auth_user_request << " conn-auth missing and failed to authenticate.");
                 *auth_user_request = NULL;
                 return AUTH_ACL_CHALLENGE;
             }
         }
     }
 
@@ -476,20 +485,20 @@
 void
 Auth::UserRequest::addReplyAuthHeader(HttpReply * rep, Auth::UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal)
 /* send the auth types we are configured to support (and have compiled in!) */
 {
     http_hdr_type type;
 
-    switch (rep->sline.status) {
+    switch (rep->sline.status()) {
 
-    case HTTP_PROXY_AUTHENTICATION_REQUIRED:
+    case Http::scProxyAuthenticationRequired:
         /* Proxy authorisation needed */
         type = HDR_PROXY_AUTHENTICATE;
         break;
 
-    case HTTP_UNAUTHORIZED:
+    case Http::scUnauthorized:
         /* WWW Authorisation needed */
         type = HDR_WWW_AUTHENTICATE;
         break;
 
     default:
         /* Keep GCC happy */
@@ -497,29 +506,32 @@
         type = HDR_ENUM_END;
         break;
     }
 
     debugs(29, 9, HERE << "headertype:" << type << " authuser:" << auth_user_request);
 
-    if (((rep->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED)
-            || (rep->sline.status == HTTP_UNAUTHORIZED)) && internal)
+    if (((rep->sline.status() == Http::scProxyAuthenticationRequired)
+            || (rep->sline.status() == Http::scUnauthorized)) && internal)
         /* this is a authenticate-needed response */
     {
 
         if (auth_user_request != NULL && auth_user_request->direction() == Auth::CRED_CHALLENGE)
             /* add the scheme specific challenge header to the response */
             auth_user_request->user()->config->fixHeader(auth_user_request, rep, type, request);
         else {
             /* call each configured & running authscheme */
 
             for (Auth::ConfigVector::iterator  i = Auth::TheConfig.begin(); i != Auth::TheConfig.end(); ++i) {
                 Auth::Config *scheme = *i;
 
-                if (scheme->active())
-                    scheme->fixHeader(NULL, rep, type, request);
-                else
+                if (scheme->active()) {
+                    if (auth_user_request != NULL && auth_user_request->scheme()->type() == scheme->type())
+                        scheme->fixHeader(auth_user_request, rep, type, request);
+                    else
+                        scheme->fixHeader(NULL, rep, type, request);
+                } else
                     debugs(29, 4, HERE << "Configured scheme " << scheme->type() << " not Active");
             }
         }
 
     }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/UserRequest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/UserRequest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/auth/UserRequest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/auth/UserRequest.h	2015-05-01 18:05:19.000000000 +0800
@@ -34,33 +34,43 @@
 
 #include "auth/AuthAclState.h"
 #include "auth/Scheme.h"
 #include "auth/User.h"
 #include "dlink.h"
 #include "ip/Address.h"
-#include "typedefs.h"
+#include "helper.h"
 #include "HttpHeader.h"
 
 class ConnStateData;
 class HttpReply;
 class HttpRequest;
 
 /**
  * Maximum length (buffer size) for token strings.
  */
 // AYJ: must match re-definition in helpers/negotiate_auth/kerberos/negotiate_kerb_auth.cc
 #define MAX_AUTHTOKEN_LEN   32768
 
-/// \ingroup AuthAPI
+/**
+ * Node used to link an IP address to some user credentials
+ * for the max_user_ip ACL feature.
+ *
+ * \ingroup AuthAPI
+ */
 class AuthUserIP
 {
 public:
     dlink_node node;
-    /* IP addr this user authenticated from */
 
+    /// IP address this user authenticated from
     Ip::Address ipaddr;
+
+    /** When this IP should be forgotten.
+     * Set to the time of last request made from this
+     * (user,IP) pair plus authenticate_ip_ttl seconds
+     */
     time_t ip_expiretime;
 };
 
 // TODO: make auth schedule AsyncCalls?
 typedef void AUTHCB(void*);
 
@@ -142,13 +152,13 @@
     /* add the [Proxy-]Authentication-Info header */
     virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
 
     /* add the [Proxy-]Authentication-Info trailer */
     virtual void addAuthenticationInfoTrailer(HttpReply * rep, int accel);
 
-    virtual void onConnectionClose(ConnStateData *);
+    virtual void releaseAuthServer();
 
     /**
      * Called when squid is ready to put the request on hold and wait for a callback from the auth module
      * when the auth module has performed it's external activities.
      *
      * \param handler	Handler to process the callback when its run
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/base/CbcPointer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base/CbcPointer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/base/CbcPointer.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base/CbcPointer.h	2015-05-01 18:05:19.000000000 +0800
@@ -132,22 +132,22 @@
 
 template<class Cbc>
 Cbc &
 CbcPointer<Cbc>::operator *() const
 {
     Cbc *c = get();
-    Must(c);
+    assert(c);
     return *c;
 }
 
 template<class Cbc>
 Cbc *
 CbcPointer<Cbc>::operator ->() const
 {
     Cbc *c = get();
-    Must(c);
+    assert(c);
     return c;
 }
 
 template <class Cbc>
 std::ostream &CbcPointer<Cbc>::print(std::ostream &os) const
 {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base: Lock.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base: LruMap.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/base/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/base/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -13,12 +12,16 @@
 	AsyncJobCalls.h \
 	AsyncCallQueue.cc \
 	AsyncCallQueue.h \
 	TidyPointer.h \
 	CbcPointer.h \
 	InstanceId.h \
+	Lock.h \
+	LruMap.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
-	StringArea.h
+	StringArea.h \
+	Vector.cc \
+	Vector.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/base/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/base/Makefile.in	2015-05-01 16:51:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base/Makefile.in	2015-05-01 18:06:52.000000000 +0800
@@ -90,25 +90,71 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LTLIBRARIES = $(noinst_LTLIBRARIES)
 libbase_la_LIBADD =
 am_libbase_la_OBJECTS = AsyncCall.lo AsyncJob.lo AsyncCallQueue.lo \
-	RunnersRegistry.lo TextException.lo
+	RunnersRegistry.lo TextException.lo Vector.lo
 libbase_la_OBJECTS = $(am_libbase_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
@@ -452,12 +498,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -495,12 +542,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -527,27 +575,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -614,13 +665,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libbase.la
 libbase_la_SOURCES = \
 	AsyncCall.cc \
 	AsyncCall.h \
 	AsyncCbdataCalls.h \
@@ -629,18 +680,22 @@
 	AsyncJobCalls.h \
 	AsyncCallQueue.cc \
 	AsyncCallQueue.h \
 	TidyPointer.h \
 	CbcPointer.h \
 	InstanceId.h \
+	Lock.h \
+	LruMap.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
 	TextException.cc \
 	TextException.h \
-	StringArea.h
+	StringArea.h \
+	Vector.cc \
+	Vector.h
 
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(top_srcdir)/src/TestHeaders.am $(am__configure_deps)
@@ -706,12 +761,13 @@
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/AsyncCall.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/AsyncCallQueue.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/AsyncJob.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/RunnersRegistry.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TextException.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Vector.Plo@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
 @am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base: RefCount.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/base/StringArea.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base/StringArea.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/base/StringArea.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base/StringArea.h	2015-05-01 18:05:19.000000000 +0800
@@ -32,12 +32,13 @@
 #ifndef SQUID_STRINGAREA_H
 #define SQUID_STRINGAREA_H
 
 #if HAVE_CSTRING
 #include <cstring>
 #endif
+#include <ostream>
 
 /** A char* plus length combination. Useful for temporary storing
  * and quickly looking up strings.
  *
  * The pointed-to string may not be null-terminated.
  * The pointed-to string is not copied.
@@ -53,14 +54,23 @@
     bool operator==(const StringArea &s) const { return theLen==s.theLen && memcmp(theStart,s.theStart,theLen)==0; }
     bool operator!=(const StringArea &s) const { return !operator==(s); }
     bool operator< ( const StringArea &s) const {
         return (theLen < s.theLen || (theLen == s.theLen && memcmp(theStart,s.theStart,theLen) < 0)) ;
     }
 
+    void print(std::ostream &os) const { os.write(theStart, theLen); }
+
 private:
     /// pointed to the externally-managed memory area
     const char *theStart;
     /// length of the string
     size_t theLen;
 };
 
+inline std::ostream &
+operator <<(std::ostream &os, const StringArea &a)
+{
+    a.print(os);
+    return os;
+}
+
 #endif /* SQUID_STRINGAREA_H */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base: Vector.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/base: Vector.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cache_cf.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cache_cf.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cache_cf.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cache_cf.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,12 +35,13 @@
 #include "acl/AclAddress.h"
 #include "acl/AclDenyInfoList.h"
 #include "acl/AclNameList.h"
 #include "acl/AclSizeLimit.h"
 #include "acl/Gadgets.h"
 #include "acl/MethodData.h"
+#include "acl/Tree.h"
 #include "anyp/PortCfg.h"
 #include "AuthReg.h"
 #include "base/RunnersRegistry.h"
 #include "mgr/ActionPasswordList.h"
 #include "CachePeer.h"
 #include "CachePeerDomainList.h"
@@ -110,15 +111,12 @@
 #if HAVE_LIMITS_H
 #include <limits>
 #endif
 #if HAVE_LIST
 #include <list>
 #endif
-#if HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
 #if HAVE_PWD_H
 #include <pwd.h>
 #endif
 #if HAVE_GRP_H
 #include <grp.h>
 #endif
@@ -131,15 +129,12 @@
 #endif
 
 #if USE_ADAPTATION
 static void parse_adaptation_service_set_type();
 static void parse_adaptation_service_chain_type();
 static void parse_adaptation_access_type();
-static void parse_adaptation_meta_type(Adaptation::Config::MetaHeaders *);
-static void dump_adaptation_meta_type(StoreEntry *, const char *, Adaptation::Config::MetaHeaders &);
-static void free_adaptation_meta_type(Adaptation::Config::MetaHeaders *);
 #endif
 
 #if ICAP_CLIENT
 static void parse_icap_service_type(Adaptation::Icap::Config *);
 static void dump_icap_service_type(StoreEntry *, const char *, const Adaptation::Icap::Config &);
 static void free_icap_service_type(Adaptation::Icap::Config *);
@@ -180,12 +175,13 @@
 static const char *const list_sep = ", \t\n\r";
 
 static void parse_access_log(CustomLog ** customlog_definitions);
 static int check_null_access_log(CustomLog *customlog_definitions);
 static void dump_access_log(StoreEntry * entry, const char *name, CustomLog * definitions);
 static void free_access_log(CustomLog ** definitions);
+static bool setLogformat(CustomLog *cl, const char *name, const bool dieWhenMissing);
 
 static void update_maxobjsize(void);
 static void configDoConfigure(void);
 static void parse_refreshpattern(RefreshPattern **);
 static uint64_t parseTimeUnits(const char *unit,  bool allowMsec);
 static void parseTimeLine(time_msec_t * tptr, const char *units, bool allowMsec);
@@ -216,12 +212,15 @@
 static void parse_http_header_replace(HeaderManglers **manglers);
 #define free_http_header_replace free_HeaderManglers
 #endif
 static void dump_HeaderWithAclList(StoreEntry * entry, const char *name, HeaderWithAclList *headers);
 static void parse_HeaderWithAclList(HeaderWithAclList **header);
 static void free_HeaderWithAclList(HeaderWithAclList **header);
+static void parse_note(Notes *);
+static void dump_note(StoreEntry *, const char *, Notes &);
+static void free_note(Notes *);
 static void parse_denyinfo(AclDenyInfoList ** var);
 static void dump_denyinfo(StoreEntry * entry, const char *name, AclDenyInfoList * var);
 static void free_denyinfo(AclDenyInfoList ** var);
 
 #if USE_WCCPv2
 static void parse_IpAddress_list(Ip::Address_list **);
@@ -674,13 +673,13 @@
         Config.Store.maxObjectSize = 0x7FFF0000;
     }
 #endif
 
     if (Config.Announce.period > 0) {
         Config.onoff.announce = 1;
-    } else if (Config.Announce.period < 1) {
+    } else {
         Config.Announce.period = 86400 * 365;	/* one year */
         Config.onoff.announce = 0;
     }
 
     if (Config.onoff.httpd_suppress_version_string)
         visible_appname_string = (char *)appname_string;
@@ -696,12 +695,19 @@
         if (Config.redirectChildren.n_max < 1) {
             Config.redirectChildren.n_max = 0;
             wordlistDestroy(&Config.Program.redirect);
         }
     }
 
+    if (Config.Program.store_id) {
+        if (Config.storeIdChildren.n_max < 1) {
+            Config.storeIdChildren.n_max = 0;
+            wordlistDestroy(&Config.Program.store_id);
+        }
+    }
+
     if (Config.appendDomain)
         if (*Config.appendDomain != '.')
             fatal("append_domain must begin with a '.'");
 
     if (Config.errHtmlText == NULL)
         Config.errHtmlText = xstrdup(null_string);
@@ -714,12 +720,13 @@
     if (Config.max_filedescriptors > FD_SETSIZE) {
         debugs(0, DBG_IMPORTANT, "WARNING: max_filedescriptors limited to " << FD_SETSIZE << " by select() algorithm.");
     }
 #endif
 
     storeConfigure();
+    update_maxobjsize(); // check for late maximum_object_size directive
 
     snprintf(ThisCache, sizeof(ThisCache), "%s (%s)",
              uniqueHostname(),
              visible_appname_string);
 
     /*
@@ -758,12 +765,15 @@
     requirePathnameExists("unlinkd_program", Config.Program.unlinkd);
 #endif
     requirePathnameExists("logfile_daemon", Log::TheConfig.logfile_daemon);
     if (Config.Program.redirect)
         requirePathnameExists("redirect_program", Config.Program.redirect->key);
 
+    if (Config.Program.store_id)
+        requirePathnameExists("store_id_program", Config.Program.store_id->key);
+
     requirePathnameExists("Icon Directory", Config.icons.directory);
 
     if (Config.errorDirectory)
         requirePathnameExists("Error Directory", Config.errorDirectory);
 
 #if USE_HTTP_VIOLATIONS
@@ -880,22 +890,24 @@
 
             Config2.effectiveUserID = pwd->pw_uid;
 
             Config2.effectiveGroupID = pwd->pw_gid;
 
 #if HAVE_PUTENV
-
             if (pwd->pw_dir && *pwd->pw_dir) {
-                int len;
-                char *env_str = (char *)xcalloc((len = strlen(pwd->pw_dir) + 6), 1);
-                snprintf(env_str, len, "HOME=%s", pwd->pw_dir);
-                putenv(env_str);
+                // putenv() leaks by design; avoid leaks when nothing changes
+                static String lastDir;
+                if (!lastDir.size() || lastDir != pwd->pw_dir) {
+                    lastDir = pwd->pw_dir;
+                    int len = strlen(pwd->pw_dir) + 6;
+                    char *env_str = (char *)xcalloc(len, 1);
+                    snprintf(env_str, len, "HOME=%s", pwd->pw_dir);
+                    putenv(env_str);
+                }
             }
-
 #endif
-
         }
     } else {
         Config2.effectiveUserID = geteuid();
         Config2.effectiveGroupID = getegid();
     }
 
@@ -909,13 +921,12 @@
             return;
         }
 
         Config2.effectiveGroupID = grp->gr_gid;
     }
 
-    HttpRequestMethod::Configure(Config);
 #if USE_SSL
 
     debugs(3, DBG_IMPORTANT, "Initializing https proxy context");
 
     Config.ssl_client.sslContext = sslCreateClientContext(Config.ssl_client.cert, Config.ssl_client.key, Config.ssl_client.version, Config.ssl_client.cipher, Config.ssl_client.options, Config.ssl_client.flags, Config.ssl_client.cafile, Config.ssl_client.capath, Config.ssl_client.crlfile);
 
@@ -924,13 +935,13 @@
             debugs(3, DBG_IMPORTANT, "Initializing cache_peer " << p->name << " SSL context");
             p->sslContext = sslCreateClientContext(p->sslcert, p->sslkey, p->sslversion, p->sslcipher, p->ssloptions, p->sslflags, p->sslcafile, p->sslcapath, p->sslcrlfile);
         }
     }
 
     for (AnyP::PortCfg *s = Config.Sockaddr.http; s != NULL; s = s->next) {
-        if (!s->sslBump)
+        if (!s->flags.tunnelSslBumping)
             continue;
 
         debugs(3, DBG_IMPORTANT, "Initializing http_port " << s->s << " SSL context");
         s->configureSslServerContext();
     }
 
@@ -946,26 +957,36 @@
     if (Config.maxRequestBufferSize <= Config.maxRequestHeaderSize) {
         fatalf("Client request buffer of %u bytes cannot hold a request with %u bytes of headers." \
                " Change client_request_buffer_max or request_header_max_size limits.",
                (uint32_t)Config.maxRequestBufferSize, (uint32_t)Config.maxRequestHeaderSize);
     }
 
+    /*
+     * Disable client side request pipelining if client_persistent_connections OFF.
+     * Waste of resources queueing any pipelined requests when the first will close the connection.
+     */
+    if (Config.pipeline_max_prefetch > 0 && !Config.onoff.client_pconns) {
+        debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: pipeline_prefetch " << Config.pipeline_max_prefetch <<
+               " requires client_persistent_connections ON. Forced pipeline_prefetch 0.");
+        Config.pipeline_max_prefetch = 0;
+    }
+
 #if USE_AUTH
     /*
      * disable client side request pipelining. There is a race with
      * Negotiate and NTLM when the client sends a second request on an
      * connection before the authenticate challenge is sent. With
      * pipelining OFF, the client may fail to authenticate, but squid's
      * state will be preserved.
      */
-    if (Config.onoff.pipeline_prefetch) {
+    if (Config.pipeline_max_prefetch > 0) {
         Auth::Config *nego = Auth::Config::Find("Negotiate");
         Auth::Config *ntlm = Auth::Config::Find("NTLM");
         if ((nego && nego->active()) || (ntlm && ntlm->active())) {
-            debugs(3, DBG_IMPORTANT, "WARNING: pipeline_prefetch breaks NTLM and Negotiate authentication. Forced OFF.");
-            Config.onoff.pipeline_prefetch = 0;
+            debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: pipeline_prefetch breaks NTLM and Negotiate authentication. Forced pipeline_prefetch 0.");
+            Config.pipeline_max_prefetch = 0;
         }
     }
 #endif
 }
 
 /** Parse a line containing an obsolete directive.
@@ -982,12 +1003,18 @@
         int cval;
         parse_int(&cval);
         debugs(3, DBG_CRITICAL, "WARNING: url_rewrite_concurrency upgrade overriding url_rewrite_children settings.");
         Config.redirectChildren.concurrency = cval;
     }
 
+    if (!strcmp(name, "log_access"))
+        self_destruct();
+
+    if (!strcmp(name, "log_icap"))
+        self_destruct();
+
     if (!strcmp(name, "ignore_ims_on_miss")) {
         // the replacement directive cache_revalidate_on_miss has opposite meanings for ON/OFF value
         // than the 2.7 directive. We need to parse and invert the configured value.
         int temp = 0;
         parse_onoff(&temp);
         Config.onoff.cache_miss_revalidate = !temp;
@@ -1210,13 +1237,12 @@
                d << " " << token << ": integer overflow (ssize_t).");
         self_destruct();
     }
 }
 #endif
 
-#if USE_SSL
 /**
  * Parse bytes from a string.
  * Similar to the parseBytesLine function but parses the string value instead of
  * the current token value.
  */
 static void parseBytesOptionValue(size_t * bptr, const char *units, char const * value)
@@ -1246,13 +1272,12 @@
     }
 
     *bptr = static_cast<size_t>(m * d / u);
     if (static_cast<double>(*bptr) * 2 != (m * d / u) * 2)
         self_destruct();
 }
-#endif
 
 static size_t
 parseBytesUnits(const char *unit)
 {
     if (!strncasecmp(unit, B_BYTES_STR, strlen(B_BYTES_STR)))
         return 1;
@@ -1273,30 +1298,31 @@
 
 /*****************************************************************************
  * Max
  *****************************************************************************/
 
 static void
-dump_acl(StoreEntry * entry, const char *name, ACL * ae)
+dump_wordlist(StoreEntry * entry, wordlist *words)
 {
-    wordlist *w;
-    wordlist *v;
+    for (wordlist *word = words; word; word = word->next)
+        // XXX: use something like ConfigParser::QuoteString() here
+        storeAppendPrintf(entry, "%s ", word->key);
+}
 
+static void
+dump_acl(StoreEntry * entry, const char *name, ACL * ae)
+{
     while (ae != NULL) {
         debugs(3, 3, "dump_acl: " << name << " " << ae->name);
-        storeAppendPrintf(entry, "%s %s %s ",
+        storeAppendPrintf(entry, "%s %s %s %s ",
                           name,
                           ae->name,
-                          ae->typeString());
-        v = w = ae->dump();
-
-        while (v != NULL) {
-            debugs(3, 3, "dump_acl: " << name << " " << ae->name << " " << v->key);
-            storeAppendPrintf(entry, "%s ", v->key);
-            v = v->next;
-        }
+                          ae->typeString(),
+                          ae->flags.flagsStr());
+        wordlist *w = ae->dump();
+        dump_wordlist(entry, w);
 
         storeAppendPrintf(entry, "\n");
         wordlistDestroy(&w);
         ae = ae->next;
     }
 }
@@ -1313,52 +1339,44 @@
     aclDestroyAcls(ae);
 }
 
 void
 dump_acl_list(StoreEntry * entry, ACLList * head)
 {
-    ACLList *l;
-
-    for (l = head; l; l = l->next) {
-        storeAppendPrintf(entry, " %s%s",
-                          l->op ? null_string : "!",
-                          l->_acl->name);
-    }
+    wordlist *values = head->dump();
+    dump_wordlist(entry, values);
+    wordlistDestroy(&values);
 }
 
 void
 dump_acl_access(StoreEntry * entry, const char *name, acl_access * head)
 {
-    acl_access *l;
-
-    for (l = head; l; l = l->next) {
-        storeAppendPrintf(entry, "%s %s",
-                          name,
-                          l->allow ? "Allow" : "Deny");
-        dump_acl_list(entry, l->aclList);
-        storeAppendPrintf(entry, "\n");
+    if (head) {
+        wordlist *lines = head->treeDump(name, NULL);
+        dump_wordlist(entry, lines);
+        wordlistDestroy(&lines);
     }
 }
 
 static void
 parse_acl_access(acl_access ** head)
 {
-    aclParseAccessLine(LegacyParser, head);
+    aclParseAccessLine(cfg_directive, LegacyParser, head);
 }
 
 static void
 free_acl_access(acl_access ** head)
 {
     aclDestroyAccessList(head);
 }
 
 static void
 dump_address(StoreEntry * entry, const char *name, Ip::Address &addr)
 {
     char buf[MAX_IPSTRLEN];
-    storeAppendPrintf(entry, "%s %s\n", name, addr.NtoA(buf,MAX_IPSTRLEN) );
+    storeAppendPrintf(entry, "%s %s\n", name, addr.toStr(buf,MAX_IPSTRLEN) );
 }
 
 static void
 parse_address(Ip::Address *addr)
 {
     char *token = strtok(NULL, w_space);
@@ -1366,15 +1384,15 @@
     if (!token) {
         self_destruct();
         return;
     }
 
     if (!strcmp(token,"any_addr"))
-        addr->SetAnyAddr();
+        addr->setAnyAddr();
     else if ( (!strcmp(token,"no_addr")) || (!strcmp(token,"full_mask")) )
-        addr->SetNoAddr();
+        addr->setNoAddr();
     else if ( (*addr = token) ) // try parse numeric/IPA
         (void) 0;
     else if (addr->GetHostByName(token)) // dont use ipcache
         (void) 0;
     else { // not an IP and not a hostname
         debugs(3, DBG_CRITICAL, "FATAL: invalid IP address or domain name '" << token << "'");
@@ -1382,26 +1400,26 @@
     }
 }
 
 static void
 free_address(Ip::Address *addr)
 {
-    addr->SetEmpty();
+    addr->setEmpty();
 }
 
 CBDATA_TYPE(AclAddress);
 
 static void
 dump_acl_address(StoreEntry * entry, const char *name, AclAddress * head)
 {
     char buf[MAX_IPSTRLEN];
     AclAddress *l;
 
     for (l = head; l; l = l->next) {
-        if (!l->addr.IsAnyAddr())
-            storeAppendPrintf(entry, "%s %s", name, l->addr.NtoA(buf,MAX_IPSTRLEN));
+        if (!l->addr.isAnyAddr())
+            storeAppendPrintf(entry, "%s %s", name, l->addr.toStr(buf,MAX_IPSTRLEN));
         else
             storeAppendPrintf(entry, "%s autoselect", name);
 
         dump_acl_list(entry, l->aclList);
 
         storeAppendPrintf(entry, "\n");
@@ -1420,13 +1438,13 @@
 {
     AclAddress *l;
     AclAddress **tail = head;	/* sane name below */
     CBDATA_INIT_TYPE_FREECB(AclAddress, freed_acl_address);
     l = cbdataAlloc(AclAddress);
     parse_address(&l->addr);
-    aclParseAclList(LegacyParser, &l->aclList);
+    aclParseAclList(LegacyParser, &l->aclList, l->addr);
 
     while (*tail)
         tail = &(*tail)->next;
 
     *tail = l;
 }
@@ -1488,13 +1506,13 @@
     CBDATA_INIT_TYPE_FREECB(acl_tos, freed_acl_tos);
 
     l = cbdataAlloc(acl_tos);
 
     l->tos = (tos_t)tos;
 
-    aclParseAclList(LegacyParser, &l->aclList);
+    aclParseAclList(LegacyParser, &l->aclList, token);
 
     while (*tail)
         tail = &(*tail)->next;
 
     *tail = l;
 }
@@ -1559,13 +1577,13 @@
     CBDATA_INIT_TYPE_FREECB(acl_nfmark, freed_acl_nfmark);
 
     l = cbdataAlloc(acl_nfmark);
 
     l->nfmark = mark;
 
-    aclParseAclList(LegacyParser, &l->aclList);
+    aclParseAclList(LegacyParser, &l->aclList, token);
 
     while (*tail)
         tail = &(*tail)->next;
 
     *tail = l;
 }
@@ -1617,13 +1635,13 @@
     CBDATA_INIT_TYPE_FREECB(AclSizeLimit, freed_acl_b_size_t);
 
     l = cbdataAlloc(AclSizeLimit);
 
     parse_b_int64_t(&l->size);
 
-    aclParseAclList(LegacyParser, &l->aclList);
+    aclParseAclList(LegacyParser, &l->aclList, l->size);
 
     while (*tail)
         tail = &(*tail)->next;
 
     *tail = l;
 }
@@ -1754,13 +1772,16 @@
 
     if (!*pm)
         *pm = new HeaderManglers;
     HeaderManglers *manglers = *pm;
     headerMangler *mangler = manglers->track(t);
     assert(mangler);
-    parse_acl_access(&mangler->access_list);
+
+    std::string directive = "http_header_access ";
+    directive += t;
+    aclParseAccessLine(directive.c_str(), LegacyParser, &mangler->access_list);
 }
 
 static void
 free_HeaderManglers(HeaderManglers **pm)
 {
     // we delete the entire http_header_* mangler configuration at once
@@ -2117,170 +2138,170 @@
     if ((token = strtok(NULL, w_space)) == NULL)
         self_destruct();
 
     p->type = parseNeighborType(token);
 
     if (p->type == PEER_MULTICAST) {
-        p->options.no_digest = 1;
-        p->options.no_netdb_exchange = 1;
+        p->options.no_digest = true;
+        p->options.no_netdb_exchange = true;
     }
 
     p->http_port = GetTcpService();
 
     if (!p->http_port)
         self_destruct();
 
     p->icp.port = GetUdpService();
     p->connection_auth = 2;    /* auto */
 
     while ((token = strtok(NULL, w_space))) {
-        if (!strcasecmp(token, "proxy-only")) {
-            p->options.proxy_only = 1;
-        } else if (!strcasecmp(token, "no-query")) {
-            p->options.no_query = 1;
-        } else if (!strcasecmp(token, "background-ping")) {
-            p->options.background_ping = 1;
-        } else if (!strcasecmp(token, "no-digest")) {
-            p->options.no_digest = 1;
-        } else if (!strcasecmp(token, "no-tproxy")) {
-            p->options.no_tproxy = 1;
-        } else if (!strcasecmp(token, "multicast-responder")) {
-            p->options.mcast_responder = 1;
+        if (!strcmp(token, "proxy-only")) {
+            p->options.proxy_only = true;
+        } else if (!strcmp(token, "no-query")) {
+            p->options.no_query = true;
+        } else if (!strcmp(token, "background-ping")) {
+            p->options.background_ping = true;
+        } else if (!strcmp(token, "no-digest")) {
+            p->options.no_digest = true;
+        } else if (!strcmp(token, "no-tproxy")) {
+            p->options.no_tproxy = true;
+        } else if (!strcmp(token, "multicast-responder")) {
+            p->options.mcast_responder = true;
 #if PEER_MULTICAST_SIBLINGS
-        } else if (!strcasecmp(token, "multicast-siblings")) {
-            p->options.mcast_siblings = 1;
+        } else if (!strcmp(token, "multicast-siblings")) {
+            p->options.mcast_siblings = true;
 #endif
-        } else if (!strncasecmp(token, "weight=", 7)) {
+        } else if (!strncmp(token, "weight=", 7)) {
             p->weight = xatoi(token + 7);
-        } else if (!strncasecmp(token, "basetime=", 9)) {
+        } else if (!strncmp(token, "basetime=", 9)) {
             p->basetime = xatoi(token + 9);
-        } else if (!strcasecmp(token, "closest-only")) {
-            p->options.closest_only = 1;
-        } else if (!strncasecmp(token, "ttl=", 4)) {
+        } else if (!strcmp(token, "closest-only")) {
+            p->options.closest_only = true;
+        } else if (!strncmp(token, "ttl=", 4)) {
             p->mcast.ttl = xatoi(token + 4);
 
             if (p->mcast.ttl < 0)
                 p->mcast.ttl = 0;
 
             if (p->mcast.ttl > 128)
                 p->mcast.ttl = 128;
-        } else if (!strcasecmp(token, "default")) {
-            p->options.default_parent = 1;
-        } else if (!strcasecmp(token, "round-robin")) {
-            p->options.roundrobin = 1;
-        } else if (!strcasecmp(token, "weighted-round-robin")) {
-            p->options.weighted_roundrobin = 1;
+        } else if (!strcmp(token, "default")) {
+            p->options.default_parent = true;
+        } else if (!strcmp(token, "round-robin")) {
+            p->options.roundrobin = true;
+        } else if (!strcmp(token, "weighted-round-robin")) {
+            p->options.weighted_roundrobin = true;
 #if USE_HTCP
-        } else if (!strcasecmp(token, "htcp")) {
-            p->options.htcp = 1;
-        } else if (!strncasecmp(token, "htcp=", 5) || !strncasecmp(token, "htcp-", 5)) {
+        } else if (!strcmp(token, "htcp")) {
+            p->options.htcp = true;
+        } else if (!strncmp(token, "htcp=", 5) || !strncmp(token, "htcp-", 5)) {
             /* Note: The htcp- form is deprecated, replaced by htcp= */
-            p->options.htcp = 1;
+            p->options.htcp = true;
             char *tmp = xstrdup(token+5);
             char *mode, *nextmode;
             for (mode = nextmode = tmp; mode; mode = nextmode) {
                 nextmode = strchr(mode, ',');
                 if (nextmode) {
                     *nextmode = '\0';
                     ++nextmode;
                 }
-                if (!strcasecmp(mode, "no-clr")) {
+                if (!strcmp(mode, "no-clr")) {
                     if (p->options.htcp_only_clr)
                         fatalf("parse_peer: can't set htcp-no-clr and htcp-only-clr simultaneously");
-                    p->options.htcp_no_clr = 1;
-                } else if (!strcasecmp(mode, "no-purge-clr")) {
-                    p->options.htcp_no_purge_clr = 1;
-                } else if (!strcasecmp(mode, "only-clr")) {
+                    p->options.htcp_no_clr = true;
+                } else if (!strcmp(mode, "no-purge-clr")) {
+                    p->options.htcp_no_purge_clr = true;
+                } else if (!strcmp(mode, "only-clr")) {
                     if (p->options.htcp_no_clr)
                         fatalf("parse_peer: can't set htcp no-clr and only-clr simultaneously");
-                    p->options.htcp_only_clr = 1;
-                } else if (!strcasecmp(mode, "forward-clr")) {
-                    p->options.htcp_forward_clr = 1;
-                } else if (!strcasecmp(mode, "oldsquid")) {
-                    p->options.htcp_oldsquid = 1;
+                    p->options.htcp_only_clr = true;
+                } else if (!strcmp(mode, "forward-clr")) {
+                    p->options.htcp_forward_clr = true;
+                } else if (!strcmp(mode, "oldsquid")) {
+                    p->options.htcp_oldsquid = true;
                 } else {
                     fatalf("invalid HTCP mode '%s'", mode);
                 }
             }
             safe_free(tmp);
 #endif
-        } else if (!strcasecmp(token, "no-netdb-exchange")) {
-            p->options.no_netdb_exchange = 1;
+        } else if (!strcmp(token, "no-netdb-exchange")) {
+            p->options.no_netdb_exchange = true;
 
-        } else if (!strcasecmp(token, "carp")) {
+        } else if (!strcmp(token, "carp")) {
             if (p->type != PEER_PARENT)
                 fatalf("parse_peer: non-parent carp peer %s/%d\n", p->host, p->http_port);
 
-            p->options.carp = 1;
-        } else if (!strncasecmp(token, "carp-key=", 9)) {
-            if (p->options.carp != 1)
+            p->options.carp = true;
+        } else if (!strncmp(token, "carp-key=", 9)) {
+            if (p->options.carp != true)
                 fatalf("parse_peer: carp-key specified on non-carp peer %s/%d\n", p->host, p->http_port);
-            p->options.carp_key.set=1;
+            p->options.carp_key.set = true;
             char *nextkey=token+strlen("carp-key="), *key=nextkey;
             for (; key; key = nextkey) {
                 nextkey=strchr(key,',');
                 if (nextkey) ++nextkey; // skip the comma, any
-                if (0==strncasecmp(key,"scheme",6)) {
-                    p->options.carp_key.scheme=1;
-                } else if (0==strncasecmp(key,"host",4)) {
-                    p->options.carp_key.host=1;
-                } else if (0==strncasecmp(key,"port",4)) {
-                    p->options.carp_key.port=1;
-                } else if (0==strncasecmp(key,"path",4)) {
-                    p->options.carp_key.path=1;
-                } else if (0==strncasecmp(key,"params",6)) {
-                    p->options.carp_key.params=1;
+                if (0==strncmp(key,"scheme",6)) {
+                    p->options.carp_key.scheme = true;
+                } else if (0==strncmp(key,"host",4)) {
+                    p->options.carp_key.host = true;
+                } else if (0==strncmp(key,"port",4)) {
+                    p->options.carp_key.port = true;
+                } else if (0==strncmp(key,"path",4)) {
+                    p->options.carp_key.path = true;
+                } else if (0==strncmp(key,"params",6)) {
+                    p->options.carp_key.params = true;
                 } else {
                     fatalf("invalid carp-key '%s'",key);
                 }
             }
-        } else if (!strcasecmp(token, "userhash")) {
+        } else if (!strcmp(token, "userhash")) {
 #if USE_AUTH
             if (p->type != PEER_PARENT)
                 fatalf("parse_peer: non-parent userhash peer %s/%d\n", p->host, p->http_port);
 
-            p->options.userhash = 1;
+            p->options.userhash = true;
 #else
             fatalf("parse_peer: userhash requires authentication. peer %s/%d\n", p->host, p->http_port);
 #endif
-        } else if (!strcasecmp(token, "sourcehash")) {
+        } else if (!strcmp(token, "sourcehash")) {
             if (p->type != PEER_PARENT)
                 fatalf("parse_peer: non-parent sourcehash peer %s/%d\n", p->host, p->http_port);
 
-            p->options.sourcehash = 1;
+            p->options.sourcehash = true;
 
-        } else if (!strcasecmp(token, "no-delay")) {
+        } else if (!strcmp(token, "no-delay")) {
 #if USE_DELAY_POOLS
-            p->options.no_delay = 1;
+            p->options.no_delay = true;
 #else
             debugs(0, DBG_CRITICAL, "WARNING: cache_peer option 'no-delay' requires --enable-delay-pools");
 #endif
-        } else if (!strncasecmp(token, "login=", 6)) {
+        } else if (!strncmp(token, "login=", 6)) {
             p->login = xstrdup(token + 6);
             rfc1738_unescape(p->login);
-        } else if (!strncasecmp(token, "connect-timeout=", 16)) {
+        } else if (!strncmp(token, "connect-timeout=", 16)) {
             p->connect_timeout = xatoi(token + 16);
-        } else if (!strncasecmp(token, "connect-fail-limit=", 19)) {
+        } else if (!strncmp(token, "connect-fail-limit=", 19)) {
             p->connect_fail_limit = xatoi(token + 19);
 #if USE_CACHE_DIGESTS
-        } else if (!strncasecmp(token, "digest-url=", 11)) {
+        } else if (!strncmp(token, "digest-url=", 11)) {
             p->digest_url = xstrdup(token + 11);
 #endif
 
-        } else if (!strcasecmp(token, "allow-miss")) {
-            p->options.allow_miss = 1;
-        } else if (!strncasecmp(token, "max-conn=", 9)) {
+        } else if (!strcmp(token, "allow-miss")) {
+            p->options.allow_miss = true;
+        } else if (!strncmp(token, "max-conn=", 9)) {
             p->max_conn = xatoi(token + 9);
-        } else if (!strcasecmp(token, "originserver")) {
-            p->options.originserver = 1;
-        } else if (!strncasecmp(token, "name=", 5)) {
+        } else if (!strcmp(token, "originserver")) {
+            p->options.originserver = true;
+        } else if (!strncmp(token, "name=", 5)) {
             safe_free(p->name);
 
             if (token[5])
                 p->name = xstrdup(token + 5);
-        } else if (!strncasecmp(token, "forceddomain=", 13)) {
+        } else if (!strncmp(token, "forceddomain=", 13)) {
             safe_free(p->domain);
 
             if (token[13])
                 p->domain = xstrdup(token + 13);
 
 #if USE_SSL
@@ -2329,15 +2350,17 @@
         } else if (strcmp(token, "connection-auth") == 0) {
             p->connection_auth = 1;
         } else if (strcmp(token, "connection-auth=on") == 0) {
             p->connection_auth = 1;
         } else if (strcmp(token, "connection-auth=auto") == 0) {
             p->connection_auth = 2;
+        } else if (token[0] == '#') {
+            // start of a text comment. stop reading this line.
+            break;
         } else {
-            debugs(3, DBG_CRITICAL, "parse_peer: token='" << token << "'");
-            self_destruct();
+            debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Ignoring unknown cache_peer option '" << token << "'");
         }
     }
 
     if (peerFindByName(p->name))
         fatalf("ERROR: cache_peer %s specified twice\n", p->name);
 
@@ -2519,13 +2542,15 @@
 
     if ((p = peerFindByName(host)) == NULL) {
         debugs(15, DBG_CRITICAL, "" << cfg_filename << ", line " << config_lineno << ": No cache_peer '" << host << "'");
         return;
     }
 
-    aclParseAccessLine(LegacyParser, &p->access);
+    std::string directive = "peer_access ";
+    directive += host;
+    aclParseAccessLine(directive.c_str(), LegacyParser, &p->access);
 }
 
 static void
 parse_hostdomain(void)
 {
     char *host = NULL;
@@ -2622,20 +2647,20 @@
 {
     char *token = strtok(NULL, w_space);
 
     if (token == NULL)
         self_destruct();
 
-    if (!strcasecmp(token, "on")) {
+    if (!strcmp(token, "on")) {
         *var = 1;
-    } else if (!strcasecmp(token, "enable")) {
+    } else if (!strcmp(token, "enable")) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'enable' is deprecated. Please update to use 'on'.");
         *var = 1;
-    } else if (!strcasecmp(token, "off")) {
+    } else if (!strcmp(token, "off")) {
         *var = 0;
-    } else if (!strcasecmp(token, "disable")) {
+    } else if (!strcmp(token, "disable")) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'disable' is deprecated. Please update to use 'off'.");
         *var = 0;
     } else {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Invalid option: Boolean options can only be 'on' or 'off'.");
         self_destruct();
     }
@@ -2663,32 +2688,55 @@
 {
     char *token = strtok(NULL, w_space);
 
     if (token == NULL)
         self_destruct();
 
-    if (!strcasecmp(token, "on")) {
+    if (!strcmp(token, "on")) {
         *var = 1;
-    } else if (!strcasecmp(token, "enable")) {
+    } else if (!strcmp(token, "enable")) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'enable' is deprecated. Please update to use value 'on'.");
         *var = 1;
-    } else if (!strcasecmp(token, "warn")) {
+    } else if (!strcmp(token, "warn")) {
         *var = -1;
-    } else if (!strcasecmp(token, "off")) {
+    } else if (!strcmp(token, "off")) {
         *var = 0;
-    } else if (!strcasecmp(token, "disable")) {
+    } else if (!strcmp(token, "disable")) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'disable' is deprecated. Please update to use value 'off'.");
         *var = 0;
     } else {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Invalid option: Tristate options can only be 'on', 'off', or 'warn'.");
         self_destruct();
     }
 }
 
 #define free_tristate free_int
 
+void
+parse_pipelinePrefetch(int *var)
+{
+    char *token = ConfigParser::strtokFile();
+
+    if (token == NULL)
+        self_destruct();
+
+    if (!strcmp(token, "on")) {
+        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: 'pipeline_prefetch on' is deprecated. Please update to use 1 (or a higher number).");
+        *var = 1;
+    } else if (!strcmp(token, "off")) {
+        debugs(0, DBG_PARSE_NOTE(2), "WARNING: 'pipeline_prefetch off' is deprecated. Please update to use '0'.");
+        *var = 0;
+    } else {
+        ConfigParser::strtokFileUndo();
+        parse_int(var);
+    }
+}
+
+#define free_pipelinePrefetch free_int
+#define dump_pipelinePrefetch dump_int
+
 static void
 dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
 {
     while (head != NULL) {
         storeAppendPrintf(entry, "%s%s %s %d %d%% %d",
                           name,
@@ -2782,12 +2830,13 @@
     } else if (strcmp(token, "+i") == 0) {
         flags &= ~REG_ICASE;
         token = strtok(NULL, w_space);
     }
 
     if (token == NULL) {
+        debugs(3, DBG_CRITICAL, "FATAL: refresh_pattern missing the regex pattern parameter");
         self_destruct();
         return;
     }
 
     pattern = xstrdup(token);
 
@@ -2863,12 +2912,13 @@
 
     if ((errcode = regcomp(&comp, pattern, flags)) != 0) {
         char errbuf[256];
         regerror(errcode, &comp, errbuf, sizeof errbuf);
         debugs(22, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(22, DBG_CRITICAL, "refreshAddToList: Invalid regular expression '" << pattern << "': " << errbuf);
+        xfree(pattern);
         return;
     }
 
     pct = pct < 0.0 ? 0.0 : pct;
     max = max < 0 ? 0 : max;
     t = static_cast<RefreshPattern *>(xcalloc(1, sizeof(RefreshPattern)));
@@ -2876,47 +2926,47 @@
     t->compiled_pattern = comp;
     t->min = min;
     t->pct = pct;
     t->max = max;
 
     if (flags & REG_ICASE)
-        t->flags.icase = 1;
+        t->flags.icase = true;
 
     if (refresh_ims)
-        t->flags.refresh_ims = 1;
+        t->flags.refresh_ims = true;
 
     if (store_stale)
-        t->flags.store_stale = 1;
+        t->flags.store_stale = true;
 
     t->max_stale = max_stale;
 
 #if USE_HTTP_VIOLATIONS
 
     if (override_expire)
-        t->flags.override_expire = 1;
+        t->flags.override_expire = true;
 
     if (override_lastmod)
-        t->flags.override_lastmod = 1;
+        t->flags.override_lastmod = true;
 
     if (reload_into_ims)
-        t->flags.reload_into_ims = 1;
+        t->flags.reload_into_ims = true;
 
     if (ignore_reload)
-        t->flags.ignore_reload = 1;
+        t->flags.ignore_reload = true;
 
     if (ignore_no_store)
-        t->flags.ignore_no_store = 1;
+        t->flags.ignore_no_store = true;
 
     if (ignore_must_revalidate)
-        t->flags.ignore_must_revalidate = 1;
+        t->flags.ignore_must_revalidate = true;
 
     if (ignore_private)
-        t->flags.ignore_private = 1;
+        t->flags.ignore_private = true;
 
     if (ignore_auth)
-        t->flags.ignore_auth = 1;
+        t->flags.ignore_auth = true;
 
 #endif
 
     t->next = NULL;
 
     while (*head)
@@ -3258,21 +3308,21 @@
 {
     char *token = strtok(NULL, w_space);
 
     if (token == NULL)
         self_destruct();
 
-    if (!strcasecmp(token, "strip"))
+    if (!strcmp(token, "strip"))
         *var = URI_WHITESPACE_STRIP;
-    else if (!strcasecmp(token, "deny"))
+    else if (!strcmp(token, "deny"))
         *var = URI_WHITESPACE_DENY;
-    else if (!strcasecmp(token, "allow"))
+    else if (!strcmp(token, "allow"))
         *var = URI_WHITESPACE_ALLOW;
-    else if (!strcasecmp(token, "encode"))
+    else if (!strcmp(token, "encode"))
         *var = URI_WHITESPACE_ENCODE;
-    else if (!strcasecmp(token, "chop"))
+    else if (!strcmp(token, "chop"))
         *var = URI_WHITESPACE_CHOP;
     else {
         debugs(0, DBG_PARSE_NOTE(2), "ERROR: Invalid option '" << token << "': 'uri_whitespace' accepts 'strip', 'deny', 'allow', 'encode', and 'chop'.");
         self_destruct();
     }
 }
@@ -3408,25 +3458,25 @@
 
 #include "cf_parser.cci"
 
 peer_t
 parseNeighborType(const char *s)
 {
-    if (!strcasecmp(s, "parent"))
+    if (!strcmp(s, "parent"))
         return PEER_PARENT;
 
-    if (!strcasecmp(s, "neighbor"))
+    if (!strcmp(s, "neighbor"))
         return PEER_SIBLING;
 
-    if (!strcasecmp(s, "neighbour"))
+    if (!strcmp(s, "neighbour"))
         return PEER_SIBLING;
 
-    if (!strcasecmp(s, "sibling"))
+    if (!strcmp(s, "sibling"))
         return PEER_SIBLING;
 
-    if (!strcasecmp(s, "multicast"))
+    if (!strcmp(s, "multicast"))
         return PEER_MULTICAST;
 
     debugs(15, DBG_CRITICAL, "WARNING: Unknown neighbor type: " << s);
 
     return PEER_SIBLING;
 }
@@ -3459,13 +3509,13 @@
 {
     char ntoabuf[MAX_IPSTRLEN];
 
     while (s) {
         storeAppendPrintf(e, "%s %s\n",
                           n,
-                          s->s.NtoA(ntoabuf,MAX_IPSTRLEN));
+                          s->s.toStr(ntoabuf,MAX_IPSTRLEN));
         s = s->next;
     }
 }
 
 static void
 free_IpAddress_list(Ip::Address_list ** head)
@@ -3536,28 +3586,28 @@
     if (port == 0 && host != NULL) {
         debugs(3, DBG_CRITICAL, s->protocol << "_port: Port cannot be 0: " << token);
         self_destruct();
     }
 
     if (NULL == host) {
-        s->s.SetAnyAddr();
-        s->s.SetPort(port);
+        s->s.setAnyAddr();
+        s->s.port(port);
         if (!Ip::EnableIpv6)
-            s->s.SetIPv4();
-        debugs(3, 3, s->protocol << "_port: found Listen on wildcard address: *:" << s->s.GetPort() );
+            s->s.setIPv4();
+        debugs(3, 3, s->protocol << "_port: found Listen on wildcard address: *:" << s->s.port() );
     } else if ( (s->s = host) ) { /* check/parse numeric IPA */
-        s->s.SetPort(port);
+        s->s.port(port);
         if (!Ip::EnableIpv6)
-            s->s.SetIPv4();
+            s->s.setIPv4();
         debugs(3, 3, s->protocol << "_port: Listen on Host/IP: " << host << " --> " << s->s);
     } else if ( s->s.GetHostByName(host) ) { /* check/parse for FQDN */
         /* dont use ipcache */
         s->defaultsite = xstrdup(host);
-        s->s.SetPort(port);
+        s->s.port(port);
         if (!Ip::EnableIpv6)
-            s->s.SetIPv4();
+            s->s.setIPv4();
         debugs(3, 3, s->protocol << "_port: found Listen as Host " << s->defaultsite << " on IP: " << s->s);
     } else {
         debugs(3, DBG_CRITICAL, s->protocol << "_port: failed to resolve Host/IP: " << host);
         self_destruct();
     }
 }
@@ -3565,153 +3615,146 @@
 static void
 parse_port_option(AnyP::PortCfg * s, char *token)
 {
     /* modes first */
 
     if (strcmp(token, "accel") == 0) {
-        if (s->intercepted || s->spoof_client_ip) {
+        if (s->flags.isIntercepted()) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: Accelerator mode requires its own port. It cannot be shared with other modes.");
             self_destruct();
         }
-        s->accel = s->vhost = 1;
+        s->flags.accelSurrogate = true;
+        s->vhost = true;
     } else if (strcmp(token, "transparent") == 0 || strcmp(token, "intercept") == 0) {
-        if (s->accel || s->spoof_client_ip) {
+        if (s->flags.accelSurrogate || s->flags.tproxyIntercept) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: Intercept mode requires its own interception port. It cannot be shared with other modes.");
             self_destruct();
         }
-        s->intercepted = 1;
+        s->flags.natIntercept = true;
         Ip::Interceptor.StartInterception();
         /* Log information regarding the port modes under interception. */
         debugs(3, DBG_IMPORTANT, "Starting Authentication on port " << s->s);
         debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (interception enabled)");
-
-        /* INET6: until transparent REDIRECT works on IPv6 SOCKET, force wildcard to IPv4 */
-        if (Ip::EnableIpv6)
-            debugs(3, DBG_IMPORTANT, "Disabling IPv6 on port " << s->s << " (interception enabled)");
-        if ( !s->s.SetIPv4() ) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 addresses cannot NAT intercept (protocol does not provide NAT)" << s->s );
-            self_destruct();
-        }
     } else if (strcmp(token, "tproxy") == 0) {
-        if (s->intercepted || s->accel) {
+        if (s->flags.natIntercept || s->flags.accelSurrogate) {
             debugs(3,DBG_CRITICAL, "FATAL: http(s)_port: TPROXY option requires its own interception port. It cannot be shared with other modes.");
             self_destruct();
         }
-        s->spoof_client_ip = 1;
+        s->flags.tproxyIntercept = true;
         Ip::Interceptor.StartTransparency();
         /* Log information regarding the port modes under transparency. */
-        debugs(3, DBG_IMPORTANT, "Starting IP Spoofing on port " << s->s);
-        debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (IP spoofing enabled)");
+        debugs(3, DBG_IMPORTANT, "Disabling Authentication on port " << s->s << " (TPROXY enabled)");
 
         if (!Ip::Interceptor.ProbeForTproxy(s->s)) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: TPROXY support in the system does not work.");
             self_destruct();
         }
 
     } else if (strncmp(token, "defaultsite=", 12) == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: defaultsite option requires Acceleration mode flag.");
             self_destruct();
         }
         safe_free(s->defaultsite);
         s->defaultsite = xstrdup(token + 12);
     } else if (strcmp(token, "vhost") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "WARNING: http(s)_port: vhost option is deprecated. Use 'accel' mode flag instead.");
         }
-        s->accel = s->vhost = 1;
+        s->flags.accelSurrogate = true;
+        s->vhost = true;
     } else if (strcmp(token, "no-vhost") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_IMPORTANT, "ERROR: http(s)_port: no-vhost option requires Acceleration mode flag.");
         }
-        s->vhost = 0;
+        s->vhost = false;
     } else if (strcmp(token, "vport") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: vport option requires Acceleration mode flag.");
             self_destruct();
         }
         s->vport = -1;
     } else if (strncmp(token, "vport=", 6) == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: vport option requires Acceleration mode flag.");
             self_destruct();
         }
         s->vport = xatos(token + 6);
     } else if (strncmp(token, "protocol=", 9) == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: protocol option requires Acceleration mode flag.");
             self_destruct();
         }
         s->protocol = xstrdup(token + 9);
     } else if (strcmp(token, "allow-direct") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: allow-direct option requires Acceleration mode flag.");
             self_destruct();
         }
-        s->allow_direct = 1;
+        s->allow_direct = true;
     } else if (strcmp(token, "act-as-origin") == 0) {
-        if (!s->accel) {
+        if (!s->flags.accelSurrogate) {
             debugs(3, DBG_IMPORTANT, "ERROR: http(s)_port: act-as-origin option requires Acceleration mode flag.");
         } else
-            s->actAsOrigin = 1;
+            s->actAsOrigin = true;
     } else if (strcmp(token, "ignore-cc") == 0) {
 #if !USE_HTTP_VIOLATIONS
-        if (!s->accel) {
-            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: ignore-cc option requires Scceleration mode flag.");
+        if (!s->flags.accelSurrogate) {
+            debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: ignore-cc option requires Acceleration mode flag.");
             self_destruct();
         }
 #endif
-        s->ignore_cc = 1;
+        s->ignore_cc = true;
     } else if (strncmp(token, "name=", 5) == 0) {
         safe_free(s->name);
         s->name = xstrdup(token + 5);
     } else if (strcmp(token, "no-connection-auth") == 0) {
         s->connection_auth_disabled = true;
     } else if (strcmp(token, "connection-auth=off") == 0) {
         s->connection_auth_disabled = true;
     } else if (strcmp(token, "connection-auth") == 0) {
         s->connection_auth_disabled = false;
     } else if (strcmp(token, "connection-auth=on") == 0) {
         s->connection_auth_disabled = false;
     } else if (strncmp(token, "disable-pmtu-discovery=", 23) == 0) {
-        if (!strcasecmp(token + 23, "off"))
+        if (!strcmp(token + 23, "off"))
             s->disable_pmtu_discovery = DISABLE_PMTU_OFF;
-        else if (!strcasecmp(token + 23, "transparent"))
+        else if (!strcmp(token + 23, "transparent"))
             s->disable_pmtu_discovery = DISABLE_PMTU_TRANSPARENT;
-        else if (!strcasecmp(token + 23, "always"))
+        else if (!strcmp(token + 23, "always"))
             s->disable_pmtu_discovery = DISABLE_PMTU_ALWAYS;
         else
             self_destruct();
     } else if (strcmp(token, "ipv4") == 0) {
-        if ( !s->s.SetIPv4() ) {
+        if ( !s->s.setIPv4() ) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 addresses cannot be used as IPv4-Only. " << s->s );
             self_destruct();
         }
     } else if (strcmp(token, "tcpkeepalive") == 0) {
-        s->tcp_keepalive.enabled = 1;
+        s->tcp_keepalive.enabled = true;
     } else if (strncmp(token, "tcpkeepalive=", 13) == 0) {
         char *t = token + 13;
-        s->tcp_keepalive.enabled = 1;
+        s->tcp_keepalive.enabled = true;
         s->tcp_keepalive.idle = xatoui(t,',');
         t = strchr(t, ',');
         if (t) {
             ++t;
             s->tcp_keepalive.interval = xatoui(t,',');
             t = strchr(t, ',');
         }
         if (t) {
             ++t;
             s->tcp_keepalive.timeout = xatoui(t);
         }
 #if USE_SSL
-    } else if (strcasecmp(token, "sslBump") == 0) {
+    } else if (strcmp(token, "sslBump") == 0) {
         debugs(3, DBG_CRITICAL, "WARNING: '" << token << "' is deprecated " <<
                "in http_port. Use 'ssl-bump' instead.");
-        s->sslBump = 1; // accelerated when bumped, otherwise not
+        s->flags.tunnelSslBumping = true;
     } else if (strcmp(token, "ssl-bump") == 0) {
-        s->sslBump = 1; // accelerated when bumped, otherwise not
+        s->flags.tunnelSslBumping = true;
     } else if (strncmp(token, "cert=", 5) == 0) {
         safe_free(s->cert);
         s->cert = xstrdup(token + 5);
     } else if (strncmp(token, "key=", 4) == 0) {
         safe_free(s->key);
         s->key = xstrdup(token + 4);
@@ -3800,30 +3843,30 @@
     /* parse options ... */
     while ((token = strtok(NULL, w_space))) {
         parse_port_option(s, token);
     }
 
 #if USE_SSL
-    if (strcasecmp(protocol, "https") == 0) {
+    if (strcmp(protocol, "https") == 0) {
         /* ssl-bump on https_port configuration requires either tproxy or intercept, and vice versa */
-        const bool hijacked = s->spoof_client_ip || s->intercepted;
-        if (s->sslBump && !hijacked) {
+        const bool hijacked = s->flags.isIntercepted();
+        if (s->flags.tunnelSslBumping && !hijacked) {
             debugs(3, DBG_CRITICAL, "FATAL: ssl-bump on https_port requires tproxy/intercept which is missing.");
             self_destruct();
         }
-        if (hijacked && !s->sslBump) {
+        if (hijacked && !s->flags.tunnelSslBumping) {
             debugs(3, DBG_CRITICAL, "FATAL: tproxy/intercept on https_port requires ssl-bump which is missing.");
             self_destruct();
         }
     }
 #endif
 
-    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && s->s.IsAnyAddr()) {
+    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && s->s.isAnyAddr()) {
         // clone the port options from *s to *(s->next)
         s->next = cbdataReference(s->clone());
-        s->next->s.SetIPv4();
+        s->next->s.setIPv4();
         debugs(3, 3, protocol << "_port: clone wildcard address for split-stack: " << s->s << " and " << s->next->s);
     }
 
     while (*head)
         head = &(*head)->next;
 
@@ -3834,22 +3877,22 @@
 dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
 {
     char buf[MAX_IPSTRLEN];
 
     storeAppendPrintf(e, "%s %s",
                       n,
-                      s->s.ToURL(buf,MAX_IPSTRLEN));
+                      s->s.toUrl(buf,MAX_IPSTRLEN));
 
     // MODES and specific sub-options.
-    if (s->intercepted)
+    if (s->flags.natIntercept)
         storeAppendPrintf(e, " intercept");
 
-    else if (s->spoof_client_ip)
+    else if (s->flags.tproxyIntercept)
         storeAppendPrintf(e, " tproxy");
 
-    else if (s->accel) {
+    else if (s->flags.accelSurrogate) {
         storeAppendPrintf(e, " accel");
 
         if (s->vhost)
             storeAppendPrintf(e, " vhost");
 
         if (s->vport < 0)
@@ -3874,13 +3917,13 @@
     // Generic independent options
 
     if (s->name)
         storeAppendPrintf(e, " name=%s", s->name);
 
 #if USE_HTTP_VIOLATIONS
-    if (!s->accel && s->ignore_cc)
+    if (!s->flags.accelSurrogate && s->ignore_cc)
         storeAppendPrintf(e, " ignore-cc");
 #endif
 
     if (s->connection_auth_disabled)
         storeAppendPrintf(e, " connection-auth=off");
     else
@@ -3894,25 +3937,25 @@
         else
             pmtu = "transparent";
 
         storeAppendPrintf(e, " disable-pmtu-discovery=%s", pmtu);
     }
 
-    if (s->s.IsAnyAddr() && !s->s.IsIPv6())
+    if (s->s.isAnyAddr() && !s->s.isIPv6())
         storeAppendPrintf(e, " ipv4");
 
     if (s->tcp_keepalive.enabled) {
         if (s->tcp_keepalive.idle || s->tcp_keepalive.interval || s->tcp_keepalive.timeout) {
             storeAppendPrintf(e, " tcpkeepalive=%d,%d,%d", s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
         } else {
             storeAppendPrintf(e, " tcpkeepalive");
         }
     }
 
 #if USE_SSL
-    if (s->sslBump)
+    if (s->flags.tunnelSslBumping)
         storeAppendPrintf(e, " ssl-bump");
 
     if (s->cert)
         storeAppendPrintf(e, " cert=%s", s->cert);
 
     if (s->key)
@@ -4012,39 +4055,124 @@
 {
     return ConfigParser::strtokFile();
 }
 
 #include "AccessLogEntry.h"
 
+/**
+ * We support several access_log configuration styles:
+ *
+ * #1: Deprecated ancient style without an explicit logging module:
+ * access_log /var/log/access.log
+ *
+ * #2: The "none" logging module (i.e., no logging [of matching transactions]):
+ * access_log none [acl ...]
+ *
+ * #3: Configurable logging module without named options:
+ * Logformat or the first ACL name, whichever comes first, may not contain '='.
+ * If no explicit logformat name is given, the first ACL name, if any,
+ * should not be an existing logformat name or it will be treated as such.
+ * access_log module:place [logformat_name] [acl ...]
+ *
+ * #4: Configurable logging module with name=value options such as logformat=x:
+ * The first ACL name may not contain '='.
+ * access_log module:place [option ...] [acl ...]
+ *
+ */
 static void
 parse_access_log(CustomLog ** logs)
 {
-    const char *filename, *logdef_name;
-
     CustomLog *cl = (CustomLog *)xcalloc(1, sizeof(*cl));
 
-    if ((filename = strtok(NULL, w_space)) == NULL) {
+    // default buffer size and fatal settings
+    cl->bufferSize = 8*MAX_URL;
+    cl->fatal = true;
+
+    /* determine configuration style */
+
+    const char *filename = strtok(NULL, w_space);
+    if (!filename) {
         self_destruct();
         return;
     }
 
     if (strcmp(filename, "none") == 0) {
         cl->type = Log::Format::CLF_NONE;
-        aclParseAclList(LegacyParser, &cl->aclList);
+        aclParseAclList(LegacyParser, &cl->aclList, filename);
         while (*logs)
             logs = &(*logs)->next;
         *logs = cl;
         return;
     }
 
-    if ((logdef_name = strtok(NULL, w_space)) == NULL)
-        logdef_name = "squid";
+    cl->filename = xstrdup(filename);
+    cl->type = Log::Format::CLF_UNKNOWN;
 
-    debugs(3, 9, "Log definition name '" << logdef_name << "' file '" << filename << "'");
+    const char *token = ConfigParser::strtokFile();
+    if (!token) { // style #1
+        // no options to deal with
+    } else if (!strchr(token, '=')) { // style #3
+        // if logformat name is not recognized,
+        // put back the token; it must be an ACL name
+        if (!setLogformat(cl, token, false))
+            ConfigParser::strtokFileUndo();
+    } else { // style #4
+        do {
+            if (strncasecmp(token, "on-error=", 9) == 0) {
+                if (strncasecmp(token+9, "die", 3) == 0) {
+                    cl->fatal = true;
+                } else if (strncasecmp(token+9, "drop", 4) == 0) {
+                    cl->fatal = false;
+                } else {
+                    debugs(3, DBG_CRITICAL, "Unknown value for on-error '" <<
+                           token << "' expected 'drop' or 'die'");
+                    self_destruct();
+                }
+            } else if (strncasecmp(token, "buffer-size=", 12) == 0) {
+                parseBytesOptionValue(&cl->bufferSize, B_BYTES_STR, token+12);
+            } else if (strncasecmp(token, "logformat=", 10) == 0) {
+                setLogformat(cl, token+10, true);
+            } else if (!strchr(token, '=')) {
+                // put back the token; it must be an ACL name
+                ConfigParser::strtokFileUndo();
+                break; // done with name=value options, now to ACLs
+            } else {
+                debugs(3, DBG_CRITICAL, "Unknown access_log option " << token);
+                self_destruct();
+            }
+        } while ((token = ConfigParser::strtokFile()) != NULL);
+    }
 
-    cl->filename = xstrdup(filename);
+    // set format if it has not been specified explicitly
+    if (cl->type == Log::Format::CLF_UNKNOWN)
+        setLogformat(cl, "squid", true);
+
+    aclParseAclList(LegacyParser, &cl->aclList, cl->filename);
+
+    while (*logs)
+        logs = &(*logs)->next;
+
+    *logs = cl;
+}
+
+/// sets CustomLog::type and, if needed, CustomLog::lf
+/// returns false iff there is no named log format
+static bool
+setLogformat(CustomLog *cl, const char *logdef_name, const bool dieWhenMissing)
+{
+    assert(cl);
+    assert(logdef_name);
+
+    debugs(3, 9, "possible " << cl->filename << " logformat: " << logdef_name);
+
+    if (cl->type != Log::Format::CLF_UNKNOWN) {
+        debugs(3, DBG_CRITICAL, "Second logformat name in one access_log: " <<
+               logdef_name << " " << cl->type << " ? " << Log::Format::CLF_NONE);
+        self_destruct();
+        return false;
+    }
 
     /* look for the definition pointer corresponding to this name */
     Format::Format *lf = Log::TheConfig.logformats;
 
     while (lf != NULL) {
         debugs(3, 9, "Comparing against '" << lf->name << "'");
@@ -4072,24 +4200,21 @@
         cl->type = Log::Format::CLF_ICAP_SQUID;
 #endif
     } else if (strcmp(logdef_name, "useragent") == 0) {
         cl->type = Log::Format::CLF_USERAGENT;
     } else if (strcmp(logdef_name, "referrer") == 0) {
         cl->type = Log::Format::CLF_REFERER;
-    } else {
+    } else if (dieWhenMissing) {
         debugs(3, DBG_CRITICAL, "Log format '" << logdef_name << "' is not defined");
         self_destruct();
-        return;
+        return false;
+    } else {
+        return false;
     }
 
-    aclParseAclList(LegacyParser, &cl->aclList);
-
-    while (*logs)
-        logs = &(*logs)->next;
-
-    *logs = cl;
+    return true;
 }
 
 static int
 check_null_access_log(CustomLog *customlog_definitions)
 {
     return customlog_definitions == NULL;
@@ -4261,30 +4386,12 @@
 
 static void
 parse_adaptation_access_type()
 {
     Adaptation::Config::ParseAccess(LegacyParser);
 }
-
-static void
-parse_adaptation_meta_type(Adaptation::Config::MetaHeaders *)
-{
-    Adaptation::Config::ParseMetaHeader(LegacyParser);
-}
-
-static void
-dump_adaptation_meta_type(StoreEntry *entry, const char *name, Adaptation::Config::MetaHeaders &)
-{
-    Adaptation::Config::DumpMetaHeader(entry, name);
-}
-
-static void
-free_adaptation_meta_type(Adaptation::Config::MetaHeaders *)
-{
-    // Nothing to do, it is released inside Adaptation::Config::freeService()
-}
 #endif /* USE_ADAPTATION */
 
 #if ICAP_CLIENT
 
 static void
 parse_icap_service_type(Adaptation::Icap::Config * cfg)
@@ -4418,33 +4525,33 @@
         *s = '\0';
     } else
         param = NULL;
 
     if (strcmp(al, Ssl::CertAdaptAlgorithmStr[Ssl::algSetValidAfter]) == 0) {
         ca->alg = Ssl::algSetValidAfter;
-        ca->param = strdup("on");
+        ca->param = xstrdup("on");
     } else if (strcmp(al, Ssl::CertAdaptAlgorithmStr[Ssl::algSetValidBefore]) == 0) {
         ca->alg = Ssl::algSetValidBefore;
-        ca->param = strdup("on");
+        ca->param = xstrdup("on");
     } else if (strcmp(al, Ssl::CertAdaptAlgorithmStr[Ssl::algSetCommonName]) == 0) {
         ca->alg = Ssl::algSetCommonName;
         if (param) {
             if (strlen(param) > 64) {
                 debugs(3, DBG_CRITICAL, "FATAL: sslproxy_cert_adapt: setCommonName{" <<param << "} : using common name longer than 64 bytes is not supported");
                 self_destruct();
                 return;
             }
-            ca->param = strdup(param);
+            ca->param = xstrdup(param);
         }
     } else {
         debugs(3, DBG_CRITICAL, "FATAL: sslproxy_cert_adapt: unknown cert adaptation algorithm: " << al);
         self_destruct();
         return;
     }
 
-    aclParseAclList(LegacyParser, &ca->aclList);
+    aclParseAclList(LegacyParser, &ca->aclList, al);
 
     while (*cert_adapt)
         cert_adapt = &(*cert_adapt)->next;
 
     *cert_adapt = ca;
 }
@@ -4492,13 +4599,13 @@
     else {
         debugs(3, DBG_CRITICAL, "FATAL: sslproxy_cert_sign: unknown cert signing algorithm: " << al);
         self_destruct();
         return;
     }
 
-    aclParseAclList(LegacyParser, &cs->aclList);
+    aclParseAclList(LegacyParser, &cs->aclList, al);
 
     while (*cert_sign)
         cert_sign = &(*cert_sign)->next;
 
     *cert_sign = cs;
 }
@@ -4578,37 +4685,36 @@
     // if this is the first rule proccessed
     if (*ssl_bump == NULL) {
         bumpCfgStyleLast = bcsNone;
         sslBumpCfgRr::lastDeprecatedRule = Ssl::bumpEnd;
     }
 
-    acl_access *A = new acl_access;
-    A->allow = allow_t(ACCESS_ALLOWED);
+    allow_t action = allow_t(ACCESS_ALLOWED);
 
     if (strcmp(bm, Ssl::BumpModeStr[Ssl::bumpClientFirst]) == 0) {
-        A->allow.kind = Ssl::bumpClientFirst;
+        action.kind = Ssl::bumpClientFirst;
         bumpCfgStyleNow = bcsNew;
     } else if (strcmp(bm, Ssl::BumpModeStr[Ssl::bumpServerFirst]) == 0) {
-        A->allow.kind = Ssl::bumpServerFirst;
+        action.kind = Ssl::bumpServerFirst;
         bumpCfgStyleNow = bcsNew;
     } else if (strcmp(bm, Ssl::BumpModeStr[Ssl::bumpNone]) == 0) {
-        A->allow.kind = Ssl::bumpNone;
+        action.kind = Ssl::bumpNone;
         bumpCfgStyleNow = bcsNew;
     } else if (strcmp(bm, "allow") == 0) {
         debugs(3, DBG_CRITICAL, "SECURITY NOTICE: auto-converting deprecated "
                "\"ssl_bump allow <acl>\" to \"ssl_bump client-first <acl>\" which "
                "is usually inferior to the newer server-first "
                "bumping mode. Update your ssl_bump rules.");
-        A->allow.kind = Ssl::bumpClientFirst;
+        action.kind = Ssl::bumpClientFirst;
         bumpCfgStyleNow = bcsOld;
         sslBumpCfgRr::lastDeprecatedRule = Ssl::bumpClientFirst;
     } else if (strcmp(bm, "deny") == 0) {
         debugs(3, DBG_CRITICAL, "WARNING: auto-converting deprecated "
                "\"ssl_bump deny <acl>\" to \"ssl_bump none <acl>\". Update "
                "your ssl_bump rules.");
-        A->allow.kind = Ssl::bumpNone;
+        action.kind = Ssl::bumpNone;
         bumpCfgStyleNow = bcsOld;
         sslBumpCfgRr::lastDeprecatedRule = Ssl::bumpNone;
     } else {
         debugs(3, DBG_CRITICAL, "FATAL: unknown ssl_bump mode: " << bm);
         self_destruct();
         return;
@@ -4620,28 +4726,32 @@
         self_destruct();
         return;
     }
 
     bumpCfgStyleLast = bumpCfgStyleNow;
 
-    aclParseAclList(LegacyParser, &A->aclList);
+    Acl::AndNode *rule = new Acl::AndNode;
+    rule->context("(ssl_bump rule)", config_input_line);
+    rule->lineParse();
+    // empty rule OK
+
+    assert(ssl_bump);
+    if (!*ssl_bump) {
+        *ssl_bump = new Acl::Tree;
+        (*ssl_bump)->context("(ssl_bump rules)", config_input_line);
+    }
 
-    acl_access *B, **T;
-    for (B = *ssl_bump, T = ssl_bump; B; T = &B->next, B = B->next);
-    *T = A;
+    (*ssl_bump)->add(rule, action);
 }
 
 static void dump_sslproxy_ssl_bump(StoreEntry *entry, const char *name, acl_access *ssl_bump)
 {
-    acl_access *sb;
-    for (sb = ssl_bump; sb != NULL; sb = sb->next) {
-        storeAppendPrintf(entry, "%s ", name);
-        storeAppendPrintf(entry, "%s ", Ssl::bumpMode(sb->allow.kind));
-        if (sb->aclList)
-            dump_acl_list(entry, sb->aclList);
-        storeAppendPrintf(entry, "\n");
+    if (ssl_bump) {
+        wordlist *lines = ssl_bump->treeDump(name, Ssl::BumpModeStr);
+        dump_wordlist(entry, lines);
+        wordlistDestroy(&lines);
     }
 }
 
 static void free_sslproxy_ssl_bump(acl_access **ssl_bump)
 {
     free_acl_access(ssl_bump);
@@ -4689,13 +4799,14 @@
         if (!nlf->parse(hwa.fieldValue.c_str())) {
             self_destruct();
             return;
         }
         hwa.valueFormat = nlf;
     }
-    aclParseAclList(LegacyParser, &hwa.aclList);
+
+    aclParseAclList(LegacyParser, &hwa.aclList, (hwa.fieldName + ':' + hwa.fieldValue).c_str());
     (*headers)->push_back(hwa);
 }
 
 static void free_HeaderWithAclList(HeaderWithAclList **header)
 {
     if (!(*header))
@@ -4710,6 +4821,22 @@
             hwa->valueFormat = NULL;
         }
     }
     delete *header;
     *header = NULL;
 }
+
+static void parse_note(Notes *notes)
+{
+    assert(notes);
+    notes->parse(LegacyParser);
+}
+
+static void dump_note(StoreEntry *entry, const char *name, Notes &notes)
+{
+    notes.dump(entry, name);
+}
+
+static void free_note(Notes *notes)
+{
+    notes->clean();
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cache_manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cache_manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cache_manager.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cache_manager.cc	2015-05-01 18:05:19.000000000 +0800
@@ -79,13 +79,13 @@
 
 /// Registers new profiles, ignoring attempts to register a duplicate
 void
 CacheManager::registerProfile(const Mgr::ActionProfile::Pointer &profile)
 {
     Must(profile != NULL);
-    if (std::find(menu_.begin(), menu_.end(), profile) == menu_.end()) {
+    if (!CacheManager::findAction(profile->name)) {
         menu_.push_back(profile);
         debugs(16, 3, HERE << "registered profile: " << *profile);
     } else {
         debugs(16, 2, HERE << "skipped duplicate profile: " << *profile);
     }
 }
@@ -327,13 +327,13 @@
 CacheManager::Start(const Comm::ConnectionPointer &client, HttpRequest * request, StoreEntry * entry)
 {
     debugs(16, 3, "CacheManager::Start: '" << entry->url() << "'" );
 
     Mgr::Command::Pointer cmd = ParseUrl(entry->url());
     if (!cmd) {
-        ErrorState *err = new ErrorState(ERR_INVALID_URL, HTTP_NOT_FOUND, request);
+        ErrorState *err = new ErrorState(ERR_INVALID_URL, Http::scNotFound, request);
         err->url = xstrdup(entry->url());
         errorAppendEntry(entry, err);
         entry->expires = squid_curtime;
         return;
     }
 
@@ -350,13 +350,13 @@
                            cmd->params.userName.termedBuf() : "unknown";
 
     /* Check password */
 
     if (CheckPassword(*cmd) != 0) {
         /* build error message */
-        ErrorState errState(ERR_CACHE_MGR_ACCESS_DENIED, HTTP_UNAUTHORIZED, request);
+        ErrorState errState(ERR_CACHE_MGR_ACCESS_DENIED, Http::scUnauthorized, request);
         /* warn if user specified incorrect password */
 
         if (cmd->params.password.size()) {
             debugs(16, DBG_IMPORTANT, "CacheManager: " <<
                    userName << "@" <<
                    client << ": incorrect password for '" <<
@@ -404,17 +404,17 @@
            userName << "@" <<
            client << " requesting '" <<
            actionName << "'" );
 
     // special case: /squid-internal-mgr/ index page
     if (!strcmp(cmd->profile->name, "index")) {
-        ErrorState err(MGR_INDEX, HTTP_OK, request);
+        ErrorState err(MGR_INDEX, Http::scOkay, request);
         err.url = xstrdup(entry->url());
         HttpReply *rep = err.BuildHttpReply();
         if (strncmp(rep->body.content(),"Internal Error:", 15) == 0)
-            rep->sline.status = HTTP_NOT_FOUND;
+            rep->sline.set(Http::ProtocolVersion(1,1), Http::scNotFound);
         // Allow cachemgr and other XHR scripts access to our version string
         if (request->header.has(HDR_ORIGIN)) {
             rep->header.putExt("Access-Control-Allow-Origin",request->header.getStr(HDR_ORIGIN));
 #if HAVE_AUTH_MODULE_BASIC
             rep->header.putExt("Access-Control-Allow-Credentials","true");
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/CachePeer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/CachePeer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/CachePeer.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/CachePeer.h	2015-05-01 18:05:19.000000000 +0800
@@ -26,24 +26,24 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
+#include "acl/forward.h"
 #include "enums.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
 
 //TODO: remove, it is unconditionally defined and always used.
 #define PEER_MULTICAST_SIBLINGS 1
 
 #if USE_SSL
 #include <openssl/ssl.h>
 #endif
 
-class acl_access;
 class CachePeerDomainList;
 class NeighborTypeDomainList;
 class PeerDigest;
 
 // currently a POD
 class CachePeer
@@ -90,51 +90,51 @@
     unsigned short http_port;
     CachePeerDomainList *peer_domain;
     NeighborTypeDomainList *typelist;
     acl_access *access;
 
     struct {
-        unsigned int proxy_only:1;
-        unsigned int no_query:1;
-        unsigned int background_ping:1;
-        unsigned int no_digest:1;
-        unsigned int default_parent:1;
-        unsigned int roundrobin:1;
-        unsigned int weighted_roundrobin:1;
-        unsigned int mcast_responder:1;
-        unsigned int closest_only:1;
+        bool proxy_only;
+        bool no_query;
+        bool background_ping;
+        bool no_digest;
+        bool default_parent;
+        bool roundrobin;
+        bool weighted_roundrobin;
+        bool mcast_responder;
+        bool closest_only;
 #if USE_HTCP
-        unsigned int htcp:1;
-        unsigned int htcp_oldsquid:1;
-        unsigned int htcp_no_clr:1;
-        unsigned int htcp_no_purge_clr:1;
-        unsigned int htcp_only_clr:1;
-        unsigned int htcp_forward_clr:1;
+        bool htcp;
+        bool htcp_oldsquid;
+        bool htcp_no_clr;
+        bool htcp_no_purge_clr;
+        bool htcp_only_clr;
+        bool htcp_forward_clr;
 #endif
-        unsigned int no_netdb_exchange:1;
+        bool no_netdb_exchange;
 #if USE_DELAY_POOLS
-        unsigned int no_delay:1;
+        bool no_delay;
 #endif
-        unsigned int allow_miss:1;
-        unsigned int carp:1;
+        bool allow_miss;
+        bool carp;
         struct {
-            unsigned int set:1; //If false, whole url is to be used. Overrides others
-            unsigned int scheme:1;
-            unsigned int host:1;
-            unsigned int port:1;
-            unsigned int path:1;
-            unsigned int params:1;
+            bool set; //If false, whole url is to be used. Overrides others
+            bool scheme;
+            bool host;
+            bool port;
+            bool path;
+            bool params;
         } carp_key;
 #if USE_AUTH
-        unsigned int userhash:1;
+        bool userhash;
 #endif
-        unsigned int sourcehash:1;
-        unsigned int originserver:1;
-        unsigned int no_tproxy:1;
+        bool sourcehash;
+        bool originserver;
+        bool no_tproxy;
 #if PEER_MULTICAST_SIBLINGS
-        unsigned int mcast_siblings:1;
+        bool mcast_siblings;
 #endif
     } options;
 
     int weight;
     int basetime;
 
@@ -143,14 +143,14 @@
         int n_times_counted;
         int n_replies_expected;
         int ttl;
         int id;
 
         struct {
-            unsigned int count_event_pending:1;
-            unsigned int counting:1;
+            bool count_event_pending;
+            bool counting;
         } flags;
     } mcast;
 #if USE_CACHE_DIGESTS
 
     PeerDigest *digest;
     char *digest_url;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cbdata.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cbdata.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cbdata.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cbdata.cc	2015-05-01 18:05:19.000000000 +0800
@@ -462,15 +462,22 @@
     assert(c != NULL);
 
     assert(c->locks > 0);
 
     -- c->locks;
 
-    if (c->valid || c->locks)
+    if (c->locks)
         return;
 
+    if (c->valid) {
+#if USE_CBDATA_DEBUG
+        debugs(45, DBG_IMPORTANT, "CBDATA memory leak. cbdata=" << p << " " << file << ":" << line);
+#endif
+        return;
+    }
+
     --cbdataCount;
 
     debugs(45, 9, "cbdataUnlock: Freeing " << p);
 
 #if USE_CBDATA_DEBUG
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cbdata.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cbdata.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cbdata.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cbdata.h	2015-05-01 18:05:19.000000000 +0800
@@ -372,15 +372,12 @@
  *
  \param var	The reference variable. Will be automatically cleared to NULL.
  */
 #define cbdataReferenceDone(var) do {if (var) {cbdataInternalUnlock(var); var = NULL;}} while(0)
 
 /// \ingroup CBDATAAPI
-#define CBDATA_CLASS(type)	static cbdata_type CBDATA_##type
-
-/// \ingroup CBDATAAPI
 #define CBDATA_CLASS_INIT(type) cbdata_type type::CBDATA_##type = CBDATA_UNKNOWN
 #define CBDATA_NAMESPACED_CLASS_INIT(namespace, type) cbdata_type namespace::type::CBDATA_##type = CBDATA_UNKNOWN
 
 /**
  \ingroup CBDATAAPI
  * Macro that defines a new cbdata datatype. Similar to a variable
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cf.data.depend /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cf.data.depend
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cf.data.depend	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cf.data.depend	2015-05-01 18:05:19.000000000 +0800
@@ -32,28 +32,29 @@
 http_header_access	acl
 http_header_replace
 HeaderWithAclList	acl
 adaptation_access_type	adaptation_service_set adaptation_service_chain acl icap_service icap_class
 adaptation_service_set_type	icap_service ecap_service
 adaptation_service_chain_type	icap_service ecap_service
-adaptation_meta_type	acl
 icap_access_type	icap_class acl
 icap_class_type		icap_service
 icap_service_type
 icap_service_failure_limit
 ecap_service_type
 int
 kb_int64_t
 kb_size_t
 logformat
 YesNoNone
 memcachemode
+note			acl
 obsolete
 onoff
 peer
 peer_access		cache_peer acl
+pipelinePrefetch
 PortCfg
 QosConfig
 refreshpattern
 removalpolicy
 size_t
 IpAddress_list
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cf.data.pre /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cf.data.pre
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cf.data.pre	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cf.data.pre	2015-05-01 18:05:19.000000000 +0800
@@ -61,12 +61,37 @@
 
   Includes can be nested up to a hard-coded depth of 16 levels.
   This arbitrary restriction is to prevent recursive include references
   from causing Squid entering an infinite loop whilst trying to load
   configuration files.
 
+  Values with byte units
+
+	Squid accepts size units on some size related directives. All
+	such directives are documented with a default value displaying
+	a unit.
+
+	Units accepted by Squid are:
+		bytes - byte
+		KB - Kilobyte (1024 bytes)
+		MB - Megabyte
+		GB - Gigabyte
+
+  Values with spaces, quotes, and other special characters
+
+	Squid supports directive parameters with spaces, quotes, and other
+	special characters. Surround such parameters with "double quotes". Use
+	the configuration_includes_quoted_values directive to enable or
+	disable that support.
+
+	For example;
+
+		configuration_includes_quoted_values on
+		acl group external groupCheck Administrators "Internet Users" Guest
+		configuration_includes_quoted_values off
+
 
   Conditional configuration
 
 	If-statements can be used to make configuration directives
 	depend on conditions:
 
@@ -144,23 +169,17 @@
 NAME: refresh_stale_hit
 TYPE: obsolete
 DOC_START
 	This option is not yet supported by Squid-3.
 DOC_END
 
-NAME: storeurl_access storeurl_rewrite_program storeurl_rewrite_concurrency storeurl_rewrite_children
-TYPE: obsolete
-DOC_START
-	This option is not yet supported by this version of Squid-3. Please try a later release.
-DOC_END
-
 # Options Removed in 3.3
 NAME: ignore_ims_on_miss
 TYPE: obsolete
 DOC_START
-	Remove this line. The HTTP/1.1 feature is now fully supported by default.
+	Remove this line. The HTTP/1.1 feature is now configured by 'cache_miss_revalidate'.
 DOC_END
 
 # Options Removed in 3.2
 NAME: chunked_request_body_max_size
 TYPE: obsolete
 DOC_START
@@ -319,15 +338,28 @@
 	authentication disabled.
 
 	=== Parameters for the basic scheme follow. ===
 
 	"program" cmdline
 	Specify the command for the external authenticator.  Such a program
-	reads a line containing "username password" and replies "OK" or
-	"ERR" in an endless loop. "ERR" responses may optionally be followed
-	by a error description available as %m in the returned error page.
+	reads a line containing "username password" and	replies with one of
+	three results:
+
+	  OK
+		the user exists.
+
+	  ERR
+		the user does not exist.
+
+	  BH
+		An internal error occurred in the helper, preventing
+		a result being identified.
+
+	"ERR" and "BH" results may optionally be followed by message="..."
+	containing a description available as %m in the returned error page.
+
 	If you use an authenticator, make sure you have 1 acl of type
 	proxy_auth.
 
 	By default, the basic authentication scheme is not used unless a
 	program is specified.
 
@@ -392,17 +424,28 @@
 
 	=== Parameters for the digest scheme follow ===
 
 	"program" cmdline
 	Specify the command for the external authenticator.  Such
 	a program reads a line containing "username":"realm" and
-	replies with the appropriate H(A1) value hex encoded or
-	ERR if the user (or his H(A1) hash) does not exists.
-	See rfc 2616 for the definition of H(A1).
-	"ERR" responses may optionally be followed by a error description
-	available as %m in the returned error page.
+	replies with one of three results:
+
+	  OK ha1="..."
+		the user exists. The ha1= key is mandatory and
+		contains the appropriate H(A1) value, hex encoded.
+		See rfc 2616 for the definition of H(A1).
+
+	  ERR
+		the user does not exist.
+
+	  BH
+		An internal error occurred in the helper, preventing
+		a result being identified.
+
+	"ERR" and "BH" results may optionally be followed by message="..."
+	containing a description available as %m in the returned error page.
 
 	By default, the digest authentication scheme is not used unless a
 	program is specified.
 
 	If you want to use a digest authenticator, set this line to
 	something like
@@ -478,13 +521,13 @@
 
 	"program" cmdline
 	Specify the command for the external NTLM authenticator.
 	Such a program reads exchanged NTLMSSP packets with
 	the browser via Squid until authentication is completed.
 	If you use an NTLM authenticator, make sure you have 1 acl
-	of type proxy_auth.  By default, the NTLM authenticator_program
+	of type proxy_auth.  By default, the NTLM authenticator program
 	is not used.
 
 	auth_param ntlm program /usr/bin/ntlm_auth
 
 	"children" numberofchildren [startup=N] [idle=N]
 	The maximum number of authenticator processes to spawn (default 5).
@@ -518,13 +561,13 @@
 	This protocol is used in Microsoft Active-Directory enabled setups with
 	the Microsoft Internet Explorer or Mozilla Firefox browsers.
 	Its main purpose is to exchange credentials with the Squid proxy
 	using the Kerberos mechanisms.
 	If you use a Negotiate authenticator, make sure you have at least
 	one acl of type proxy_auth active. By default, the negotiate
-	authenticator_program is not used.
+	authenticator program is not used.
 	The only supported program for this role is the ntlm_auth
 	program distributed as part of Samba, version 4 or later.
 
 	auth_param negotiate program /usr/bin/ntlm_auth --helper-protocol=gss-spnego
 
 	"children" numberofchildren [startup=N] [idle=N]
@@ -599,13 +642,13 @@
 	TTL are removed from memory.
 DOC_END
 
 NAME: authenticate_ip_ttl
 TYPE: time_t
 LOC: Config.authenticateIpTTL
-DEFAULT: 0 seconds
+DEFAULT: 1 second
 DOC_START
 	If you use proxy authentication and the 'max_user_ip' ACL,
 	this directive controls how long Squid remembers the IP
 	addresses associated with each user.  Use a small value
 	(e.g., 60 seconds) if your users might change addresses
 	quickly, as is the case with dialup.   You might be safe
@@ -629,37 +672,50 @@
 	  external_acl_type name [options] FORMAT.. /path/to/helper [helper arguments..]
 
 	Options:
 
 	  ttl=n		TTL in seconds for cached results (defaults to 3600
 	  		for 1 hour)
+
 	  negative_ttl=n
 	  		TTL for cached negative lookups (default same
 	  		as ttl)
+
+	  grace=n	Percentage remaining of TTL where a refresh of a
+			cached entry should be initiated without needing to
+			wait for a new reply. (default is for no grace period)
+
+	  cache=n	Limit the result cache size, default is 262144.
+			The expanded FORMAT value is used as the cache key, so
+			if the details in FORMAT are highly variable a larger
+			cache may be needed to produce reduction in helper load.
+
 	  children-max=n
 			Maximum number of acl helper processes spawned to service
 			external acl lookups of this type. (default 20)
+
 	  children-startup=n
 			Minimum number of acl helper processes to spawn during
 			startup and reconfigure to service external acl lookups
 			of this type. (default 0)
+
 	  children-idle=n
 			Number of acl helper processes to keep ahead of traffic
 			loads. Squid will spawn this many at once whenever load
 			rises above the capabilities of existing processes.
 			Up to the value of children-max. (default 1)
+
 	  concurrency=n	concurrency level per process. Only used with helpers
 			capable of processing more than one query at a time.
-	  cache=n	limit the result cache size, default is unbounded.
-	  grace=n	Percentage remaining of TTL where a refresh of a
-			cached entry should be initiated without needing to
-			wait for a new reply. (default is for no grace period)
-	  protocol=2.5	Compatibility mode for Squid-2.5 external acl helpers
+
+	  protocol=2.5	Compatibility mode for Squid-2.5 external acl helpers.
+
 	  ipv4 / ipv6	IP protocol used to communicate with this helper.
 			The default is to auto-detect IPv6 and use it when available.
 
+
 	FORMAT specifications
 
 	  %LOGIN	Authenticated user login name
 	  %EXT_USER	Username from previous external acl
 	  %EXT_LOG	Log details from previous external acl
 	  %EXT_TAG	Tag from previous external acl
@@ -675,13 +731,13 @@
 	  %MYADDR	Squid interface address
 	  %MYPORT	Squid http_port number
 	  %PATH		Requested URL-path (including query-string if any)
 	  %USER_CERT	SSL User certificate in PEM format
 	  %USER_CERTCHAIN SSL User certificate chain in PEM format
 	  %USER_CERT_xx	SSL User certificate subject attribute xx
-	  %USER_CA_xx	SSL User certificate issuer attribute xx
+	  %USER_CA_CERT_xx SSL User certificate issuer attribute xx
 
 	  %>{Header}	HTTP request header "Header"
 	  %>{Hdr:member}
 	  		HTTP request header "Hdr" list member "member"
 	  %>{Hdr:;member}
 	  		HTTP request header list member using ; as
@@ -703,46 +759,93 @@
 			NOTE: this will encode the arguments as one token,
 			whereas the default will pass each separately.
 
 	  %%		The percent sign. Useful for helpers which need
 			an unchanging input format.
 
-	In addition to the above, any string specified in the referencing
-	acl will also be included in the helper request line, after the
-	specified formats (see the "acl external" directive)
-
-	The helper receives lines per the above format specification,
-	and returns lines starting with OK or ERR indicating the validity
-	of the request and optionally followed by additional keywords with
-	more details.
+
+	General request syntax:
+
+	  [channel-ID] FORMAT-values [acl-values ...]
+
+
+	FORMAT-values consists of transaction details expanded with
+	whitespace separation per the config file FORMAT specification
+	using the FORMAT macros listed above.
+
+	acl-values consists of any string specified in the referencing
+	config 'acl ... external' line. see the "acl external" directive.
+
+	Request values sent to the helper are URL escaped to protect
+	each value in requests against whitespaces.
+
+	If using protocol=2.5 then the request sent to the helper is not
+	URL escaped to protect against whitespace.
+
+	NOTE: protocol=3.0 is deprecated as no longer necessary.
+
+	When using the concurrency= option the protocol is changed by
+	introducing a query channel tag in front of the request/response.
+	The query channel tag is a number between 0 and concurrency-1.
+	This value must be echoed back unchanged to Squid as the first part
+	of the response relating to its request.
+
+
+	The helper receives lines expanded per the above format specification
+	and for each input line returns 1 line starting with OK/ERR/BH result
+	code and optionally followed by additional keywords with more details.
+
 
 	General result syntax:
 
-	  OK/ERR keyword=value ...
+	  [channel-ID] result keyword=value ...
+
+	Result consists of one of the codes:
+
+	  OK
+		the ACL test produced a match.
+
+	  ERR
+		the ACL test does not produce a match.
+
+	  BH
+		An internal error occurred in the helper, preventing
+		a result being identified.
+
+	The meaning of 'a match' is determined by your squid.conf
+	access control configuration. See the Squid wiki for details.
 
 	Defined keywords:
 
 	  user=		The users name (login)
+
 	  password=	The users password (for login= cache_peer option)
-	  message=	Message describing the reason. Available as %o
-	  		in error pages
-	  tag=		Apply a tag to a request (for both ERR and OK results)
-	  		Only sets a tag, does not alter existing tags.
+
+	  message=	Message describing the reason for this response.
+			Available as %o in error pages.
+			Useful on (ERR and BH results).
+
+	  tag=		Apply a tag to a request. Only sets a tag once,
+			does not alter existing tags.
+
 	  log=		String to be logged in access.log. Available as
-	  		%ea in logformat specifications
+	  		%ea in logformat specifications.
 
-	If protocol=3.0 (the default) then URL escaping is used to protect
-	each value in both requests and responses.
+	Any keywords may be sent on any response whether OK, ERR or BH.
 
-	If using protocol=2.5 then all values need to be enclosed in quotes
-	if they may contain whitespace, or the whitespace escaped using \.
-	And quotes or \ characters within the keyword value must be \ escaped.
+	All response keyword values need to be a single token with URL
+	escaping, or enclosed in double quotes (") and escaped using \ on
+	any double quotes or \ characters within the value. The wrapping
+	double quotes are removed before the value is interpreted by Squid.
+	\r and \n are also replace by CR and LF.
 
-	When using the concurrency= option the protocol is changed by
-	introducing a query channel tag infront of the request/response.
-	The query channel tag is a number between 0 and concurrency-1.
+	Some example key values:
+
+		user=John%20Smith
+		user="John Smith"
+		user="J. \"Bob\" Smith"
 DOC_END
 
 NAME: acl
 TYPE: acl
 LOC: Config.aclList
 IF USE_SSL
@@ -766,28 +869,42 @@
 
 	   acl aclname acltype argument ...
 	   acl aclname acltype "file" ...
 
 	When using "file", the file should contain one item per line.
 
-	By default, regular expressions are CASE-SENSITIVE.
-	To make them case-insensitive, use the -i option. To return case-sensitive
-	use the +i option between patterns, or make a new ACL line without -i.
+	Some acl types supports options which changes their default behaviour.
+	The available options are:
+
+	-i,+i	By default, regular expressions are CASE-SENSITIVE. To make them
+		case-insensitive, use the -i option. To return case-sensitive
+		use the +i option between patterns, or make a new ACL line
+		without -i.	
+
+	-n	Disable lookups and address type conversions.  If lookup or
+		conversion is required because the parameter type (IP or
+		domain name) does not match the message address type (domain
+		name or IP), then the ACL would immediately declare a mismatch
+		without any warnings or lookups.
+
+	--	Used to stop processing all options, in the case the first acl
+		value has '-' character as first character (for example the '-'
+		is a valid domain name)
 
 	Some acl types require suspending the current request in order
 	to access some external data source.
 	Those which do are marked with the tag [slow], those which
 	don't are marked as [fast].
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl
 	for further information
 
 	***** ACL TYPES AVAILABLE *****
 
 	acl aclname src ip-address/mask ...	# clients IP address [fast]
 	acl aclname src addr1-addr2/mask ...	# range of addresses [fast]
-	acl aclname dst ip-address/mask ...	# URL host's IP address [slow]
+	acl aclname dst [-n] ip-address/mask ...	# URL host's IP address [slow]
 	acl aclname localip ip-address/mask ... # IP address the client connected to [fast]
 
 	acl aclname arp      mac-address ... (xx:xx:xx:xx:xx:xx notation)
 	  # The arp ACL requires the special configure option --enable-arp-acl.
 	  # Furthermore, the ARP ACL code is not portable to all operating systems.
 	  # It works on Linux, Solaris, Windows, FreeBSD, and some
@@ -797,17 +914,17 @@
 	  # NOTE: Squid can only determine the MAC address for clients that are on
 	  # the same subnet. If the client is on a different subnet,
 	  # then Squid cannot find out its MAC address.
 
 	acl aclname srcdomain   .foo.com ...
 	  # reverse lookup, from client IP [slow]
-	acl aclname dstdomain   .foo.com ...
+	acl aclname dstdomain [-n] .foo.com ...
 	  # Destination server from URL [fast]
 	acl aclname srcdom_regex [-i] \.foo\.com ...
 	  # regex matching client name [slow]
-	acl aclname dstdom_regex [-i] \.foo\.com ...
+	acl aclname dstdom_regex [-n] [-i] \.foo\.com ...
 	  # regex matching server [fast]
 	  #
 	  # For dstdomain and dstdom_regex a reverse lookup is tried if a IP
 	  # based URL is used and no match is found. The name "none" is used
 	  # if the reverse lookup fails.
 
@@ -975,12 +1092,21 @@
 	  #  e.g., DIRECT, PARENT_HIT, NONE, etc.
 	  #
 	  # NOTE: This has no effect in http_access rules. It only has
 	  # effect in rules that affect the reply data stream such as
 	  # http_reply_access.
 
+	acl aclname note name [value ...]
+	  # match transaction annotation [fast]
+	  # Without values, matches any annotation with a given name.
+	  # With value(s), matches any annotation with a given name that
+	  # also has one of the given values.
+	  # Names and values are compared using a string equality test.
+	  # Annotation sources include note and adaptation_meta directives
+	  # as well as helper and eCAP responses.
+
 IF USE_SSL
 	acl aclname ssl_error errorname
 	  # match against SSL certificate validation error [fast]
 	  #
 	  # For valid error names see in @DEFAULT_ERROR_DIR@/templates/error-details.txt
 	  # template file.
@@ -996,13 +1122,45 @@
 	  # The ssl::certHasExpired, ssl::certNotYetValid, ssl::certDomainMismatch,
 	  # ssl::certUntrusted, and ssl::certSelfSigned can also be used as
 	  # predefined ACLs, just like the 'all' ACL.
 	  #
 	  # NOTE: The ssl_error ACL is only supported with sslproxy_cert_error,
 	  # sslproxy_cert_sign, and sslproxy_cert_adapt options.
+
+	acl aclname server_cert_fingerprint [-sha1] fingerprint
+	  # match against server SSL certificate fingerprint [fast]
+	  #
+	  # The fingerprint is the digest of the DER encoded version 
+	  # of the whole certificate. The user should use the form: XX:XX:...
+	  # Optional argument specifies the digest algorithm to use.
+	  # The SHA1 digest algorithm is the default and is currently
+	  # the only algorithm supported (-sha1).
 ENDIF
+	acl aclname any-of acl1 acl2 ...
+	  # match any one of the acls [fast or slow]
+	  # The first matching ACL stops further ACL evaluation.
+	  #
+	  # ACLs from multiple any-of lines with the same name are ORed.
+	  # For example, A = (a1 or a2) or (a3 or a4) can be written as
+	  #   acl A any-of a1 a2
+	  #   acl A any-of a3 a4
+	  #
+	  # This group ACL is fast if all evaluated ACLs in the group are fast
+	  # and slow otherwise.
+
+	acl aclname all-of acl1 acl2 ... 
+	  # match all of the acls [fast or slow]
+	  # The first mismatching ACL stops further ACL evaluation.
+	  #
+	  # ACLs from multiple all-of lines with the same name are ORed.
+	  # For example, B = (b1 and b2) or (b3 and b4) can be written as
+	  #   acl B all-of b1 b2
+	  #   acl B all-of b3 b4
+	  #
+	  # This group ACL is fast if all evaluated ACLs in the group are fast
+	  # and slow otherwise.
 
 	Examples:
 		acl macaddress arp 09:00:2b:23:45:67
 		acl myexample dst_as 1241
 		acl password proxy_auth REQUIRED
 		acl fileupload req_mime_type -i ^multipart/form-data$
@@ -1145,12 +1303,32 @@
 	SECURITY WARNING: Usage of this option is dangerous
 	and should not be used trivially. Correct configuration
 	of follow_x_forewarded_for with a limited set of trusted
 	sources is required to prevent abuse of your proxy.
 DOC_END
 
+NAME: spoof_client_ip
+TYPE: acl_access
+LOC: Config.accessList.spoof_client_ip
+DEFAULT: none
+DEFAULT_DOC: Allow spoofing on all TPROXY traffic.
+DOC_START
+	Control client IP address spoofing of TPROXY traffic based on
+	defined access lists.
+
+	spoof_client_ip allow|deny [!]aclname ...
+
+	If there are no "spoof_client_ip" lines present, the default
+	is to "allow" spoofing of any suitable request.
+
+	Note that the cache_peer "no-tproxy" option overrides this ACL.
+
+	This clause supports fast acl types.
+	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
+DOC_END
+
 NAME: http_access
 TYPE: acl_access
 LOC: Config.accessList.http
 DEFAULT_IF_NONE: deny all
 DEFAULT_DOC: Deny, unless rules exist in squid.conf.
 DOC_START
@@ -1559,12 +1737,13 @@
 			    NO_SSLv3    Disallow the use of SSLv3
 			    NO_TLSv1    Disallow the use of TLSv1.0
 			    NO_TLSv1_1  Disallow the use of TLSv1.1
 			    NO_TLSv1_2  Disallow the use of TLSv1.2
 			    SINGLE_DH_USE Always create a new key when using
 				      temporary/ephemeral DH key exchanges
+			    NO_TICKET Disables TLS tickets extension
 			    ALL       Enable various bug workarounds
 				      suggested as "harmless" by OpenSSL
 				      Be warned that this reduces SSL/TLS
 				      strength to some attacks.
 			See OpenSSL SSL_CTX_set_options documentation for a
 			complete list of options.
@@ -1884,16 +2063,25 @@
 TYPE: QosConfig
 IFDEF: USE_QOS_TOS
 DEFAULT: none
 LOC: Ip::Qos::TheConfig
 DOC_START
 	Allows you to select a TOS/DSCP value to mark outgoing
-	connections with, based on where the reply was sourced.	For
-	platforms using netfilter, allows you to set a netfilter mark
+	connections to the client, based on where the reply was sourced.
+	For platforms using netfilter, allows you to set a netfilter mark
 	value instead of, or in addition to, a TOS value.
 
+	By default this functionality is disabled. To enable it with the default
+	settings simply use "qos_flows mark" or "qos_flows tos". Default
+	settings will result in the netfilter mark or TOS value being copied
+	from the upstream connection to the client. Note that it is the connection
+	CONNMARK value not the packet MARK value that is copied.
+
+	It is not currently possible to copy the mark or TOS value from the
+	client to the upstream connection request.
+
 	TOS values really only have local significance - so you should
 	know what you're specifying. For more information, see RFC2474,
 	RFC2475, and RFC3260.
 
 	The TOS/DSCP byte must be exactly that - a octet value  0 - 255. Note that
 	in practice often only multiples of 4 is usable as the two rightmost bits
@@ -2299,12 +2487,15 @@
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
 	Using slow acl types may result in server crashes
 
 	Without this option, all server certificate validation errors
 	terminate the transaction to protect Squid and the client.
 
+	SQUID_X509_V_ERR_INFINITE_VALIDATION error cannot be bypassed
+	but should not happen unless your OpenSSL library is buggy.
+
 	SECURITY WARNING:
 		Bypassing validation errors is dangerous because an
 		error usually implies that the server cannot be trusted
 		and the connection may be insecure.
 
 	See also: sslproxy_flags and DONT_VERIFY_PEER.
@@ -2460,12 +2651,71 @@
 	processes can handle this many more will be spawned up to the maximum
 	configured. A minimum setting of 1 is required.
 	
 	You must have at least one ssl_crtd process.
 DOC_END
 
+NAME: sslcrtvalidator_program
+TYPE: eol
+IFDEF: USE_SSL
+DEFAULT: none
+LOC: Ssl::TheConfig.ssl_crt_validator
+DOC_START
+	Specify the location and options of the executable for ssl_crt_validator
+	process.
+
+	Usage:  sslcrtvalidator_program [ttl=n] [cache=n] path ...
+
+	Options:
+	  ttl=n         TTL in seconds for cached results. The default is 60 secs
+	  cache=n       limit the result cache size. The default value is 2048
+DOC_END
+
+NAME: sslcrtvalidator_children
+TYPE: HelperChildConfig
+IFDEF: USE_SSL
+DEFAULT: 32 startup=5 idle=1 concurrency=1
+LOC: Ssl::TheConfig.ssl_crt_validator_Children
+DOC_START
+	The maximum number of processes spawn to service SSL server.
+	The maximum this may be safely set to is 32.
+	
+	The startup= and idle= options allow some measure of skew in your
+	tuning.
+	
+		startup=N
+	
+	Sets the minimum number of processes to spawn when Squid
+	starts or reconfigures. When set to zero the first request will
+	cause spawning of the first child process to handle it.
+	
+	Starting too few children temporary slows Squid under load while it
+	tries to spawn enough additional processes to cope with traffic.
+	
+		idle=N
+	
+	Sets a minimum of how many processes Squid is to try and keep available
+	at all times. When traffic begins to rise above what the existing
+	processes can handle this many more will be spawned up to the maximum
+	configured. A minimum setting of 1 is required.
+
+		concurrency=
+	
+	The number of requests each certificate validator helper can handle in
+	parallel. A value of 0 indicates the certficate validator does not
+	support concurrency. Defaults to 1.
+	
+	When this directive is set to a value >= 1 then the protocol
+	used to communicate with the helper is modified to include
+	a request ID in front of the request/response. The request
+	ID from the request must be echoed back with the response
+	to that request.
+	
+	You must have at least one ssl_crt_validator process.
+DOC_END
+
 COMMENT_START
  OPTIONS WHICH AFFECT THE NEIGHBOR SELECTION ALGORITHM
  -----------------------------------------------------------------------------
 COMMENT_END
 
 NAME: cache_peer
@@ -2822,12 +3072,13 @@
 			directives to dentify the peer.
 			Can be used by outgoing access controls through the
 			peername ACL type.
 	
 	no-tproxy	Do not use the client-spoof TPROXY support when forwarding
 			requests to this peer. Use normal address selection instead.
+			This overrides the spoof_client_ip ACL.
 	
 	proxy-only	objects fetched from the peer will not be stored locally.
 	
 DOC_END
 
 NAME: cache_peer_domain cache_host_domain
@@ -3106,12 +3357,45 @@
 
 	For more information about the GDSF and LFUDA cache replacement
 	policies see http://www.hpl.hp.com/techreports/1999/HPL-1999-69.html
 	and http://fog.hpl.external.hp.com/techreports/98/HPL-98-173.html.
 DOC_END
 
+NAME: minimum_object_size
+COMMENT: (bytes)
+TYPE: b_int64_t
+DEFAULT: 0 KB
+DEFAULT_DOC: no limit
+LOC: Config.Store.minObjectSize
+DOC_START
+	Objects smaller than this size will NOT be saved on disk.  The
+	value is specified in bytes, and the default is 0 KB, which
+	means all responses can be stored.
+DOC_END
+
+NAME: maximum_object_size
+COMMENT: (bytes)
+TYPE: b_int64_t
+DEFAULT: 4 MB
+LOC: Config.Store.maxObjectSize
+DOC_START
+	Set the default value for max-size parameter on any cache_dir.
+	The value is specified in bytes, and the default is 4 MB.
+	
+	If you wish to get a high BYTES hit ratio, you should probably
+	increase this (one 32 MB object hit counts for 3200 10KB
+	hits).
+	
+	If you wish to increase hit ratio more than you want to
+	save bandwidth you should leave this low.
+	
+	NOTE: if using the LFUDA replacement policy you should increase
+	this value to maximize the byte hit rate improvement of LFUDA!
+	See cache_replacement_policy for a discussion of this policy.
+DOC_END
+
 NAME: cache_dir
 TYPE: cachedir
 DEFAULT: none
 DEFAULT_DOC: No disk cache. Store cache ojects only in memory.
 LOC: Config.cacheSwap
 DOC_START
@@ -3266,15 +3550,15 @@
 			other stores are optimized for smaller objects
 			(e.g. COSS).
 			Defaults to 0.
 
 	max-size=n	the maximum object size in bytes this cache_dir
 			supports.
-			The value in maximum_object_size directive, sets
-			a default unless more specific details are available
-			about the cache_dir (ie a small store capacity).
+			The value in maximum_object_size directive sets
+			the default unless more specific details are
+			available (ie a small store capacity).
 
 	Note: To make optimal use of the max-size limits you should order
 	the cache_dir lines with the smallest max-size value first.
 
 	Note for coss, max-size must be less than COSS_MEMBUF_SZ,
 	which can be changed with the --with-coss-membuf-size=N configure
@@ -3345,46 +3629,12 @@
 	bypass the on-disk cache if more than this amount of disk file
 	descriptors are open.
 
 	A value of 0 indicates no limit.
 DOC_END
 
-NAME: minimum_object_size
-COMMENT: (bytes)
-TYPE: b_int64_t
-DEFAULT: 0 KB
-DEFAULT_DOC: no limit
-LOC: Config.Store.minObjectSize
-DOC_START
-	Objects smaller than this size will NOT be saved on disk.  The
-	value is specified in bytes, and the default is 0 KB, which
-	means all responses can be stored.
-DOC_END
-
-NAME: maximum_object_size
-COMMENT: (bytes)
-TYPE: b_int64_t
-DEFAULT: 4 MB
-LOC: Config.Store.maxObjectSize
-DOC_START
-	The default limit on size of objects stored to disk.
-	This size is used for cache_dir where max-size is not set.
-	The value is specified in bytes, and the default is 4 MB.
-
-	If you wish to get a high BYTES hit ratio, you should probably
-	increase this (one 32 MB object hit counts for 3200 10KB
-	hits).
-
-	If you wish to increase hit ratio more than you want to
-	save bandwidth you should leave this low.
-
-	NOTE: if using the LFUDA replacement policy you should increase
-	this value to maximize the byte hit rate improvement of LFUDA!
-	See replacement_policy below for a discussion of this policy.
-DOC_END
-
 NAME: cache_swap_low
 COMMENT: (percent, 0-100)
 TYPE: int
 DEFAULT: 90
 LOC: Config.Swap.lowWaterMark
 DOC_START
@@ -3467,30 +3717,50 @@
 
 		%	a literal % character
 		sn	Unique sequence number per log line entry
 		err_code    The ID of an error response served by Squid or
 				a similar internal error identifier.
 		err_detail  Additional err_code-dependent error information.
+		note	The annotation specified by the argument. Also
+			logs the adaptation meta headers set by the
+			adaptation_meta configuration parameter.
+			If no argument given all annotations logged.
+			The argument may include a separator to use with
+			annotation values:
+                            name[:separator]
+			By default, multiple note values are separated with ","
+			and multiple notes are separated with "\r\n".
+			When logging named notes with %{name}note, the
+			explicitly configured separator is used between note
+			values. When logging all notes with %note, the
+			explicitly configured separator is used between
+			individual notes. There is currently no way to
+			specify both value and notes separators when logging
+			all notes with %note.
 
 	Connection related format codes:
 
 		>a	Client source IP address
 		>A	Client FQDN
 		>p	Client source port
 		>eui	Client source EUI (MAC address, EUI-48 or EUI-64 identifier)
 		>la	Local IP address the client connected to
 		>lp	Local port number the client connected to
+		>qos    Client connection TOS/DSCP value set by Squid
+		>nfmark Client connection netfilter mark set by Squid
 
 		la	Local listening IP address the client connection was connected to.
 		lp	Local listening port number the client connection was connected to.
 
 		<a	Server IP address of the last server or peer connection
 		<A	Server FQDN or peer name
 		<p	Server port number of the last server or peer connection
 		<la	Local IP address of the last server or peer connection
 		<lp     Local port number of the last server or peer connection
+		<qos	Server connection TOS/DSCP value set by Squid
+		<nfmark Server connection netfilter mark set by Squid
 
 	Time related format codes:
 
 		ts	Seconds since epoch
 		tu	subsecond time (milliseconds)
 		tl	Local time. Optional strftime format argument
@@ -3655,22 +3925,53 @@
 
 NAME: access_log cache_access_log
 TYPE: access_log
 LOC: Config.Log.accesslogs
 DEFAULT_IF_NONE: daemon:@DEFAULT_ACCESS_LOG@ squid
 DOC_START
-	These files log client request activities. Has a line every HTTP or
-	ICP request. The format is:
+	Configures whether and how Squid logs HTTP and ICP transactions.
+	If access logging is enabled, a single line is logged for every 
+	matching HTTP or ICP request. The recommended directive formats are:
+
+	access_log <module>:<place> [option ...] [acl acl ...]
+	access_log none [acl acl ...]
+
+	The following directive format is accepted but may be deprecated:
 	access_log <module>:<place> [<logformat name> [acl acl ...]]
-	access_log none [acl acl ...]]
+
+        In most cases, the first ACL name must not contain the '=' character
+	and should not be equal to an existing logformat name. You can always
+	start with an 'all' ACL to work around those restrictions.
 	
 	Will log to the specified module:place using the specified format (which
 	must be defined in a logformat directive) those entries which match
 	ALL the acl's specified (which must be defined in acl clauses).
 	If no acl is specified, all requests will be logged to this destination.
 	
+	===== Available options for the recommended directive format =====
+
+	logformat=name		Names log line format (either built-in or
+				defined by a logformat directive). Defaults
+				to 'squid'.
+
+	buffer-size=64KB	Defines approximate buffering limit for log
+				records (see buffered_logs).  Squid should not
+				keep more than the specified size and, hence,
+				should flush records before the buffer becomes
+				full to avoid overflows under normal
+				conditions (the exact flushing algorithm is
+				module-dependent though).  The on-error option
+				controls overflow handling.
+
+	on-error=die|drop	Defines action on unrecoverable errors. The
+				'drop' action ignores (i.e., does not log)
+				affected log records. The default 'die' action
+				kills the affected worker. The drop action 
+				support has not been tested for modules other
+				than tcp.
+
 	===== Modules Currently available =====
 	
 	none	Do not log any requests matching these ACL.
 		Do not specify Place or logformat name.
 	
 	stdio	Write each log line to disk immediately at the completion of
@@ -3695,12 +3996,13 @@
 	
 	udp	To send each log line as text data to a UDP receiver.
 		Place: The destination host name or IP and port.
 		Place Format:   //host:port
 
 	tcp	To send each log line as text data to a TCP receiver.
+		Lines may be accumulated before sending (see buffered_logs).
 		Place: The destination host name or IP and port.
 		Place Format:   //host:port
 
 	Default:
 		access_log daemon:@DEFAULT_ACCESS_LOG@ squid
 DOC_END
@@ -3812,37 +4114,37 @@
 	  b<n>\n - 1 = buffer output, 0 = don't buffer output
 
 	No responses is expected.
 DOC_END
 
 NAME: log_access
+TYPE: obsolete
+DOC_START
+	Remove this line. Use acls with access_log directives to control access logging
+DOC_END
+
+NAME: log_icap
+TYPE: obsolete
+DOC_START
+	Remove this line. Use acls with icap_log directives to control icap logging
+DOC_END
+
+NAME: stats_collection
 TYPE: acl_access
-LOC: Config.accessList.log
+LOC: Config.accessList.stats_collection
 DEFAULT: none
 DEFAULT_DOC: Allow logging for all transactions.
 COMMENT: allow|deny acl acl...
 DOC_START
-	This options allows you to control which requests gets logged
-	to access.log (see access_log directive). Requests denied for
-	logging will also not be accounted for in performance counters.
+	This options allows you to control which requests gets accounted
+	in performance counters.
 
 	This clause only supports fast acl types.
 	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
 DOC_END
 
-NAME: log_icap
-TYPE: acl_access
-IFDEF: ICAP_CLIENT
-LOC: Config.accessList.icap
-DEFAULT: none
-DEFAULT_DOC: Allow logging for all ICAP transactions.
-DOC_START
-	This options allows you to control which requests get logged
-	to icap.log. See the icap_log directive for ICAP log details.
-DOC_END
-
 NAME: cache_store_log
 TYPE: string
 DEFAULT: none
 LOC: Config.Log.store
 DOC_START
 	Logs the activities of the storage manager.  Shows which
@@ -4023,13 +4325,13 @@
 	hence, increases the risk of log records loss.
 
 	Note that even when buffered_logs are off, Squid may have to buffer
 	records if it cannot write/send them immediately due to pending I/Os
 	(e.g., the I/O writing the previous log record) or connectivity loss.
 
-	Currently honored by 'daemon' access_log module only.
+	Currently honored by 'daemon' and 'tcp' access_log modules only.
 DOC_END
 
 NAME: netdb_filename
 TYPE: string
 DEFAULT: stdio:@DEFAULT_NETDB_FILE@
 LOC: Config.netdbFilename
@@ -4279,25 +4581,65 @@
 DOC_START
 	Specify the location of the executable URL rewriter to use.
 	Since they can perform almost any function there isn't one included.
 
 	For each requested URL, the rewriter will receive on line with the format
 
-	URL <SP> client_ip "/" fqdn <SP> user <SP> method [<SP> kvpairs]<NL>
+	  [channel-ID <SP>] URL <SP> client_ip "/" fqdn <SP> user <SP> method [<SP> kv-pairs]<NL>
+
+
+	After processing the request the helper must reply using the following format:
+
+	  [channel-ID <SP>] result [<SP> kv-pairs]
+
+	The result code can be:
+
+	  OK status=30N url="..."
+		Redirect the URL to the one supplied in 'url='.
+		'status=' is optional and contains the status code to send
+		the client in Squids HTTP response. It must be one of the
+		HTTP redirect status codes: 301, 302, 303, 307, 308.
+		When no status is given Squid will use 302.
+
+	  OK rewrite-url="..."
+		Rewrite the URL to the one supplied in 'rewrite-url='.
+		The new URL is fetched directly by Squid and returned to
+		the client as the response to its request.
+
+	  OK
+		When neither of url= and rewrite-url= are sent Squid does
+		not change the URL.
+
+	  ERR
+		Do not change the URL.
 
-	In the future, the rewriter interface will be extended with
-	key=value pairs ("kvpairs" shown above).  Rewriter programs
+	  BH
+		An internal error occurred in the helper, preventing
+		a result being identified. The 'message=' key name is
+		reserved for delivering a log message.
+
+
+	In the future, the interface protocol will be extended with
+	key=value pairs ("kv-pairs" shown above).  Helper programs
 	should be prepared to receive and possibly ignore additional
 	whitespace-separated tokens on each input line.
 
-	And the rewriter may return a rewritten URL. The other components of
-	the request line does not need to be returned (ignored if they are).
+	When using the concurrency= option the protocol is changed by
+	introducing a query channel tag in front of the request/response.
+	The query channel tag is a number between 0 and concurrency-1.
+	This value must be echoed back unchanged to Squid as the first part
+	of the response relating to its request.
+
+	WARNING: URL re-writing ability should be avoided whenever possible.
+		 Use the URL redirect form of response instead.
 
-	The rewriter can also indicate that a client-side redirect should
-	be performed to the new URL. This is done by prefixing the returned
-	URL with "301:" (moved permanently) or 302: (moved temporarily), etc.
+	Re-write creates a difference in the state held by the client
+	and server. Possibly causing confusion when the server response
+	contains snippets of its view state. Embeded URLs, response
+	and content Location headers, etc. are not re-written by this
+	interface.
 
 	By default, a URL rewriter is not used.
 DOC_END
 
 NAME: url_rewrite_children redirect_children
 TYPE: HelperChildConfig
@@ -4333,15 +4675,14 @@
 	The number of requests each redirector helper can handle in
 	parallel. Defaults to 0 which indicates the redirector
 	is a old-style single threaded redirector.
 
 	When this directive is set to a value >= 1 then the protocol
 	used to communicate with the helper is modified to include
-	a request ID in front of the request/response. The request
-	ID from the request must be echoed back with the response
-	to that request.
+	an ID in front of the request/response. The ID from the request
+	must be echoed back with the response to that request.
 DOC_END
 
 NAME: url_rewrite_host_header redirect_rewrites_host_header
 TYPE: onoff
 DEFAULT: on
 LOC: Config.onoff.redir_rewrites_host
@@ -4389,12 +4730,135 @@
 	redirectors for access control, and you enable this option,
 	users may have access to pages they should not
 	be allowed to request.
 DOC_END
 
 COMMENT_START
+ OPTIONS FOR STORE ID
+ -----------------------------------------------------------------------------
+COMMENT_END
+
+NAME: store_id_program storeurl_rewrite_program
+TYPE: wordlist
+LOC: Config.Program.store_id
+DEFAULT: none
+DOC_START
+	Specify the location of the executable StoreID helper to use.
+	Since they can perform almost any function there isn't one included.
+
+	For each requested URL, the helper will receive one line with the format
+
+	  [channel-ID <SP>] URL <SP> client_ip "/" fqdn <SP> user <SP> method [<SP> kv-pairs]<NL>
+
+
+	After processing the request the helper must reply using the following format:
+
+	  [channel-ID <SP>] result [<SP> kv-pairs]
+
+	The result code can be:
+
+	  OK store-id="..."
+		Use the StoreID supplied in 'store-id='.
+
+	  ERR
+		The default is to use HTTP request URL as the store ID.
+
+	  BH
+		An internal error occured in the helper, preventing
+		a result being identified.
+
+
+	Helper programs should be prepared to receive and possibly ignore additional
+	kv-pairs with keys they do not support.
+
+	When using the concurrency= option the protocol is changed by
+	introducing a query channel tag in front of the request/response.
+	The query channel tag is a number between 0 and concurrency-1.
+	This value must be echoed back unchanged to Squid as the first part
+	of the response relating to its request.
+
+	NOTE: when using StoreID refresh_pattern will apply to the StoreID
+	      returned from the helper and not the URL.
+
+	WARNING: Wrong StoreID value returned by a careless helper may result
+	         in the wrong cached response returned to the user.
+
+	By default, a StoreID helper is not used.
+DOC_END
+
+NAME: store_id_children storeurl_rewrite_children
+TYPE: HelperChildConfig
+DEFAULT: 20 startup=0 idle=1 concurrency=0
+LOC: Config.storeIdChildren
+DOC_START
+	The maximum number of StoreID helper processes to spawn. If you limit
+	it too few Squid will have to wait for them to process a backlog of
+	requests, slowing it down. If you allow too many they will use RAM
+	and other system resources noticably.
+	
+	The startup= and idle= options allow some measure of skew in your
+	tuning.
+	
+		startup=
+	
+	Sets a minimum of how many processes are to be spawned when Squid
+	starts or reconfigures. When set to zero the first request will
+	cause spawning of the first child process to handle it.
+	
+	Starting too few will cause an initial slowdown in traffic as Squid
+	attempts to simultaneously spawn enough processes to cope.
+	
+		idle=
+	
+	Sets a minimum of how many processes Squid is to try and keep available
+	at all times. When traffic begins to rise above what the existing
+	processes can handle this many more will be spawned up to the maximum
+	configured. A minimum setting of 1 is required.
+
+		concurrency=
+
+	The number of requests each storeID helper can handle in
+	parallel. Defaults to 0 which indicates the helper
+	is a old-style single threaded program.
+
+	When this directive is set to a value >= 1 then the protocol
+	used to communicate with the helper is modified to include
+	an ID in front of the request/response. The ID from the request
+	must be echoed back with the response to that request.
+DOC_END
+
+NAME: store_id_access storeurl_rewrite_access
+TYPE: acl_access
+DEFAULT: none
+DEFAULT_DOC: Allow, unless rules exist in squid.conf.
+LOC: Config.accessList.store_id
+DOC_START
+	If defined, this access list specifies which requests are
+	sent to the StoreID processes.  By default all requests
+	are sent.
+
+	This clause supports both fast and slow acl types.
+	See http://wiki.squid-cache.org/SquidFaq/SquidAcl for details.
+DOC_END
+
+NAME: store_id_bypass storeurl_rewrite_bypass
+TYPE: onoff
+LOC: Config.onoff.store_id_bypass
+DEFAULT: on
+DOC_START
+	When this is 'on', a request will not go through the
+	helper if all helpers are busy.  If this is 'off'
+	and the helper queue grows too large, Squid will exit
+	with a FATAL error and ask you to increase the number of
+	helpers.  You should only enable this if the helperss
+	are not critical to your caching system.  If you use
+	helpers for critical caching components, and you enable this 
+	option,	users may not get objects from cache.
+DOC_END
+
+COMMENT_START
  OPTIONS FOR TUNING THE CACHE
  -----------------------------------------------------------------------------
 COMMENT_END
 
 NAME: cache no_cache
 TYPE: acl_access
@@ -4574,13 +5038,13 @@
 	may be undesirable on slow (e.g. SLIP) links and/or very busy
 	caches.  Impatient users may tie up file descriptors and
 	bandwidth by repeatedly requesting and immediately aborting
 	downloads.
 
 	When the user aborts a request, Squid will check the
-	quick_abort values to the amount of data transfered until
+	quick_abort values to the amount of data transferred until
 	then.
 
 	If the transfer has less than 'quick_abort_min' KB remaining,
 	it will finish the retrieval.
 
 	If the transfer has more than 'quick_abort_max' KB remaining,
@@ -5106,12 +5570,28 @@
 	injection to matching requests. As always in squid.conf, all
 	ACLs in an option ACL list must be satisfied for the insertion
 	to happen. The request_header_add option supports fast ACLs
 	only.
 DOC_END
 
+NAME: note
+TYPE: note
+LOC: Config.notes
+DEFAULT: none
+DOC_START
+	This option used to log custom information about the master
+	transaction. For example, an admin may configure Squid to log
+	which "user group" the transaction belongs to, where "user group"
+	will be determined based on a set of ACLs and not [just]
+	authentication information.
+	Values of key/value pairs can be logged using %{key}note macros:
+
+	    note key value acl ...
+	    logformat myFormat ... %{key}note ...
+DOC_END
+
 NAME: relaxed_header_parser
 COMMENT: on|off|warn
 TYPE: tristate
 LOC: Config.onoff.relaxed_header_parser
 DEFAULT: on
 DOC_START
@@ -6859,23 +7339,31 @@
 NAME: cache_miss_revalidate
 COMMENT: on|off
 TYPE: onoff
 DEFAULT: on
 LOC: Config.onoff.cache_miss_revalidate
 DOC_START
-	Whether Squid on cache MISS will pass client revalidation requests
-	to the server or tries to fetch new content for caching.
-	This is useful while the cache is mostly empty to more quickly
-	have the cache populated.
+	RFC 7232 defines a conditional request mechanism to prevent
+	response objects being unnecessarily transferred over the network.
+	If that mechanism is used by the client and a cache MISS occurs
+	it can prevent new cache entries being created.
+
+	This option determines whether Squid on cache MISS will pass the
+	client revalidation request to the server or tries to fetch new
+	content for caching. It can be useful while the cache is mostly
+	empty to more quickly have the cache populated by generating
+	non-conditional GETs.
 
 	When set to 'on' (default), Squid will pass all client If-* headers
-	to the server.
+	to the server. This permits server responses without a cacheable
+	payload to be delivered and on MISS no new cache entry is created.
 
 	When set to 'off' and if the request is cacheable, Squid will
 	remove the clients If-Modified-Since and If-None-Match headers from
-	the request sent to the server.
+	the request sent to the server. This requests a 200 status response
+	from the server to create a new cache entry with.
 DOC_END
 
 NAME: always_direct
 TYPE: acl_access
 LOC: Config.accessList.AlwaysDirect
 DEFAULT: none
@@ -7688,13 +8176,13 @@
 Example:
 # share authentication information among ICAP services
 adaptation_masterx_shared_names X-Subscriber-ID
 DOC_END
 
 NAME: adaptation_meta
-TYPE: adaptation_meta_type
+TYPE: note
 IFDEF: USE_ADAPTATION
 LOC: Adaptation::Config::metaHeaders
 DEFAULT: none
 DOC_START
 	This option allows Squid administrator to add custom ICAP request
 	headers or eCAP options to Squid ICAP requests or eCAP transactions.
@@ -7720,12 +8208,18 @@
 	
 	The "value" parameter may be a regular squid.conf token or a "double
 	quoted string". Within the quoted string, use backslash (\) to escape
 	any character, which is currently only useful for escaping backslashes
 	and double quotes. For example,
 	    "this string has one backslash (\\) and two \"quotes\""
+
+	Used adaptation_meta header values may be logged via %note
+	logformat code. If multiple adaptation_meta headers with the same name
+	are used during master transaction lifetime, the header values are
+	logged in the order they were used and duplicate values are ignored
+	(only the first repeated value will be logged).
 DOC_END
 
 NAME: icap_retry
 TYPE: acl_access
 IFDEF: ICAP_CLIENT
 LOC: Adaptation::Icap::TheConfig.repeat
@@ -7888,12 +8382,25 @@
 	Normally the RES_DEFNAMES resolver option is disabled
 	(see res_init(3)).  This prevents caches in a hierarchy
 	from interpreting single-component hostnames locally.  To allow
 	Squid to handle single-component names, enable this option.
 DOC_END
 
+NAME: dns_multicast_local
+COMMENT: on|off
+TYPE: onoff
+DEFAULT: off
+DEFAULT_DOC: Search for .local and .arpa names is disabled.
+LOC: Config.onoff.dns_mdns
+DOC_START
+	When set to on, Squid sends multicast DNS lookups on the local
+	network for domains ending in .local and .arpa.
+	This enables local servers and devices to be contacted in an
+	ad-hoc or zero-configuration network environment.
+DOC_END
+
 NAME: dns_nameservers
 TYPE: wordlist
 DEFAULT: none
 DEFAULT_DOC: Use operating system definitions
 LOC: Config.dns_nameservers
 DOC_START
@@ -8023,12 +8530,41 @@
 
 COMMENT_START
  MISCELLANEOUS
  -----------------------------------------------------------------------------
 COMMENT_END
 
+NAME: configuration_includes_quoted_values
+COMMENT: on|off
+TYPE: onoff
+DEFAULT: off
+LOC: ConfigParser::RecognizeQuotedValues
+DOC_START
+	Previous Squid versions have defined "quoted/string" as syntax for
+	ACL to signifiy the value is an included file containing values and
+	has treated the " characters in other places of the configuration file
+	as part of the parameter value it was used for.
+
+	For compatibility with existing installations that behaviour
+	remains the default.
+
+	If this directive is set to 'on', Squid will start parsing each
+	"quoted string" as a single configuration directive parameter. The
+	quotes are stripped before the parameter value is interpreted or use.
+
+	That will continue for all lines until this directive is set to 'off',
+	where Squid will return to the default configuration parsing.
+
+	For example;
+
+		configuration_includes_quoted_values on
+		acl group external groupCheck Administrators "Internet Users" Guest
+		configuration_includes_quoted_values off
+
+DOC_END
+
 NAME: memory_pools
 COMMENT: on|off
 TYPE: onoff
 DEFAULT: on
 LOC: Config.onoff.mem_pools
 DOC_START
@@ -8318,23 +8854,29 @@
 	to different IP addresses.
 
 	Enabling this directive Squid rotates IP's per request.
 DOC_END
 
 NAME: pipeline_prefetch
-TYPE: onoff
-LOC: Config.onoff.pipeline_prefetch
-DEFAULT: off
+TYPE: pipelinePrefetch
+LOC: Config.pipeline_max_prefetch
+DEFAULT: 0
+DEFAULT_DOC: Do not pre-parse pipelined requests.
 DOC_START
-	To boost the performance of pipelined requests to closer
-	match that of a non-proxied environment Squid can try to fetch
-	up to two requests in parallel from a pipeline.
+	HTTP clients may send a pipeline of 1+N requests to Squid using a
+	single connection, without waiting for Squid to respond to the first
+	of those requests. This option limits the number of concurrent
+	requests Squid will try to handle in parallel. If set to N, Squid
+	will try to receive and process up to 1+N requests on the same
+	connection concurrently.
 
-	Defaults to off for bandwidth management and access logging
+	Defaults to 0 (off) for bandwidth management and access logging
 	reasons.
 
+	NOTE: pipelining requires persistent connections to clients.
+
 	WARNING: pipelining breaks NTLM and Negotiate/Kerberos authentication.
 DOC_END
 
 NAME: high_response_time_warning
 TYPE: int
 COMMENT: (msec)
@@ -8359,12 +8901,13 @@
 	per second.
 DOC_END
 
 NAME: high_memory_warning
 TYPE: b_size_t
 LOC: Config.warnings.high_memory
+IFDEF: HAVE_MSTATS&&HAVE_GNUMALLOC_H
 DEFAULT: 0 KB
 DEFAULT_DOC: disabled.
 DOC_START
 	If the memory usage (as determined by mallinfo) exceeds
 	this amount, Squid prints a WARNING with debug level 0 to get
 	the administrators attention.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cf_gen.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cf_gen.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cf_gen.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cf_gen.cc	2015-05-01 18:05:19.000000000 +0800
@@ -628,12 +628,13 @@
 void
 Entry::genParseAlias(const std::string &aName, std::ostream &fout) const
 {
     fout << "    if (!strcmp(token, \"" << aName << "\")) {" << std::endl;
     if (ifdef.size())
         fout << "#if " << ifdef << std::endl;
+    fout << "        cfg_directive = \"" << aName << "\";" << std::endl;
     fout << "        ";
     if (type.compare("obsolete") == 0) {
         fout << "debugs(0, DBG_CRITICAL, \"ERROR: Directive '" << aName << "' is obsolete.\");\n";
         for (LineList::const_iterator l = doc.begin(); l != doc.end(); ++l) {
             // offset line to strip initial whitespace tab byte
             fout << "        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), \"" << aName << " : " << &(*l)[1] << "\");" << std::endl;
@@ -642,12 +643,13 @@
     } else if (!loc.size() || loc.compare("none") == 0) {
         fout << "parse_" << type << "();";
     } else {
         fout << "parse_" << type << "(&" << loc << (array_flag ? "[0]" : "") << ");";
     }
     fout << std::endl;
+    fout << "        cfg_directive = NULL;" << std::endl;
     if (ifdef.size()) {
         fout <<
         "#else" << std::endl <<
         "    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), \"ERROR: '" << name << "' requires " << available_if(ifdef) << "\");" << std::endl <<
         "#endif" << std::endl;
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cf_gen_defines /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cf_gen_defines
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/cf_gen_defines	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/cf_gen_defines	2015-05-01 18:05:19.000000000 +0800
@@ -2,41 +2,43 @@
 BEGIN {
 	print "/* Generated automatically from cf.data.pre"
 	print " * DO NOT EDIT"
 	print "*/"
 	print "#include \"autoconf.h\""
 	print "static struct { const char *name; const char *enable; int defined;} defines[] = {"
-	define["USE_DELAY_POOLS"]="--enable-delay-pools"
+	define["_SQUID_WINDOWS_"]="MS Windows"
 	define["FOLLOW_X_FORWARDED_FOR"]="--enable-follow-x-forwarded-for"
-	define["FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS"]="--enable-follow-x-forwarded-for and --enable-delay-pools"
-	define["FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION"]="--enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)"
 	define["FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER"]="--enable-follow-x-forwarded-for and --enable-linux-netfilter"
-	define["USE_HTTP_VIOLATIONS"]="--enable-http-violations"
+	define["FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION"]="--enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)"
+	define["FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS"]="--enable-follow-x-forwarded-for and --enable-delay-pools"
+	define["HAVE_MSTATS&&HAVE_GNUMALLOC_H"]="GNU Malloc with mstats()"
 	define["ICAP_CLIENT"]="--enable-icap-client"
+	define["SO_MARK&&USE_LIBCAP"]="Packet MARK (Linux)"
 	define["SQUID_SNMP"]="--enable-snmp"
 	define["USE_ADAPTATION"]="--enable-ecap or --enable-icap-client"
 	define["USE_AUTH"]="--enable-auth"
 	define["USE_CACHE_DIGESTS"]="--enable-cache-digests"
+	define["USE_DELAY_POOLS"]="--enable-delay-pools"
 	define["USE_DNSHELPER"]="--disable-internal-dns"
 	define["!USE_DNSHELPER"]="--enable-internal-dns"
 	define["USE_ECAP"]="--enable-ecap"
 	define["USE_ERR_LOCALES"]="--enable-auto-locale"
 	define["USE_HTCP"]="--enable-htcp"
+	define["USE_HTTP_VIOLATIONS"]="--enable-http-violations"
 	define["USE_ICMP"]="--enable-icmp"
 	define["USE_IDENT"]="--enable-ident-lookups"
 	define["USE_LOADABLE_MODULES"]="--enable-loadable-modules"
+	define["USE_OPENSSL"]="--with-openssl"
+	define["USE_QOS_TOS"]="--enable-zph-qos"
 	define["USE_SQUID_ESI"]="--enable-esi"
 	define["USE_SQUID_EUI"]="--enable-eui"
 	define["USE_SSL_CRTD"]="--enable-ssl-crtd"
 	define["USE_SSL"]="--enable-ssl"
 	define["USE_UNLINKD"]="--enable-unlinkd"
 	define["USE_WCCP"]="--enable-wccp"
 	define["USE_WCCPv2"]="--enable-wccpv2"
-	define["USE_QOS_TOS"]="--enable-zph-qos"
-	define["_SQUID_WINDOWS_"]="MS Windows"
-	define["SO_MARK&&USE_LIBCAP"]="Packet MARK (Linux)"
 }
 /^IFDEF:/ {
 	if (define[$2] != "")
 	    DEFINE=define[$2]
 	else
 	    DEFINE="-D" $2 " define"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_db.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_db.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_db.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_db.cc	2015-05-01 18:05:19.000000000 +0800
@@ -28,12 +28,13 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #include "squid.h"
+#include "base/RunnersRegistry.h"
 #include "client_db.h"
 #include "event.h"
 #include "format/Token.h"
 #include "ClientInfo.h"
 #include "fqdncache.h"
 #include "ip/Address.h"
@@ -79,13 +80,13 @@
 clientdbAdd(const Ip::Address &addr)
 {
     ClientInfo *c;
     char *buf = static_cast<char*>(xmalloc(MAX_IPSTRLEN)); // becomes hash.key
     c = (ClientInfo *)memAllocate(MEM_CLIENT_INFO);
     debugs(77, 9, "ClientInfo constructed, this=" << c);
-    c->hash.key = addr.NtoA(buf,MAX_IPSTRLEN);
+    c->hash.key = addr.toStr(buf,MAX_IPSTRLEN);
     c->addr = addr;
 #if USE_DELAY_POOLS
     /* setup default values for client write limiter */
     c->writeLimitingActive=false;
     c->writeSpeedLimit=0;
     c->bucketSize = 0;
@@ -109,28 +110,34 @@
     }
 
     return c;
 }
 
 static void
-clientdbRegisterWithCacheManager(void)
-{
-    Mgr::RegisterAction("client_list", "Cache Client List", clientdbDump, 0, 1);
-}
-
-void
 clientdbInit(void)
 {
-    clientdbRegisterWithCacheManager();
-
     if (client_table)
         return;
 
     client_table = hash_create((HASHCMP *) strcmp, CLIENT_DB_HASH_SIZE, hash_string);
 }
 
+class ClientDbRr: public RegisteredRunner
+{
+public:
+    virtual void run(const RunnerRegistry &);
+};
+RunnerRegistrationEntry(rrAfterConfig, ClientDbRr);
+
+void
+ClientDbRr::run(const RunnerRegistry &r)
+{
+    clientdbInit();
+    Mgr::RegisterAction("client_list", "Cache Client List", clientdbDump, 0, 1);
+}
+
 #if USE_DELAY_POOLS
 /* returns ClientInfo for given IP addr
    Returns NULL if no such client (or clientdb turned off)
    (it is assumed that clientdbEstablished will be called before and create client record if needed)
 */
 ClientInfo * clientdbGetInfo(const Ip::Address &addr)
@@ -138,32 +145,32 @@
     char key[MAX_IPSTRLEN];
     ClientInfo *c;
 
     if (!Config.onoff.client_db)
         return NULL;
 
-    addr.NtoA(key,MAX_IPSTRLEN);
+    addr.toStr(key,MAX_IPSTRLEN);
 
     c = (ClientInfo *) hash_lookup(client_table, key);
     if (c==NULL) {
         debugs(77, DBG_IMPORTANT,"Client db does not contain information for given IP address "<<(const char*)key);
         return NULL;
     }
     return c;
 }
 #endif
 void
-clientdbUpdate(const Ip::Address &addr, log_type ltype, AnyP::ProtocolType p, size_t size)
+clientdbUpdate(const Ip::Address &addr, LogTags ltype, AnyP::ProtocolType p, size_t size)
 {
     char key[MAX_IPSTRLEN];
     ClientInfo *c;
 
     if (!Config.onoff.client_db)
         return;
 
-    addr.NtoA(key,MAX_IPSTRLEN);
+    addr.toStr(key,MAX_IPSTRLEN);
 
     c = (ClientInfo *) hash_lookup(client_table, key);
 
     if (c == NULL)
         c = clientdbAdd(addr);
 
@@ -201,13 +208,13 @@
     char key[MAX_IPSTRLEN];
     ClientInfo *c;
 
     if (!Config.onoff.client_db)
         return 0;
 
-    addr.NtoA(key,MAX_IPSTRLEN);
+    addr.toStr(key,MAX_IPSTRLEN);
 
     c = (ClientInfo *) hash_lookup(client_table, key);
 
     if (c == NULL) {
         c = clientdbAdd(addr);
     }
@@ -231,13 +238,13 @@
     double p;
     ClientInfo *c;
 
     if (!Config.onoff.client_db)
         return 0;
 
-    addr.NtoA(key,MAX_IPSTRLEN);
+    addr.toStr(key,MAX_IPSTRLEN);
 
     c = (ClientInfo *) hash_lookup(client_table, key);
 
     if (c == NULL)
         return 0;
 
@@ -277,25 +284,17 @@
 
     c->cutoff.n_denied = c->Icp.result_hist[LOG_UDP_DENIED];
 
     return 1;
 }
 
-log_type &operator++ (log_type &aLogType)
-{
-    int tmp = (int)aLogType;
-    aLogType = (log_type)(++tmp);
-    return aLogType;
-}
-
 void
 clientdbDump(StoreEntry * sentry)
 {
     const char *name;
     ClientInfo *c;
-    log_type l;
     int icp_total = 0;
     int icp_hits = 0;
     int http_total = 0;
     int http_hits = 0;
     storeAppendPrintf(sentry, "Cache Clients:\n");
     hash_first(client_table);
@@ -307,38 +306,38 @@
         }
         storeAppendPrintf(sentry, "Currently established connections: %d\n",
                           c->n_established);
         storeAppendPrintf(sentry, "    ICP  Requests %d\n",
                           c->Icp.n_requests);
 
-        for (l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
+        for (LogTags l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
             if (c->Icp.result_hist[l] == 0)
                 continue;
 
             icp_total += c->Icp.result_hist[l];
 
             if (LOG_UDP_HIT == l)
                 icp_hits += c->Icp.result_hist[l];
 
-            storeAppendPrintf(sentry, "        %-20.20s %7d %3d%%\n",Format::log_tags[l], c->Icp.result_hist[l], Math::intPercent(c->Icp.result_hist[l], c->Icp.n_requests));
+            storeAppendPrintf(sentry, "        %-20.20s %7d %3d%%\n",LogTags_str[l], c->Icp.result_hist[l], Math::intPercent(c->Icp.result_hist[l], c->Icp.n_requests));
         }
 
         storeAppendPrintf(sentry, "    HTTP Requests %d\n", c->Http.n_requests);
 
-        for (l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
+        for (LogTags l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
             if (c->Http.result_hist[l] == 0)
                 continue;
 
             http_total += c->Http.result_hist[l];
 
             if (logTypeIsATcpHit(l))
                 http_hits += c->Http.result_hist[l];
 
             storeAppendPrintf(sentry,
                               "        %-20.20s %7d %3d%%\n",
-                              Format::log_tags[l],
+                              LogTags_str[l],
                               c->Http.result_hist[l],
                               Math::intPercent(c->Http.result_hist[l], c->Http.n_requests));
         }
 
         storeAppendPrintf(sentry, "\n");
     }
@@ -450,13 +449,13 @@
 client_entry(Ip::Address *current)
 {
     ClientInfo *c = NULL;
     char key[MAX_IPSTRLEN];
 
     if (current) {
-        current->NtoA(key,MAX_IPSTRLEN);
+        current->toStr(key,MAX_IPSTRLEN);
         hash_first(client_table);
         while ((c = (ClientInfo *) hash_next(client_table))) {
             if (!strcmp(key, hashKeyStr(&c->hash)))
                 break;
         }
 
@@ -491,44 +490,43 @@
         oid2addr(&(Var->name[12]), keyIp, 16);
     } else {
         *ErrP = SNMP_ERR_NOSUCHNAME;
         return NULL;
     }
 
-    keyIp.NtoA(key, sizeof(key));
+    keyIp.toStr(key, sizeof(key));
     debugs(49, 5, HERE << "[" << key << "] requested!");
     c = (ClientInfo *) hash_lookup(client_table, key);
 
     if (c == NULL) {
         debugs(49, 5, HERE << "not found.");
         *ErrP = SNMP_ERR_NOSUCHNAME;
         return NULL;
     }
 
     variable_list *Answer = NULL;
     int aggr = 0;
-    log_type l;
 
     switch (Var->name[LEN_SQ_NET + 2]) {
 
     case MESH_CTBL_ADDR_TYPE: {
         int ival;
-        ival = c->addr.IsIPv4() ? INETADDRESSTYPE_IPV4 : INETADDRESSTYPE_IPV6 ;
+        ival = c->addr.isIPv4() ? INETADDRESSTYPE_IPV4 : INETADDRESSTYPE_IPV6 ;
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
                                       ival, SMI_INTEGER);
     }
     break;
 
     case MESH_CTBL_ADDR: {
         Answer = snmp_var_new(Var->name, Var->name_length);
         // InetAddress doesn't have its own ASN.1 type,
         // like IpAddr does (SMI_IPADDRESS)
         // See: rfc4001.txt
         Answer->type = ASN_OCTET_STR;
         char client[MAX_IPSTRLEN];
-        c->addr.NtoA(client,MAX_IPSTRLEN);
+        c->addr.toStr(client,MAX_IPSTRLEN);
         Answer->val_len = strlen(client);
         Answer->val.string =  (u_char *) xstrdup(client);
     }
     break;
     case MESH_CTBL_HTBYTES:
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
@@ -542,13 +540,13 @@
                                       SMI_COUNTER32);
         break;
 
     case MESH_CTBL_HTHITS:
         aggr = 0;
 
-        for (l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
+        for (LogTags l = LOG_TAG_NONE; l < LOG_TYPE_MAX; ++l) {
             if (logTypeIsATcpHit(l))
                 aggr += c->Http.result_hist[l];
         }
 
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
                                       (snint) aggr,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_db.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_db.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_db.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_db.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,24 +31,25 @@
  */
 
 #ifndef SQUID_CLIENT_DB_H_
 #define SQUID_CLIENT_DB_H_
 
 #include "anyp/ProtocolType.h"
-#include "enums.h"
+//#include "enums.h"
 #include "ip/Address.h"
+#include "LogTags.h"
+
 namespace Ip
 {
 class Address;
 }
 
 class StoreEntry;
 class ClientInfo;
 
-void clientdbInit(void);
-void clientdbUpdate(const Ip::Address &, log_type, AnyP::ProtocolType, size_t);
+void clientdbUpdate(const Ip::Address &, LogTags, AnyP::ProtocolType, size_t);
 int clientdbCutoffDenied(const Ip::Address &);
 void clientdbDump(StoreEntry *);
 void clientdbFreeMemory(void);
 int clientdbEstablished(const Ip::Address &, int);
 
 #if USE_DELAY_POOLS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ClientDelayConfig.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ClientDelayConfig.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ClientDelayConfig.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ClientDelayConfig.cc	2015-05-01 18:05:19.000000000 +0800
@@ -80,13 +80,13 @@
     if (pool < 1 || pool > pools.size()) {
         debugs(3, DBG_CRITICAL, "parse_client_delay_pool_rates: Ignoring pool " << pool << " not in 1 .. " << pools.size());
         return;
     }
 
     --pool;
-    aclParseAccessLine(parser, &pools[pool].access);
+    aclParseAccessLine("client_delay_access", parser, &pools[pool].access);
 }
 
 void ClientDelayConfig::clean()
 {
     for (unsigned int i = 0; i < pools.size(); ++i) {
         aclDestroyAccessList(&pools[i].access);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ClientDelayConfig.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ClientDelayConfig.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ClientDelayConfig.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ClientDelayConfig.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,13 @@
 #ifndef SQUID_CLIENTDELAYCONFIG_H
 #define SQUID_CLIENTDELAYCONFIG_H
 
-#include "Array.h"
+#include "acl/forward.h"
+#include "base/Vector.h"
+
 class StoreEntry;
-class acl_access;
 class ConfigParser;
 
 /// \ingroup DelayPoolsAPI
 
 /* represents one client write limiting delay 'pool' */
 class ClientDelayPool
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ClientInfo.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ClientInfo.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ClientInfo.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ClientInfo.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,12 @@
 #ifndef SQUID__SRC_CLIENTINFO_H
 #define SQUID__SRC_CLIENTINFO_H
 
 #include "ip/Address.h"
 #include "hash.h"
+#include "LogTags.h"
 #include "enums.h"
 #include "typedefs.h"
 #include "cbdata.h"
 #include <deque>
 
 #if USE_DELAY_POOLS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ClientRequestContext.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ClientRequestContext.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ClientRequestContext.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ClientRequestContext.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,41 +1,42 @@
 #ifndef SQUID_CLIENTREQUESTCONTEXT_H
 #define SQUID_CLIENTREQUESTCONTEXT_H
 
+#include "base/RefCount.h"
 #include "cbdata.h"
-#include "RefCount.h"
 #include "ipcache.h"
 
 #if USE_ADAPTATION
 #include "adaptation/forward.h"
 #endif
 
 class ACLChecklist;
 class ClientHttpRequest;
 class DnsLookupDetails;
 class ErrorState;
 
+class HelperReply;
+
 class ClientRequestContext : public RefCountable
 {
 
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
-
     ClientRequestContext(ClientHttpRequest *);
     ~ClientRequestContext();
 
     bool httpStateIsValid();
     void hostHeaderVerify();
     void hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLookupDetails &dns);
     void hostHeaderVerifyFailed(const char *A, const char *B);
     void clientAccessCheck();
     void clientAccessCheck2();
     void clientAccessCheckDone(const allow_t &answer);
     void clientRedirectStart();
-    void clientRedirectDone(char *result);
+    void clientRedirectDone(const HelperReply &reply);
+    void clientStoreIdStart();
+    void clientStoreIdDone(const HelperReply &reply);
     void checkNoCache();
     void checkNoCacheDone(const allow_t &answer);
 #if USE_ADAPTATION
 
     void adaptationAccessCheck();
 #endif
@@ -50,29 +51,40 @@
     void sslBumpAccessCheckDone(const allow_t &answer);
 #endif
 
     ClientHttpRequest *http;
     ACLChecklist *acl_checklist;        /* need ptr back so we can unreg if needed */
     int redirect_state;
+    int store_id_state;
+
+    /**
+     * URL-rewrite/redirect helper may return BH for internal errors.
+     * We attempt to recover by trying the lookup again, but limit the
+     * number of retries to prevent lag and lockups.
+     * This tracks the number of previous failures for the current context.
+     */
+    uint8_t redirect_fail_count;
+    uint8_t store_id_fail_count;
 
     bool host_header_verify_done;
     bool http_access_done;
     bool adapted_http_access_done;
 #if USE_ADAPTATION
     bool adaptation_acl_check_done;
 #endif
     bool redirect_done;
+    bool store_id_done;
     bool no_cache_done;
     bool interpreted_req_hdrs;
     bool tosToClientDone;
     bool nfmarkToClientDone;
 #if USE_SSL
     bool sslBumpCheckDone;
 #endif
     ErrorState *error; ///< saved error page for centralized/delayed processing
     bool readNextRequest; ///< whether Squid should read after error handling
 
 private:
-    CBDATA_CLASS(ClientRequestContext);
+    CBDATA_CLASS2(ClientRequestContext);
 };
 
 #endif /* SQUID_CLIENTREQUESTCONTEXT_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side.cc	2015-05-01 18:05:19.000000000 +0800
@@ -95,17 +95,16 @@
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "comm/TcpAcceptor.h"
 #include "comm/Write.h"
 #include "CommCalls.h"
 #include "errorpage.h"
-#include "eui/Config.h"
 #include "fd.h"
 #include "fde.h"
-#include "forward.h"
 #include "fqdncache.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "http.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -191,66 +190,49 @@
 static void clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub);
 
 /* our socket-related context */
 
 CBDATA_CLASS_INIT(ClientSocketContext);
 
-void *
-ClientSocketContext::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (ClientSocketContext));
-    CBDATA_INIT_TYPE(ClientSocketContext);
-    return cbdataAlloc(ClientSocketContext);
-}
-
-void
-ClientSocketContext::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
 /* Local functions */
 /* ClientSocketContext */
 static ClientSocketContext *ClientSocketContextNew(const Comm::ConnectionPointer &clientConn, ClientHttpRequest *);
 /* other */
 static IOCB clientWriteComplete;
 static IOCB clientWriteBodyComplete;
 static IOACB httpAccept;
 #if USE_SSL
 static IOACB httpsAccept;
 #endif
 static CTCB clientLifetimeTimeout;
 static ClientSocketContext *parseHttpRequestAbort(ConnStateData * conn, const char *uri);
-static ClientSocketContext *parseHttpRequest(ConnStateData *, HttpParser *, HttpRequestMethod *, HttpVersion *);
+static ClientSocketContext *parseHttpRequest(ConnStateData *, HttpParser *, HttpRequestMethod *, Http::ProtocolVersion *);
 #if USE_IDENT
 static IDCB clientIdentDone;
 #endif
 static CSCB clientSocketRecipient;
 static CSD clientSocketDetach;
 static void clientSetKeepaliveFlag(ClientHttpRequest *);
 static int clientIsContentLengthValid(HttpRequest * r);
 static int clientIsRequestBodyTooLargeForPolicy(int64_t bodyLength);
 
-static void clientUpdateStatHistCounters(log_type logType, int svc_time);
-static void clientUpdateStatCounters(log_type logType);
+static void clientUpdateStatHistCounters(LogTags logType, int svc_time);
+static void clientUpdateStatCounters(LogTags logType);
 static void clientUpdateHierCounters(HierarchyLogEntry *);
 static bool clientPingHasFinished(ping_data const *aPing);
 void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
 #ifndef PURIFY
 static bool connIsUsable(ConnStateData * conn);
 #endif
 static int responseFinishedOrFailed(HttpReply * rep, StoreIOBuffer const &receivedData);
 static void ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn);
-static void clientUpdateSocketStats(log_type logType, size_t size);
+static void clientUpdateSocketStats(LogTags logType, size_t size);
 
 char *skipLeadingSpace(char *aString);
 static void connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount);
 
-static ConnStateData *connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port);
-
 clientStreamNode *
 ClientSocketContext::getTail() const
 {
     if (http->client_stream.tail)
         return (clientStreamNode *)http->client_stream.tail->data;
 
@@ -378,14 +360,14 @@
     return newContext;
 }
 
 void
 ClientSocketContext::writeControlMsg(HttpControlMsg &msg)
 {
-    HttpReply *rep = msg.reply;
-    Must(rep);
+    const HttpReply::Pointer rep(msg.reply);
+    Must(rep != NULL);
 
     // apply selected clientReplyContext::buildReplyHeader() mods
     // it is not clear what headers are required for control messages
     rep->header.removeHopByHopEntries();
     rep->header.putStr(HDR_CONNECTION, "keep-alive");
     httpHdrMangleList(&rep->header, http->request, ROR_REPLY);
@@ -441,13 +423,13 @@
     ConnStateData *conn = (ConnStateData *)data;
     xstrncpy(conn->clientConnection->rfc931, ident ? ident : dash_str, USER_IDENT_SZ);
 }
 #endif
 
 void
-clientUpdateStatCounters(log_type logType)
+clientUpdateStatCounters(LogTags logType)
 {
     ++statCounter.client_http.requests;
 
     if (logTypeIsATcpHit(logType))
         ++statCounter.client_http.hits;
 
@@ -455,13 +437,13 @@
         ++statCounter.client_http.disk_hits;
     else if (logType == LOG_TCP_MEM_HIT)
         ++statCounter.client_http.mem_hits;
 }
 
 void
-clientUpdateStatHistCounters(log_type logType, int svc_time)
+clientUpdateStatHistCounters(LogTags logType, int svc_time)
 {
     statCounter.client_http.allSvcTime.count(svc_time);
     /**
      * The idea here is not to be complete, but to get service times
      * for only well-defined types.  For example, we don't include
      * LOG_TCP_REFRESH_FAIL because its not really a cache hit
@@ -636,25 +618,25 @@
 
     al->icp.opcode = ICP_INVALID;
     al->url = log_uri;
     debugs(33, 9, "clientLogRequest: al.url='" << al->url << "'");
 
     if (al->reply) {
-        al->http.code = al->reply->sline.status;
+        al->http.code = al->reply->sline.status();
         al->http.content_type = al->reply->content_type.termedBuf();
     } else if (loggingEntry() && loggingEntry()->mem_obj) {
-        al->http.code = loggingEntry()->mem_obj->getReply()->sline.status;
+        al->http.code = loggingEntry()->mem_obj->getReply()->sline.status();
         al->http.content_type = loggingEntry()->mem_obj->getReply()->content_type.termedBuf();
     }
 
     debugs(33, 9, "clientLogRequest: http.code='" << al->http.code << "'");
 
     if (loggingEntry() && loggingEntry()->mem_obj)
         al->cache.objectSize = loggingEntry()->contentLen();
 
-    al->cache.caddr.SetNoAddr();
+    al->cache.caddr.setNoAddr();
 
     if (getConn() != NULL) {
         al->cache.caddr = getConn()->log_addr;
         al->cache.port =  cbdataReference(getConn()->port);
     }
 
@@ -683,29 +665,53 @@
      */
     if (getConn() != NULL)
         al->cache.ssluser = sslGetUserEmail(fd_table[getConn()->fd].ssl);
 
 #endif
 
-    ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.log, this);
+    /*Add notes*/
+    // The al->notes and request->notes must point to the same object.
+    (void)SyncNotes(*al, *request);
+    typedef Notes::iterator ACAMLI;
+    for (ACAMLI i = Config.notes.begin(); i != Config.notes.end(); ++i) {
+        if (const char *value = (*i)->match(request, al->reply)) {
+            NotePairs &notes = SyncNotes(*al, *request);
+            notes.add((*i)->key.termedBuf(), value);
+            debugs(33, 3, HERE << (*i)->key.termedBuf() << " " << value);
+        }
+    }
+
+    ACLFilledChecklist checklist(NULL, request, NULL);
+    if (al->reply) {
+        checklist.reply = al->reply;
+        HTTPMSGLOCK(checklist.reply);
+    }
 
-    if (al->reply)
-        checklist->reply = HTTPMSGLOCK(al->reply);
+    if (request) {
+        al->adapted_request = request;
+        HTTPMSGLOCK(al->adapted_request);
+    }
+    accessLogLog(al, &checklist);
 
-    if (!Config.accessList.log || checklist->fastCheck() == ACCESS_ALLOWED) {
-        if (request)
-            al->adapted_request = HTTPMSGLOCK(request);
-        accessLogLog(al, checklist);
+    bool updatePerformanceCounters = true;
+    if (Config.accessList.stats_collection) {
+        ACLFilledChecklist statsCheck(Config.accessList.stats_collection, request, NULL);
+        if (al->reply) {
+            statsCheck.reply = al->reply;
+            HTTPMSGLOCK(statsCheck.reply);
+        }
+        updatePerformanceCounters = (statsCheck.fastCheck() == ACCESS_ALLOWED);
+    }
+
+    if (updatePerformanceCounters) {
         if (request)
             updateCounters();
 
         if (getConn() != NULL && getConn()->clientConnection != NULL)
             clientdbUpdate(getConn()->clientConnection->remote, logType, AnyP::PROTO_HTTP, out.size);
     }
-
-    delete checklist;
 }
 
 void
 ClientHttpRequest::freeResources()
 {
     safe_free(uri);
@@ -767,33 +773,112 @@
 /* This is a handler normally called by comm_close() */
 void ConnStateData::connStateClosed(const CommCloseCbParams &io)
 {
     deleteThis("ConnStateData::connStateClosed");
 }
 
+#if USE_AUTH
+void
+ConnStateData::setAuth(const Auth::UserRequest::Pointer &aur, const char *by)
+{
+    if (auth_ == NULL) {
+        if (aur != NULL) {
+            debugs(33, 2, "Adding connection-auth to " << clientConnection << " from " << by);
+            auth_ = aur;
+        }
+        return;
+    }
+
+    // clobered with self-pointer
+    // NP: something nasty is going on in Squid, but harmless.
+    if (aur == auth_) {
+        debugs(33, 2, "WARNING: Ignoring duplicate connection-auth for " << clientConnection << " from " << by);
+        return;
+    }
+
+    /*
+     * Connection-auth relies on a single set of credentials being preserved
+     * for all requests on a connection once they have been setup.
+     * There are several things which need to happen to preserve security
+     * when connection-auth credentials change unexpectedly or are unset.
+     *
+     * 1) auth helper released from any active state
+     *
+     * They can only be reserved by a handshake process which this
+     * connection can now never complete.
+     * This prevents helpers hanging when their connections close.
+     *
+     * 2) pinning is expected to be removed and server conn closed
+     *
+     * The upstream link is authenticated with the same credentials.
+     * Expecting the same level of consistency we should have received.
+     * This prevents upstream being faced with multiple or missing
+     * credentials after authentication.
+     * NP: un-pin is left to the cleanup in ConnStateData::swanSong()
+     *     we just trigger that cleanup here via comm_reset_close() or
+     *     ConnStateData::stopReceiving()
+     *
+     * 3) the connection needs to close.
+     *
+     * This prevents attackers injecting requests into a connection,
+     * or gateways wrongly multiplexing users into a single connection.
+     *
+     * When credentials are missing closure needs to follow an auth
+     * challenge for best recovery by the client.
+     *
+     * When credentials change there is nothing we can do but abort as
+     * fast as possible. Sending TCP RST instead of an HTTP response
+     * is the best-case action.
+     */
+
+    // clobbered with nul-pointer
+    if (aur == NULL) {
+        debugs(33, 2, "WARNING: Graceful closure on " << clientConnection << " due to connection-auth erase from " << by);
+        auth_->releaseAuthServer();
+        auth_ = NULL;
+        // XXX: need to test whether the connection re-auth challenge is sent. If not, how to trigger it from here.
+        // NP: the current situation seems to fix challenge loops in Safari without visible issues in others.
+        // we stop receiving more traffic but can leave the Job running to terminate after the error or challenge is delivered.
+        stopReceiving("connection-auth removed");
+        return;
+    }
+
+    // clobbered with alternative credentials
+    if (aur != auth_) {
+        debugs(33, 2, "ERROR: Closing " << clientConnection << " due to change of connection-auth from " << by);
+        auth_->releaseAuthServer();
+        auth_ = NULL;
+        // this is a fatal type of problem.
+        // Close the connection immediately with TCP RST to abort all traffic flow
+        comm_reset_close(clientConnection);
+        return;
+    }
+
+    /* NOT REACHABLE */
+}
+#endif
+
 // cleans up before destructor is called
 void
 ConnStateData::swanSong()
 {
     debugs(33, 2, HERE << clientConnection);
     flags.readMore = false;
     clientdbEstablished(clientConnection->remote, -1);	/* decrement */
     assert(areAllContextsForThisConnection());
     freeAllContexts();
-#if USE_AUTH
-    if (auth_user_request != NULL) {
-        debugs(33, 4, "ConnStateData::swanSong: freeing auth_user_request '" << auth_user_request << "' (this is '" << this << "')");
-        auth_user_request->onConnectionClose(this);
-    }
-#endif
 
     unpinConnection();
 
     if (Comm::IsConnOpen(clientConnection))
         clientConnection->close();
-    clientConnection = NULL;
+
+#if USE_AUTH
+    // NP: do this bit after closing the connections to avoid side effects from unwanted TCP RST
+    setAuth(NULL, "ConnStateData::SwanSong cleanup");
+#endif
 
     BodyProducer::swanSong();
     flags.swanSang = true;
 }
 
 bool
@@ -839,23 +924,23 @@
     debugs(33, 3, "clientSetKeepaliveFlag: http_ver = " <<
            request->http_ver.major << "." << request->http_ver.minor);
     debugs(33, 3, "clientSetKeepaliveFlag: method = " <<
            RequestMethodStr(request->method));
 
     // TODO: move to HttpRequest::hdrCacheInit, just like HttpReply.
-    request->flags.proxyKeepalive = request->persistent() ? 1 : 0;
+    request->flags.proxyKeepalive = request->persistent();
 }
 
 static int
 clientIsContentLengthValid(HttpRequest * r)
 {
     switch (r->method.id()) {
 
-    case METHOD_GET:
+    case Http::METHOD_GET:
 
-    case METHOD_HEAD:
+    case Http::METHOD_HEAD:
         /* We do not want to see a request entity on GET/HEAD requests */
         return (r->content_length <= 0 || Config.onoff.request_entities);
 
     default:
         /* For other types of requests we don't care */
         return 1;
@@ -1250,13 +1335,13 @@
     /* check if we still want to do ranges */
 
     int64_t roffLimit = request->getRangeOffsetLimit();
 
     if (!rep)
         range_err = "no [parse-able] reply";
-    else if ((rep->sline.status != HTTP_OK) && (rep->sline.status != HTTP_PARTIAL_CONTENT))
+    else if ((rep->sline.status() != Http::scOkay) && (rep->sline.status() != Http::scPartialContent))
         range_err = "wrong status code";
     else if (hdr->has(HDR_CONTENT_RANGE))
         range_err = "origin server does ranges";
     else if (rep->content_length < 0)
         range_err = "unknown length";
     else if (rep->content_length != http->memObject()->getReply()->content_length)
@@ -1280,15 +1365,14 @@
          * code will lead to incorrect store offset requests - the store will have the
          * offset data, but we won't be requesting it.
          * So, we can either re-request, or generate an error
          */
         http->request->ignoreRange(range_err);
     } else {
-        /* XXX: TODO: Review, this unconditional set may be wrong. - TODO: review. */
-        httpStatusLineSet(&rep->sline, rep->sline.version,
-                          HTTP_PARTIAL_CONTENT, NULL);
+        /* XXX: TODO: Review, this unconditional set may be wrong. */
+        rep->sline.set(rep->sline.version, Http::scPartialContent);
         // web server responded with a valid, but unexpected range.
         // will (try-to) forward as-is.
         //TODO: we should cope with multirange request/responses
         bool replyMatchRequest = rep->content_range != NULL ?
                                  request->range->contains(rep->content_range->spec) :
                                  true;
@@ -1449,13 +1533,14 @@
     }
 
     if (!context->startOfOutput())
         context->sendBody(rep, receivedData);
     else {
         assert(rep);
-        http->al->reply = HTTPMSGLOCK(rep);
+        http->al->reply = rep;
+        HTTPMSGLOCK(http->al->reply);
         context->sendStartOfMessage(rep, receivedData);
     }
 
     PROF_stop(clientSocketRecipient);
 }
 
@@ -1614,13 +1699,13 @@
         // XXX: Can this happen? CONNECT tunnels have deferredRequest set.
         debugs(33, DBG_IMPORTANT, HERE << "abandoning " << conn->clientConnection);
     }
 }
 
 void
-clientUpdateSocketStats(log_type logType, size_t size)
+clientUpdateSocketStats(LogTags logType, size_t size)
 {
     if (size == 0)
         return;
 
     kb_incr(&statCounter.client_http.kbytes_out, size);
 
@@ -2011,13 +2096,13 @@
 {
     int vhost = conn->port->vhost;
     int vport = conn->port->vport;
     char *host;
     char ipbuf[MAX_IPSTRLEN];
 
-    http->flags.accel = 1;
+    http->flags.accel = true;
 
     /* BUG: Squid cannot deal with '*' URLs (RFC2616 5.1.2) */
 
     if (strncasecmp(url, "cache_object://", 15) == 0)
         return; /* already in good shape */
 
@@ -2028,26 +2113,26 @@
         /* else we need to ignore the host name */
         url = strstr(url, "//");
 
 #if SHOULD_REJECT_UNKNOWN_URLS
 
         if (!url) {
-            hp->request_parse_status = HTTP_BAD_REQUEST;
+            hp->request_parse_status = Http::scBadRequest;
             return parseHttpRequestAbort(conn, "error:invalid-request");
         }
 #endif
 
         if (url)
             url = strchr(url + 2, '/');
 
         if (!url)
             url = (char *) "/";
     }
 
     if (vport < 0)
-        vport = http->getConn()->clientConnection->local.GetPort();
+        vport = http->getConn()->clientConnection->local.port();
 
     const bool switchedToHttps = conn->switchedToHttps();
     const bool tryHostHeader = vhost || switchedToHttps;
     if (tryHostHeader && (host = mime_get_header(req_hdr, "Host")) != NULL) {
         debugs(33, 5, "ACCEL VHOST REWRITE: vhost=" << host << " + vport=" << vport);
         char thost[256];
@@ -2085,13 +2170,13 @@
         debugs(33, 5, "ACCEL DEFAULTSITE REWRITE: '" << http->uri <<"'");
     } else if (vport > 0 /* && (!vhost || no Host:) */) {
         debugs(33, 5, "ACCEL VPORT REWRITE: http_port IP + vport=" << vport);
         /* Put the local socket IP address as the hostname, with whatever vport we found  */
         int url_sz = strlen(url) + 32 + Config.appendDomainLen;
         http->uri = (char *)xcalloc(url_sz, 1);
-        http->getConn()->clientConnection->local.ToHostname(ipbuf,MAX_IPSTRLEN);
+        http->getConn()->clientConnection->local.toHostStr(ipbuf,MAX_IPSTRLEN);
         snprintf(http->uri, url_sz, "%s://%s:%d%s",
                  http->getConn()->port->protocol,
                  ipbuf, vport, url);
         debugs(33, 5, "ACCEL VPORT REWRITE: '" << http->uri << "'");
     }
 }
@@ -2114,16 +2199,16 @@
         snprintf(http->uri, url_sz, "%s://%s%s", conn->port->protocol, host, url);
         debugs(33, 5, "TRANSPARENT HOST REWRITE: '" << http->uri <<"'");
     } else {
         /* Put the local socket IP address as the hostname.  */
         int url_sz = strlen(url) + 32 + Config.appendDomainLen;
         http->uri = (char *)xcalloc(url_sz, 1);
-        http->getConn()->clientConnection->local.ToHostname(ipbuf,MAX_IPSTRLEN);
+        http->getConn()->clientConnection->local.toHostStr(ipbuf,MAX_IPSTRLEN);
         snprintf(http->uri, url_sz, "%s://%s:%d%s",
                  http->getConn()->port->protocol,
-                 ipbuf, http->getConn()->clientConnection->local.GetPort(), url);
+                 ipbuf, http->getConn()->clientConnection->local.port(), url);
         debugs(33, 5, "TRANSPARENT REWRITE: '" << http->uri << "'");
     }
 }
 
 /** Parse an HTTP request
  *
@@ -2136,33 +2221,33 @@
  *          parsing failure
  *  \param[out] http_ver will be set as a side-effect of the parsing
  *  \return NULL on incomplete requests,
  *          a ClientSocketContext structure on success or failure.
  */
 static ClientSocketContext *
-parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_p, HttpVersion *http_ver)
+parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_p, Http::ProtocolVersion *http_ver)
 {
     char *req_hdr = NULL;
     char *end;
     size_t req_sz;
     ClientHttpRequest *http;
     ClientSocketContext *result;
     StoreIOBuffer tempBuffer;
     int r;
 
     /* pre-set these values to make aborting simpler */
-    *method_p = METHOD_NONE;
+    *method_p = Http::METHOD_NONE;
 
     /* NP: don't be tempted to move this down or remove again.
      * It's the only DDoS protection old-String has against long URL */
     if ( hp->bufsiz <= 0) {
         debugs(33, 5, "Incomplete request, waiting for end of request line");
         return NULL;
     } else if ( (size_t)hp->bufsiz >= Config.maxRequestHeaderSize && headersEnd(hp->buf, Config.maxRequestHeaderSize) == 0) {
         debugs(33, 5, "parseHttpRequest: Too large request");
-        hp->request_parse_status = HTTP_HEADER_TOO_LARGE;
+        hp->request_parse_status = Http::scHeaderTooLarge;
         return parseHttpRequestAbort(csd, "error:request-too-large");
     }
 
     /* Attempt to parse the first line; this'll define the method, url, version and header begin */
     r = HttpParserParseReqLine(hp);
 
@@ -2173,13 +2258,13 @@
 
     if (r == -1) {
         return parseHttpRequestAbort(csd, "error:invalid-request");
     }
 
     /* Request line is valid here .. */
-    *http_ver = HttpVersion(hp->req.v_maj, hp->req.v_min);
+    *http_ver = Http::ProtocolVersion(hp->req.v_maj, hp->req.v_min);
 
     /* This call scans the entire request, not just the headers */
     if (hp->req.v_maj > 0) {
         if ((req_sz = headersEnd(hp->buf, hp->bufsiz)) == 0) {
             debugs(33, 5, "Incomplete request, waiting for end of headers");
             return NULL;
@@ -2201,32 +2286,32 @@
 
     hp->hdr_start = hp->req.end + 1;
 
     /* Enforce max_request_size */
     if (req_sz >= Config.maxRequestHeaderSize) {
         debugs(33, 5, "parseHttpRequest: Too large request");
-        hp->request_parse_status = HTTP_HEADER_TOO_LARGE;
+        hp->request_parse_status = Http::scHeaderTooLarge;
         return parseHttpRequestAbort(csd, "error:request-too-large");
     }
 
     /* Set method_p */
     *method_p = HttpRequestMethod(&hp->buf[hp->req.m_start], &hp->buf[hp->req.m_end]+1);
 
     /* deny CONNECT via accelerated ports */
-    if (*method_p == METHOD_CONNECT && csd->port && csd->port->accel) {
-        debugs(33, DBG_IMPORTANT, "WARNING: CONNECT method received on " << csd->port->protocol << " Accelerator port " << csd->port->s.GetPort() );
+    if (*method_p == Http::METHOD_CONNECT && csd->port && csd->port->flags.accelSurrogate) {
+        debugs(33, DBG_IMPORTANT, "WARNING: CONNECT method received on " << csd->port->protocol << " Accelerator port " << csd->port->s.port() );
         /* XXX need a way to say "this many character length string" */
         debugs(33, DBG_IMPORTANT, "WARNING: for request: " << hp->buf);
-        hp->request_parse_status = HTTP_METHOD_NOT_ALLOWED;
+        hp->request_parse_status = Http::scMethodNotAllowed;
         return parseHttpRequestAbort(csd, "error:method-not-allowed");
     }
 
-    if (*method_p == METHOD_NONE) {
+    if (*method_p == Http::METHOD_NONE) {
         /* XXX need a way to say "this many character length string" */
         debugs(33, DBG_IMPORTANT, "clientParseRequestMethod: Unsupported method in request '" << hp->buf << "'");
-        hp->request_parse_status = HTTP_METHOD_NOT_ALLOWED;
+        hp->request_parse_status = Http::scMethodNotAllowed;
         return parseHttpRequestAbort(csd, "error:unsupported-request-method");
     }
 
     /*
      * Process headers after request line
      * TODO: Use httpRequestParse here.
@@ -2275,13 +2360,14 @@
 
     if ((t = strchr(url, '#')))	/* remove HTML anchors */
         *t = '\0';
 
 #endif
 
-    debugs(33,5, HERE << "repare absolute URL from " << (csd->transparent()?"intercept":(csd->port->accel ? "accel":"")));
+    debugs(33,5, HERE << "repare absolute URL from " <<
+           (csd->transparent()?"intercept":(csd->port->flags.accelSurrogate ? "accel":"")));
     /* Rewrite the URL in transparent or accelerator mode */
     /* NP: there are several cases to traverse here:
      *  - standard mode (forward proxy)
      *  - transparent mode (TPROXY)
      *  - transparent mode with failures
      *  - intercept mode (NAT)
@@ -2297,15 +2383,15 @@
     } else if (internalCheck(url)) {
         /* internal URL mode */
         /* prepend our name & port */
         http->uri = xstrdup(internalLocalUri(NULL, url));
         // We just re-wrote the URL. Must replace the Host: header.
         //  But have not parsed there yet!! flag for local-only handling.
-        http->flags.internal = 1;
+        http->flags.internal = true;
 
-    } else if (csd->port->accel || csd->switchedToHttps()) {
+    } else if (csd->port->flags.accelSurrogate || csd->switchedToHttps()) {
         /* accelerator mode */
         prepareAcceleratedURL(csd, http, url, req_hdr);
     }
 
     if (!http->uri) {
         /* No special rewrites have been applied above, use the
@@ -2443,13 +2529,13 @@
 
     ClientSocketContext *context = parseHttpRequestAbort(this, "error:request-too-large");
     clientStreamNode *node = context->getClientReplyContext();
     clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
     assert (repContext);
     repContext->setReplyToError(ERR_TOO_BIG,
-                                HTTP_BAD_REQUEST, METHOD_NONE, NULL,
+                                Http::scBadRequest, Http::METHOD_NONE, NULL,
                                 clientConnection->remote, NULL, NULL, NULL);
     context->registerWithConn();
     context->pullData();
 }
 
 void
@@ -2470,13 +2556,13 @@
 ConnStateData::quitAfterError(HttpRequest *request)
 {
     // From HTTP p.o.v., we do not have to close after every error detected
     // at the client-side, but many such errors do require closure and the
     // client-side code is bad at handling errors so we play it safe.
     if (request)
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     flags.readMore = false;
     debugs(33,4, HERE << "Will close after error: " << clientConnection);
 }
 
 #if USE_SSL
 bool ConnStateData::serveDelayedError(ClientSocketContext *context)
@@ -2497,34 +2583,36 @@
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert(repContext);
         debugs(33, 5, "Responding with delated error for " << http->uri);
         repContext->setReplyToStoreEntry(sslServerBump->entry, "delayed SslBump error");
 
         // save the original request for logging purposes
-        if (!context->http->al->request)
-            context->http->al->request = HTTPMSGLOCK(http->request);
+        if (!context->http->al->request) {
+            context->http->al->request = http->request;
+            HTTPMSGLOCK(context->http->al->request);
+        }
 
         // Get error details from the fake certificate-peeking request.
         http->request->detailError(sslServerBump->request->errType, sslServerBump->request->errDetail);
         context->pullData();
         return true;
     }
 
     // In bump-server-first mode, we have not necessarily seen the intended
     // server name at certificate-peeking time. Check for domain mismatch now,
     // when we can extract the intended name from the bumped HTTP request.
-    if (sslServerBump->serverCert.get()) {
+    if (X509 *srvCert = sslServerBump->serverCert.get()) {
         HttpRequest *request = http->request;
-        if (!Ssl::checkX509ServerValidity(sslServerBump->serverCert.get(), request->GetHost())) {
+        if (!Ssl::checkX509ServerValidity(srvCert, request->GetHost())) {
             debugs(33, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " <<
                    "does not match domainname " << request->GetHost());
 
             bool allowDomainMismatch = false;
             if (Config.ssl_client.cert_error) {
                 ACLFilledChecklist check(Config.ssl_client.cert_error, request, dash_str);
-                check.sslErrors = new Ssl::Errors(SQUID_X509_V_ERR_DOMAIN_MISMATCH);
+                check.sslErrors = new Ssl::CertErrors(Ssl::CertError(SQUID_X509_V_ERR_DOMAIN_MISMATCH, srvCert));
                 allowDomainMismatch = (check.fastCheck() == ACCESS_ALLOWED);
                 delete check.sslErrors;
                 check.sslErrors = NULL;
             }
 
             if (!allowDomainMismatch) {
@@ -2536,21 +2624,23 @@
 
                 // Fill the server IP and hostname for error page generation.
                 HttpRequest::Pointer const & peekerRequest = sslServerBump->request;
                 request->hier.note(peekerRequest->hier.tcpServer, request->GetHost());
 
                 // Create an error object and fill it
-                ErrorState *err = new ErrorState(ERR_SECURE_CONNECT_FAIL, HTTP_SERVICE_UNAVAILABLE, request);
+                ErrorState *err = new ErrorState(ERR_SECURE_CONNECT_FAIL, Http::scServiceUnavailable, request);
                 err->src_addr = clientConnection->remote;
                 Ssl::ErrorDetail *errDetail = new Ssl::ErrorDetail(
                     SQUID_X509_V_ERR_DOMAIN_MISMATCH,
-                    sslServerBump->serverCert.get(), NULL);
+                    srvCert, NULL);
                 err->detail = errDetail;
                 // Save the original request for logging purposes.
-                if (!context->http->al->request)
-                    context->http->al->request = HTTPMSGLOCK(request);
+                if (!context->http->al->request) {
+                    context->http->al->request = request;
+                    HTTPMSGLOCK(context->http->al->request);
+                }
                 repContext->setReplyToError(request->method, err);
                 assert(context->http->out.offset == 0);
                 context->pullData();
                 return true;
             }
         }
@@ -2558,13 +2648,13 @@
 
     return false;
 }
 #endif // USE_SSL
 
 static void
-clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *context, const HttpRequestMethod& method, HttpVersion http_ver)
+clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *context, const HttpRequestMethod& method, Http::ProtocolVersion http_ver)
 {
     ClientHttpRequest *http = context->http;
     HttpRequest::Pointer request;
     bool notedUseOfBuffer = false;
     bool chunked = false;
     bool mustReplyToOptions = false;
@@ -2581,17 +2671,17 @@
         conn->quitAfterError(NULL);
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri,  true);
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
         switch (hp->request_parse_status) {
-        case HTTP_HEADER_TOO_LARGE:
-            repContext->setReplyToError(ERR_TOO_BIG, HTTP_BAD_REQUEST, method, http->uri, conn->clientConnection->remote, NULL, conn->in.buf, NULL);
+        case Http::scHeaderTooLarge:
+            repContext->setReplyToError(ERR_TOO_BIG, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, conn->in.buf, NULL);
             break;
-        case HTTP_METHOD_NOT_ALLOWED:
-            repContext->setReplyToError(ERR_UNSUP_REQ, HTTP_METHOD_NOT_ALLOWED, method, http->uri,
+        case Http::scMethodNotAllowed:
+            repContext->setReplyToError(ERR_UNSUP_REQ, Http::scMethodNotAllowed, method, http->uri,
                                         conn->clientConnection->remote, NULL, conn->in.buf, NULL);
             break;
         default:
             repContext->setReplyToError(ERR_INVALID_REQ, hp->request_parse_status, method, http->uri,
                                         conn->clientConnection->remote, NULL, conn->in.buf, NULL);
         }
@@ -2600,54 +2690,54 @@
         goto finish;
     }
 
     if ((request = HttpRequest::CreateFromUrlAndMethod(http->uri, method)) == NULL) {
         clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Invalid URL: " << http->uri);
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri,  true);
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        repContext->setReplyToError(ERR_INVALID_URL, HTTP_BAD_REQUEST, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
+        repContext->setReplyToError(ERR_INVALID_URL, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
         goto finish;
     }
 
     /* RFC 2616 section 10.5.6 : handle unsupported HTTP major versions cleanly. */
     /* We currently only support 0.9, 1.0, 1.1 properly */
     if ( (http_ver.major == 0 && http_ver.minor != 9) ||
             (http_ver.major > 1) ) {
 
         clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Unsupported HTTP version discovered. :\n" << HttpParserHdrBuf(hp));
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri,  true);
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        repContext->setReplyToError(ERR_UNSUP_HTTPVERSION, HTTP_HTTP_VERSION_NOT_SUPPORTED, method, http->uri,
+        repContext->setReplyToError(ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, method, http->uri,
                                     conn->clientConnection->remote, NULL, HttpParserHdrBuf(hp), NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
         goto finish;
     }
 
     /* compile headers */
     /* we should skip request line! */
     /* XXX should actually know the damned buffer size here */
     if (http_ver.major >= 1 && !request->parseHeader(HttpParserHdrBuf(hp), HttpParserHdrSz(hp))) {
         clientStreamNode *node = context->getClientReplyContext();
         debugs(33, 5, "Failed to parse request headers:\n" << HttpParserHdrBuf(hp));
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         // setLogUri should called before repContext->setReplyToError
         setLogUri(http, http->uri,  true);
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        repContext->setReplyToError(ERR_INVALID_REQ, HTTP_BAD_REQUEST, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
+        repContext->setReplyToError(ERR_INVALID_REQ, Http::scBadRequest, method, http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
         goto finish;
     }
 
     request->clientConnectionManager = conn;
@@ -2657,44 +2747,53 @@
     request->flags.ignoreCc = conn->port->ignore_cc;
     // TODO: decouple http->flags.accel from request->flags.sslBumped
     request->flags.noDirect = (request->flags.accelerated && !request->flags.sslBumped) ?
                               !conn->port->allow_direct : 0;
 #if USE_AUTH
     if (request->flags.sslBumped) {
-        if (conn->auth_user_request != NULL)
-            request->auth_user_request = conn->auth_user_request;
+        if (conn->getAuth() != NULL)
+            request->auth_user_request = conn->getAuth();
     }
 #endif
 
     /** \par
      * If transparent or interception mode is working clone the transparent and interception flags
      * from the port settings to the request.
      */
     if (http->clientConnection != NULL) {
         request->flags.intercepted = ((http->clientConnection->flags & COMM_INTERCEPTION) != 0);
-        request->flags.spoofClientIp = ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        request->flags.interceptTproxy = ((http->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        if (request->flags.interceptTproxy) {
+            if (Config.accessList.spoof_client_ip) {
+                ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.spoof_client_ip, http);
+                request->flags.spoofClientIp = (checklist->fastCheck() == ACCESS_ALLOWED);
+                delete checklist;
+            } else
+                request->flags.spoofClientIp = true;
+        } else
+            request->flags.spoofClientIp = false;
     }
 
     if (internalCheck(request->urlpath.termedBuf())) {
         if (internalHostnameIs(request->GetHost()) &&
                 request->port == getMyPort()) {
-            http->flags.internal = 1;
+            http->flags.internal = true;
         } else if (Config.onoff.global_internal_static && internalStaticCheck(request->urlpath.termedBuf())) {
             request->SetHost(internalHostname());
             request->port = getMyPort();
-            http->flags.internal = 1;
+            http->flags.internal = true;
         }
     }
 
     if (http->flags.internal) {
         request->protocol = AnyP::PROTO_HTTP;
         request->login[0] = '\0';
     }
 
     request->flags.internal = http->flags.internal;
-    setLogUri (http, urlCanonicalClean(request));
+    setLogUri (http, urlCanonicalClean(request.getRaw()));
     request->client_addr = conn->clientConnection->remote; // XXX: remove reuest->client_addr member.
 #if FOLLOW_X_FORWARDED_FOR
     // indirect client gets stored here because it is an HTTP header result (from X-Forwarded-For:)
     // not a details about teh TCP connection itself
     request->indirect_client_addr = conn->clientConnection->remote;
 #endif /* FOLLOW_X_FORWARDED_FOR */
@@ -2711,62 +2810,67 @@
     } else if (request->header.has(HDR_TRANSFER_ENCODING)) {
         const String te = request->header.getList(HDR_TRANSFER_ENCODING);
         // HTTP/1.1 requires chunking to be the last encoding if there is one
         unsupportedTe = te.size() && te != "identity";
     } // else implied identity coding
 
-    mustReplyToOptions = (method == METHOD_OPTIONS) &&
+    mustReplyToOptions = (method == Http::METHOD_OPTIONS) &&
                          (request->header.getInt64(HDR_MAX_FORWARDS) == 0);
-    if (!urlCheckRequest(request) || mustReplyToOptions || unsupportedTe) {
+    if (!urlCheckRequest(request.getRaw()) || mustReplyToOptions || unsupportedTe) {
         clientStreamNode *node = context->getClientReplyContext();
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        repContext->setReplyToError(ERR_UNSUP_REQ, HTTP_NOT_IMPLEMENTED, request->method, NULL,
-                                    conn->clientConnection->remote, request, NULL, NULL);
+        repContext->setReplyToError(ERR_UNSUP_REQ, Http::scNotImplemented, request->method, NULL,
+                                    conn->clientConnection->remote, request.getRaw(), NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
         goto finish;
     }
 
-    if (!chunked && !clientIsContentLengthValid(request)) {
+    if (!chunked && !clientIsContentLengthValid(request.getRaw())) {
         clientStreamNode *node = context->getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
-        conn->quitAfterError(request);
+        conn->quitAfterError(request.getRaw());
         repContext->setReplyToError(ERR_INVALID_REQ,
-                                    HTTP_LENGTH_REQUIRED, request->method, NULL,
-                                    conn->clientConnection->remote, request, NULL, NULL);
+                                    Http::scLengthRequired, request->method, NULL,
+                                    conn->clientConnection->remote, request.getRaw(), NULL, NULL);
         assert(context->http->out.offset == 0);
         context->pullData();
         goto finish;
     }
 
     if (request->header.has(HDR_EXPECT)) {
         const String expect = request->header.getList(HDR_EXPECT);
         const bool supportedExpect = (expect.caseCmp("100-continue") == 0);
         if (!supportedExpect) {
             clientStreamNode *node = context->getClientReplyContext();
             clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
             assert (repContext);
-            conn->quitAfterError(request);
-            repContext->setReplyToError(ERR_INVALID_REQ, HTTP_EXPECTATION_FAILED, request->method, http->uri,
-                                        conn->clientConnection->remote, request, NULL, NULL);
+            conn->quitAfterError(request.getRaw());
+            repContext->setReplyToError(ERR_INVALID_REQ, Http::scExpectationFailed, request->method, http->uri,
+                                        conn->clientConnection->remote, request.getRaw(), NULL, NULL);
             assert(context->http->out.offset == 0);
             context->pullData();
             goto finish;
         }
     }
 
-    http->request = HTTPMSGLOCK(request);
+    http->request = request.getRaw();
+    HTTPMSGLOCK(http->request);
     clientSetKeepaliveFlag(http);
 
     // Let tunneling code be fully responsible for CONNECT requests
-    if (http->request->method == METHOD_CONNECT) {
+    if (http->request->method == Http::METHOD_CONNECT) {
         context->mayUseConnection(true);
         conn->flags.readMore = false;
+
+        // consume header early so that tunnel gets just the body
+        connNoteUseOfBuffer(conn, http->req_sz);
+        notedUseOfBuffer = true;
     }
 
 #if USE_SSL
     if (conn->switchedToHttps() && conn->serveDelayedError(context))
         goto finish;
 #endif
@@ -2784,15 +2888,15 @@
         /* Is it too large? */
         if (!chunked && // if chunked, we will check as we accumulate
                 clientIsRequestBodyTooLargeForPolicy(request->content_length)) {
             clientStreamNode *node = context->getClientReplyContext();
             clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
             assert (repContext);
-            conn->quitAfterError(request);
+            conn->quitAfterError(request.getRaw());
             repContext->setReplyToError(ERR_TOO_BIG,
-                                        HTTP_REQUEST_ENTITY_TOO_LARGE, METHOD_NONE, NULL,
+                                        Http::scPayloadTooLarge, Http::METHOD_NONE, NULL,
                                         conn->clientConnection->remote, http->request, NULL, NULL);
             assert(context->http->out.offset == 0);
             context->pullData();
             goto finish;
         }
 
@@ -2820,13 +2924,13 @@
      * DPW 2007-05-18
      * Moved the TCP_RESET feature from clientReplyContext::sendMoreData
      * to here because calling comm_reset_close() causes http to
      * be freed and the above connNoteUseOfBuffer() would hit an
      * assertion, not to mention that we were accessing freed memory.
      */
-    if (request && request->flags.resetTcp && Comm::IsConnOpen(conn->clientConnection)) {
+    if (request != NULL && request->flags.resetTcp && Comm::IsConnOpen(conn->clientConnection)) {
         debugs(33, 3, HERE << "Sending TCP RST on " << conn->clientConnection);
         conn->flags.readMore = false;
         comm_reset_close(conn->clientConnection);
     }
 }
 
@@ -2836,62 +2940,72 @@
     while (conn->in.notYetUsed > 0 && xisspace(conn->in.buf[0])) {
         memmove(conn->in.buf, conn->in.buf + 1, conn->in.notYetUsed - 1);
         -- conn->in.notYetUsed;
     }
 }
 
-static int
-connOkToAddRequest(ConnStateData * conn)
+/**
+ * Limit the number of concurrent requests.
+ * \return true  when there are available position(s) in the pipeline queue for another request.
+ * \return false when the pipeline queue is full or disabled.
+ */
+bool
+ConnStateData::concurrentRequestQueueFilled() const
 {
-    int result = conn->getConcurrentRequestCount() < (Config.onoff.pipeline_prefetch ? 2 : 1);
+    const int existingRequestCount = getConcurrentRequestCount();
 
-    if (!result) {
-        debugs(33, 3, HERE << conn->clientConnection << " max concurrent requests reached");
-        debugs(33, 5, HERE << conn->clientConnection << " defering new request until one is done");
+    // default to the configured pipeline size.
+    // add 1 because the head of pipeline is counted in concurrent requests and not prefetch queue
+    const int concurrentRequestLimit = Config.pipeline_max_prefetch + 1;
+
+    // when queue filled already we cant add more.
+    if (existingRequestCount >= concurrentRequestLimit) {
+        debugs(33, 3, clientConnection << " max concurrent requests reached (" << concurrentRequestLimit << ")");
+        debugs(33, 5, clientConnection << " deferring new request until one is done");
+        return true;
     }
 
-    return result;
+    return false;
 }
 
 /**
  * Attempt to parse one or more requests from the input buffer.
  * If a request is successfully parsed, even if the next request
  * is only partially parsed, it will return TRUE.
  */
 bool
 ConnStateData::clientParseRequests()
 {
     HttpRequestMethod method;
     bool parsed_req = false;
-    HttpVersion http_ver;
 
     debugs(33, 5, HERE << clientConnection << ": attempting to parse");
 
     // Loop while we have read bytes that are not needed for producing the body
     // On errors, bodyPipe may become nil, but readMore will be cleared
     while (in.notYetUsed > 0 && !bodyPipe && flags.readMore) {
         connStripBufferWhitespace(this);
 
         /* Don't try to parse if the buffer is empty */
         if (in.notYetUsed == 0)
             break;
 
-        /* Limit the number of concurrent requests to 2 */
-        if (!connOkToAddRequest(this)) {
+        /* Limit the number of concurrent requests */
+        if (concurrentRequestQueueFilled())
             break;
-        }
 
         /* Should not be needed anymore */
         /* Terminate the string */
         in.buf[in.notYetUsed] = '\0';
 
         /* Begin the parsing */
         PROF_start(parseHttpRequest);
         HttpParserInit(&parser_, in.buf, in.notYetUsed);
 
         /* Process request */
+        Http::ProtocolVersion http_ver;
         ClientSocketContext *context = parseHttpRequest(this, &parser_, &method, &http_ver);
         PROF_stop(parseHttpRequest);
 
         /* partial or incomplete request */
         if (!context) {
             // TODO: why parseHttpRequest can just return parseHttpRequestAbort
@@ -2966,13 +3080,13 @@
             if (connFinishedWithConn(io.size)) {
                 clientConnection->close();
                 return;
             }
 
             /* It might be half-closed, we can't tell */
-            fd_table[io.conn->fd].flags.socket_eof = 1;
+            fd_table[io.conn->fd].flags.socket_eof = true;
 
             commMarkHalfClosed(io.conn->fd);
 
             fd_note(io.conn->fd, "half-closed");
 
             /* There is one more close check at the end, to detect aborted
@@ -3140,14 +3254,14 @@
 #if WE_KNOW_HOW_TO_SEND_ERRORS
     ClientSocketContext::Pointer context = getCurrentContext();
     if (context != NULL && !context->http->out.offset) { // output nothing yet
         clientStreamNode *node = context->getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast<clientReplyContext*>(node->data.getRaw());
         assert(repContext);
-        const http_status scode = (error == ERR_TOO_BIG) ?
-                                  HTTP_REQUEST_ENTITY_TOO_LARGE : HTTP_BAD_REQUEST;
+        const Http::StatusCode scode = (error == ERR_TOO_BIG) ?
+                                       Http::scPayloadTooLarge : HTTP_BAD_REQUEST;
         repContext->setReplyToError(error, scode,
                                     repContext->http->request->method,
                                     repContext->http->uri,
                                     CachePeer,
                                     repContext->http->request,
                                     in.buf, NULL);
@@ -3187,77 +3301,22 @@
 }
 
 /** general lifetime handler for HTTP requests */
 void
 ConnStateData::requestTimeout(const CommTimeoutCbParams &io)
 {
-#if THIS_CONFUSES_PERSISTENT_CONNECTION_AWARE_BROWSERS_AND_USERS
-    debugs(33, 3, "requestTimeout: FD " << io.fd << ": lifetime is expired.");
-
-    if (COMMIO_FD_WRITECB(io.fd)->active) {
-        /* FIXME: If this code is reinstated, check the conn counters,
-         * not the fd table state
-         */
-        /*
-         * Some data has been sent to the client, just close the FD
-         */
-        clientConnection->close();
-    } else if (nrequests) {
-        /*
-         * assume its a persistent connection; just close it
-         */
-        clientConnection->close();
-    } else {
-        /*
-         * Generate an error
-         */
-        ClientHttpRequest **H;
-        clientStreamNode *node;
-        ClientHttpRequest *http = parseHttpRequestAbort(this, "error:Connection%20lifetime%20expired");
-        node = http->client_stream.tail->prev->data;
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert (repContext);
-        repContext->setReplyToError(ERR_LIFETIME_EXP,
-                                    HTTP_REQUEST_TIMEOUT, METHOD_NONE, "N/A", &CachePeer.sin_addr,
-                                    NULL, NULL, NULL);
-        /* No requests can be outstanded */
-        assert(chr == NULL);
-        /* add to the client request queue */
-
-        for (H = &chr; *H; H = &(*H)->next);
-        *H = http;
-
-        clientStreamRead(http->client_stream.tail->data, http, 0,
-                         HTTP_REQBUF_SZ, context->reqbuf);
-
-        /*
-         * if we don't close() here, we still need a timeout handler!
-         */
-        typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
-        AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
-                                          TimeoutDialer, this, ConnStateData::requestTimeout);
-        commSetConnTimeout(io.conn, 30, timeoutCall);
-
-        /*
-         * Aha, but we don't want a read handler!
-         */
-        Comm::SetSelect(io.fd, COMM_SELECT_READ, NULL, NULL, 0);
-    }
-
-#else
     /*
     * Just close the connection to not confuse browsers
-    * using persistent connections. Some browsers opens
-    * an connection and then does not use it until much
+    * using persistent connections. Some browsers open
+    * a connection and then do not use it until much
     * later (presumeably because the request triggering
     * the open has already been completed on another
     * connection)
     */
     debugs(33, 3, "requestTimeout: FD " << io.fd << ": lifetime is expired.");
     io.conn->close();
-#endif
 }
 
 static void
 clientLifetimeTimeout(const CommTimeoutCbParams &io)
 {
     ClientHttpRequest *http = static_cast<ClientHttpRequest *>(io.data);
@@ -3265,77 +3324,87 @@
     debugs(33, DBG_IMPORTANT, "\t" << http->uri);
     http->al->http.timedout = true;
     if (Comm::IsConnOpen(io.conn))
         io.conn->close();
 }
 
-ConnStateData *
-connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port)
+ConnStateData::ConnStateData(const MasterXaction::Pointer &xact) :
+        AsyncJob("ConnStateData"),
+#if USE_SSL
+        sslBumpMode(Ssl::bumpEnd),
+        switchedToHttps_(false),
+        sslServerBump(NULL),
+#endif
+        stoppedSending_(NULL),
+        stoppedReceiving_(NULL)
 {
-    ConnStateData *result = new ConnStateData;
+    pinning.host = NULL;
+    pinning.port = -1;
+    pinning.pinned = false;
+    pinning.auth = false;
+    pinning.zeroReply = false;
+    pinning.peer = NULL;
+
+    // store the details required for creating more MasterXaction objects as new requests come in
+    clientConnection = xact->tcpClient;
+    port = cbdataReference(xact->squidPort.get());
+    log_addr = xact->tcpClient->remote;
+    log_addr.applyMask(Config.Addrs.client_netmask);
 
-    result->clientConnection = client;
-    result->log_addr = client->remote;
-    result->log_addr.ApplyMask(Config.Addrs.client_netmask);
-    result->in.buf = (char *)memAllocBuf(CLIENT_REQ_BUF_SZ, &result->in.allocatedSize);
-    result->port = cbdataReference(port);
+    in.buf = (char *)memAllocBuf(CLIENT_REQ_BUF_SZ, &in.allocatedSize);
 
     if (port->disable_pmtu_discovery != DISABLE_PMTU_OFF &&
-            (result->transparent() || port->disable_pmtu_discovery == DISABLE_PMTU_ALWAYS)) {
+            (transparent() || port->disable_pmtu_discovery == DISABLE_PMTU_ALWAYS)) {
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
         int i = IP_PMTUDISC_DONT;
-        if (setsockopt(client->fd, SOL_IP, IP_MTU_DISCOVER, &i, sizeof(i)) < 0)
-            debugs(33, 2, "WARNING: Path MTU discovery disabling failed on " << client << " : " << xstrerror());
+        if (setsockopt(clientConnection->fd, SOL_IP, IP_MTU_DISCOVER, &i, sizeof(i)) < 0)
+            debugs(33, 2, "WARNING: Path MTU discovery disabling failed on " << clientConnection << " : " << xstrerror());
 #else
         static bool reported = false;
 
         if (!reported) {
             debugs(33, DBG_IMPORTANT, "NOTICE: Path MTU discovery disabling is not supported on your platform.");
             reported = true;
         }
 #endif
     }
 
     typedef CommCbMemFunT<ConnStateData, CommCloseCbParams> Dialer;
-    AsyncCall::Pointer call = JobCallback(33, 5, Dialer, result, ConnStateData::connStateClosed);
-    comm_add_close_handler(client->fd, call);
+    AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, ConnStateData::connStateClosed);
+    comm_add_close_handler(clientConnection->fd, call);
 
     if (Config.onoff.log_fqdn)
-        fqdncache_gethostbyaddr(client->remote, FQDN_LOOKUP_IF_MISS);
+        fqdncache_gethostbyaddr(clientConnection->remote, FQDN_LOOKUP_IF_MISS);
 
 #if USE_IDENT
     if (Ident::TheConfig.identLookup) {
         ACLFilledChecklist identChecklist(Ident::TheConfig.identLookup, NULL, NULL);
-        identChecklist.src_addr = client->remote;
-        identChecklist.my_addr = client->local;
+        identChecklist.src_addr = xact->tcpClient->remote;
+        identChecklist.my_addr = xact->tcpClient->local;
         if (identChecklist.fastCheck() == ACCESS_ALLOWED)
-            Ident::Start(client, clientIdentDone, result);
+            Ident::Start(xact->tcpClient, clientIdentDone, this);
     }
 #endif
 
-#if USE_SQUID_EUI
-    if (Eui::TheConfig.euiLookup) {
-        if (client->remote.IsIPv4()) {
-            result->clientConnection->remoteEui48.lookup(client->remote);
-        } else if (client->remote.IsIPv6()) {
-            result->clientConnection->remoteEui64.lookup(client->remote);
-        }
-    }
-#endif
-
-    clientdbEstablished(client->remote, 1);
+    clientdbEstablished(clientConnection->remote, 1);
 
-    result->flags.readMore = true;
-    return result;
+    flags.readMore = true;
 }
 
 /** Handle a new connection on HTTP socket. */
 void
 httpAccept(const CommAcceptCbParams &params)
 {
-    AnyP::PortCfg *s = static_cast<AnyP::PortCfg *>(params.data);
+    MasterXaction::Pointer xact = params.xaction;
+    AnyP::PortCfgPointer s = xact->squidPort;
+
+    if (!s.valid()) {
+        // it is possible the call or accept() was still queued when the port was reconfigured
+        debugs(33, 2, "HTTP accept failure: port reconfigured.");
+        return;
+    }
 
     if (params.flag != COMM_OK) {
         // Its possible the call was still queued when the client disconnected
         debugs(33, 2, "httpAccept: " << s->listenConn << ": accept failure: " << xstrerr(params.xerrno));
         return;
     }
@@ -3347,13 +3416,13 @@
         commSetTcpKeepalive(params.conn->fd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
     }
 
     ++ incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = connStateCreate(params.conn, s);
+    ConnStateData *connState = new ConnStateData(xact);
 
     typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
                                       TimeoutDialer, connState, ConnStateData::requestTimeout);
     commSetConnTimeout(params.conn, Config.Timeout.request, timeoutCall);
 
@@ -3569,31 +3638,40 @@
 
     if (ssl)
         Comm::SetSelect(details->fd, COMM_SELECT_READ, clientNegotiateSSL, connState, 0);
     else {
         char buf[MAX_IPSTRLEN];
         assert(bumpMode != Ssl::bumpNone && bumpMode != Ssl::bumpEnd);
-        HttpRequest *fakeRequest = new HttpRequest;
-        fakeRequest->SetHost(details->local.NtoA(buf, sizeof(buf)));
-        fakeRequest->port = details->local.GetPort();
+        HttpRequest::Pointer fakeRequest(new HttpRequest);
+        fakeRequest->SetHost(details->local.toStr(buf, sizeof(buf)));
+        fakeRequest->port = details->local.port();
         fakeRequest->clientConnectionManager = connState;
         fakeRequest->client_addr = connState->clientConnection->remote;
 #if FOLLOW_X_FORWARDED_FOR
         fakeRequest->indirect_client_addr = connState->clientConnection->remote;
 #endif
         fakeRequest->my_addr = connState->clientConnection->local;
-        fakeRequest->flags.spoofClientIp = ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
+        fakeRequest->flags.interceptTproxy = ((connState->clientConnection->flags & COMM_TRANSPARENT) != 0 ) ;
         fakeRequest->flags.intercepted = ((connState->clientConnection->flags & COMM_INTERCEPTION) != 0);
+        fakeRequest->myportname = connState->port->name;
+        if (fakeRequest->flags.interceptTproxy) {
+            if (Config.accessList.spoof_client_ip) {
+                ACLFilledChecklist checklist(Config.accessList.spoof_client_ip, fakeRequest.getRaw(), NULL);
+                fakeRequest->flags.spoofClientIp = (checklist.fastCheck() == ACCESS_ALLOWED);
+            } else
+                fakeRequest->flags.spoofClientIp = true;
+        } else
+            fakeRequest->flags.spoofClientIp = false;
         debugs(33, 4, HERE << details << " try to generate a Dynamic SSL CTX");
-        connState->switchToHttps(fakeRequest, bumpMode);
+        connState->switchToHttps(fakeRequest.getRaw(), bumpMode);
     }
 }
 
 /**
  * A callback function to use with the ACLFilledChecklist callback.
- * In the case of ACCES_ALLOWED answer initializes a bumped SSL connection,
+ * In the case of ACCESS_ALLOWED answer initializes a bumped SSL connection,
  * else reverts the connection to tunnel mode.
  */
 static void
 httpsSslBumpAccessCheckDone(allow_t answer, void *data)
 {
     ConnStateData *connState = (ConnStateData *) data;
@@ -3612,13 +3690,13 @@
         debugs(33, 2, HERE << "sslBump not needed for " << connState->clientConnection);
         connState->sslBumpMode = Ssl::bumpNone;
 
         // fake a CONNECT request to force connState to tunnel
         static char ip[MAX_IPSTRLEN];
         static char reqStr[MAX_IPSTRLEN + 80];
-        connState->clientConnection->local.ToURL(ip, sizeof(ip));
+        connState->clientConnection->local.toUrl(ip, sizeof(ip));
         snprintf(reqStr, sizeof(reqStr), "CONNECT %s HTTP/1.1\r\nHost: %s\r\n\r\n", ip, ip);
         bool ret = connState->handleReadData(reqStr, strlen(reqStr));
         if (ret)
             ret = connState->clientParseRequests();
 
         if (!ret) {
@@ -3629,13 +3707,20 @@
 }
 
 /** handle a new HTTPS connection */
 static void
 httpsAccept(const CommAcceptCbParams &params)
 {
-    AnyP::PortCfg *s = static_cast<AnyP::PortCfg *>(params.data);
+    MasterXaction::Pointer xact = params.xaction;
+    const AnyP::PortCfgPointer s = xact->squidPort;
+
+    if (!s.valid()) {
+        // it is possible the call or accept() was still queued when the port was reconfigured
+        debugs(33, 2, "HTTPS accept failure: port reconfigured.");
+        return;
+    }
 
     if (params.flag != COMM_OK) {
         // Its possible the call was still queued when the client disconnected
         debugs(33, 2, "httpsAccept: " << s->listenConn << ": accept failure: " << xstrerr(params.xerrno));
         return;
     }
@@ -3647,29 +3732,29 @@
         commSetTcpKeepalive(params.conn->fd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
     }
 
     ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = connStateCreate(params.conn, s);
+    ConnStateData *connState = new ConnStateData(xact);
 
-    if (s->sslBump) {
+    if (s->flags.tunnelSslBumping) {
         debugs(33, 5, "httpsAccept: accept transparent connection: " << params.conn);
 
         if (!Config.accessList.ssl_bump) {
             httpsSslBumpAccessCheckDone(ACCESS_DENIED, connState);
             return;
         }
 
         // Create a fake HTTP request for ssl_bump ACL check,
         // using tproxy/intercept provided destination IP and port.
         HttpRequest *request = new HttpRequest();
         static char ip[MAX_IPSTRLEN];
         assert(params.conn->flags & (COMM_TRANSPARENT | COMM_INTERCEPTION));
-        request->SetHost(params.conn->local.NtoA(ip, sizeof(ip)));
-        request->port = params.conn->local.GetPort();
+        request->SetHost(params.conn->local.toStr(ip, sizeof(ip)));
+        request->port = params.conn->local.port();
         request->myportname = s->name;
 
         ACLFilledChecklist *acl_checklist = new ACLFilledChecklist(Config.accessList.ssl_bump, request, NULL);
         acl_checklist->src_addr = params.conn->remote;
         acl_checklist->my_addr = s->s;
         acl_checklist->nonBlockingCheck(httpsSslBumpAccessCheckDone, connState);
@@ -3678,29 +3763,31 @@
         SSL_CTX *sslContext = s->staticSslContext.get();
         httpsEstablish(connState, sslContext, Ssl::bumpNone);
     }
 }
 
 void
-ConnStateData::sslCrtdHandleReplyWrapper(void *data, char *reply)
+ConnStateData::sslCrtdHandleReplyWrapper(void *data, const HelperReply &reply)
 {
     ConnStateData * state_data = (ConnStateData *)(data);
     state_data->sslCrtdHandleReply(reply);
 }
 
 void
-ConnStateData::sslCrtdHandleReply(const char * reply)
+ConnStateData::sslCrtdHandleReply(const HelperReply &reply)
 {
-    if (!reply) {
-        debugs(1, DBG_IMPORTANT, HERE << "\"ssl_crtd\" helper return <NULL> reply");
+    if (reply.result == HelperReply::BrokenHelper) {
+        debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " cannot be generated. ssl_crtd response: " << reply);
+    } else if (!reply.other().hasContent()) {
+        debugs(1, DBG_IMPORTANT, HERE << "\"ssl_crtd\" helper returned <NULL> reply.");
     } else {
-        Ssl::CrtdMessage reply_message;
-        if (reply_message.parse(reply, strlen(reply)) != Ssl::CrtdMessage::OK) {
+        Ssl::CrtdMessage reply_message(Ssl::CrtdMessage::REPLY);
+        if (reply_message.parse(reply.other().content(), reply.other().contentSize()) != Ssl::CrtdMessage::OK) {
             debugs(33, 5, HERE << "Reply from ssl_crtd for " << sslConnectHostOrIp << " is incorrect");
         } else {
-            if (reply_message.getCode() != "OK") {
+            if (reply.result != HelperReply::Okay) {
                 debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " cannot be generated. ssl_crtd response: " << reply_message.getBody());
             } else {
                 debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " was successfully recieved from ssl_crtd");
                 SSL_CTX *ctx = Ssl::generateSslContextUsingPkeyAndCertFromMemory(reply_message.getBody().c_str(), *port);
                 getSslContextDone(ctx, true);
                 return;
@@ -3730,13 +3817,13 @@
     // number of warnings the user will have to see to get to the error page.
     assert(sslServerBump->entry);
     if (sslServerBump->entry->isEmpty()) {
         if (X509 *mimicCert = sslServerBump->serverCert.get())
             certProperties.mimicCert.resetAndLock(mimicCert);
 
-        ACLFilledChecklist checklist(NULL, sslServerBump->request,
+        ACLFilledChecklist checklist(NULL, sslServerBump->request.getRaw(),
                                      clientConnection != NULL ? clientConnection->rfc931 : dash_str);
         checklist.sslErrors = cbdataReference(sslServerBump->sslErrors);
 
         for (sslproxy_cert_adapt *ca = Config.ssl_client.cert_adapt; ca != NULL; ca = ca->next) {
             // If the algorithm already set, then ignore it.
             if ((ca->alg == Ssl::algSetCommonName && certProperties.setCommonName) ||
@@ -3807,32 +3894,34 @@
         Ssl::CertificateProperties certProperties;
         buildSslCertGenerationParams(certProperties);
         sslBumpCertKey = certProperties.dbKey().c_str();
         assert(sslBumpCertKey.defined() && sslBumpCertKey[0] != '\0');
 
         debugs(33, 5, HERE << "Finding SSL certificate for " << sslBumpCertKey << " in cache");
-        Ssl::LocalContextStorage & ssl_ctx_cache(Ssl::TheGlobalContextStorage.getLocalStorage(port->s));
-        SSL_CTX * dynCtx = ssl_ctx_cache.find(sslBumpCertKey.termedBuf());
-        if (dynCtx) {
+        Ssl::LocalContextStorage *ssl_ctx_cache = Ssl::TheGlobalContextStorage.getLocalStorage(port->s);
+        SSL_CTX * dynCtx = NULL;
+        Ssl::SSL_CTX_Pointer *cachedCtx = ssl_ctx_cache ? ssl_ctx_cache->get(sslBumpCertKey.termedBuf()) : NULL;
+        if (cachedCtx && (dynCtx = cachedCtx->get())) {
             debugs(33, 5, HERE << "SSL certificate for " << sslBumpCertKey << " have found in cache");
             if (Ssl::verifySslCertificate(dynCtx, certProperties)) {
                 debugs(33, 5, HERE << "Cached SSL certificate for " << sslBumpCertKey << " is valid");
                 getSslContextDone(dynCtx);
                 return;
             } else {
                 debugs(33, 5, HERE << "Cached SSL certificate for " << sslBumpCertKey << " is out of date. Delete this certificate from cache");
-                ssl_ctx_cache.remove(sslBumpCertKey.termedBuf());
+                if (ssl_ctx_cache)
+                    ssl_ctx_cache->del(sslBumpCertKey.termedBuf());
             }
         } else {
             debugs(33, 5, HERE << "SSL certificate for " << sslBumpCertKey << " haven't found in cache");
         }
 
 #if USE_SSL_CRTD
         try {
             debugs(33, 5, HERE << "Generating SSL certificate for " << certProperties.commonName << " using ssl_crtd.");
-            Ssl::CrtdMessage request_message;
+            Ssl::CrtdMessage request_message(Ssl::CrtdMessage::REQUEST);
             request_message.setCode(Ssl::CrtdMessage::code_new_certificate);
             request_message.composeRequest(certProperties);
             debugs(33, 5, HERE << "SSL crtd request: " << request_message.compose().c_str());
             Ssl::Helper::GetInstance()->sslSubmit(request_message, sslCrtdHandleReplyWrapper, this);
             return;
         } catch (const std::exception &e) {
@@ -3869,16 +3958,16 @@
                 debugs(33, DBG_IMPORTANT, "WARNING: can not add signing certificate to SSL context chain: " << ERR_error_string(ssl_error, NULL));
             }
             Ssl::addChainToSslContext(sslContext, port->certsToChain.get());
         }
         //else it is self-signed or untrusted do not attrach any certificate
 
-        Ssl::LocalContextStorage & ssl_ctx_cache(Ssl::TheGlobalContextStorage.getLocalStorage(port->s));
+        Ssl::LocalContextStorage *ssl_ctx_cache = Ssl::TheGlobalContextStorage.getLocalStorage(port->s);
         assert(sslBumpCertKey.defined() && sslBumpCertKey[0] != '\0');
         if (sslContext) {
-            if (!ssl_ctx_cache.add(sslBumpCertKey.termedBuf(), sslContext)) {
+            if (!ssl_ctx_cache || !ssl_ctx_cache->add(sslBumpCertKey.termedBuf(), new Ssl::SSL_CTX_Pointer(sslContext))) {
                 // If it is not in storage delete after using. Else storage deleted it.
                 fd_table[clientConnection->fd].dynamicSslContext = sslContext;
             }
         } else {
             debugs(33, 2, HERE << "Failed to generate SSL cert for " << sslConnectHostOrIp);
         }
@@ -3893,17 +3982,22 @@
         } else {
             debugs(33, 5, HERE << "Using static ssl context.");
             sslContext = port->staticSslContext.get();
         }
     }
 
-    SSL *ssl = NULL;
-    if (!(ssl = httpsCreate(clientConnection, sslContext)))
+    if (!httpsCreate(clientConnection, sslContext))
         return;
 
-    // commSetConnTimeout() was called for this request before we switched.
+    // bumped intercepted conns should already have Config.Timeout.request set
+    // but forwarded connections may only have Config.Timeout.lifetime. [Re]set
+    // to make sure the connection does not get stuck on non-SSL clients.
+    typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall = JobCallback(33, 5, TimeoutDialer,
+                                     this, ConnStateData::requestTimeout);
+    commSetConnTimeout(clientConnection, Config.Timeout.request, timeoutCall);
 
     // Disable the client read handler until CachePeer selection is complete
     Comm::SetSelect(clientConnection->fd, COMM_SELECT_READ, NULL, NULL, 0);
     Comm::SetSelect(clientConnection->fd, COMM_SELECT_READ, clientNegotiateSSL, this, 0);
     switchedToHttps_ = true;
 }
@@ -3921,17 +4015,17 @@
     debugs(33, 5, HERE << "converting " << clientConnection << " to SSL");
 
     // If sslServerBump is set, then we have decided to deny CONNECT
     // and now want to switch to SSL to send the error to the client
     // without even peeking at the origin server certificate.
     if (bumpServerMode == Ssl::bumpServerFirst && !sslServerBump) {
-        request->flags.sslPeek = 1;
+        request->flags.sslPeek = true;
         sslServerBump = new Ssl::ServerBump(request);
 
         // will call httpsPeeked() with certificate and connection, eventually
-        FwdState::fwdStart(clientConnection, sslServerBump->entry, sslServerBump->request);
+        FwdState::fwdStart(clientConnection, sslServerBump->entry, sslServerBump->request.getRaw());
         return;
     }
 
     // otherwise, use sslConnectHostOrIp
     getSslContextStart();
 }
@@ -3954,18 +4048,18 @@
 
         debugs(33, 5, HERE << "bumped HTTPS server: " << sslConnectHostOrIp);
     } else {
         debugs(33, 5, HERE << "Error while bumping: " << sslConnectHostOrIp);
         Ip::Address intendedDest;
         intendedDest = sslConnectHostOrIp.termedBuf();
-        const bool isConnectRequest = !port->spoof_client_ip && !port->intercepted;
+        const bool isConnectRequest = !port->flags.isIntercepted();
 
         // Squid serves its own error page and closes, so we want
         // a CN that causes no additional browser errors. Possible
         // only when bumping CONNECT with a user-typed address.
-        if (intendedDest.IsAnyAddr() || isConnectRequest)
+        if (intendedDest.isAnyAddr() || isConnectRequest)
             sslCommonName = sslConnectHostOrIp;
         else if (sslServerBump->serverCert.get())
             sslCommonName = Ssl::CommonHostName(sslServerBump->serverCert.get());
 
         //  copy error detail from bump-server-first request to CONNECT request
         if (currentobject != NULL && currentobject->http != NULL && currentobject->http->request)
@@ -4016,32 +4110,34 @@
             debugs(1, DBG_IMPORTANT, "WARNING: You have too many 'http_port' lines.");
             debugs(1, DBG_IMPORTANT, "         The limit is " << MAXTCPLISTENPORTS << " HTTP ports.");
             continue;
         }
 
 #if USE_SSL
-        if (s->sslBump && !Config.accessList.ssl_bump) {
+        if (s->flags.tunnelSslBumping && !Config.accessList.ssl_bump) {
             debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << s->protocol << "_port " << s->s);
-            s->sslBump = 0;
+            s->flags.tunnelSslBumping = false;
         }
 
-        if (s->sslBump && !s->staticSslContext && !s->generateHostCertificates) {
+        if (s->flags.tunnelSslBumping &&
+                !s->staticSslContext &&
+                !s->generateHostCertificates) {
             debugs(1, DBG_IMPORTANT, "Will not bump SSL at http_port " << s->s << " due to SSL initialization failure.");
-            s->sslBump = 0;
+            s->flags.tunnelSslBumping = false;
         }
-        if (s->sslBump) {
+        if (s->flags.tunnelSslBumping) {
             // Create ssl_ctx cache for this port.
             Ssl::TheGlobalContextStorage.addLocalStorage(s->s, s->dynamicCertMemCacheSize == std::numeric_limits<size_t>::max() ? 4194304 : s->dynamicCertMemCacheSize);
         }
 #endif
 
         // Fill out a Comm::Connection which IPC will open as a listener for us
         //  then pass back when active so we can start a TcpAcceptor subscription.
         s->listenConn = new Comm::Connection;
         s->listenConn->local = s->s;
-        s->listenConn->flags = COMM_NONBLOCKING | (s->spoof_client_ip ? COMM_TRANSPARENT : 0) | (s->intercepted ? COMM_INTERCEPTION : 0);
+        s->listenConn->flags = COMM_NONBLOCKING | (s->flags.tproxyIntercept ? COMM_TRANSPARENT : 0) | (s->flags.natIntercept ? COMM_INTERCEPTION : 0);
 
         // setup the subscriptions such that new connections accepted by listenConn are handled by HTTP
         typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
         RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpAccept", CommAcceptCbPtrFun(httpAccept, s));
         Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
 
@@ -4071,32 +4167,32 @@
             debugs(1, DBG_IMPORTANT, "Ignoring https_port " << s->s <<
                    " due to SSL initialization failure.");
             continue;
         }
 
         // TODO: merge with similar code in clientHttpConnectionsOpen()
-        if (s->sslBump && !Config.accessList.ssl_bump) {
+        if (s->flags.tunnelSslBumping && !Config.accessList.ssl_bump) {
             debugs(33, DBG_IMPORTANT, "WARNING: No ssl_bump configured. Disabling ssl-bump on " << s->protocol << "_port " << s->s);
-            s->sslBump = 0;
+            s->flags.tunnelSslBumping = false;
         }
 
-        if (s->sslBump && !s->staticSslContext && !s->generateHostCertificates) {
+        if (s->flags.tunnelSslBumping && !s->staticSslContext && !s->generateHostCertificates) {
             debugs(1, DBG_IMPORTANT, "Will not bump SSL at http_port " << s->s << " due to SSL initialization failure.");
-            s->sslBump = 0;
+            s->flags.tunnelSslBumping = false;
         }
 
-        if (s->sslBump) {
+        if (s->flags.tunnelSslBumping) {
             // Create ssl_ctx cache for this port.
             Ssl::TheGlobalContextStorage.addLocalStorage(s->s, s->dynamicCertMemCacheSize == std::numeric_limits<size_t>::max() ? 4194304 : s->dynamicCertMemCacheSize);
         }
 
         // Fill out a Comm::Connection which IPC will open as a listener for us
         s->listenConn = new Comm::Connection;
         s->listenConn->local = s->s;
-        s->listenConn->flags = COMM_NONBLOCKING | (s->spoof_client_ip ? COMM_TRANSPARENT : 0) |
-                               (s->intercepted ? COMM_INTERCEPTION : 0);
+        s->listenConn->flags = COMM_NONBLOCKING | (s->flags.tproxyIntercept ? COMM_TRANSPARENT : 0) |
+                               (s->flags.natIntercept ? COMM_INTERCEPTION : 0);
 
         // setup the subscriptions such that new connections accepted by listenConn are handled by HTTPS
         typedef CommCbFunPtrCallT<CommAcceptCbPtrFun> AcceptCall;
         RefCount<AcceptCall> subCall = commCbCall(5, 5, "httpsAccept", CommAcceptCbPtrFun(httpsAccept, s));
         Subscription::Pointer sub = new CallSubscription<AcceptCall>(subCall);
 
@@ -4121,16 +4217,16 @@
     Must(Comm::IsConnOpen(s->listenConn));
 
     // TCP: setup a job to handle accept() with subscribed handler
     AsyncJob::Start(new Comm::TcpAcceptor(s->listenConn, FdNote(portTypeNote), sub));
 
     debugs(1, DBG_IMPORTANT, "Accepting " <<
-           (s->intercepted ? "NAT intercepted " : "") <<
-           (s->spoof_client_ip ? "TPROXY spoofing " : "") <<
-           (s->sslBump ? "SSL bumped " : "") <<
-           (s->accel ? "reverse-proxy " : "")
+           (s->flags.natIntercept ? "NAT intercepted " : "") <<
+           (s->flags.tproxyIntercept ? "TPROXY intercepted " : "") <<
+           (s->flags.tunnelSslBumping ? "SSL bumped " : "") <<
+           (s->flags.accelSurrogate ? "reverse-proxy " : "")
            << FdNote(portTypeNote) << " connections at "
            << s->listenConn);
 
     Must(AddOpenedHttpSocket(s->listenConn)); // otherwise, we have received a fd we did not ask for
 }
 
@@ -4252,30 +4348,12 @@
     /* connection oriented auth also needs these two lines for it's operation. */
     return ch;
 }
 
 CBDATA_CLASS_INIT(ConnStateData);
 
-ConnStateData::ConnStateData() :
-        AsyncJob("ConnStateData"),
-#if USE_SSL
-        sslBumpMode(Ssl::bumpEnd),
-        switchedToHttps_(false),
-        sslServerBump(NULL),
-#endif
-        stoppedSending_(NULL),
-        stoppedReceiving_(NULL)
-{
-    pinning.host = NULL;
-    pinning.port = -1;
-    pinning.pinned = false;
-    pinning.auth = false;
-    pinning.zeroReply = false;
-    pinning.peer = NULL;
-}
-
 bool
 ConnStateData::transparent() const
 {
     return clientConnection != NULL && (clientConnection->flags & (COMM_TRANSPARENT|COMM_INTERCEPTION));
 }
 
@@ -4458,22 +4536,22 @@
     const char *pinnedHost = "[unknown]";
     if (request) {
         pinning.host = xstrdup(request->GetHost());
         pinning.port = request->port;
         pinnedHost = pinning.host;
     } else {
-        pinning.port = pinServer->remote.GetPort();
+        pinning.port = pinServer->remote.port();
     }
     pinning.pinned = true;
     if (aPeer)
         pinning.peer = cbdataReference(aPeer);
     pinning.auth = auth;
     char stmp[MAX_IPSTRLEN];
     snprintf(desc, FD_DESC_SZ, "%s pinned connection for %s (%d)",
              (auth || !aPeer) ? pinnedHost : aPeer->name,
-             clientConnection->remote.ToURL(stmp,MAX_IPSTRLEN),
+             clientConnection->remote.toUrl(stmp,MAX_IPSTRLEN),
              clientConnection->fd);
     fd_note(pinning.serverConnection->fd, desc);
 
     typedef CommCbMemFunT<ConnStateData, CommCloseCbParams> Dialer;
     pinning.closeHandler = JobCallback(33, 5,
                                        Dialer, this, ConnStateData::clientPinnedConnectionClosed);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,32 +30,27 @@
  *
  */
 
 #ifndef SQUID_CLIENTSIDE_H
 #define SQUID_CLIENTSIDE_H
 
-#include "base/AsyncJob.h"
-#include "BodyPipe.h"
 #include "comm.h"
-#include "CommCalls.h"
-#include "HttpRequest.h"
 #include "HttpControlMsg.h"
 #include "HttpParser.h"
-#include "RefCount.h"
-#include "StoreIOBuffer.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
 #if USE_SSL
 #include "ssl/support.h"
 #endif
 
 class ConnStateData;
 class ClientHttpRequest;
 class clientStreamNode;
 class ChunkedCodingParser;
+class HelperReply;
 namespace AnyP
 {
 class PortCfg;
 } // namespace Anyp
 
 /**
@@ -85,14 +80,12 @@
  */
 class ClientSocketContext : public RefCountable
 {
 
 public:
     typedef RefCount<ClientSocketContext> Pointer;
-    void *operator new(size_t);
-    void operator delete(void *);
     ClientSocketContext();
     ~ClientSocketContext();
     bool startOfOutput() const;
     void writeComplete(const Comm::ConnectionPointer &conn, char *bufnotused, size_t size, comm_err_t errflag);
     void keepaliveNextRequest();
 
@@ -161,26 +154,26 @@
 
     AsyncCall::Pointer cbControlMsgSent; ///< notifies HttpControlMsg Source
 
     bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
     bool connRegistered_;
 
-    CBDATA_CLASS(ClientSocketContext);
+    CBDATA_CLASS2(ClientSocketContext);
 };
 
 class ConnectionDetail;
 #if USE_SSL
 namespace Ssl
 {
 class ServerBump;
 }
 #endif
 /**
  * Manages a connection to a client.
  *
- * Multiple requests (up to 2) can be pipelined. This object is responsible for managing
+ * Multiple requests (up to pipeline_prefetch) can be pipelined. This object is responsible for managing
  * which one is currently being fulfilled and what happens to the queue if the current one
  * causes the client connection to be closed early.
  *
  * Act as a manager for the connection and passes data in buffer to the current parser.
  * the parser has ambiguous scope at present due to being made from global functions
  * I believe this object uses the parser to identify boundaries and kick off the
@@ -189,14 +182,13 @@
  * If the above can be confirmed accurate we can call this object PipelineManager or similar
  */
 class ConnStateData : public BodyProducer, public HttpControlMsgSink
 {
 
 public:
-
-    ConnStateData();
+    explicit ConnStateData(const MasterXaction::Pointer &xact);
     ~ConnStateData();
 
     void readSomeData();
     int getAvailableBufferLength() const;
     bool areAllContextsForThisConnection() const;
     void freeAllContexts();
@@ -235,16 +227,26 @@
      * \retval positive  Need to read exactly that many more body bytes
      */
     int64_t mayNeedToReadMoreBody() const;
 
 #if USE_AUTH
     /**
-     * note this is ONLY connection based because NTLM and Negotiate is against HTTP spec.
-     * the user details for connection based authentication
+     * Fetch the user details for connection based authentication
+     * NOTE: this is ONLY connection based because NTLM and Negotiate is against HTTP spec.
+     */
+    const Auth::UserRequest::Pointer &getAuth() const { return auth_; }
+
+    /**
+     * Set the user details for connection-based authentication to use from now until connection closure.
+     *
+     * Any change to existing credentials shows that something invalid has happened. Such as:
+     * - NTLM/Negotiate auth was violated by the per-request headers missing a revalidation token
+     * - NTLM/Negotiate auth was violated by the per-request headers being for another user
+     * - SSL-Bump CONNECT tunnel with persistent credentials has ended
      */
-    Auth::UserRequest::Pointer auth_user_request;
+    void setAuth(const Auth::UserRequest::Pointer &aur, const char *cause);
 #endif
 
     /**
      * used by the owner of the connection, opaque otherwise
      * TODO: generalise the connection owner concept.
      */
@@ -266,12 +268,13 @@
         bool zeroReply; ///< server closed w/o response (ERR_ZERO_SIZE_OBJECT)
         CachePeer *peer;             /* CachePeer the connection goes via */
         AsyncCall::Pointer readHandler; ///< detects serverConnection closure
         AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
     } pinning;
 
+    /// Squid listening port details where this connection arrived.
     AnyP::PortCfg *port;
 
     bool transparent() const;
     bool reading() const;
     void stopReading(); ///< cancels comm_read if it is scheduled
 
@@ -344,15 +347,15 @@
      * Done create dynamic ssl certificate.
      *
      * \param[in] isNew if generated certificate is new, so we need to add this certificate to storage.
      */
     void getSslContextDone(SSL_CTX * sslContext, bool isNew = false);
     /// Callback function. It is called when squid receive message from ssl_crtd.
-    static void sslCrtdHandleReplyWrapper(void *data, char *reply);
+    static void sslCrtdHandleReplyWrapper(void *data, const HelperReply &reply);
     /// Proccess response from ssl_crtd.
-    void sslCrtdHandleReply(const char * reply);
+    void sslCrtdHandleReply(const HelperReply &reply);
 
     void switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode);
     bool switchedToHttps() const { return switchedToHttps_; }
     Ssl::ServerBump *serverBump() {return sslServerBump;}
     inline void setServerBump(Ssl::ServerBump *srvBump) {
         if (!sslServerBump)
@@ -385,14 +388,19 @@
     void clientPinnedConnectionRead(const CommIoCbParams &io);
 
 private:
     int connReadWasError(comm_err_t flag, int size, int xerrno);
     int connFinishedWithConn(int size);
     void clientAfterReadingRequests();
+    bool concurrentRequestQueueFilled() const;
+
+#if USE_AUTH
+    /// some user details that can be used to perform authentication on this connection
+    Auth::UserRequest::Pointer auth_;
+#endif
 
-private:
     HttpParser parser_;
 
     // XXX: CBDATA plays with public/private and leaves the following 'private' fields all public... :(
 
 #if USE_SSL
     bool switchedToHttps_;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side_reply.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side_reply.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side_reply.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side_reply.cc	2015-05-01 18:05:19.000000000 +0800
@@ -31,21 +31,18 @@
  */
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "anyp/PortCfg.h"
 #include "client_side_reply.h"
-#include "client_side.h"
-#include "clientStream.h"
-#include "dlink.h"
 #include "errorpage.h"
 #include "ETag.h"
 #include "fd.h"
 #include "fde.h"
 #include "format/Token.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "globals.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "ip/QosConfig.h"
@@ -56,13 +53,12 @@
 #include "neighbors.h"
 #include "refresh.h"
 #include "RequestFlags.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
-#include "StoreClient.h"
 #include "StrList.h"
 #include "tools.h"
 #include "URL.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
@@ -70,17 +66,19 @@
 #include "DelayPools.h"
 #endif
 #if USE_SQUID_ESI
 #include "esi/Esi.h"
 #endif
 
+#include <memory>
+
 CBDATA_CLASS_INIT(clientReplyContext);
 
 /* Local functions */
 extern "C" CSS clientReplyStatus;
-ErrorState *clientBuildError(err_type, http_status, char const *, Ip::Address &, HttpRequest *);
+ErrorState *clientBuildError(err_type, Http::StatusCode, char const *, Ip::Address &, HttpRequest *);
 
 /* privates */
 
 clientReplyContext::~clientReplyContext()
 {
     deleting = true;
@@ -103,13 +101,13 @@
  *
  * This may be better placed in the clientStream logic, but it has not been
  * relocated there yet
  */
 void
 clientReplyContext::setReplyToError(
-    err_type err, http_status status, const HttpRequestMethod& method, char const *uri,
+    err_type err, Http::StatusCode status, const HttpRequestMethod& method, char const *uri,
     Ip::Address &addr, HttpRequest * failedrequest, const char *unparsedrequest,
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request
 #else
     void*
 #endif
@@ -125,15 +123,15 @@
 #endif
     setReplyToError(method, errstate);
 }
 
 void clientReplyContext::setReplyToError(const HttpRequestMethod& method, ErrorState *errstate)
 {
-    if (errstate->httpStatus == HTTP_NOT_IMPLEMENTED && http->request)
+    if (errstate->httpStatus == Http::scNotImplemented && http->request)
         /* prevent confusion over whether we default to persistent or not */
-        http->request->flags.proxyKeepalive = 0;
+        http->request->flags.proxyKeepalive = false;
 
     http->al->http.code = errstate->httpStatus;
 
     if (http->request)
         http->request->ignoreRange("responding with a Squid-generated error");
 
@@ -180,28 +178,12 @@
 {
     StoreEntry *reference = aHttpRequest->storeEntry();
     removeStoreReference(scp, &reference);
     aHttpRequest->storeEntry(reference);
 }
 
-void *
-clientReplyContext::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (clientReplyContext));
-    CBDATA_INIT_TYPE(clientReplyContext);
-    return cbdataAlloc(clientReplyContext);
-}
-
-void
-clientReplyContext::operator delete (void *address)
-{
-    clientReplyContext * tmp = (clientReplyContext *)address;
-    cbdataFree (tmp);
-}
-
 void
 clientReplyContext::saveState()
 {
     assert(old_sc == NULL);
     debugs(88, 3, "clientReplyContext::saveState: saving store context");
     old_entry = http->storeEntry();
@@ -263,13 +245,13 @@
 /* there is an expired entry in the store.
  * setup a temporary buffer area and perform an IMS to the origin
  */
 void
 clientReplyContext::processExpired()
 {
-    char *url = http->uri;
+    const char *url = storeId();
     StoreEntry *entry = NULL;
     debugs(88, 3, "clientReplyContext::processExpired: '" << http->uri << "'");
     assert(http->storeEntry()->lastmod >= 0);
     /*
      * check if we are allowed to contact other servers
      * @?@: Instead of a 504 (Gateway Timeout) reply, we may want to return
@@ -278,13 +260,13 @@
 
     if (http->onlyIfCached()) {
         processOnlyIfCachedMiss();
         return;
     }
 
-    http->request->flags.refresh = 1;
+    http->request->flags.refresh = true;
 #if STORE_CLIENT_LIST_DEBUG
     /* Prevent a race with the store client memory free routines
      */
     assert(storeClientIsThisAClient(sc, this));
 #endif
     /* Prepare to make a new temporary request */
@@ -388,27 +370,27 @@
     if (result.flags.error && !EBIT_TEST(http->storeEntry()->flags, ENTRY_ABORTED))
         return;
 
     /* update size of the request */
     reqsize = result.length + reqofs;
 
-    const http_status status = http->storeEntry()->getReply()->sline.status;
+    const Http::StatusCode status = http->storeEntry()->getReply()->sline.status();
 
     // request to origin was aborted
     if (EBIT_TEST(http->storeEntry()->flags, ENTRY_ABORTED)) {
         debugs(88, 3, "handleIMSReply: request to origin aborted '" << http->storeEntry()->url() << "', sending old entry to client" );
         http->logType = LOG_TCP_REFRESH_FAIL_OLD;
         sendClientOldEntry();
     }
 
     HttpReply *old_rep = (HttpReply *) old_entry->getReply();
 
     // origin replied 304
-    if (status == HTTP_NOT_MODIFIED) {
+    if (status == Http::scNotModified) {
         http->logType = LOG_TCP_REFRESH_UNMODIFIED;
-        http->request->flags.staleIfHit = 0; // old_entry is no longer stale
+        http->request->flags.staleIfHit = false; // old_entry is no longer stale
 
         // update headers on existing entry
         old_rep->updateOnNotModified(http->storeEntry()->getReply());
         old_entry->timestampsSet();
 
         // if client sent IMS
@@ -417,19 +399,19 @@
             // forward the 304 from origin
             debugs(88, 3, "handleIMSReply: origin replied 304, revalidating existing entry and forwarding 304 to client");
             sendClientUpstreamResponse();
         } else {
             // send existing entry, it's still valid
             debugs(88, 3, "handleIMSReply: origin replied 304, revalidating existing entry and sending " <<
-                   old_rep->sline.status << " to client");
+                   old_rep->sline.status() << " to client");
             sendClientOldEntry();
         }
     }
 
     // origin replied with a non-error code
-    else if (status > HTTP_STATUS_NONE && status < HTTP_INTERNAL_SERVER_ERROR) {
+    else if (status > Http::scNone && status < Http::scInternalServerError) {
         // forward response from origin
         http->logType = LOG_TCP_REFRESH_MODIFIED;
         debugs(88, 3, "handleIMSReply: origin replied " << status << ", replacing existing entry and forwarding to client");
         sendClientUpstreamResponse();
     }
 
@@ -440,13 +422,13 @@
                ", forwarding to client due to fail_on_validation_err");
         sendClientUpstreamResponse();
     } else {
         // ignore and let client have old entry
         http->logType = LOG_TCP_REFRESH_FAIL_OLD;
         debugs(88, 3, "handleIMSReply: origin replied with error " <<
-               status << ", sending old entry (" << old_rep->sline.status << ") to client");
+               status << ", sending old entry (" << old_rep->sline.status() << ") to client");
         sendClientOldEntry();
     }
 }
 
 SQUIDCEXTERN CSR clientGetMoreData;
 SQUIDCEXTERN CSD clientReplyDetach;
@@ -509,14 +491,14 @@
 
     /*
      * Got the headers, now grok them
      */
     assert(http->logType == LOG_TCP_HIT);
 
-    if (strcmp(e->mem_obj->url, urlCanonical(r)) != 0) {
-        debugs(33, DBG_IMPORTANT, "clientProcessHit: URL mismatch, '" << e->mem_obj->url << "' != '" << urlCanonical(r) << "'");
+    if (strcmp(e->mem_obj->url, http->request->storeId()) != 0) {
+        debugs(33, DBG_IMPORTANT, "clientProcessHit: URL mismatch, '" << e->mem_obj->url << "' != '" << http->request->storeId() << "'");
         http->logType = LOG_TCP_MISS; // we lack a more precise LOG_*_MISS code
         processMiss();
         return;
     }
 
     switch (varyEvaluateMatch(e, r)) {
@@ -548,13 +530,13 @@
         debugs(88, DBG_IMPORTANT, "clientProcessHit: Vary object loop!");
         http->logType = LOG_TCP_MISS; // we lack a more precise LOG_*_MISS code
         processMiss();
         return;
     }
 
-    if (r->method == METHOD_PURGE) {
+    if (r->method == Http::METHOD_PURGE) {
         removeClientStoreReference(&sc, http);
         e = NULL;
         purgeRequest();
         return;
     }
 
@@ -572,13 +554,13 @@
          * The 'needValidation' flag is used to prevent forwarding
          * loops between siblings.  If our copy of the object is stale,
          * then we should probably only use parents for the validation
          * request.  Otherwise two siblings could generate a loop if
          * both have a stale version of the object.
          */
-        r->flags.needValidation = 1;
+        r->flags.needValidation = true;
 
         if (e->lastmod < 0) {
             debugs(88, 3, "validate HIT object? NO. Missing Last-Modified header. Do MISS.");
             /*
              * Previous reply didn't have a Last-Modified header,
              * we cannot revalidate it.
@@ -645,40 +627,40 @@
      * We might have a left-over StoreEntry from a failed cache hit
      * or IMS request.
      */
     if (http->storeEntry()) {
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
             debugs(88, DBG_CRITICAL, "clientProcessMiss: miss on a special object (" << url << ").");
-            debugs(88, DBG_CRITICAL, "\tlog_type = " << Format::log_tags[http->logType]);
+            debugs(88, DBG_CRITICAL, "\tlog_type = " << LogTags_str[http->logType]);
             http->storeEntry()->dump(1);
         }
 
         removeClientStoreReference(&sc, http);
     }
 
     /** Check if its a PURGE request to be actioned. */
-    if (r->method == METHOD_PURGE) {
+    if (r->method == Http::METHOD_PURGE) {
         purgeRequest();
         return;
     }
 
     /** Check if its an 'OTHER' request. Purge all cached entries if so and continue. */
-    if (r->method == METHOD_OTHER) {
+    if (r->method == Http::METHOD_OTHER) {
         purgeAllCached();
     }
 
     /** Check if 'only-if-cached' flag is set. Action if so. */
     if (http->onlyIfCached()) {
         processOnlyIfCachedMiss();
         return;
     }
 
     /// Deny loops
     if (r->flags.loopDetected) {
-        http->al->http.code = HTTP_FORBIDDEN;
-        err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL, http->getConn()->clientConnection->remote, http->request);
+        http->al->http.code = Http::scForbidden;
+        err = clientBuildError(ERR_ACCESS_DENIED, Http::scForbidden, NULL, http->getConn()->clientConnection->remote, http->request);
         createStoreEntry(r->method, RequestFlags());
         errorAppendEntry(http->storeEntry(), err);
         triggerInitialStoreRead();
         return;
     } else {
         assert(http->out.offset == 0);
@@ -715,28 +697,28 @@
  */
 void
 clientReplyContext::processOnlyIfCachedMiss()
 {
     debugs(88, 4, "clientProcessOnlyIfCachedMiss: '" <<
            RequestMethodStr(http->request->method) << " " << http->uri << "'");
-    http->al->http.code = HTTP_GATEWAY_TIMEOUT;
-    ErrorState *err = clientBuildError(ERR_ONLY_IF_CACHED_MISS, HTTP_GATEWAY_TIMEOUT, NULL,
+    http->al->http.code = Http::scGatewayTimeout;
+    ErrorState *err = clientBuildError(ERR_ONLY_IF_CACHED_MISS, Http::scGatewayTimeout, NULL,
                                        http->getConn()->clientConnection->remote, http->request);
     removeClientStoreReference(&sc, http);
     startError(err);
 }
 
 /// process conditional request from client
 void
 clientReplyContext::processConditional(StoreIOBuffer &result)
 {
     StoreEntry *const e = http->storeEntry();
 
-    if (e->getReply()->sline.status != HTTP_OK) {
+    if (e->getReply()->sline.status() != Http::scOkay) {
         debugs(88, 4, "clientReplyContext::processConditional: Reply code " <<
-               e->getReply()->sline.status << " != 200");
+               e->getReply()->sline.status() << " != 200");
         http->logType = LOG_TCP_MISS;
         processMiss();
         return;
     }
 
     HttpRequest &r = *http->request;
@@ -748,13 +730,13 @@
     }
 
     bool matchedIfNoneMatch = false;
     if (r.header.has(HDR_IF_NONE_MATCH)) {
         if (!e->hasIfNoneMatchEtag(r)) {
             // RFC 2616: ignore IMS if If-None-Match did not match
-            r.flags.ims = 0;
+            r.flags.ims = false;
             r.ims = -1;
             r.imslen = 0;
             r.header.delById(HDR_IF_MODIFIED_SINCE);
             http->logType = LOG_TCP_MISS;
             sendMoreData(result);
             return;
@@ -792,18 +774,18 @@
 }
 
 void
 clientReplyContext::purgeRequestFindObjectToPurge()
 {
     /* Try to find a base entry */
-    http->flags.purging = 1;
+    http->flags.purging = true;
     lookingforstore = 1;
 
     // TODO: can we use purgeAllCached() here instead of doing the
     // getPublicByRequestMethod() dance?
-    StoreEntry::getPublicByRequestMethod(this, http->request, METHOD_GET);
+    StoreEntry::getPublicByRequestMethod(this, http->request, Http::METHOD_GET);
 }
 
 // Purges all entries with a given url
 // TODO: move to SideAgent parent, when we have one
 /*
  * We probably cannot purge Vary-affected responses because their MD5
@@ -813,30 +795,30 @@
 purgeEntriesByUrl(HttpRequest * req, const char *url)
 {
 #if USE_HTCP
     bool get_or_head_sent = false;
 #endif
 
-    for (HttpRequestMethod m(METHOD_NONE); m != METHOD_ENUM_END; ++m) {
-        if (m.isCacheble()) {
+    for (HttpRequestMethod m(Http::METHOD_NONE); m != Http::METHOD_ENUM_END; ++m) {
+        if (m.respMaybeCacheable()) {
             if (StoreEntry *entry = storeGetPublic(url, m)) {
                 debugs(88, 5, "purging " << RequestMethodStr(m) << ' ' << url);
 #if USE_HTCP
                 neighborsHtcpClear(entry, url, req, m, HTCP_CLR_INVALIDATION);
-                if (m == METHOD_GET || m == METHOD_HEAD) {
+                if (m == Http::METHOD_GET || m == Http::METHOD_HEAD) {
                     get_or_head_sent = true;
                 }
 #endif
                 entry->release();
             }
         }
     }
 
 #if USE_HTCP
     if (!get_or_head_sent) {
-        neighborsHtcpClear(NULL, url, req, HttpRequestMethod(METHOD_GET), HTCP_CLR_INVALIDATION);
+        neighborsHtcpClear(NULL, url, req, HttpRequestMethod(Http::METHOD_GET), HTCP_CLR_INVALIDATION);
     }
 #endif
 }
 
 void
 clientReplyContext::purgeAllCached()
@@ -862,13 +844,13 @@
 
 void
 clientReplyContext::purgeFoundGet(StoreEntry *newEntry)
 {
     if (newEntry->isNull()) {
         lookingforstore = 2;
-        StoreEntry::getPublicByRequestMethod(this, http->request, METHOD_HEAD);
+        StoreEntry::getPublicByRequestMethod(this, http->request, Http::METHOD_HEAD);
     } else
         purgeFoundObject (newEntry);
 }
 
 void
 clientReplyContext::purgeFoundHead(StoreEntry *newEntry)
@@ -883,24 +865,24 @@
 clientReplyContext::purgeFoundObject(StoreEntry *entry)
 {
     assert (entry && !entry->isNull());
 
     if (EBIT_TEST(entry->flags, ENTRY_SPECIAL)) {
         http->logType = LOG_TCP_DENIED;
-        ErrorState *err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL,
+        ErrorState *err = clientBuildError(ERR_ACCESS_DENIED, Http::scForbidden, NULL,
                                            http->getConn()->clientConnection->remote, http->request);
         startError(err);
         return;
     }
 
     StoreIOBuffer localTempBuffer;
     /* Swap in the metadata */
     http->storeEntry(entry);
 
     http->storeEntry()->lock();
-    http->storeEntry()->createMemObject(http->uri, http->log_uri);
+    http->storeEntry()->createMemObject(storeId(), http->log_uri);
 
     http->storeEntry()->mem_obj->method = http->request->method;
 
     sc = storeClientListAdd(http->storeEntry(), this);
 
     http->logType = LOG_TCP_HIT;
@@ -922,13 +904,13 @@
 {
     debugs(88, 3, "Config2.onoff.enable_purge = " <<
            Config2.onoff.enable_purge);
 
     if (!Config2.onoff.enable_purge) {
         http->logType = LOG_TCP_DENIED;
-        ErrorState *err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL, http->getConn()->clientConnection->remote, http->request);
+        ErrorState *err = clientBuildError(ERR_ACCESS_DENIED, Http::scForbidden, NULL, http->getConn()->clientConnection->remote, http->request);
         startError(err);
         return;
     }
 
     /* Release both IP cache */
     ipcacheInvalidate(http->request->GetHost());
@@ -941,72 +923,72 @@
 
 void
 clientReplyContext::purgeDoMissPurge()
 {
     http->logType = LOG_TCP_MISS;
     lookingforstore = 3;
-    StoreEntry::getPublicByRequestMethod(this,http->request, METHOD_GET);
+    StoreEntry::getPublicByRequestMethod(this,http->request, Http::METHOD_GET);
 }
 
 void
 clientReplyContext::purgeDoPurgeGet(StoreEntry *newEntry)
 {
     assert (newEntry);
     /* Move to new() when that is created */
-    purgeStatus = HTTP_NOT_FOUND;
+    purgeStatus = Http::scNotFound;
 
     if (!newEntry->isNull()) {
         /* Release the cached URI */
         debugs(88, 4, "clientPurgeRequest: GET '" << newEntry->url() << "'" );
 #if USE_HTCP
-        neighborsHtcpClear(newEntry, NULL, http->request, HttpRequestMethod(METHOD_GET), HTCP_CLR_PURGE);
+        neighborsHtcpClear(newEntry, NULL, http->request, HttpRequestMethod(Http::METHOD_GET), HTCP_CLR_PURGE);
 #endif
         newEntry->release();
-        purgeStatus = HTTP_OK;
+        purgeStatus = Http::scOkay;
     }
 
     lookingforstore = 4;
-    StoreEntry::getPublicByRequestMethod(this, http->request, METHOD_HEAD);
+    StoreEntry::getPublicByRequestMethod(this, http->request, Http::METHOD_HEAD);
 }
 
 void
 clientReplyContext::purgeDoPurgeHead(StoreEntry *newEntry)
 {
     if (newEntry && !newEntry->isNull()) {
         debugs(88, 4, "clientPurgeRequest: HEAD '" << newEntry->url() << "'" );
 #if USE_HTCP
-        neighborsHtcpClear(newEntry, NULL, http->request, HttpRequestMethod(METHOD_HEAD), HTCP_CLR_PURGE);
+        neighborsHtcpClear(newEntry, NULL, http->request, HttpRequestMethod(Http::METHOD_HEAD), HTCP_CLR_PURGE);
 #endif
         newEntry->release();
-        purgeStatus = HTTP_OK;
+        purgeStatus = Http::scOkay;
     }
 
     /* And for Vary, release the base URI if none of the headers was included in the request */
 
     if (http->request->vary_headers
             && !strstr(http->request->vary_headers, "=")) {
-        StoreEntry *entry = storeGetPublic(urlCanonical(http->request), METHOD_GET);
+        StoreEntry *entry = storeGetPublic(urlCanonical(http->request), Http::METHOD_GET);
 
         if (entry) {
             debugs(88, 4, "clientPurgeRequest: Vary GET '" << entry->url() << "'" );
 #if USE_HTCP
-            neighborsHtcpClear(entry, NULL, http->request, HttpRequestMethod(METHOD_GET), HTCP_CLR_PURGE);
+            neighborsHtcpClear(entry, NULL, http->request, HttpRequestMethod(Http::METHOD_GET), HTCP_CLR_PURGE);
 #endif
             entry->release();
-            purgeStatus = HTTP_OK;
+            purgeStatus = Http::scOkay;
         }
 
-        entry = storeGetPublic(urlCanonical(http->request), METHOD_HEAD);
+        entry = storeGetPublic(urlCanonical(http->request), Http::METHOD_HEAD);
 
         if (entry) {
             debugs(88, 4, "clientPurgeRequest: Vary HEAD '" << entry->url() << "'" );
 #if USE_HTCP
-            neighborsHtcpClear(entry, NULL, http->request, HttpRequestMethod(METHOD_HEAD), HTCP_CLR_PURGE);
+            neighborsHtcpClear(entry, NULL, http->request, HttpRequestMethod(Http::METHOD_HEAD), HTCP_CLR_PURGE);
 #endif
             entry->release();
-            purgeStatus = HTTP_OK;
+            purgeStatus = Http::scOkay;
         }
     }
 
     /*
      * Make a new entry to hold the reply to be written
      * to the client.
@@ -1035,13 +1017,13 @@
     localTempBuffer.data = nextNode->readBuffer.data;
     storeClientCopy(sc, http->storeEntry(),
                     localTempBuffer, SendMoreData, this);
     http->storeEntry()->releaseRequest();
     http->storeEntry()->buffer();
     HttpReply *rep = new HttpReply;
-    rep->setHeaders(HTTP_OK, NULL, "text/plain", http->request->prefixLen(), 0, squid_curtime);
+    rep->setHeaders(Http::scOkay, NULL, "text/plain", http->request->prefixLen(), 0, squid_curtime);
     http->storeEntry()->replaceHttpReply(rep);
     http->request->swapOut(http->storeEntry());
     http->storeEntry()->complete();
 }
 
 #define SENDING_BODY 0
@@ -1246,27 +1228,27 @@
  * status codes, and then supply a default ruleset that puts these
  * codes before any user defines access entries. That way the user
  * can choose to block these responses where appropriate, but won't get
  * mysterious breakages.
  */
 bool
-clientReplyContext::alwaysAllowResponse(http_status sline) const
+clientReplyContext::alwaysAllowResponse(Http::StatusCode sline) const
 {
     bool result;
 
     switch (sline) {
 
-    case HTTP_CONTINUE:
+    case Http::scContinue:
 
-    case HTTP_SWITCHING_PROTOCOLS:
+    case Http::scSwitchingProtocols:
 
-    case HTTP_PROCESSING:
+    case Http::scProcessing:
 
-    case HTTP_NO_CONTENT:
+    case Http::scNoContent:
 
-    case HTTP_NOT_MODIFIED:
+    case Http::scNotModified:
         result = true;
         break;
 
     default:
         result = false;
     }
@@ -1319,21 +1301,12 @@
         hdr->delById(HDR_AGE);
         /*
          * This adds the calculated object age. Note that the details of the
          * age calculation is performed by adjusting the timestamp in
          * StoreEntry::timestampsSet(), not here.
          */
-#if DEAD_CODE
-        // XXX: realy useless? or is there a bug now that this is detatched from the below if-sequence ?
-        // looks like this pre-if was supposed to be the browser workaround...
-        if (NULL == http->storeEntry())
-            (void) 0;
-        else if (http->storeEntry()->timestamp < 0)
-            (void) 0;
-#endif
-
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
             hdr->delById(HDR_DATE);
             hdr->insertTime(HDR_DATE, squid_curtime);
         } else if (http->getConn() && http->getConn()->port->actAsOrigin) {
             // Swap the Date: header to current time if we are simulating an origin
             HttpHeaderEntry *h = hdr->findEntry(HDR_DATE);
@@ -1347,13 +1320,13 @@
                 hdr->delById(HDR_EXPIRES);
                 hdr->insertTime(HDR_EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
             }
             if (http->storeEntry()->timestamp <= squid_curtime) {
                 // put X-Cache-Age: instead of Age:
                 char age[64];
-                snprintf(age, sizeof(age), "%ld", (long int) squid_curtime - http->storeEntry()->timestamp);
+                snprintf(age, sizeof(age), "%" PRId64, static_cast<int64_t>(squid_curtime - http->storeEntry()->timestamp));
                 hdr->putExt("X-Cache-Age", age);
             }
         } else if (http->storeEntry()->timestamp <= squid_curtime) {
             hdr->putInt(HDR_AGE,
                         squid_curtime - http->storeEntry()->timestamp);
             /* Signal old objects.  NB: rfc 2616 is not clear,
@@ -1421,17 +1394,17 @@
                         (strncasecmp(value, "Kerberos", 8) == 0 &&
                          (value[8] == '\0' || value[8] == ' '))) {
                     if (request->flags.connectionAuthDisabled) {
                         hdr->delAt(pos, connection_auth_blocked);
                         continue;
                     }
-                    request->flags.mustKeepalive = 1;
+                    request->flags.mustKeepalive = true;
                     if (!request->flags.accelerated && !request->flags.intercepted) {
                         httpHeaderPutStrf(hdr, HDR_PROXY_SUPPORT, "Session-Based-Authentication");
                         /*
-                          We send "[Proxy-]Connection: Proxy-Support" header to mark
+                          We send "Connection: Proxy-Support" header to mark
                           Proxy-Support as a hop-by-hop header for intermediaries that do not
                           understand the semantics of this header. The RFC should have included
                           this recommendation.
                         */
                         httpHeaderPutStrf(hdr, HDR_CONNECTION, "Proxy-support");
                     }
@@ -1444,14 +1417,14 @@
             hdr->refreshMask();
     }
 
 #if USE_AUTH
     /* Handle authentication headers */
     if (http->logType == LOG_TCP_DENIED &&
-            ( reply->sline.status == HTTP_PROXY_AUTHENTICATION_REQUIRED ||
-              reply->sline.status == HTTP_UNAUTHORIZED)
+            ( reply->sline.status() == Http::scProxyAuthenticationRequired ||
+              reply->sline.status() == Http::scUnauthorized)
        ) {
         /* Add authentication header */
         /*! \todo alter errorstate to be accel on|off aware. The 0 on the next line
          * depends on authenticate behaviour: all schemes to date send no extra
          * data on 407/401 responses, and do not check the accel state on 401/407
          * responses
@@ -1472,49 +1445,49 @@
                       getMyHostname(), getMyPort());
 
 #endif
 
     const bool maySendChunkedReply = !request->multipartRangeRequest() &&
                                      reply->sline.protocol == AnyP::PROTO_HTTP && // response is HTTP
-                                     (request->http_ver >= HttpVersion(1, 1));
+                                     (request->http_ver >= Http::ProtocolVersion(1, 1));
 
     /* Check whether we should send keep-alive */
-    if (!Config.onoff.error_pconns && reply->sline.status >= 400 && !request->flags.mustKeepalive) {
+    if (!Config.onoff.error_pconns && reply->sline.status() >= 400 && !request->flags.mustKeepalive) {
         debugs(33, 3, "clientBuildReplyHeader: Error, don't keep-alive");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (!Config.onoff.client_pconns && !request->flags.mustKeepalive) {
         debugs(33, 2, "clientBuildReplyHeader: Connection Keep-Alive not requested by admin or client");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (request->flags.proxyKeepalive && shutting_down) {
         debugs(88, 3, "clientBuildReplyHeader: Shutting down, don't keep-alive.");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (request->flags.connectionAuth && !reply->keep_alive) {
         debugs(33, 2, "clientBuildReplyHeader: Connection oriented auth but server side non-persistent");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (reply->bodySize(request->method) < 0 && !maySendChunkedReply) {
         debugs(88, 3, "clientBuildReplyHeader: can't keep-alive, unknown body size" );
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (fdUsageHigh()&& !request->flags.mustKeepalive) {
         debugs(88, 3, "clientBuildReplyHeader: Not many unused FDs, can't keep-alive");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (request->flags.sslBumped && !reply->persistent()) {
         // We do not really have to close, but we pretend we are a tunnel.
         debugs(88, 3, "clientBuildReplyHeader: bumped reply forces close");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     } else if (request->pinnedConnection() && !reply->persistent()) {
         // The peer wants to close the pinned connection
         debugs(88, 3, "pinned reply forces close");
-        request->flags.proxyKeepalive = 0;
+        request->flags.proxyKeepalive = false;
     }
 
     // Decide if we send chunked reply
     if (maySendChunkedReply &&
             request->flags.proxyKeepalive &&
             reply->bodySize(request->method) < 0) {
         debugs(88, 3, "clientBuildReplyHeader: chunked reply");
-        request->flags.chunkedReply = 1;
+        request->flags.chunkedReply = true;
         hdr->putStr(HDR_TRANSFER_ENCODING, "chunked");
     }
 
     /* Append VIA */
     if (Config.onoff.via) {
         LOCAL_ARRAY(char, bbuf, MAX_URL + 32);
@@ -1556,19 +1529,18 @@
 
 void
 clientReplyContext::cloneReply()
 {
     assert(reply == NULL);
 
-    HttpReply *rep = http->storeEntry()->getReply()->clone();
-
-    reply = HTTPMSGLOCK(rep);
+    reply = http->storeEntry()->getReply()->clone();
+    HTTPMSGLOCK(reply);
 
     if (reply->sline.protocol == AnyP::PROTO_HTTP) {
         /* RFC 2616 requires us to advertise our 1.1 version (but only on real HTTP traffic) */
-        reply->sline.version = HttpVersion(1,1);
+        reply->sline.version = Http::ProtocolVersion(1,1);
     }
 
     /* do header conversions */
     buildReplyHeader();
 }
 
@@ -1719,20 +1691,20 @@
 
         storeClientCopy(context->sc, http->storeEntry(),
                         tempBuffer, clientReplyContext::SendMoreData, context);
         return;
     }
 
-    if (context->http->request->method == METHOD_PURGE) {
+    if (context->http->request->method == Http::METHOD_PURGE) {
         context->purgeRequest();
         return;
     }
 
     // OPTIONS with Max-Forwards:0 handled in clientProcessRequest()
 
-    if (context->http->request->method == METHOD_TRACE) {
+    if (context->http->request->method == Http::METHOD_TRACE) {
         if (context->http->request->header.getInt64(HDR_MAX_FORWARDS) == 0) {
             context->traceReply(aNode);
             return;
         }
 
         /* continue forwarding, not finished yet. */
@@ -1758,14 +1730,19 @@
              * This if-block exists because we don't want to clobber
              * a preexiting mem_obj->method value if the mem_obj
              * already exists.  For example, when a HEAD request
              * is a cache hit for a GET response, we want to keep
              * the method as GET.
              */
-            http->storeEntry()->createMemObject(http->uri, http->log_uri);
+            http->storeEntry()->createMemObject(storeId(), http->log_uri);
             http->storeEntry()->mem_obj->method = http->request->method;
+            /**
+             * Here we can see if the object was
+             * created using URL or alternative StoreID from helper.
+             */
+            debugs(88, 3, "mem_obj->url: " << http->storeEntry()->mem_obj->url);
         }
 
         sc = storeClientListAdd(http->storeEntry(), this);
 #if USE_DELAY_POOLS
         sc->setDelayId(DelayId::DelayClient(http));
 #endif
@@ -1838,13 +1815,13 @@
      * We call into the stream, because we don't know that there is a
      * client socket!
      */
     debugs(88, 5, "clientReplyContext::sendStreamError: A stream error has occured, marking as complete and sending no data.");
     StoreIOBuffer localTempBuffer;
     flags.complete = 1;
-    http->request->flags.streamError = 1;
+    http->request->flags.streamError = true;
     localTempBuffer.flags.error = result.flags.error;
     clientStreamCallback((clientStreamNode*)http->client_stream.head->data, http, NULL,
                          localTempBuffer);
 }
 
 void
@@ -1876,15 +1853,15 @@
 }
 
 void
 clientReplyContext::sendBodyTooLargeError()
 {
     Ip::Address tmp_noaddr;
-    tmp_noaddr.SetNoAddr(); // TODO: make a global const
+    tmp_noaddr.setNoAddr(); // TODO: make a global const
     http->logType = LOG_TCP_DENIED_REPLY;
-    ErrorState *err = clientBuildError(ERR_TOO_BIG, HTTP_FORBIDDEN, NULL,
+    ErrorState *err = clientBuildError(ERR_TOO_BIG, Http::scForbidden, NULL,
                                        http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmp_noaddr,
                                        http->request);
     removeClientStoreReference(&(sc), http);
     HTTPMSGUNLOCK(reply);
     startError(err);
 
@@ -1893,13 +1870,13 @@
 /// send 412 (Precondition Failed) to client
 void
 clientReplyContext::sendPreconditionFailedError()
 {
     http->logType = LOG_TCP_HIT;
     ErrorState *const err =
-        clientBuildError(ERR_PRECONDITION_FAILED, HTTP_PRECONDITION_FAILED,
+        clientBuildError(ERR_PRECONDITION_FAILED, Http::scPreconditionFailed,
                          NULL, http->getConn()->clientConnection->remote, http->request);
     removeClientStoreReference(&sc, http);
     HTTPMSGUNLOCK(reply);
     startError(err);
 }
 
@@ -1930,14 +1907,14 @@
 
 /// send 304 (Not Modified) or 412 (Precondition Failed) to client
 /// depending on request method
 void
 clientReplyContext::sendNotModifiedOrPreconditionFailedError()
 {
-    if (http->request->method == METHOD_GET ||
-            http->request->method == METHOD_HEAD)
+    if (http->request->method == Http::METHOD_GET ||
+            http->request->method == Http::METHOD_HEAD)
         sendNotModified();
     else
         sendPreconditionFailedError();
 }
 
 void
@@ -1946,13 +1923,13 @@
     /* NP: this should probably soft-fail to a zero-sized-reply error ?? */
     assert(reply);
 
     /** Don't block our own responses or HTTP status messages */
     if (http->logType == LOG_TCP_DENIED ||
             http->logType == LOG_TCP_DENIED_REPLY ||
-            alwaysAllowResponse(reply->sline.status)) {
+            alwaysAllowResponse(reply->sline.status())) {
         headers_sz = reply->hdr_sz;
         processReplyAccessResult(ACCESS_ALLOWED);
         return;
     }
 
     /** Check for reply to big error */
@@ -1969,13 +1946,14 @@
         return;
     }
 
     /** Process http_reply_access lists */
     ACLFilledChecklist *replyChecklist =
         clientAclChecklistCreate(Config.accessList.reply, http);
-    replyChecklist->reply = HTTPMSGLOCK(reply);
+    replyChecklist->reply = reply;
+    HTTPMSGLOCK(replyChecklist->reply);
     replyChecklist->nonBlockingCheck(ProcessReplyAccessResult, this);
 }
 
 void
 clientReplyContext::ProcessReplyAccessResult(allow_t rv, void *voidMe)
 {
@@ -1998,14 +1976,14 @@
         http->logType = LOG_TCP_DENIED_REPLY;
 
         if (page_id == ERR_NONE)
             page_id = ERR_ACCESS_DENIED;
 
         Ip::Address tmp_noaddr;
-        tmp_noaddr.SetNoAddr();
-        err = clientBuildError(page_id, HTTP_FORBIDDEN, NULL,
+        tmp_noaddr.setNoAddr();
+        err = clientBuildError(page_id, Http::scForbidden, NULL,
                                http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmp_noaddr,
                                http->request);
 
         removeClientStoreReference(&sc, http);
 
         HTTPMSGUNLOCK(reply);
@@ -2027,26 +2005,26 @@
     debugs(88, 3, "clientReplyContext::sendMoreData: Appending " <<
            (int) body_size << " bytes after " << reply->hdr_sz <<
            " bytes of headers");
 
 #if USE_SQUID_ESI
 
-    if (http->flags.accel && reply->sline.status != HTTP_FORBIDDEN &&
-            !alwaysAllowResponse(reply->sline.status) &&
+    if (http->flags.accel && reply->sline.status() != Http::scForbidden &&
+            !alwaysAllowResponse(reply->sline.status()) &&
             esiEnableProcessing(reply)) {
         debugs(88, 2, "Enabling ESI processing for " << http->uri);
         clientStreamInsertHead(&http->client_stream, esiStreamRead,
                                esiProcessStream, esiStreamDetach, esiStreamStatus, NULL);
     }
 
 #endif
 
-    if (http->request->method == METHOD_HEAD) {
+    if (http->request->method == Http::METHOD_HEAD) {
         /* do not forward body for HEAD replies */
         body_size = 0;
-        http->flags.done_copying = 1;
+        http->flags.done_copying = true;
         flags.complete = 1;
     }
 
     assert (!flags.headersSent);
     flags.headersSent = true;
 
@@ -2187,16 +2165,18 @@
     assert(http != NULL);
     /*
      * For erroneous requests, we might not have a h->request,
      * so make a fake one.
      */
 
-    if (http->request == NULL)
-        http->request = HTTPMSGLOCK(new HttpRequest(m, AnyP::PROTO_NONE, null_string));
+    if (http->request == NULL) {
+        http->request = new HttpRequest(m, AnyP::PROTO_NONE, null_string);
+        HTTPMSGLOCK(http->request);
+    }
 
-    StoreEntry *e = storeCreateEntry(http->uri, http->log_uri, reqFlags, m);
+    StoreEntry *e = storeCreateEntry(storeId(), http->log_uri, reqFlags, m);
 
     sc = storeClientListAdd(e, this);
 
 #if USE_DELAY_POOLS
     sc->setDelayId(DelayId::DelayClient(http));
 #endif
@@ -2221,13 +2201,13 @@
      * this function CAN NOT be used to manage errors
      */
     http->storeEntry(e);
 }
 
 ErrorState *
-clientBuildError(err_type page_id, http_status status, char const *url,
+clientBuildError(err_type page_id, Http::StatusCode status, char const *url,
                  Ip::Address &src_addr, HttpRequest * request)
 {
     ErrorState *err = new ErrorState(page_id, status, request);
     err->src_addr = src_addr;
 
     if (url)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side_reply.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side_reply.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side_reply.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side_reply.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,29 +29,24 @@
  */
 
 #ifndef SQUID_CLIENTSIDEREPLY_H
 #define SQUID_CLIENTSIDEREPLY_H
 
 #include "client_side_request.h"
-#include "clientStream.h"
-#include "HttpHeader.h"
-#include "RefCount.h"
+#include "ip/forward.h"
 #include "RequestFlags.h"
 #include "StoreClient.h"
 
 class ErrorState;
-#include "ip/forward.h"
 
 /* XXX make static method */
 
 class clientReplyContext : public RefCountable, public StoreClient
 {
 
 public:
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
     static STCB CacheHit;
     static STCB HandleIMSReply;
     static STCB SendMoreData;
 
     clientReplyContext(ClientHttpRequest *);
     ~clientReplyContext();
@@ -72,13 +67,13 @@
     void identifyFoundObject(StoreEntry *entry);
     int storeOKTransferDone() const;
     int storeNotOKTransferDone() const;
     /// replaces current response store entry with the given one
     void setReplyToStoreEntry(StoreEntry *e, const char *reason);
     /// builds error using clientBuildError() and calls setReplyToError() below
-    void setReplyToError(err_type, http_status, const HttpRequestMethod&, char const *, Ip::Address &, HttpRequest *, const char *,
+    void setReplyToError(err_type, Http::StatusCode, const HttpRequestMethod&, char const *, Ip::Address &, HttpRequest *, const char *,
 #if USE_AUTH
                          Auth::UserRequest::Pointer);
 #else
                          void * unused);
 #endif
     /// creates a store entry for the reply and appends err to it
@@ -88,14 +83,15 @@
     void removeClientStoreReference(store_client **scp, ClientHttpRequest *http);
     void startError(ErrorState * err);
     void processExpired();
     clientStream_status_t replyStatus();
     void processMiss();
     void traceReply(clientStreamNode * node);
+    const char *storeId() const { return (http->store_id.size() > 0 ? http->store_id.termedBuf() : http->uri); }
 
-    http_status purgeStatus;
+    Http::StatusCode purgeStatus;
 
     /* state variable - replace with class to handle storeentries at some point */
     int lookingforstore;
     virtual void created (StoreEntry *newEntry);
 
     ClientHttpRequest *http;
@@ -131,13 +127,13 @@
     HttpReply *reply;
     void processReplyAccess();
     static ACLCB ProcessReplyAccessResult;
     void processReplyAccessResult(const allow_t &accessAllowed);
     void cloneReply();
     void buildReplyHeader ();
-    bool alwaysAllowResponse(http_status sline) const;
+    bool alwaysAllowResponse(Http::StatusCode sline) const;
     int checkTransferDone();
     void processOnlyIfCachedMiss();
     void processConditional(StoreIOBuffer &result);
     void cacheHit(StoreIOBuffer result);
     void handleIMSReply(StoreIOBuffer result);
     void sendMoreData(StoreIOBuffer result);
@@ -151,10 +147,10 @@
     void sendNotModifiedOrPreconditionFailedError();
 
     StoreEntry *old_entry;
     store_client *old_sc;	/* ... for entry to be validated */
     bool deleting;
 
-    CBDATA_CLASS(clientReplyContext);
+    CBDATA_CLASS2(clientReplyContext);
 };
 
 #endif /* SQUID_CLIENTSIDEREPLY_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side_request.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side_request.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side_request.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side_request.cc	2015-05-01 18:05:19.000000000 +0800
@@ -54,22 +54,24 @@
 #include "err_detail_type.h"
 #include "errorpage.h"
 #include "fd.h"
 #include "fde.h"
 #include "format/Token.h"
 #include "gopher.h"
+#include "helper.h"
 #include "http.h"
 #include "HttpHdrCc.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
 #include "ip/QosConfig.h"
 #include "log/access_log.h"
 #include "MemObject.h"
 #include "Parsing.h"
 #include "profiler/Profiler.h"
+#include "redirect.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StrList.h"
 #include "tools.h"
 #include "URL.h"
@@ -98,41 +100,26 @@
 static const char *const crlf = "\r\n";
 
 #if FOLLOW_X_FORWARDED_FOR
 static void clientFollowXForwardedForCheck(allow_t answer, void *data);
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
-ErrorState *clientBuildError(err_type, http_status, char const *url, Ip::Address &, HttpRequest *);
+ErrorState *clientBuildError(err_type, Http::StatusCode, char const *url, Ip::Address &, HttpRequest *);
 
 CBDATA_CLASS_INIT(ClientRequestContext);
 
-void *
-ClientRequestContext::operator new (size_t size)
-{
-    assert (size == sizeof(ClientRequestContext));
-    CBDATA_INIT_TYPE(ClientRequestContext);
-    ClientRequestContext *result = cbdataAlloc(ClientRequestContext);
-    return result;
-}
-
-void
-ClientRequestContext::operator delete (void *address)
-{
-    ClientRequestContext *t = static_cast<ClientRequestContext *>(address);
-    cbdataFree(t);
-}
-
 /* Local functions */
 /* other */
 static void clientAccessCheckDoneWrapper(allow_t, void *);
 #if USE_SSL
 static void sslBumpAccessCheckDoneWrapper(allow_t, void *);
 #endif
 static int clientHierarchical(ClientHttpRequest * http);
 static void clientInterpretRequestHeaders(ClientHttpRequest * http);
-static RH clientRedirectDoneWrapper;
+static HLPCB clientRedirectDoneWrapper;
+static HLPCB clientStoreIdDoneWrapper;
 static void checkNoCacheDoneWrapper(allow_t, void *);
 SQUIDCEXTERN CSR clientGetMoreData;
 SQUIDCEXTERN CSS clientReplyStatus;
 SQUIDCEXTERN CSD clientReplyDetach;
 static void checkFailureRatio(err_type, hier_code);
 
@@ -147,42 +134,29 @@
         cbdataReferenceDone(http);
 
     delete error;
     debugs(85,3, HERE << this << " ClientRequestContext destructed");
 }
 
-ClientRequestContext::ClientRequestContext(ClientHttpRequest *anHttp) : http(cbdataReference(anHttp)), acl_checklist (NULL), redirect_state (REDIRECT_NONE), error(NULL), readNextRequest(false)
+ClientRequestContext::ClientRequestContext(ClientHttpRequest *anHttp) : http(cbdataReference(anHttp)), acl_checklist (NULL), redirect_state (REDIRECT_NONE), store_id_state(REDIRECT_NONE),error(NULL), readNextRequest(false)
 {
     http_access_done = false;
     redirect_done = false;
+    redirect_fail_count = 0;
+    store_id_done = false;
+    store_id_fail_count = 0;
     no_cache_done = false;
     interpreted_req_hdrs = false;
 #if USE_SSL
     sslBumpCheckDone = false;
 #endif
     debugs(85,3, HERE << this << " ClientRequestContext constructed");
 }
 
 CBDATA_CLASS_INIT(ClientHttpRequest);
 
-void *
-ClientHttpRequest::operator new (size_t size)
-{
-    assert (size == sizeof (ClientHttpRequest));
-    CBDATA_INIT_TYPE(ClientHttpRequest);
-    ClientHttpRequest *result = cbdataAlloc(ClientHttpRequest);
-    return result;
-}
-
-void
-ClientHttpRequest::operator delete (void *address)
-{
-    ClientHttpRequest *t = static_cast<ClientHttpRequest *>(address);
-    cbdataFree(t);
-}
-
 ClientHttpRequest::ClientHttpRequest(ConnStateData * aConn) :
 #if USE_ADAPTATION
         AsyncJob("ClientHttpRequest"),
 #endif
         loggingEntry_(NULL)
 {
@@ -358,13 +332,13 @@
                      clientReplyStatus, new clientReplyContext(http), streamcallback,
                      streamdetach, streamdata, tempBuffer);
     /* make it visible in the 'current acctive requests list' */
     /* Set flags */
     /* internal requests only makes sense in an
      * accelerator today. TODO: accept flags ? */
-    http->flags.accel = 1;
+    http->flags.accel = true;
     /* allow size for url rewriting */
     url_sz = strlen(url) + Config.appendDomainLen + 5;
     http->uri = (char *)xcalloc(url_sz, 1);
     strcpy(http->uri, url);
 
     if ((request = HttpRequest::CreateFromUrlAndMethod(http->uri, method)) == NULL) {
@@ -386,40 +360,40 @@
 
     /*
      * build new header list *? TODO
      */
     request->flags.accelerated = http->flags.accel;
 
-    request->flags.internalClient = 1;
+    request->flags.internalClient = true;
 
     /* this is an internally created
      * request, not subject to acceleration
      * target overrides */
     /*
      * FIXME? Do we want to detect and handle internal requests of internal
      * objects ?
      */
 
     /* Internally created requests cannot have bodies today */
     request->content_length = 0;
 
-    request->client_addr.SetNoAddr();
+    request->client_addr.setNoAddr();
 
 #if FOLLOW_X_FORWARDED_FOR
-    request->indirect_client_addr.SetNoAddr();
+    request->indirect_client_addr.setNoAddr();
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
-    request->my_addr.SetNoAddr();	/* undefined for internal requests */
+    request->my_addr.setNoAddr();	/* undefined for internal requests */
 
-    request->my_addr.SetPort(0);
+    request->my_addr.port(0);
 
     /* Our version is HTTP/1.1 */
-    HttpVersion http_ver(1,1);
-    request->http_ver = http_ver;
+    request->http_ver = Http::ProtocolVersion(1,1);
 
-    http->request = HTTPMSGLOCK(request);
+    http->request = request;
+    HTTPMSGLOCK(http->request);
 
     /* optional - skip the access check ? */
     http->calloutContext = new ClientRequestContext(http);
 
     http->calloutContext->http_access_done = false;
 
@@ -531,13 +505,13 @@
         * instead of the direct client.
         */
         ConnStateData *conn = http->getConn();
         conn->log_addr = request->indirect_client_addr;
     }
     request->x_forwarded_for_iterator.clean();
-    request->flags.done_follow_x_forwarded_for=true;
+    request->flags.done_follow_x_forwarded_for = true;
 
     if (answer != ACCESS_ALLOWED && answer != ACCESS_DENIED) {
         debugs(28, DBG_CRITICAL, "ERROR: Processing X-Forwarded-For. Stopping at IP address: " << request->indirect_client_addr );
     }
 
     /* process actual access ACL as normal. */
@@ -562,13 +536,13 @@
 
     if (ia != NULL && ia->count > 0) {
         // Is the NAT destination IP in DNS?
         for (int i = 0; i < ia->count; ++i) {
             if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                 debugs(85, 3, HERE << "validate IP " << clientConn->local << " possible from Host:");
-                http->request->flags.hostVerified = 1;
+                http->request->flags.hostVerified = true;
                 http->doCallouts();
                 return;
             }
             debugs(85, 3, HERE << "validate IP " << clientConn->local << " non-match from Host: IP " << ia->in_addrs[i]);
         }
     }
@@ -578,21 +552,21 @@
 
 void
 ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
 {
     // IP address validation for Host: failed. Admin wants to ignore them.
     // NP: we do not yet handle CONNECT tunnels well, so ignore for them
-    if (!Config.onoff.hostStrictVerify && http->request->method != METHOD_CONNECT) {
+    if (!Config.onoff.hostStrictVerify && http->request->method != Http::METHOD_CONNECT) {
         debugs(85, 3, "SECURITY ALERT: Host header forgery detected on " << http->getConn()->clientConnection <<
                " (" << A << " does not match " << B << ") on URL: " << urlCanonical(http->request));
 
         // NP: it is tempting to use 'flags.noCache' but that is all about READing cache data.
         // The problems here are about WRITE for new cache content, which means flags.cachable
-        http->request->flags.cachable = 0; // MUST NOT cache (for now)
+        http->request->flags.cachable = false; // MUST NOT cache (for now)
         // XXX: when we have updated the cache key to base on raw-IP + URI this cacheable limit can go.
-        http->request->flags.hierarchical = 0; // MUST NOT pass to peers (for now)
+        http->request->flags.hierarchical = false; // MUST NOT pass to peers (for now)
         // XXX: when we have sorted out the best way to relay requests properly to peers this hierarchical limit can go.
         http->doCallouts();
         return;
     }
 
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: Host header forgery detected on " <<
@@ -601,20 +575,20 @@
     debugs(85, DBG_IMPORTANT, "SECURITY ALERT: on URL: " << urlCanonical(http->request));
 
     // IP address validation for Host: failed. reject the connection.
     clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->prev->data;
     clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
     assert (repContext);
-    repContext->setReplyToError(ERR_CONFLICT_HOST, HTTP_CONFLICT,
+    repContext->setReplyToError(ERR_CONFLICT_HOST, Http::scConflict,
                                 http->request->method, NULL,
                                 http->getConn()->clientConnection->remote,
                                 http->request,
                                 NULL,
 #if USE_AUTH
-                                http->getConn() != NULL && http->getConn()->auth_user_request != NULL ?
-                                http->getConn()->auth_user_request : http->request->auth_user_request);
+                                http->getConn() != NULL && http->getConn()->getAuth() != NULL ?
+                                http->getConn()->getAuth() : http->request->auth_user_request);
 #else
                                 NULL);
 #endif
     node = (clientStreamNode *)http->client_stream.tail->data;
     clientStreamRead(node, http, node->readBuffer);
 }
@@ -669,16 +643,16 @@
             } else
                 port = (ret & 0xFFFF);
         }
     }
 
     debugs(85, 3, HERE << "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
-    if (http->request->flags.intercepted || http->request->flags.spoofClientIp) {
+    if (http->request->flags.intercepted || http->request->flags.interceptTproxy) {
         // verify the Host: port (if any) matches the apparent destination
-        if (portStr && port != http->getConn()->clientConnection->local.GetPort()) {
-            debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.GetPort() <<
+        if (portStr && port != http->getConn()->clientConnection->local.port()) {
+            debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.port() <<
                    " matches Host: port " << port << " (" << portStr << ")");
             hostHeaderVerifyFailed("intercepted port", portStr);
         } else {
             // XXX: match the scheme default port against the apparent destination
 
             // verify the destination DNS is one of the Host: headers IPs
@@ -696,21 +670,21 @@
         debugs(85, 3, HERE << "FAIL on validate URL domain " << http->request->GetHost() << " matches Host: " << host);
         hostHeaderVerifyFailed(host, http->request->GetHost());
     } else if (portStr && port != http->request->port) {
         // Verify forward-proxy requested URL domain matches the Host: header
         debugs(85, 3, HERE << "FAIL on validate URL port " << http->request->port << " matches Host: port " << portStr);
         hostHeaderVerifyFailed("URL port", portStr);
-    } else if (!portStr && http->request->method != METHOD_CONNECT && http->request->port != urlDefaultPort(http->request->protocol)) {
+    } else if (!portStr && http->request->method != Http::METHOD_CONNECT && http->request->port != urlDefaultPort(http->request->protocol)) {
         // Verify forward-proxy requested URL domain matches the Host: header
         // Special case: we don't have a default-port to check for CONNECT. Assume URL is correct.
         debugs(85, 3, HERE << "FAIL on validate URL port " << http->request->port << " matches Host: default port " << urlDefaultPort(http->request->protocol));
         hostHeaderVerifyFailed("URL port", "default port");
     } else {
         // Okay no problem.
         debugs(85, 3, HERE << "validate passed.");
-        http->request->flags.hostVerified = 1;
+        http->request->flags.hostVerified = true;
         http->doCallouts();
     }
     safe_free(hostB);
 }
 
 /* This is the entry point for external users of the client_side routines */
@@ -721,13 +695,13 @@
     if (!http->request->flags.doneFollowXff() &&
             Config.accessList.followXFF &&
             http->request->header.has(HDR_X_FORWARDED_FOR)) {
 
         /* we always trust the direct client address for actual use */
         http->request->indirect_client_addr = http->request->client_addr;
-        http->request->indirect_client_addr.SetPort(0);
+        http->request->indirect_client_addr.port(0);
 
         /* setup the XFF iterator for processing */
         http->request->x_forwarded_for_iterator = http->request->header.getList(HDR_X_FORWARDED_FOR);
 
         /* begin by checking to see if we trust direct client enough to walk XFF */
         acl_checklist = clientAclChecklistCreate(Config.accessList.followXFF, http);
@@ -775,23 +749,22 @@
 
 void
 ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
 {
     acl_checklist = NULL;
     err_type page_id;
-    http_status status;
+    Http::StatusCode status;
     debugs(85, 2, "The request " <<
            RequestMethodStr(http->request->method) << " " <<
            http->uri << " is " << answer <<
-           ", because it matched '" <<
-           (AclMatchedName ? AclMatchedName : "NO ACL's") << "'" );
+           "; last ACL checked: " << (AclMatchedName ? AclMatchedName : "[none]"));
 
 #if USE_AUTH
     char const *proxy_auth_msg = "<null>";
-    if (http->getConn() != NULL && http->getConn()->auth_user_request != NULL)
-        proxy_auth_msg = http->getConn()->auth_user_request->denyMessage("<null>");
+    if (http->getConn() != NULL && http->getConn()->getAuth() != NULL)
+        proxy_auth_msg = http->getConn()->getAuth()->denyMessage("<null>");
     else if (http->request->auth_user_request != NULL)
         proxy_auth_msg = http->request->auth_user_request->denyMessage("<null>");
 #endif
 
     if (answer != ACCESS_ALLOWED) {
         // auth has a grace period where credentials can be expired but okay not to challenge.
@@ -817,45 +790,45 @@
         http->logType = LOG_TCP_DENIED;
 
         if (auth_challenge) {
 #if USE_AUTH
             if (http->request->flags.sslBumped) {
                 /*SSL Bumped request, authentication is not possible*/
-                status = HTTP_FORBIDDEN;
+                status = Http::scForbidden;
             } else if (!http->flags.accel) {
                 /* Proxy authorisation needed */
-                status = HTTP_PROXY_AUTHENTICATION_REQUIRED;
+                status = Http::scProxyAuthenticationRequired;
             } else {
                 /* WWW authorisation needed */
-                status = HTTP_UNAUTHORIZED;
+                status = Http::scUnauthorized;
             }
 #else
             // need auth, but not possible to do.
-            status = HTTP_FORBIDDEN;
+            status = Http::scForbidden;
 #endif
             if (page_id == ERR_NONE)
                 page_id = ERR_CACHE_ACCESS_DENIED;
         } else {
-            status = HTTP_FORBIDDEN;
+            status = Http::scForbidden;
 
             if (page_id == ERR_NONE)
                 page_id = ERR_ACCESS_DENIED;
         }
 
         Ip::Address tmpnoaddr;
-        tmpnoaddr.SetNoAddr();
+        tmpnoaddr.setNoAddr();
         error = clientBuildError(page_id, status,
                                  NULL,
                                  http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmpnoaddr,
                                  http->request
                                 );
 
 #if USE_AUTH
         error->auth_user_request =
-            http->getConn() != NULL && http->getConn()->auth_user_request != NULL ?
-            http->getConn()->auth_user_request : http->request->auth_user_request;
+            http->getConn() != NULL && http->getConn()->getAuth() != NULL ?
+            http->getConn()->getAuth() : http->request->auth_user_request;
 #endif
 
         readNextRequest = true;
     }
 
     /* ACCESS_ALLOWED continues here ... */
@@ -905,14 +878,17 @@
     ClientRequestContext *context = (ClientRequestContext *)data;
     ClientHttpRequest *http = context->http;
     context->acl_checklist = NULL;
 
     if (answer == ACCESS_ALLOWED)
         redirectStart(http, clientRedirectDoneWrapper, context);
-    else
-        context->clientRedirectDone(NULL);
+    else {
+        HelperReply nilReply;
+        nilReply.result = HelperReply::Error;
+        context->clientRedirectDone(nilReply);
+    }
 }
 
 void
 ClientRequestContext::clientRedirectStart()
 {
     debugs(33, 5, HERE << "'" << http->uri << "'");
@@ -921,22 +897,60 @@
         acl_checklist = clientAclChecklistCreate(Config.accessList.redirector, http);
         acl_checklist->nonBlockingCheck(clientRedirectAccessCheckDone, this);
     } else
         redirectStart(http, clientRedirectDoneWrapper, this);
 }
 
+/**
+ * This methods handles Access checks result of StoreId access list.
+ * Will handle as "ERR" (no change) in a case Access is not allowed.
+ */
+static void
+clientStoreIdAccessCheckDone(allow_t answer, void *data)
+{
+    ClientRequestContext *context = static_cast<ClientRequestContext *>(data);
+    ClientHttpRequest *http = context->http;
+    context->acl_checklist = NULL;
+
+    if (answer == ACCESS_ALLOWED)
+        storeIdStart(http, clientStoreIdDoneWrapper, context);
+    else {
+        debugs(85, 3, "access denied expected ERR reply handling: " << answer);
+        HelperReply nilReply;
+        nilReply.result = HelperReply::Error;
+        context->clientStoreIdDone(nilReply);
+    }
+}
+
+/**
+ * Start locating an alternative storeage ID string (if any) from admin
+ * configured helper program. This is an asynchronous operation terminating in
+ * ClientRequestContext::clientStoreIdDone() when completed.
+ */
+void
+ClientRequestContext::clientStoreIdStart()
+{
+    debugs(33, 5,"'" << http->uri << "'");
+
+    if (Config.accessList.store_id) {
+        acl_checklist = clientAclChecklistCreate(Config.accessList.store_id, http);
+        acl_checklist->nonBlockingCheck(clientStoreIdAccessCheckDone, this);
+    } else
+        storeIdStart(http, clientStoreIdDoneWrapper, this);
+}
+
 static int
 clientHierarchical(ClientHttpRequest * http)
 {
     const char *url = http->uri;
     HttpRequest *request = http->request;
     HttpRequestMethod method = request->method;
     const wordlist *p = NULL;
 
     // intercepted requests MUST NOT (yet) be sent to peers unless verified
-    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.spoofClientIp))
+    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))
         return 0;
 
     /*
      * IMS needs a private key, so we can use the hierarchy for IMS only if our
      * neighbors support private keys
      */
@@ -948,28 +962,28 @@
      * This is incorrect: authenticating requests can be sent via a hierarchy
      * (they can even be cached if the correct headers are set on the reply)
      */
     if (request->flags.auth)
         return 0;
 
-    if (method == METHOD_TRACE)
+    if (method == Http::METHOD_TRACE)
         return 1;
 
-    if (method != METHOD_GET)
+    if (method != Http::METHOD_GET)
         return 0;
 
     /* scan hierarchy_stoplist */
     for (p = Config.hierarchy_stoplist; p; p = p->next)
         if (strstr(url, p->key))
             return 0;
 
     if (request->flags.loopDetected)
         return 0;
 
     if (request->protocol == AnyP::PROTO_HTTP)
-        return httpCachable(method);
+        return method.respMaybeCacheable();
 
     if (request->protocol == AnyP::PROTO_GOPHER)
         return gopherCachable(request);
 
     if (request->protocol == AnyP::PROTO_CACHE_OBJECT)
         return 0;
@@ -991,16 +1005,16 @@
         return;
 
     request->flags.connectionAuthDisabled = http_conn->port->connection_auth_disabled;
     if (!request->flags.connectionAuthDisabled) {
         if (Comm::IsConnOpen(http_conn->pinning.serverConnection)) {
             if (http_conn->pinning.auth) {
-                request->flags.connectionAuth = 1;
-                request->flags.auth = 1;
+                request->flags.connectionAuth = true;
+                request->flags.auth = true;
             } else {
-                request->flags.connectionProxyAuth = 1;
+                request->flags.connectionProxyAuth = true;
             }
             // These should already be linked correctly.
             assert(request->clientConnectionManager == http_conn);
         }
     }
 
@@ -1020,16 +1034,16 @@
                     if (strncasecmp(value, "NTLM ", 5) == 0
                             ||
                             strncasecmp(value, "Negotiate ", 10) == 0
                             ||
                             strncasecmp(value, "Kerberos ", 9) == 0) {
                         if (e->id == HDR_AUTHORIZATION) {
-                            request->flags.connectionAuth = 1;
+                            request->flags.connectionAuth = true;
                             may_pin = 1;
                         } else {
-                            request->flags.connectionProxyAuth = 1;
+                            request->flags.connectionProxyAuth = true;
                             may_pin = 1;
                         }
                     }
                 }
             }
             if (may_pin && !request->pinnedConnection()) {
@@ -1049,13 +1063,13 @@
     const char *str;
 
     request->imslen = -1;
     request->ims = req_hdr->getTime(HDR_IF_MODIFIED_SINCE);
 
     if (request->ims > 0)
-        request->flags.ims = 1;
+        request->flags.ims = true;
 
     if (!request->flags.ignoreCc) {
         if (request->cache_control) {
             if (request->cache_control->hasNoCache())
                 no_cache=true;
 
@@ -1083,37 +1097,37 @@
                         no_cache=true;
                 }
             }
         }
     }
 
-    if (request->method == METHOD_OTHER) {
+    if (request->method == Http::METHOD_OTHER) {
         no_cache=true;
     }
 
     if (no_cache) {
 #if USE_HTTP_VIOLATIONS
 
         if (Config.onoff.reload_into_ims)
-            request->flags.nocacheHack = 1;
+            request->flags.nocacheHack = true;
         else if (refresh_nocache_hack)
-            request->flags.nocacheHack = 1;
+            request->flags.nocacheHack = true;
         else
 #endif
 
-            request->flags.noCache = 1;
+            request->flags.noCache = true;
     }
 
     /* ignore range header in non-GETs or non-HEADs */
-    if (request->method == METHOD_GET || request->method == METHOD_HEAD) {
+    if (request->method == Http::METHOD_GET || request->method == Http::METHOD_HEAD) {
         // XXX: initialize if we got here without HttpRequest::parseHeader()
         if (!request->range)
             request->range = req_hdr->getRange();
 
         if (request->range) {
-            request->flags.isRanged=true;
+            request->flags.isRanged = true;
             clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->data;
             /* XXX: This is suboptimal. We should give the stream the range set,
              * and thereby let the top of the stream set the offset when the
              * size becomes known. As it is, we will end up requesting from 0
              * for evey -X range specification.
              * RBC - this may be somewhat wrong. We should probably set the range
@@ -1132,31 +1146,31 @@
         req_hdr->delById(HDR_RANGE);
         req_hdr->delById(HDR_REQUEST_RANGE);
         request->ignoreRange("neither HEAD nor GET");
     }
 
     if (req_hdr->has(HDR_AUTHORIZATION))
-        request->flags.auth = 1;
+        request->flags.auth = true;
 
     clientCheckPinning(http);
 
     if (request->login[0] != '\0')
-        request->flags.auth = 1;
+        request->flags.auth = true;
 
     if (req_hdr->has(HDR_VIA)) {
         String s = req_hdr->getList(HDR_VIA);
         /*
          * ThisCache cannot be a member of Via header, "1.1 ThisCache" can.
          * Note ThisCache2 has a space prepended to the hostname so we don't
          * accidentally match super-domains.
          */
 
         if (strListIsSubstr(&s, ThisCache2, ',')) {
             debugObj(33, 1, "WARNING: Forwarding loop detected for:\n",
                      request, (ObjPackMethod) & httpRequestPack);
-            request->flags.loopDetected = 1;
+            request->flags.loopDetected = true;
         }
 
 #if USE_FORW_VIA_DB
         fvdbCountVia(s.termedBuf());
 
 #endif
@@ -1171,102 +1185,222 @@
         fvdbCountForw(s.termedBuf());
         s.clean();
     }
 
 #endif
 
-    request->flags.cachable = http->request->cacheable();
+    request->flags.cachable = http->request->maybeCacheable();
 
     if (clientHierarchical(http))
-        request->flags.hierarchical = 1;
+        request->flags.hierarchical = true;
 
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_NOCACHE = " <<
            (request->flags.noCache ? "SET" : "NOT SET"));
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_CACHABLE = " <<
            (request->flags.cachable ? "SET" : "NOT SET"));
     debugs(85, 5, "clientInterpretRequestHeaders: REQ_HIERARCHICAL = " <<
            (request->flags.hierarchical ? "SET" : "NOT SET"));
 
 }
 
 void
-clientRedirectDoneWrapper(void *data, char *result)
+clientRedirectDoneWrapper(void *data, const HelperReply &result)
 {
     ClientRequestContext *calloutContext = (ClientRequestContext *)data;
 
     if (!calloutContext->httpStateIsValid())
         return;
 
     calloutContext->clientRedirectDone(result);
 }
 
 void
-ClientRequestContext::clientRedirectDone(char *result)
+clientStoreIdDoneWrapper(void *data, const HelperReply &result)
+{
+    ClientRequestContext *calloutContext = (ClientRequestContext *)data;
+
+    if (!calloutContext->httpStateIsValid())
+        return;
+
+    calloutContext->clientStoreIdDone(result);
+}
+
+void
+ClientRequestContext::clientRedirectDone(const HelperReply &reply)
 {
     HttpRequest *old_request = http->request;
-    debugs(85, 5, "clientRedirectDone: '" << http->uri << "' result=" << (result ? result : "NULL"));
+    debugs(85, 5, HERE << "'" << http->uri << "' result=" << reply);
     assert(redirect_state == REDIRECT_PENDING);
     redirect_state = REDIRECT_DONE;
 
-    if (result) {
-        http_status status = (http_status) atoi(result);
+    // Put helper response Notes into the transaction state record (ALE) eventually
+    // do it early to ensure that no matter what the outcome the notes are present.
+    if (http->al != NULL) {
+        NotePairs &notes = SyncNotes(*http->al, *old_request);
+        notes.append(&reply.notes);
+    }
+
+    switch (reply.result) {
+    case HelperReply::Unknown:
+    case HelperReply::TT:
+        // Handler in redirect.cc should have already mapped Unknown
+        // IF it contained valid entry for the old URL-rewrite helper protocol
+        debugs(85, DBG_IMPORTANT, "ERROR: URL rewrite helper returned invalid result code. Wrong helper? " << reply);
+        break;
 
-        if (status == HTTP_MOVED_PERMANENTLY
-                || status == HTTP_MOVED_TEMPORARILY
-                || status == HTTP_SEE_OTHER
-                || status == HTTP_PERMANENT_REDIRECT
-                || status == HTTP_TEMPORARY_REDIRECT) {
-            char *t = result;
+    case HelperReply::BrokenHelper:
+        debugs(85, DBG_IMPORTANT, "ERROR: URL rewrite helper: " << reply << ", attempt #" << (redirect_fail_count+1) << " of 2");
+        if (redirect_fail_count < 2) { // XXX: make this configurable ?
+            ++redirect_fail_count;
+            // reset state flag to try redirector again from scratch.
+            redirect_done = false;
+        }
+        break;
 
-            if ((t = strchr(result, ':')) != NULL) {
+    case HelperReply::Error:
+        // no change to be done.
+        break;
+
+    case HelperReply::Okay: {
+        // #1: redirect with a specific status code    OK status=NNN url="..."
+        // #2: redirect with a default status code     OK url="..."
+        // #3: re-write the URL                        OK rewrite-url="..."
+
+        const char *statusNote = reply.notes.findFirst("status");
+        const char *urlNote = reply.notes.findFirst("url");
+
+        if (urlNote != NULL) {
+            // HTTP protocol redirect to be done.
+
+            // TODO: change default redirect status for appropriate requests
+            // Squid defaults to 302 status for now for better compatibility with old clients.
+            // HTTP/1.0 client should get 302 (Http::scFound)
+            // HTTP/1.1 client contacting reverse-proxy should get 307 (Http::scTemporaryRedirect)
+            // HTTP/1.1 client being diverted by forward-proxy should get 303 (Http::scSeeOther)
+            Http::StatusCode status = Http::scFound;
+            if (statusNote != NULL) {
+                const char * result = statusNote;
+                status = static_cast<Http::StatusCode>(atoi(result));
+            }
+
+            if (status == Http::scMovedPermanently
+                    || status == Http::scFound
+                    || status == Http::scSeeOther
+                    || status == Http::scPermanentRedirect
+                    || status == Http::scTemporaryRedirect) {
                 http->redirect.status = status;
-                http->redirect.location = xstrdup(t + 1);
+                http->redirect.location = xstrdup(urlNote);
                 // TODO: validate the URL produced here is RFC 2616 compliant absolute URI
             } else {
-                debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid " << status << " redirect Location: " << result);
+                debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid " << status << " redirect Location: " << urlNote);
             }
-        } else if (strcmp(result, http->uri)) {
-            // XXX: validate the URL properly *without* generating a whole new request object right here.
-            // XXX: the clone() should be done only AFTER we know the new URL is valid.
-            HttpRequest *new_request = old_request->clone();
-            if (urlParse(old_request->method, result, new_request)) {
-                debugs(61,2, HERE << "URL-rewriter diverts URL from " << urlCanonical(old_request) << " to " << urlCanonical(new_request));
-
-                // update the new request to flag the re-writing was done on it
-                new_request->flags.redirected = 1;
-
-                // unlink bodypipe from the old request. Not needed there any longer.
-                if (old_request->body_pipe != NULL) {
-                    old_request->body_pipe = NULL;
-                    debugs(61,2, HERE << "URL-rewriter diverts body_pipe " << new_request->body_pipe <<
-                           " from request " << old_request << " to " << new_request);
-                }
+        } else {
+            // URL-rewrite wanted. Ew.
+            urlNote = reply.notes.findFirst("rewrite-url");
 
-                // update the current working ClientHttpRequest fields
-                safe_free(http->uri);
-                http->uri = xstrdup(urlCanonical(new_request));
-                HTTPMSGUNLOCK(old_request);
-                http->request = HTTPMSGLOCK(new_request);
-            } else {
-                debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid request: " <<
-                       old_request->method << " " << result << " " << old_request->http_ver);
-                delete new_request;
+            // prevent broken helpers causing too much damage. If old URL == new URL skip the re-write.
+            if (urlNote != NULL && strcmp(urlNote, http->uri)) {
+                // XXX: validate the URL properly *without* generating a whole new request object right here.
+                // XXX: the clone() should be done only AFTER we know the new URL is valid.
+                HttpRequest *new_request = old_request->clone();
+                if (urlParse(old_request->method, const_cast<char*>(urlNote), new_request)) {
+                    debugs(61,2, HERE << "URL-rewriter diverts URL from " << urlCanonical(old_request) << " to " << urlCanonical(new_request));
+
+                    // update the new request to flag the re-writing was done on it
+                    new_request->flags.redirected = true;
+
+                    // unlink bodypipe from the old request. Not needed there any longer.
+                    if (old_request->body_pipe != NULL) {
+                        old_request->body_pipe = NULL;
+                        debugs(61,2, HERE << "URL-rewriter diverts body_pipe " << new_request->body_pipe <<
+                               " from request " << old_request << " to " << new_request);
+                    }
+
+                    // update the current working ClientHttpRequest fields
+                    safe_free(http->uri);
+                    http->uri = xstrdup(urlCanonical(new_request));
+                    HTTPMSGUNLOCK(old_request);
+                    http->request = new_request;
+                    HTTPMSGLOCK(http->request);
+                } else {
+                    debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid request: " <<
+                           old_request->method << " " << urlNote << " " << old_request->http_ver);
+                    delete new_request;
+                }
             }
         }
     }
+    break;
+    }
 
     /* FIXME PIPELINE: This is innacurate during pipelining */
 
     if (http->getConn() != NULL && Comm::IsConnOpen(http->getConn()->clientConnection))
         fd_note(http->getConn()->clientConnection->fd, http->uri);
 
     assert(http->uri);
 
     http->doCallouts();
 }
 
+/**
+ * This method handles the different replies from StoreID helper.
+ */
+void
+ClientRequestContext::clientStoreIdDone(const HelperReply &reply)
+{
+    HttpRequest *old_request = http->request;
+    debugs(85, 5, "'" << http->uri << "' result=" << reply);
+    assert(store_id_state == REDIRECT_PENDING);
+    store_id_state = REDIRECT_DONE;
+
+    // Put helper response Notes into the transaction state record (ALE) eventually
+    // do it early to ensure that no matter what the outcome the notes are present.
+    if (http->al != NULL) {
+        NotePairs &notes = SyncNotes(*http->al, *old_request);
+        notes.append(&reply.notes);
+    }
+
+    switch (reply.result) {
+    case HelperReply::Unknown:
+    case HelperReply::TT:
+        // Handler in redirect.cc should have already mapped Unknown
+        // IF it contained valid entry for the old helper protocol
+        debugs(85, DBG_IMPORTANT, "ERROR: storeID helper returned invalid result code. Wrong helper? " << reply);
+        break;
+
+    case HelperReply::BrokenHelper:
+        debugs(85, DBG_IMPORTANT, "ERROR: storeID helper: " << reply << ", attempt #" << (store_id_fail_count+1) << " of 2");
+        if (store_id_fail_count < 2) { // XXX: make this configurable ?
+            ++store_id_fail_count;
+            // reset state flag to try StoreID again from scratch.
+            store_id_done = false;
+        }
+        break;
+
+    case HelperReply::Error:
+        // no change to be done.
+        break;
+
+    case HelperReply::Okay: {
+        const char *urlNote = reply.notes.findFirst("store-id");
+
+        // prevent broken helpers causing too much damage. If old URL == new URL skip the re-write.
+        if (urlNote != NULL && strcmp(urlNote, http->uri) ) {
+            // Debug section required for some very specific cases.
+            debugs(85, 9, "Setting storeID with: " << urlNote );
+            http->request->store_id = urlNote;
+            http->store_id = urlNote;
+        }
+    }
+    break;
+    }
+
+    http->doCallouts();
+}
+
 /** Test cache allow/deny configuration
  *  Sets flags.cachable=1 if caching is not denied.
  */
 void
 ClientRequestContext::checkNoCache()
 {
@@ -1313,31 +1447,32 @@
 
     // If we have not decided yet, decide whether to bump now.
 
     // Bumping here can only start with a CONNECT request on a bumping port
     // (bumping of intercepted SSL conns is decided before we get 1st request).
     // We also do not bump redirected CONNECT requests.
-    if (http->request->method != METHOD_CONNECT || http->redirect.status ||
-            !Config.accessList.ssl_bump || !http->getConn()->port->sslBump) {
+    if (http->request->method != Http::METHOD_CONNECT || http->redirect.status ||
+            !Config.accessList.ssl_bump ||
+            !http->getConn()->port->flags.tunnelSslBumping) {
         http->al->ssl.bumpMode = Ssl::bumpEnd; // SslBump does not apply; log -
         debugs(85, 5, HERE << "cannot SslBump this request");
         return false;
     }
 
     // Do not bump during authentication: clients would not proxy-authenticate
     // if we delay a 407 response and respond with 200 OK to CONNECT.
-    if (error && error->httpStatus == HTTP_PROXY_AUTHENTICATION_REQUIRED) {
+    if (error && error->httpStatus == Http::scProxyAuthenticationRequired) {
         http->al->ssl.bumpMode = Ssl::bumpEnd; // SslBump does not apply; log -
         debugs(85, 5, HERE << "no SslBump during proxy authentication");
         return false;
     }
 
     debugs(85, 5, HERE << "SslBump possible, checking ACL");
 
-    ACLFilledChecklist *acl_checklist = clientAclChecklistCreate(Config.accessList.ssl_bump, http);
-    acl_checklist->nonBlockingCheck(sslBumpAccessCheckDoneWrapper, this);
+    ACLFilledChecklist *aclChecklist = clientAclChecklistCreate(Config.accessList.ssl_bump, http);
+    aclChecklist->nonBlockingCheck(sslBumpAccessCheckDoneWrapper, this);
     return true;
 }
 
 /**
  * A wrapper function to use the ClientRequestContext::sslBumpAccessCheckDone method
  * as ACLFilledChecklist callback
@@ -1374,13 +1509,13 @@
  */
 void
 ClientHttpRequest::processRequest()
 {
     debugs(85, 4, "clientProcessRequest: " << RequestMethodStr(request->method) << " '" << uri << "'");
 
-    if (request->method == METHOD_CONNECT && !redirect.status) {
+    if (request->method == Http::METHOD_CONNECT && !redirect.status) {
 #if USE_SSL
         if (sslBumpNeeded()) {
             sslBumpStart();
             return;
         }
 #endif
@@ -1395,13 +1530,13 @@
 
 void
 ClientHttpRequest::httpStart()
 {
     PROF_start(httpStart);
     logType = LOG_TAG_NONE;
-    debugs(85, 4, "ClientHttpRequest::httpStart: " << Format::log_tags[logType] << " for '" << uri << "'");
+    debugs(85, 4, LogTags_str[logType] << " for '" << uri << "'");
 
     /* no one should have touched this */
     assert(out.offset == 0);
     /* Use the Stream Luke */
     clientStreamNode *node = (clientStreamNode *)client_stream.tail->data;
     clientStreamRead(node, this, node->readBuffer);
@@ -1445,13 +1580,13 @@
     // TODO: Use HttpReply instead of the "200 Connection established" string.
     al->http.code = 200;
 
 #if USE_AUTH
     // Preserve authentication info for the ssl-bumped request
     if (request->auth_user_request != NULL)
-        getConn()->auth_user_request = request->auth_user_request;
+        getConn()->setAuth(request->auth_user_request, "SSL-bumped CONNECT");
 #endif
 
     assert(sslBumpNeeded());
     getConn()->switchToHttps(request, sslBumpNeed_);
 }
 
@@ -1542,14 +1677,16 @@
 void
 ClientHttpRequest::doCallouts()
 {
     assert(calloutContext);
 
     /*Save the original request for logging purposes*/
-    if (!calloutContext->http->al->request)
-        calloutContext->http->al->request = HTTPMSGLOCK(request);
+    if (!calloutContext->http->al->request) {
+        calloutContext->http->al->request = request;
+        HTTPMSGLOCK(calloutContext->http->al->request);
+    }
 
     if (!calloutContext->error) {
         // CVE-2009-0801: verify the Host: header is consistent with other known details.
         if (!calloutContext->host_header_verify_done) {
             debugs(83, 3, HERE << "Doing calloutContext->hostHeaderVerify()");
             calloutContext->host_header_verify_done = true;
@@ -1590,12 +1727,24 @@
             debugs(83, 3, HERE << "Doing calloutContext->clientAccessCheck2()");
             calloutContext->adapted_http_access_done = true;
             calloutContext->clientAccessCheck2();
             return;
         }
 
+        if (!calloutContext->store_id_done) {
+            calloutContext->store_id_done = true;
+            assert(calloutContext->store_id_state == REDIRECT_NONE);
+
+            if (Config.Program.store_id) {
+                debugs(83, 3,"Doing calloutContext->clientStoreIdStart()");
+                calloutContext->store_id_state = REDIRECT_PENDING;
+                calloutContext->clientStoreIdStart();
+                return;
+            }
+        }
+
         if (!calloutContext->interpreted_req_hdrs) {
             debugs(83, 3, HERE << "Doing clientInterpretRequestHeaders()");
             calloutContext->interpreted_req_hdrs = 1;
             clientInterpretRequestHeaders(this);
         }
 
@@ -1643,14 +1792,14 @@
             return;
         /* else no ssl bump required*/
     }
 #endif
 
     if (calloutContext->error) {
-        const char *uri = urlCanonical(request);
-        StoreEntry *e= storeCreateEntry(uri, uri, request->flags, request->method);
+        const char *storeUri = request->storeId();
+        StoreEntry *e= storeCreateEntry(storeUri, storeUri, request->flags, request->method);
 #if USE_SSL
         if (sslBumpNeeded()) {
             // set final error but delay sending until we bump
             Ssl::ServerBump *srvBump = new Ssl::ServerBump(request, e);
             errorAppendEntry(e, calloutContext->error);
             calloutContext->error = NULL;
@@ -1719,13 +1868,13 @@
     assert(cbdataReferenceValid(this));		// indicates bug
     clearAdaptation(virginHeadSource);
     assert(!adaptedBodySource);
 
     switch (answer.kind) {
     case Adaptation::Answer::akForward:
-        handleAdaptedHeader(answer.message);
+        handleAdaptedHeader(const_cast<HttpMsg*>(answer.message.getRaw()));
         break;
 
     case Adaptation::Answer::akBlock:
         handleAdaptationBlock(answer);
         break;
 
@@ -1742,13 +1891,19 @@
 
     if (HttpRequest *new_req = dynamic_cast<HttpRequest*>(msg)) {
         /*
          * Replace the old request with the new request.
          */
         HTTPMSGUNLOCK(request);
-        request = HTTPMSGLOCK(new_req);
+        request = new_req;
+        HTTPMSGLOCK(request);
+
+        // update the new message to flag whether URL re-writing was done on it
+        if (strcmp(urlCanonical(request),uri) != 0)
+            request->flags.redirected = 1;
+
         /*
          * Store the new URI for logging
          */
         xfree(uri);
         uri = xstrdup(urlCanonical(request));
         setLogUri(this, urlCanonicalClean(request));
@@ -1903,22 +2058,22 @@
 
     // The original author of the code also wanted to pass an errno to
     // setReplyToError, but it seems unlikely that the errno reflects the
     // true cause of the error at this point, so I did not pass it.
     if (calloutContext) {
         Ip::Address noAddr;
-        noAddr.SetNoAddr();
+        noAddr.setNoAddr();
         ConnStateData * c = getConn();
-        calloutContext->error = clientBuildError(ERR_ICAP_FAILURE, HTTP_INTERNAL_SERVER_ERROR,
+        calloutContext->error = clientBuildError(ERR_ICAP_FAILURE, Http::scInternalServerError,
                                 NULL,
                                 c != NULL ? c->clientConnection->remote : noAddr,
                                 request
                                                 );
 #if USE_AUTH
         calloutContext->error->auth_user_request =
-            c != NULL && c->auth_user_request != NULL ? c->auth_user_request : request->auth_user_request;
+            c != NULL && c->getAuth() != NULL ? c->getAuth() : request->auth_user_request;
 #endif
         calloutContext->error->detailError(errDetail);
         calloutContext->readNextRequest = true;
         if (c != NULL)
             c->expectNoForwarding();
         doCallouts();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side_request.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side_request.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/client_side_request.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/client_side_request.h	2015-05-01 18:05:19.000000000 +0800
@@ -27,28 +27,25 @@
  *
  */
 
 #ifndef SQUID_CLIENTSIDEREQUEST_H
 #define SQUID_CLIENTSIDEREQUEST_H
 
-#include "HttpHeader.h"
+#include "acl/forward.h"
+#include "AccessLogEntry.h"
 #include "clientStream.h"
 #include "client_side.h"
-#include "AccessLogEntry.h"
-#include "dlink.h"
-#include "base/AsyncJob.h"
 #include "HttpHeaderRange.h"
+#include "LogTags.h"
 
 #if USE_ADAPTATION
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
 class HttpMsg;
 #endif
 
-class acl_access;
-class ACLFilledChecklist;
 class ClientRequestContext;
 class ConnStateData;
 class MemObject;
 
 /* client_side_request.c - client side request related routines (pure logic) */
 int clientBeginRequest(const HttpRequestMethod&, char const *, CSCB *, CSD *, ClientStreamData, HttpHeader const *, char *, size_t);
@@ -58,17 +55,12 @@
         : public Adaptation::Initiator, // to start adaptation transactions
         public BodyConsumer     // to receive reply bodies in request satisf. mode
 #endif
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
-#if USE_ADAPTATION
-    void *toCbdata() { return this; }
-#endif
     ClientHttpRequest(ConnStateData *csd);
     ~ClientHttpRequest();
     /* Not implemented - present to prevent synthetic operations */
     ClientHttpRequest(ClientHttpRequest const &);
     ClientHttpRequest& operator=(ClientHttpRequest const &);
 
@@ -95,37 +87,41 @@
      */
     Comm::ConnectionPointer clientConnection;
 
     HttpRequest *request;		/* Parsed URL ... */
     char *uri;
     char *log_uri;
+    String store_id; /* StoreID for transactions where the request member is nil */
 
     struct {
         int64_t offset;
         int64_t size;
         size_t headers_sz;
     } out;
 
     HttpHdrRangeIter range_iter;	/* data for iterating thru range specs */
     size_t req_sz;		/* raw request size on input, not current request size */
-    log_type logType;
+
+    /// the processing tags associated with this request transaction.
+    // NP: still an enum so each stage altering it must take care when replacing it.
+    LogTags logType;
 
     struct timeval start_time;
     AccessLogEntry::Pointer al; ///< access.log entry
 
     struct {
-        unsigned int accel:1;
-        unsigned int intercepted:1;
-        unsigned int spoof_client_ip:1;
-        unsigned int internal:1;
-        unsigned int done_copying:1;
-        unsigned int purging:1;
+        bool accel;
+        //bool intercepted; //XXX: it's apparently never used.
+        //bool spoof_client_ip; //XXX: it's apparently never used.
+        bool internal;
+        bool done_copying;
+        bool purging;
     } flags;
 
     struct {
-        http_status status;
+        Http::StatusCode status;
         char *location;
     } redirect;
 
     dlink_node active;
     dlink_list client_stream;
     int mRangeCLen();
@@ -192,24 +188,23 @@
 
     bool request_satisfaction_mode;
     int64_t request_satisfaction_offset;
 #endif
 
 private:
-    CBDATA_CLASS(ClientHttpRequest);
+    CBDATA_CLASS2(ClientHttpRequest);
 };
 
 /* client http based routines */
 char *clientConstructTraceEcho(ClientHttpRequest *);
 
 ACLFilledChecklist *clientAclChecklistCreate(const acl_access * acl,ClientHttpRequest * http);
 int clientHttpRequestStatus(int fd, ClientHttpRequest const *http);
 void clientAccessCheck(ClientHttpRequest *);
 
 /* ones that should be elsewhere */
-void redirectStart(ClientHttpRequest *, RH *, void *);
 void tunnelStart(ClientHttpRequest *, int64_t *, int *, const AccessLogEntry::Pointer &al);
 
 #if _USE_INLINE_
 #include "Store.h"
 #include "client_side_request.cci"
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/clientStream.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/clientStream.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/clientStream.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/clientStream.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,14 +29,14 @@
  *
  */
 
 #ifndef SQUID_CLIENTSTREAM_H
 #define SQUID_CLIENTSTREAM_H
 
+#include "base/RefCount.h"
 #include "dlink.h"
-#include "RefCount.h"
 #include "StoreIOBuffer.h"
 
 /**
  \defgroup ClientStreamAPI Client Streams API
  \ingroup Components
  \section Introduction Introduction
@@ -93,13 +93,13 @@
  \li	read request parameters - For two reasons:
  \li		To allow a node to determine the requested data offset, length and target buffer dynamically. Again, this is to promote loose coupling.
  \li		Because of the callback nature of squid, every node would have to keep these parameters in their context anyway, so this reduces programmer overhead.
  */
 
 /// \ingroup ClientStreamAPI
-typedef RefCount<RefCountable_> ClientStreamData;
+typedef RefCount<Lock> ClientStreamData;
 
 class clientStreamNode;
 class ClientHttpRequest;
 class HttpReply;
 
 /* client stream read callback */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/AcceptLimiter.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/AcceptLimiter.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/AcceptLimiter.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/AcceptLimiter.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,10 @@
 #ifndef _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 #define _SQUID_SRC_COMM_ACCEPT_LIMITER_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "comm/TcpAcceptor.h"
 
 namespace Comm
 {
 
 /**
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/Connection.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/Connection.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/Connection.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/Connection.cc	2015-05-01 18:05:19.000000000 +0800
@@ -16,12 +16,13 @@
 Comm::Connection::Connection() :
         local(),
         remote(),
         peerType(HIER_NONE),
         fd(-1),
         tos(0),
+        nfmark(0),
         flags(COMM_NONBLOCKING),
         peer_(NULL)
 {
     *rfc931 = 0; // quick init the head. the rest does not matter.
 }
 
@@ -43,12 +44,13 @@
     ConnectionPointer c = new Comm::Connection;
 
     c->local = local;
     c->remote = remote;
     c->peerType = peerType;
     c->tos = tos;
+    c->nfmark = nfmark;
     c->flags = flags;
 
     // ensure FD is not open in the new copy.
     c->fd = -1;
 
     // ensure we have a cbdata reference to peer_ not a straight ptr copy.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/Connection.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/Connection.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/Connection.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/Connection.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,12 @@
 
 #include "comm/forward.h"
 #include "defines.h"
 #include "hier_code.h"
 #include "ip/Address.h"
 #include "MemPool.h"
-#include "RefCount.h"
 #include "typedefs.h"
 #if USE_SQUID_EUI
 #include "eui/Eui48.h"
 #include "eui/Eui64.h"
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/ConnOpener.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/ConnOpener.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/ConnOpener.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/ConnOpener.cc	2015-05-01 18:05:19.000000000 +0800
@@ -222,29 +222,29 @@
 void
 Comm::ConnOpener::start()
 {
     Must(conn_ != NULL);
 
     /* outbound sockets have no need to be protocol agnostic. */
-    if (!(Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING) && conn_->remote.IsIPv4()) {
-        conn_->local.SetIPv4();
+    if (!(Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING) && conn_->remote.isIPv4()) {
+        conn_->local.setIPv4();
     }
 
     if (createFd())
-        connect();
+        doConnect();
 }
 
 /// called at the end of Comm::ConnOpener::DelayedConnectRetry event
 void
 Comm::ConnOpener::restart()
 {
     debugs(5, 5, conn_ << " restarting after sleep");
     calls_.sleep_ = false;
 
     if (createFd())
-        connect();
+        doConnect();
 }
 
 /// Create a socket for the future connection or return false.
 /// If false is returned, done() is guaranteed to return true and end the job.
 bool
 Comm::ConnOpener::createFd()
@@ -308,13 +308,13 @@
 
     sendAnswer(COMM_OK, 0, "Comm::ConnOpener::connected");
 }
 
 /// Make an FD connection attempt.
 void
-Comm::ConnOpener::connect()
+Comm::ConnOpener::doConnect()
 {
     Must(conn_ != NULL);
     Must(temporaryFd_ >= 0);
 
     ++ totalTries_;
 
@@ -341,13 +341,13 @@
             debugs(5, 5, HERE << conn_ << ": * - try again");
             retrySleep();
             return;
         } else {
             // send ERROR back to the upper layer.
             debugs(5, 5, HERE << conn_ << ": * - ERR tried too many times already.");
-            sendAnswer(COMM_ERR_CONNECT, xerrno, "Comm::ConnOpener::connect");
+            sendAnswer(COMM_ERR_CONNECT, xerrno, "Comm::ConnOpener::doConnect");
         }
     }
     }
 }
 
 /// Close and wait a little before trying to open and connect again.
@@ -385,22 +385,22 @@
  * This ensure the connection local details are set correctly
  */
 void
 Comm::ConnOpener::lookupLocalAddress()
 {
     struct addrinfo *addr = NULL;
-    conn_->local.InitAddrInfo(addr);
+    Ip::Address::InitAddrInfo(addr);
 
     if (getsockname(conn_->fd, addr->ai_addr, &(addr->ai_addrlen)) != 0) {
         debugs(50, DBG_IMPORTANT, "ERROR: Failed to retrieve TCP/UDP details for socket: " << conn_ << ": " << xstrerror());
-        conn_->local.FreeAddrInfo(addr);
+        Ip::Address::FreeAddrInfo(addr);
         return;
     }
 
     conn_->local = *addr;
-    conn_->local.FreeAddrInfo(addr);
+    Ip::Address::FreeAddrInfo(addr);
     debugs(5, 6, HERE << conn_);
 }
 
 /** Abort connection attempt.
  * Handles the case(s) when a partially setup connection gets closed early.
  */
@@ -423,24 +423,24 @@
     debugs(5, 5, HERE << conn_ << ": * - ERR took too long to receive response.");
     calls_.timeout_ = NULL;
     sendAnswer(COMM_TIMEOUT, ETIMEDOUT, "Comm::ConnOpener::timeout");
 }
 
 /* Legacy Wrapper for the retry event after COMM_INPROGRESS
- * XXX: As soon as Comm::SetSelect() accepts Async calls we can use a ConnOpener::connect call
+ * XXX: As soon as Comm::SetSelect() accepts Async calls we can use a ConnOpener::doConnect call
  */
 void
 Comm::ConnOpener::InProgressConnectRetry(int fd, void *data)
 {
     Pointer *ptr = static_cast<Pointer*>(data);
     assert(ptr);
     if (ConnOpener *cs = ptr->valid()) {
         // Ew. we are now outside the all AsyncJob protections.
         // get back inside by scheduling another call...
         typedef NullaryMemFunT<Comm::ConnOpener> Dialer;
-        AsyncCall::Pointer call = JobCallback(5, 4, Dialer, cs, Comm::ConnOpener::connect);
+        AsyncCall::Pointer call = JobCallback(5, 4, Dialer, cs, Comm::ConnOpener::doConnect);
         ScheduleCallHere(call);
     }
     delete ptr;
 }
 
 /* Legacy Wrapper for the retry event with small delay after errors.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/ConnOpener.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/ConnOpener.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/ConnOpener.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/ConnOpener.h	2015-05-01 18:05:19.000000000 +0800
@@ -40,13 +40,13 @@
 
     void earlyAbort(const CommCloseCbParams &);
     void timeout(const CommTimeoutCbParams &);
     void sendAnswer(comm_err_t errFlag, int xerrno, const char *why);
     static void InProgressConnectRetry(int fd, void *data);
     static void DelayedConnectRetry(void *data);
-    void connect();
+    void doConnect();
     void connected();
     void lookupLocalAddress();
 
     void retrySleep();
     void restart();
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/forward.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/forward.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/forward.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/forward.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,11 @@
 #ifndef _SQUID_COMM_FORWARD_H
 #define _SQUID_COMM_FORWARD_H
 
-#include "Array.h"
-#include "RefCount.h"
+#include "base/Vector.h"
+#include "base/RefCount.h"
 
 namespace Comm
 {
 
 class Connection;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/Makefile.in	2015-05-01 16:51:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/Makefile.in	2015-05-01 18:06:53.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -454,12 +500,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -497,12 +544,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -529,27 +577,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -616,13 +667,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libcomm.la
 libcomm_la_SOURCES = \
 	AcceptLimiter.cc \
 	AcceptLimiter.h \
 	ConnOpener.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/ModPoll.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/ModPoll.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/ModPoll.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/ModPoll.cc	2015-05-01 18:05:19.000000000 +0800
@@ -499,13 +499,13 @@
             if (revents & (POLLRDNORM | POLLIN | POLLHUP | POLLERR)) {
                 debugs(5, 6, "comm_poll: FD " << fd << " ready for reading");
 
                 if ((hdl = F->read_handler)) {
                     PROF_start(comm_read_handler);
                     F->read_handler = NULL;
-                    F->flags.read_pending = 0;
+                    F->flags.read_pending = false;
                     hdl(fd, F->read_data);
                     PROF_stop(comm_read_handler);
                     ++ statCounter.select_fds;
 
                     if (commCheckUdpIncoming)
                         comm_poll_udp_incoming();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/TcpAcceptor.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/TcpAcceptor.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/TcpAcceptor.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/TcpAcceptor.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,24 +30,27 @@
  *
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
+#include "anyp/PortCfg.h"
 #include "base/TextException.h"
 #include "client_db.h"
 #include "comm/AcceptLimiter.h"
 #include "CommCalls.h"
 #include "comm/comm_internal.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "comm/TcpAcceptor.h"
+#include "eui/Config.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
 #include "ip/Intercept.h"
+#include "MasterXaction.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 
 #if HAVE_ERRNO_H
@@ -116,12 +119,18 @@
 
 void
 Comm::TcpAcceptor::swanSong()
 {
     debugs(5,5, HERE);
     unsubscribe("swanSong");
+    if (IsConnOpen(conn)) {
+        if (closer_ != NULL)
+            comm_remove_close_handler(conn->fd, closer_);
+        conn->close();
+    }
+
     conn = NULL;
     AcceptLimiter::Instance().removeDead(this);
     AsyncJob::swanSong();
 }
 
 const char *
@@ -129,13 +138,13 @@
 {
     if (conn == NULL)
         return "[nil connection]";
 
     static char ipbuf[MAX_IPSTRLEN] = {'\0'};
     if (ipbuf[0] == '\0')
-        conn->local.ToHostname(ipbuf, MAX_IPSTRLEN);
+        conn->local.toHostStr(ipbuf, MAX_IPSTRLEN);
 
     static MemBuf buf;
     buf.reset();
     buf.Printf(" FD %d, %s",conn->fd, ipbuf);
 
     const char *jobStatus = AsyncJob::status();
@@ -176,12 +185,26 @@
         if (setsockopt(conn->fd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &seconds, sizeof(seconds)) < 0)
             debugs(5, DBG_CRITICAL, "WARNING: TCP_DEFER_ACCEPT '" << Config.accept_filter << "': '" << xstrerror());
 #else
         debugs(5, DBG_CRITICAL, "WARNING: accept_filter not supported on your OS");
 #endif
     }
+
+    typedef CommCbMemFunT<Comm::TcpAcceptor, CommCloseCbParams> Dialer;
+    closer_ = JobCallback(5, 4, Dialer, this, Comm::TcpAcceptor::handleClosure);
+    comm_add_close_handler(conn->fd, closer_);
+}
+
+/// called when listening descriptor is closed by an external force
+/// such as clientHttpConnectionsClose()
+void
+Comm::TcpAcceptor::handleClosure(const CommCloseCbParams &io)
+{
+    closer_ = NULL;
+    conn = NULL;
+    Must(done());
 }
 
 /**
  * This private callback is called whenever a filedescriptor is ready
  * to dupe itself and fob off an accept()ed connection
  *
@@ -282,14 +305,16 @@
         return;
     }
 
     if (theCallSub != NULL) {
         AsyncCall::Pointer call = theCallSub->callback();
         CommAcceptCbParams &params = GetCommParams<CommAcceptCbParams>(call);
+        params.xaction = new MasterXaction;
+        params.xaction->squidPort = static_cast<AnyP::PortCfg*>(params.data);
         params.fd = conn->fd;
-        params.conn = newConnDetails;
+        params.conn = params.xaction->tcpClient = newConnDetails;
         params.flag = flag;
         params.xerrno = errcode;
         ScheduleCallHere(call);
     }
 }
 
@@ -306,19 +331,19 @@
 Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
 {
     PROF_start(comm_accept);
     ++statCounter.syscalls.sock.accepts;
     int sock;
     struct addrinfo *gai = NULL;
-    details->local.InitAddrInfo(gai);
+    Ip::Address::InitAddrInfo(gai);
 
     errcode = 0; // reset local errno copy.
     if ((sock = accept(conn->fd, gai->ai_addr, &gai->ai_addrlen)) < 0) {
         errcode = errno; // store last accept errno locally.
 
-        details->local.FreeAddrInfo(gai);
+        Ip::Address::FreeAddrInfo(gai);
 
         PROF_stop(comm_accept);
 
         if (ignoreErrno(errno)) {
             debugs(50, 5, HERE << status() << ": " << xstrerror());
             return COMM_NOMESSAGE;
@@ -335,37 +360,41 @@
     details->fd = sock;
     details->remote = *gai;
 
     if ( Config.client_ip_max_connections >= 0) {
         if (clientdbEstablished(details->remote, 0) > Config.client_ip_max_connections) {
             debugs(50, DBG_IMPORTANT, "WARNING: " << details->remote << " attempting more than " << Config.client_ip_max_connections << " connections.");
-            details->local.FreeAddrInfo(gai);
+            Ip::Address::FreeAddrInfo(gai);
             return COMM_ERROR;
         }
     }
 
     // lookup the local-end details of this new connection
-    details->local.InitAddrInfo(gai);
-    details->local.SetEmpty();
-    getsockname(sock, gai->ai_addr, &gai->ai_addrlen);
+    Ip::Address::InitAddrInfo(gai);
+    details->local.setEmpty();
+    if (getsockname(sock, gai->ai_addr, &gai->ai_addrlen) != 0) {
+        debugs(50, DBG_IMPORTANT, "ERROR: getsockname() failed to locate local-IP on " << details << ": " << xstrerror());
+        Ip::Address::FreeAddrInfo(gai);
+        return COMM_ERROR;
+    }
     details->local = *gai;
-    details->local.FreeAddrInfo(gai);
+    Ip::Address::FreeAddrInfo(gai);
 
     /* fdstat update */
     // XXX : these are not all HTTP requests. use a note about type and ip:port details->
     // so we end up with a uniform "(HTTP|FTP-data|HTTPS|...) remote-ip:remote-port"
     fd_open(sock, FD_SOCKET, "HTTP Request");
 
     fdd_table[sock].close_file = NULL;
     fdd_table[sock].close_line = 0;
 
     fde *F = &fd_table[sock];
-    details->remote.NtoA(F->ipaddr,MAX_IPSTRLEN);
-    F->remote_port = details->remote.GetPort();
+    details->remote.toStr(F->ipaddr,MAX_IPSTRLEN);
+    F->remote_port = details->remote.port();
     F->local_addr = details->local;
-    F->sock_family = details->local.IsIPv6()?AF_INET6:AF_INET;
+    F->sock_family = details->local.isIPv6()?AF_INET6:AF_INET;
 
     // set socket flags
     commSetCloseOnExec(sock);
     commSetNonBlocking(sock);
 
     /* IFF the socket is (tproxy) transparent, pass the flag down to allow spoofing */
@@ -374,9 +403,19 @@
     // Perform NAT or TPROXY operations to retrieve the real client/dest IP addresses
     if (conn->flags&(COMM_TRANSPARENT|COMM_INTERCEPTION) && !Ip::Interceptor.Lookup(details, conn)) {
         // Failed.
         return COMM_ERROR;
     }
 
+#if USE_SQUID_EUI
+    if (Eui::TheConfig.euiLookup) {
+        if (details->remote.isIPv4()) {
+            details->remoteEui48.lookup(details->remote);
+        } else if (details->remote.isIPv6()) {
+            details->remoteEui64.lookup(details->remote);
+        }
+    }
+#endif
+
     PROF_stop(comm_accept);
     return COMM_OK;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/TcpAcceptor.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/TcpAcceptor.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm/TcpAcceptor.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm/TcpAcceptor.h	2015-05-01 18:05:19.000000000 +0800
@@ -4,12 +4,14 @@
 #include "base/AsyncJob.h"
 #include "base/CbcPointer.h"
 #include "base/Subscription.h"
 #include "comm_err_t.h"
 #include "comm/forward.h"
 
+class CommCloseCbParams;
+
 namespace Comm
 {
 
 class AcceptLimiter;
 
 /**
@@ -70,22 +72,26 @@
     Subscription::Pointer theCallSub;    ///< used to generate AsyncCalls handling our events.
 
     /// conn being listened on for new connections
     /// Reserved for read-only use.
     ConnectionPointer conn;
 
+    /// listen socket closure handler
+    AsyncCall::Pointer closer_;
+
     /// Method to test if there are enough file descriptors to open a new client connection
     /// if not the accept() will be postponed
     static bool okToAccept();
 
     /// Method callback for whenever an FD is ready to accept a client connection.
     static void doAccept(int fd, void *data);
 
     void acceptOne();
     comm_err_t oldAccept(Comm::ConnectionPointer &details);
     void setListen();
+    void handleClosure(const CommCloseCbParams &io);
 
     CBDATA_CLASS2(TcpAcceptor);
 };
 
 } // namespace Comm
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/CommCalls.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/CommCalls.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/CommCalls.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/CommCalls.cc	2015-05-01 18:05:19.000000000 +0800
@@ -37,16 +37,25 @@
         os << ", data=" << data;
 }
 
 /* CommAcceptCbParams */
 
 CommAcceptCbParams::CommAcceptCbParams(void *aData):
-        CommCommonCbParams(aData)
+        CommCommonCbParams(aData), xaction()
 {
 }
 
+void
+CommAcceptCbParams::print(std::ostream &os) const
+{
+    CommCommonCbParams::print(os);
+
+    if (xaction != NULL)
+        os << ", " << xaction->id;
+}
+
 /* CommConnectCbParams */
 
 CommConnectCbParams::CommConnectCbParams(void *aData):
         CommCommonCbParams(aData)
 {
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/CommCalls.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/CommCalls.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/CommCalls.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/CommCalls.h	2015-05-01 18:05:19.000000000 +0800
@@ -2,12 +2,13 @@
 #define SQUID_COMMCALLS_H
 
 #include "base/AsyncCall.h"
 #include "base/AsyncJobCalls.h"
 #include "comm_err_t.h"
 #include "comm/forward.h"
+#include "MasterXaction.h"
 
 /* CommCalls implement AsyncCall interface for comm_* callbacks.
  * The classes cover two call dialer kinds:
  *     - A C-style call using a function pointer (depricated);
  *     - A C++-style call to an AsyncJob child.
  * and several comm_* callback kinds:
@@ -86,12 +87,17 @@
 
 // accept parameters
 class CommAcceptCbParams: public CommCommonCbParams
 {
 public:
     CommAcceptCbParams(void *aData);
+
+    void print(std::ostream &os) const;
+
+    /// Transaction which this call is part of.
+    MasterXaction::Pointer xaction;
 };
 
 // connect parameters
 class CommConnectCbParams: public CommCommonCbParams
 {
 public:
@@ -166,15 +172,15 @@
 class CommCbMemFunT: public JobDialer<C>, public CommDialerParamsT<Params_>
 {
 public:
     typedef Params_ Params;
     typedef void (C::*Method)(const Params &io);
 
-    CommCbMemFunT(const CbcPointer<C> &job, Method meth): JobDialer<C>(job),
-            CommDialerParamsT<Params_>(job.get()),
-            method(meth) {}
+    CommCbMemFunT(const CbcPointer<C> &aJob, Method aMeth): JobDialer<C>(aJob),
+            CommDialerParamsT<Params_>(aJob->toCbdata()),
+            method(aMeth) {}
 
     virtual bool canDial(AsyncCall &c) {
         return JobDialer<C>::canDial(c) &&
                this->params.syncWithComm();
     }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,17 +30,13 @@
  *
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
-#include "base/AsyncCall.h"
-#include "cbdata.h"
-#include "comm.h"
 #include "ClientInfo.h"
-#include "CommCalls.h"
 #include "comm/AcceptLimiter.h"
 #include "comm/comm_internal.h"
 #include "comm/Connection.h"
 #include "comm/IoCallback.h"
 #include "comm/Loops.h"
 #include "comm/Write.h"
@@ -50,21 +46,18 @@
 #include "DescriptorSet.h"
 #include "event.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
 #include "icmp/net_db.h"
-#include "ip/Address.h"
 #include "ip/Intercept.h"
 #include "ip/QosConfig.h"
 #include "ip/tools.h"
-#include "MemBuf.h"
 #include "pconn.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
-#include "SquidTime.h"
 #include "StatCounters.h"
 #include "StoreIOBuffer.h"
 #include "tools.h"
 
 #if USE_SSL
 #include "ssl/support.h"
@@ -205,13 +198,13 @@
 comm_empty_os_read_buffers(int fd)
 {
 #if _SQUID_LINUX_
     /* prevent those nasty RST packets */
     char buf[SQUID_TCP_SO_RCVBUF];
 
-    if (fd_table[fd].flags.nonblocking == 1) {
+    if (fd_table[fd].flags.nonblocking) {
         while (FD_READ_METHOD(fd, buf, SQUID_TCP_SO_RCVBUF) > 0) {};
     }
 #endif
 }
 
 /**
@@ -327,27 +320,18 @@
  * synchronous wrapper around udp socket functions
  */
 int
 comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from)
 {
     ++ statCounter.syscalls.sock.recvfroms;
-    int x = 0;
-    struct addrinfo *AI = NULL;
-
     debugs(5,8, "comm_udp_recvfrom: FD " << fd << " from " << from);
-
-    assert( NULL == AI );
-
-    from.InitAddrInfo(AI);
-
-    x = recvfrom(fd, buf, len, flags, AI->ai_addr, &AI->ai_addrlen);
-
+    struct addrinfo *AI = NULL;
+    Ip::Address::InitAddrInfo(AI);
+    int x = recvfrom(fd, buf, len, flags, AI->ai_addr, &AI->ai_addrlen);
     from = *AI;
-
-    from.FreeAddrInfo(AI);
-
+    Ip::Address::FreeAddrInfo(AI);
     return x;
 }
 
 int
 comm_udp_recv(int fd, void *buf, size_t len, int flags)
 {
@@ -385,38 +369,38 @@
 
     if (!F->flags.open) {
         debugs(5, 0, "comm_local_port: FD " << fd << " has been closed.");
         return 0;
     }
 
-    if (F->local_addr.GetPort())
-        return F->local_addr.GetPort();
+    if (F->local_addr.port())
+        return F->local_addr.port();
 
     if (F->sock_family == AF_INET)
-        temp.SetIPv4();
+        temp.setIPv4();
 
-    temp.InitAddrInfo(addr);
+    Ip::Address::InitAddrInfo(addr);
 
     if (getsockname(fd, addr->ai_addr, &(addr->ai_addrlen)) ) {
         debugs(50, DBG_IMPORTANT, "comm_local_port: Failed to retrieve TCP/UDP port number for socket: FD " << fd << ": " << xstrerror());
-        temp.FreeAddrInfo(addr);
+        Ip::Address::FreeAddrInfo(addr);
         return 0;
     }
     temp = *addr;
 
-    temp.FreeAddrInfo(addr);
+    Ip::Address::FreeAddrInfo(addr);
 
-    if (F->local_addr.IsAnyAddr()) {
+    if (F->local_addr.isAnyAddr()) {
         /* save the whole local address, not just the port. */
         F->local_addr = temp;
     } else {
-        F->local_addr.SetPort(temp.GetPort());
+        F->local_addr.port(temp.port());
     }
 
-    debugs(5, 6, "comm_local_port: FD " << fd << ": port " << F->local_addr.GetPort() << "(family=" << F->sock_family << ")");
-    return F->local_addr.GetPort();
+    debugs(5, 6, "comm_local_port: FD " << fd << ": port " << F->local_addr.port() << "(family=" << F->sock_family << ")");
+    return F->local_addr.port();
 }
 
 static comm_err_t
 commBind(int s, struct addrinfo &inaddr)
 {
     ++ statCounter.syscalls.sock.binds;
@@ -492,41 +476,52 @@
 #else
     debugs(50, 0, "WARNING: comm_open: setsockopt(IPV6_V6ONLY) not supported on this platform");
 #endif /* sockopt */
 }
 
 /**
- * Set the socket IP_TRANSPARENT option for Linux TPROXY v4 support,
- * or set the socket SO_BINDANY option for BSD divert-to support.
+ * Set the socket option required for TPROXY spoofing for:
+ * - Linux TPROXY v4 support,
+ * - OpenBSD divert-to support,
+ * - FreeBSD IPFW TPROXY v4 support.
  */
 void
 comm_set_transparent(int fd)
 {
-#if _SQUID_LINUX_ && defined(IP_TRANSPARENT)
-    int tos = 1;
-    if (setsockopt(fd, SOL_IP, IP_TRANSPARENT, (char *) &tos, sizeof(int)) < 0) {
-        debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(IP_TRANSPARENT) on FD " << fd << ": " << xstrerror());
-    } else {
-        /* mark the socket as having transparent options */
-        fd_table[fd].flags.transparent = 1;
-    }
+#if _SQUID_LINUX_ && defined(IP_TRANSPARENT) // Linux
+# define soLevel SOL_IP
+# define soFlag  IP_TRANSPARENT
+    bool doneSuid = false;
+
+#elif defined(SO_BINDANY) // OpenBSD 4.7+ and NetBSD with PF
+# define soLevel SOL_SOCKET
+# define soFlag  SO_BINDANY
+    enter_suid();
+    bool doneSuid = true;
 
-#elif defined(SO_BINDANY)
-    int tos = 1;
+#elif defined(IP_BINDANY) // FreeBSD with IPFW
+# define soLevel IPPROTO_IP
+# define soFlag  IP_BINDANY
     enter_suid();
-    if (setsockopt(fd, SOL_SOCKET, SO_BINDANY, (char *) &tos, sizeof(int)) < 0) {
-        debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(SO_BINDANY) on FD " << fd << ": " << xstrerror());
+    bool doneSuid = true;
+
+#else
+    debugs(50, DBG_CRITICAL, "WARNING: comm_open: setsockopt(TPROXY) not supported on this platform");
+#endif /* sockopt */
+
+#if defined(soLevel) && defined(soFlag)
+    int tos = 1;
+    if (setsockopt(fd, soLevel, soFlag, (char *) &tos, sizeof(int)) < 0) {
+        debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(TPROXY) on FD " << fd << ": " << xstrerror());
     } else {
         /* mark the socket as having transparent options */
         fd_table[fd].flags.transparent = true;
     }
-    leave_suid();
-
-#else
-    debugs(50, DBG_CRITICAL, "WARNING: comm_open: setsockopt(IP_TRANSPARENT) not supported on this platform");
-#endif /* sockopt */
+    if (doneSuid)
+        leave_suid();
+#endif
 }
 
 /**
  * Create a socket. Default is blocking, stream (TCP) socket.  IO_TYPE
  * is OR of flags specified in defines.h:COMM_*
  */
@@ -544,27 +539,27 @@
 
     PROF_start(comm_open);
     /* Create socket for accepting new connections. */
     ++ statCounter.syscalls.sock.sockets;
 
     /* Setup the socket addrinfo details for use */
-    addr.GetAddrInfo(AI);
+    addr.getAddrInfo(AI);
     AI->ai_socktype = sock_type;
     AI->ai_protocol = proto;
 
     debugs(50, 3, "comm_openex: Attempt open socket for: " << addr );
 
     new_socket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol);
 
     /* under IPv6 there is the possibility IPv6 is present but disabled. */
     /* try again as IPv4-native if possible */
-    if ( new_socket < 0 && Ip::EnableIpv6 && addr.IsIPv6() && addr.SetIPv4() ) {
+    if ( new_socket < 0 && Ip::EnableIpv6 && addr.isIPv6() && addr.setIPv4() ) {
         /* attempt to open this IPv4-only. */
-        addr.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
         /* Setup the socket addrinfo details for use */
-        addr.GetAddrInfo(AI);
+        addr.getAddrInfo(AI);
         AI->ai_socktype = sock_type;
         AI->ai_protocol = proto;
         debugs(50, 3, "comm_openex: Attempt fallback open socket for: " << addr );
         new_socket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol);
         debugs(50, 2, HERE << "attempt open " << note << " socket on: " << addr);
     }
@@ -578,13 +573,13 @@
             debugs(50, DBG_IMPORTANT, "comm_open: socket failure: " << xstrerror());
             fdAdjustReserved();
         } else {
             debugs(50, DBG_CRITICAL, "comm_open: socket failure: " << xstrerror());
         }
 
-        addr.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
 
         PROF_stop(comm_open);
         return -1;
     }
 
     // XXX: temporary for the transition. comm_openex will eventually have a conn to play with.
@@ -599,24 +594,24 @@
         Ip::Qos::setSockTos(conn, tos);
 
     /* set netfilter mark if needed */
     if (nfmark)
         Ip::Qos::setSockNfmark(conn, nfmark);
 
-    if ( Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && addr.IsIPv6() )
+    if ( Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && addr.isIPv6() )
         comm_set_v6only(conn->fd, 1);
 
     /* Windows Vista supports Dual-Sockets. BUT defaults them to V6ONLY. Turn it OFF. */
     /* Other OS may have this administratively disabled for general use. Same deal. */
-    if ( Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING && addr.IsIPv6() )
+    if ( Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING && addr.isIPv6() )
         comm_set_v6only(conn->fd, 0);
 
     comm_init_opened(conn, tos, nfmark, note, AI);
     new_socket = comm_apply_flags(conn->fd, addr, flags, AI);
 
-    addr.FreeAddrInfo(AI);
+    Ip::Address::FreeAddrInfo(AI);
 
     PROF_stop(comm_open);
 
     // XXX transition only. prevent conn from closing the new FD on function exit.
     conn->fd = -1;
     return new_socket;
@@ -666,13 +661,13 @@
     if (!(flags & COMM_NOCLOEXEC))
         commSetCloseOnExec(new_socket);
 
     if ((flags & COMM_REUSEADDR))
         commSetReuseAddr(new_socket);
 
-    if (addr.GetPort() > (unsigned short) 0) {
+    if (addr.port() > (unsigned short) 0) {
 #if _SQUID_WINDOWS_
         if (sock_type != SOCK_DGRAM)
 #endif
             commSetNoLinger(new_socket);
 
         if (opt_reuseaddr)
@@ -681,16 +676,16 @@
 
     /* MUST be done before binding or face OS Error: "(99) Cannot assign requested address"... */
     if ((flags & COMM_TRANSPARENT)) {
         comm_set_transparent(new_socket);
     }
 
-    if ( (flags & COMM_DOBIND) || addr.GetPort() > 0 || !addr.IsAnyAddr() ) {
-        if ( !(flags & COMM_DOBIND) && addr.IsAnyAddr() )
+    if ( (flags & COMM_DOBIND) || addr.port() > 0 || !addr.isAnyAddr() ) {
+        if ( !(flags & COMM_DOBIND) && addr.isAnyAddr() )
             debugs(5, DBG_IMPORTANT,"WARNING: Squid is attempting to bind() port " << addr << " without being a listener.");
-        if ( addr.IsNoAddr() )
+        if ( addr.isNoAddr() )
             debugs(5,0,"CRITICAL: Squid is attempting to bind() port " << addr << "!!");
 
         if (commBind(new_socket, *AI) != COMM_OK) {
             comm_close(new_socket);
             return -1;
         }
@@ -723,30 +718,30 @@
     assert(Comm::IsConnOpen(conn));
     assert(AI);
 
     comm_init_opened(conn, 0, 0, note, AI);
 
     if (!(conn->flags & COMM_NOCLOEXEC))
-        fd_table[conn->fd].flags.close_on_exec = 1;
+        fd_table[conn->fd].flags.close_on_exec = true;
 
-    if (conn->local.GetPort() > (unsigned short) 0) {
+    if (conn->local.port() > (unsigned short) 0) {
 #if _SQUID_WINDOWS_
         if (AI->ai_socktype != SOCK_DGRAM)
 #endif
-            fd_table[conn->fd].flags.nolinger = 1;
+            fd_table[conn->fd].flags.nolinger = true;
     }
 
     if ((conn->flags & COMM_TRANSPARENT))
-        fd_table[conn->fd].flags.transparent = 1;
+        fd_table[conn->fd].flags.transparent = true;
 
     if (conn->flags & COMM_NONBLOCKING)
-        fd_table[conn->fd].flags.nonblocking = 1;
+        fd_table[conn->fd].flags.nonblocking = true;
 
 #ifdef TCP_NODELAY
     if (AI->ai_socktype == SOCK_STREAM)
-        fd_table[conn->fd].flags.nodelay = 1;
+        fd_table[conn->fd].flags.nodelay = true;
 #endif
 
     /* no fd_table[fd].flags. updates needed for these conditions:
      * if ((flags & COMM_REUSEADDR)) ...
      * if ((flags & COMM_DOBIND) ...) ...
      */
@@ -809,45 +804,45 @@
     int x = 0;
     int err = 0;
     socklen_t errlen;
     struct addrinfo *AI = NULL;
     PROF_start(comm_connect_addr);
 
-    assert(address.GetPort() != 0);
+    assert(address.port() != 0);
 
     debugs(5, 9, HERE << "connecting socket FD " << sock << " to " << address << " (want family: " << F->sock_family << ")");
 
     /* Handle IPv6 over IPv4-only socket case.
-     * this case must presently be handled here since the GetAddrInfo asserts on bad mappings.
+     * this case must presently be handled here since the getAddrInfo asserts on bad mappings.
      * NP: because commResetFD is private to ConnStateData we have to return an error and
      *     trust its handled properly.
      */
-    if (F->sock_family == AF_INET && !address.IsIPv4()) {
+    if (F->sock_family == AF_INET && !address.isIPv4()) {
         errno = ENETUNREACH;
         return COMM_ERR_PROTOCOL;
     }
 
     /* Handle IPv4 over IPv6-only socket case.
      * This case is presently handled here as it's both a known case and it's
      * uncertain what error will be returned by the IPv6 stack in such case. It's
      * possible this will also be handled by the errno checks below after connect()
      * but needs carefull cross-platform verification, and verifying the address
      * condition here is simple.
      */
-    if (!F->local_addr.IsIPv4() && address.IsIPv4()) {
+    if (!F->local_addr.isIPv4() && address.isIPv4()) {
         errno = ENETUNREACH;
         return COMM_ERR_PROTOCOL;
     }
 
-    address.GetAddrInfo(AI, F->sock_family);
+    address.getAddrInfo(AI, F->sock_family);
 
     /* Establish connection. */
     errno = 0;
 
     if (!F->flags.called_connect) {
-        F->flags.called_connect = 1;
+        F->flags.called_connect = true;
         ++ statCounter.syscalls.sock.connects;
 
         x = connect(sock, AI->ai_addr, AI->ai_addrlen);
 
         // XXX: ICAP code refuses callbacks during a pending comm_ call
         // Async calls development will fix this.
@@ -902,45 +897,28 @@
 
 #endif
 #endif
 
     }
 
-    /* Squid seems to be working fine without this code. With this code,
-     * we leak memory on many connect requests because of EINPROGRESS.
-     * If you find that this code is needed, please file a bug report. */
-#if 0
-#if _SQUID_LINUX_
-    /* 2007-11-27:
-     * Linux Debian replaces our allocated AI pointer with garbage when
-     * connect() fails. This leads to segmentation faults deallocating
-     * the system-allocated memory when we go to clean up our pointer.
-     * HACK: is to leak the memory returned since we can't deallocate.
-     */
-    if (errno != 0) {
-        AI = NULL;
-    }
-#endif
-#endif
-
-    address.FreeAddrInfo(AI);
+    Ip::Address::FreeAddrInfo(AI);
 
     PROF_stop(comm_connect_addr);
 
     if (errno == 0 || errno == EISCONN)
         status = COMM_OK;
     else if (ignoreErrno(errno))
         status = COMM_INPROGRESS;
     else if (errno == EAFNOSUPPORT || errno == EINVAL)
         return COMM_ERR_PROTOCOL;
     else
         return COMM_ERROR;
 
-    address.NtoA(F->ipaddr, MAX_IPSTRLEN);
+    address.toStr(F->ipaddr, MAX_IPSTRLEN);
 
-    F->remote_port = address.GetPort(); /* remote_port is HS */
+    F->remote_port = address.port(); /* remote_port is HS */
 
     if (status == COMM_OK) {
         debugs(5, DBG_DATA, "comm_connect_addr: FD " << sock << " connected to " << address);
     } else if (status == COMM_INPROGRESS) {
         debugs(5, DBG_DATA, "comm_connect_addr: FD " << sock << " connection pending");
     }
@@ -1053,13 +1031,13 @@
 }
 
 #if USE_SSL
 void
 commStartSslClose(const FdeCbParams &params)
 {
-    assert(&fd_table[params.fd].ssl);
+    assert(fd_table[params.fd].ssl != NULL);
     ssl_shutdown_method(fd_table[params.fd].ssl);
 }
 #endif
 
 void
 comm_close_complete(const FdeCbParams &params)
@@ -1122,13 +1100,13 @@
     }
 
     assert(F->type != FD_FILE);
 
     PROF_start(comm_close);
 
-    F->flags.close_request = 1;
+    F->flags.close_request = true;
 
 #if USE_SSL
     if (F->ssl) {
         AsyncCall::Pointer startCall=commCbCall(5,4, "commStartSslClose",
                                                 FdeCbPtrFun(commStartSslClose, NULL));
         FdeCbParams &startParams = GetCommParams<FdeCbParams>(startCall);
@@ -1184,30 +1162,22 @@
 int
 comm_udp_sendto(int fd,
                 const Ip::Address &to_addr,
                 const void *buf,
                 int len)
 {
-    int x = 0;
-    struct addrinfo *AI = NULL;
-
     PROF_start(comm_udp_sendto);
     ++ statCounter.syscalls.sock.sendtos;
 
     debugs(50, 3, "comm_udp_sendto: Attempt to send UDP packet to " << to_addr <<
            " using FD " << fd << " using Port " << comm_local_port(fd) );
 
-    /* BUG: something in the above macro appears to occasionally be setting AI to garbage. */
-    /* AYJ: 2007-08-27 : or was it because I wasn't then setting 'fd_table[fd].sock_family' to fill properly. */
-    assert( NULL == AI );
-
-    to_addr.GetAddrInfo(AI, fd_table[fd].sock_family);
-
-    x = sendto(fd, buf, len, 0, AI->ai_addr, AI->ai_addrlen);
-
-    to_addr.FreeAddrInfo(AI);
+    struct addrinfo *AI = NULL;
+    to_addr.getAddrInfo(AI, fd_table[fd].sock_family);
+    int x = sendto(fd, buf, len, 0, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
 
     PROF_stop(comm_udp_sendto);
 
     if (x >= 0)
         return x;
 
@@ -1299,13 +1269,13 @@
     L.l_onoff = 0;		/* off */
     L.l_linger = 0;
 
     if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char *) &L, sizeof(L)) < 0)
         debugs(50, 0, "commSetNoLinger: FD " << fd << ": " << xstrerror());
 
-    fd_table[fd].flags.nolinger = 1;
+    fd_table[fd].flags.nolinger = true;
 }
 
 static void
 commSetReuseAddr(int fd)
 {
     int on = 1;
@@ -1363,13 +1333,13 @@
         }
 
 #endif
 #if _SQUID_CYGWIN_
     }
 #endif
-    fd_table[fd].flags.nonblocking = 1;
+    fd_table[fd].flags.nonblocking = true;
 
     return 0;
 }
 
 int
 commUnsetNonBlocking(int fd)
@@ -1390,13 +1360,13 @@
     if (fcntl(fd, F_SETFL, flags & (~SQUID_NONBLOCK)) < 0) {
 #endif
         debugs(50, 0, "commUnsetNonBlocking: FD " << fd << ": " << xstrerror());
         return COMM_ERROR;
     }
 
-    fd_table[fd].flags.nonblocking = 0;
+    fd_table[fd].flags.nonblocking = false;
     return 0;
 }
 
 void
 commSetCloseOnExec(int fd)
 {
@@ -1409,13 +1379,13 @@
         return;
     }
 
     if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0)
         debugs(50, 0, "FD " << fd << ": set close-on-exec failed: " << xstrerror());
 
-    fd_table[fd].flags.close_on_exec = 1;
+    fd_table[fd].flags.close_on_exec = true;
 
 #endif
 }
 
 #ifdef TCP_NODELAY
 static void
@@ -1423,13 +1393,13 @@
 {
     int on = 1;
 
     if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) < 0)
         debugs(50, DBG_IMPORTANT, "commSetTcpNoDelay: FD " << fd << ": " << xstrerror());
 
-    fd_table[fd].flags.nodelay = 1;
+    fd_table[fd].flags.nodelay = true;
 }
 
 #endif
 
 void
 commSetTcpKeepalive(int fd, int idle, int interval, int timeout)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/comm.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/comm.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,10 @@
 #ifndef __COMM_H__
 #define __COMM_H__
 
-#include "AsyncEngine.h"
-#include "base/AsyncCall.h"
 #include "CommCalls.h"
-#include "comm_err_t.h"
 #include "comm/IoCallback.h"
 #include "StoreIOBuffer.h"
 
 namespace Ip
 {
 class Address;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Common.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Common.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Common.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Common.am	2015-05-01 18:05:19.000000000 +0800
@@ -40,10 +40,10 @@
 LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
 else
 LIBPROFILER=
 endif
 
 ## Because compatibility is almost universal. And the link order is important.
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 
 ## Some helpers are written in Perl and need the local shell defined properly
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ConfigOption.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ConfigOption.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ConfigOption.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ConfigOption.h	2015-05-01 18:05:19.000000000 +0800
@@ -27,14 +27,13 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 #ifndef SQUID_CONFIGOPTION_H
 #define SQUID_CONFIGOPTION_H
 
-/* for Vector<> */
-#include "Array.h"
+#include "base/Vector.h"
 
 class StoreEntry;
 
 /* cache option parsers */
 
 class ConfigOption
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ConfigParser.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ConfigParser.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ConfigParser.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ConfigParser.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,29 +35,71 @@
 #include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "fatal.h"
 #include "globals.h"
 
+char *ConfigParser::lastToken = NULL;
+std::queue<std::string> ConfigParser::undo;
+
+int ConfigParser::RecognizeQuotedValues = true;
+
 void
 ConfigParser::destruct()
 {
     shutting_down = 1;
     fatalf("Bungled %s line %d: %s",
            cfg_filename, config_lineno, config_input_line);
 }
 
+void
+ConfigParser::strtokFileUndo()
+{
+    assert(lastToken);
+    undo.push(lastToken);
+}
+
+void
+ConfigParser::strtokFilePutBack(const char *tok)
+{
+    assert(tok);
+    undo.push(tok);
+}
+
+char *
+xstrtok(char *str, const char *delimiters)
+{
+    assert(!str); // we are parsing the configuration file
+    // no support unless enabled in the configuration and
+    // no support for other delimiters (they may need to be eradicated!)
+    return (ConfigParser::RecognizeQuotedValues &&
+            strcmp(delimiters, " \t\n\r") == 0) ?
+           ConfigParser::NextToken() : ::strtok(str, delimiters);
+}
+
 char *
 ConfigParser::strtokFile(void)
 {
     static int fromFile = 0;
     static FILE *wordFile = NULL;
+    LOCAL_ARRAY(char, undoToken, CONFIG_LINE_LIMIT);
 
     char *t, *fn;
     LOCAL_ARRAY(char, buf, CONFIG_LINE_LIMIT);
 
+    if (!undo.empty()) {
+        strncpy(undoToken, undo.front().c_str(), sizeof(undoToken));
+        undoToken[sizeof(undoToken) - 1] = '\0';
+        undo.pop();
+        return lastToken = undoToken;
+    }
+
+    if (RecognizeQuotedValues)
+        return lastToken = ConfigParser::NextToken();
+
+    lastToken = NULL;
     do {
 
         if (!fromFile) {
             t = (strtok(NULL, w_space));
 
             if (!t || *t == '#') {
@@ -79,13 +121,13 @@
 #if _SQUID_WINDOWS_
                 setmode(fileno(wordFile), O_TEXT);
 #endif
 
                 fromFile = 1;
             } else {
-                return t;
+                return lastToken = t;
             }
         }
 
         /* fromFile */
         if (fgets(buf, CONFIG_LINE_LIMIT, wordFile) == NULL) {
             /* stop reading from file */
@@ -110,38 +152,71 @@
         }
 
         /* skip comments */
         /* skip blank lines */
     } while ( *t == '#' || !*t );
 
-    return t;
+    return lastToken = t;
+}
+
+/// returns token after stripping any comments
+/// must be called in non-quoted context only
+char *
+ConfigParser::StripComment(char *token)
+{
+    if (!token)
+        return NULL;
+
+    // we are outside the quoted string context
+    // assume that anything starting with a '#' is a comment
+    if (char *comment = strchr(token, '#')) {
+        *comment = '\0'; // remove the comment from this token
+        (void)strtok(NULL, ""); // remove the comment from the current line
+        if (!*token)
+            return NULL; // token was a comment
+    }
+
+    return token;
 }
 
 void
 ConfigParser::ParseQuotedString(char **var, bool *wasQuoted)
 {
-    String sVar;
-    ParseQuotedString(&sVar, wasQuoted);
-    *var = xstrdup(sVar.termedBuf());
+    if (const char *phrase = NextElement(wasQuoted))
+        *var = xstrdup(phrase);
+    else
+        self_destruct();
 }
 
 void
 ConfigParser::ParseQuotedString(String *var, bool *wasQuoted)
 {
+    if (const char *phrase = NextElement(wasQuoted))
+        var->reset(phrase);
+    else
+        self_destruct();
+}
+
+char *
+ConfigParser::NextElement(bool *wasQuoted)
+{
+    if (wasQuoted)
+        *wasQuoted = false;
+
     // Get all of the remaining string
     char *token = strtok(NULL, "");
     if (token == NULL)
-        self_destruct();
+        return NULL;
+
+    // skip leading whitespace (may skip the entire token that way)
+    while (xisspace(*token)) ++token;
+
+    if (*token != '"')
+        return StripComment(strtok(token, w_space));
 
-    if (*token != '"') {
-        token = strtok(token, w_space);
-        var->reset(token);
-        if (wasQuoted)
-            *wasQuoted = false;
-        return;
-    } else if (wasQuoted)
+    if (wasQuoted)
         *wasQuoted = true;
 
     char  *s = token + 1;
     /* scan until the end of the quoted string, unescaping " and \  */
     while (*s && *s != '"') {
         if (*s == '\\') {
@@ -149,23 +224,29 @@
             memmove(s, next, strlen(next) + 1);
         }
         ++s;
     }
 
     if (*s != '"') {
-        debugs(3, DBG_CRITICAL, "ParseQuotedString: missing '\"' at the end of quoted string" );
+        debugs(3, DBG_CRITICAL, "missing '\"' at the end of quoted string" );
         self_destruct();
     }
     strtok(s-1, "\""); /*Reset the strtok to point after the "  */
     *s = '\0';
 
-    var->reset(token+1);
+    return (token+1);
+}
+
+char *
+ConfigParser::NextToken()
+{
+    return NextElement(NULL);
 }
 
 const char *
-ConfigParser::QuoteString(String &var)
+ConfigParser::QuoteString(const String &var)
 {
     static String quotedStr;
     const char *s = var.termedBuf();
     bool  needQuote = false;
 
     for (const char *l = s; !needQuote &&  *l != '\0'; ++l  )
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ConfigParser.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ConfigParser.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ConfigParser.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ConfigParser.h	2015-05-01 18:05:19.000000000 +0800
@@ -32,12 +32,16 @@
  */
 
 #ifndef SQUID_CONFIGPARSER_H
 #define SQUID_CONFIGPARSER_H
 
 #include "SquidString.h"
+#include <queue>
+#if HAVE_STRING
+#include <string>
+#endif
 
 class wordlist;
 /**
  * Limit to how long any given config line may be.
  * This affects squid.conf and all included files.
  *
@@ -70,14 +74,39 @@
     /// may include spaces. In some contexts, quotes strings may also
     /// include macros. Quoted strings may escape any character with
     /// a backslash (\), which is currently only useful for inner
     /// quotes. TODO: support quoted strings anywhere a token is accepted.
     static void ParseQuotedString(char **var, bool *wasQuoted = NULL);
     static void ParseQuotedString(String *var, bool *wasQuoted = NULL);
-    static const char *QuoteString(String &var);
+    static const char *QuoteString(const String &var);
     static void ParseWordList(wordlist **list);
     static char * strtokFile();
+    static void strtokFileUndo();
+    static void strtokFilePutBack(const char *);
+
+    /**
+      Returns the body of the next element. The element is either a token or
+      a quoted string with optional escape sequences and/or macros. The body
+      of a quoted string element does not include quotes or escape sequences.
+      Future code will want to see Elements and not just their bodies.
+    */
+    static char *NextToken();
+
+    /// configuration_includes_quoted_values in squid.conf
+    static int RecognizeQuotedValues;
+
+protected:
+    static char *NextElement(bool *wasQuoted);
+    static char *StripComment(char *token);
+
+private:
+    static char *lastToken;
+    static std::queue<std::string> undo;
 };
 
 int parseConfigFile(const char *file_name);
 
+/// Used for temporary hacks to allow old code to handle quoted values
+/// without replacing every strtok() call.
+extern char *xstrtok(char *str, const char *delimiters);
+
 #endif /* SQUID_CONFIGPARSER_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/CpuAffinityMap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/CpuAffinityMap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/CpuAffinityMap.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/CpuAffinityMap.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  */
 
 #ifndef SQUID_CPU_AFFINITY_MAP_H
 #define SQUID_CPU_AFFINITY_MAP_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 class CpuAffinitySet;
 
 /// stores cpu_affinity_map configuration
 class CpuAffinityMap
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/debug.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/debug.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/debug.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/debug.cc	2015-05-01 18:05:19.000000000 +0800
@@ -42,12 +42,13 @@
 char *Debug::debugOptions = NULL;
 int Debug::override_X = 0;
 int Debug::log_stderr = -1;
 bool Debug::log_syslog = false;
 int Debug::Levels[MAX_DEBUG_SECTIONS];
 int Debug::level;
+int Debug::sectionLevel;
 char *Debug::cache_log = NULL;
 int Debug::rotateNumber = -1;
 FILE *debug_log = NULL;
 static char *debug_log_file = NULL;
 static int Ctx_Lock = 0;
 static const char *debugLogTime(void);
@@ -798,6 +799,29 @@
 SkipBuildPrefix(const char* path)
 {
     static const size_t BuildPrefixLength = BuildPrefixInit();
 
     return path+BuildPrefixLength;
 }
+
+std::ostream &
+Raw::print(std::ostream &os) const
+{
+    if (label_)
+        os << ' ' << label_ << '[' << size_ << ']';
+
+    if (!size_)
+        return os;
+
+    // finalize debugging level if no level was set explicitly via minLevel()
+    const int finalLevel = (level >= 0) ? level :
+                           (size_ > 40 ? DBG_DATA : Debug::sectionLevel);
+    if (finalLevel <= Debug::sectionLevel) {
+        os << (label_ ? '=' : ' ');
+        if (data_)
+            os.write(data_, size_);
+        else
+            os << "[null]";
+    }
+
+    return os;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Debug.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Debug.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Debug.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Debug.h	2015-05-01 18:05:19.000000000 +0800
@@ -78,13 +78,14 @@
 
 public:
     static char *debugOptions;
     static char *cache_log;
     static int rotateNumber;
     static int Levels[MAX_DEBUG_SECTIONS];
-    static int level;
+    static int level; ///< minimum debugging level required by debugs() call
+    static int sectionLevel; ///< maximum debugging level allowed now
     static int override_X;
     static int log_stderr;
     static bool log_syslog;
 
     static std::ostream &getDebugOut();
     static void finishDebug();
@@ -104,12 +105,13 @@
 const char * SkipBuildPrefix(const char* path);
 
 /* Debug stream */
 #define debugs(SECTION, LEVEL, CONTENT) \
    do { \
         if ((Debug::level = (LEVEL)) <= Debug::Levels[SECTION]) { \
+            Debug::sectionLevel = Debug::Levels[SECTION]; \
             std::ostream &_dbo=Debug::getDebugOut(); \
             if (Debug::level > DBG_IMPORTANT) \
                 _dbo << SkipBuildPrefix(__FILE__)<<"("<<__LINE__<<") "<<__FUNCTION__<<": "; \
             _dbo << CONTENT; \
             Debug::finishDebug(); \
         } \
@@ -154,7 +156,45 @@
 /* Legacy debug function definitions */
 void _db_init(const char *logfile, const char *options);
 void _db_print(const char *,...) PRINTF_FORMAT_ARG1;
 void _db_set_syslog(const char *facility);
 void _db_rotate_log(void);
 
+/// Prints raw and/or non-terminated data safely, efficiently, and beautifully.
+/// Allows raw data debugging in debugs() statements with low debugging levels
+/// by printing only if higher section debugging levels are configured:
+///   debugs(11, DBG_IMPORTANT, "always printed" << Raw(may be printed...));
+class Raw
+{
+public:
+    Raw(const char *label, const char *data, const size_t size):
+            level(-1), label_(label), data_(data), size_(size) {}
+
+    /// limit data printing to at least the given debugging level
+    Raw &minLevel(const int aLevel) { level = aLevel; return *this; }
+
+    /// If debugging is prohibited by the current debugs() or section level,
+    /// prints nothing. Otherwise, dumps data using one of these formats:
+    ///   " label[size]=data" if label was set and data size is positive
+    ///   " label[0]" if label was set and data size is zero
+    ///   " data" if label was not set and data size is positive
+    ///   "" (i.e., prints nothing) if label was not set and data size is zero
+    std::ostream &print(std::ostream &os) const;
+
+    /// Minimum section debugging level necessary for printing. By default,
+    /// small strings are always printed while large strings are only printed
+    /// if DBG_DATA debugging level is enabled.
+    int level;
+
+private:
+    const char *label_; ///< optional data name or ID; triggers size printing
+    const char *data_; ///< raw data to be printed
+    size_t size_; ///< data length
+};
+
+inline
+std::ostream &operator <<(std::ostream &os, const Raw &raw)
+{
+    return raw.print(os);
+}
+
 #endif /* SQUID_DEBUG_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/defines.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/defines.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/defines.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/defines.h	2015-05-01 18:05:19.000000000 +0800
@@ -38,13 +38,12 @@
 #endif
 
 #ifndef BUFSIZ
 #define BUFSIZ  4096            /* make unreasonable guess */
 #endif
 
-#define ACL_NAME_SZ 32
 #define BROWSERNAMELEN 128
 
 #define ACL_SUNDAY	0x01
 #define ACL_MONDAY	0x02
 #define ACL_TUESDAY	0x04
 #define ACL_WEDNESDAY	0x08
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayBucket.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayBucket.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayBucket.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayBucket.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,12 +39,14 @@
 
 /// \ingroup DelayPoolsAPI
 class DelayBucket
 {
 
 public:
+    DelayBucket() : level_(0) {}
+
     int const& level() const {return level_;}
 
     int & level() {return level_;}
 
     void stats(StoreEntry *)const;
     void update (DelaySpec const &, int incr);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayConfig.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayConfig.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayConfig.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayConfig.cc	2015-05-01 18:05:19.000000000 +0800
@@ -110,13 +110,13 @@
     if (pool < 1 || pool > DelayPools::pools()) {
         debugs(3, DBG_CRITICAL, "parse_delay_pool_rates: Ignoring pool " << pool << " not in 1 .. " << DelayPools::pools());
         return;
     }
 
     --pool;
-    aclParseAccessLine(parser, &DelayPools::delay_data[pool].access);
+    aclParseAccessLine("delay_access", parser, &DelayPools::delay_data[pool].access);
 }
 
 void
 DelayConfig::freePoolCount()
 {
     DelayPools::FreePools();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayId.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayId.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayId.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayId.cc	2015-05-01 18:05:19.000000000 +0800
@@ -94,13 +94,13 @@
 {
     HttpRequest *r;
     unsigned short pool;
     assert(http);
     r = http->request;
 
-    if (r->client_addr.IsNoAddr()) {
+    if (r->client_addr.isNoAddr()) {
         debugs(77, 2, "delayClient: WARNING: Called with 'NO_ADDR' address, ignoring");
         return DelayId();
     }
 
     for (pool = 0; pool < DelayPools::pools(); ++pool) {
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayIdComposite.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayIdComposite.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayIdComposite.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayIdComposite.h	2015-05-01 18:05:19.000000000 +0800
@@ -35,14 +35,14 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 #ifndef DELAYIDCOMPOSITE_H
 #define DELAYIDCOMPOSITE_H
 
 #if USE_DELAY_POOLS
+#include "base/RefCount.h"
 #include "fatal.h"
-#include "RefCount.h"
 
 class DeferredRead;
 
 class DelayIdComposite : public RefCountable
 {
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayPool.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayPool.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayPool.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayPool.h	2015-05-01 18:05:19.000000000 +0800
@@ -36,19 +36,18 @@
  */
 #ifndef DELAYPOOL_H
 #define DELAYPOOL_H
 
 #if USE_DELAY_POOLS
 #include "CompositePoolNode.h"
+#include "acl/forward.h"
 
 class StoreEntry;
 
 class CommonPool;
 
-class acl_access;
-
 /// \ingroup DelayPoolsAPI
 class DelayPool
 {
 
 public:
     DelayPool();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/delay_pools.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/delay_pools.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/delay_pools.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/delay_pools.cc	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
  \ingroup DelayPoolsAPI
  */
 
 #include "squid.h"
 
 #if USE_DELAY_POOLS
-#include "Array.h"
+#include "base/Vector.h"
 #include "client_side_request.h"
 #include "comm/Connection.h"
 #include "CommonPool.h"
 #include "CompositePoolNode.h"
 #include "ConfigParser.h"
 #include "DelayBucket.h"
@@ -807,13 +807,13 @@
 VectorPool::id(CompositeSelectionDetails &details)
 {
     if (rate()->restore_bps == -1)
         return new NullDelayId;
 
     /* non-IPv4 are not able to provide IPv4-bitmask for this pool type key. */
-    if ( !details.src_addr.IsIPv4() )
+    if ( !details.src_addr.isIPv4() )
         return new NullDelayId;
 
     unsigned int key = makeKey(details.src_addr);
 
     if (keyAllocated(key))
         return new Id(this, buckets.findKeyIndex(key));
@@ -855,17 +855,17 @@
 }
 
 unsigned int
 IndividualPool::makeKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
-    if ( !src_addr.IsIPv4() )
+    if ( !src_addr.isIPv4() )
         return 1;
 
     struct in_addr host;
-    src_addr.GetInAddr(host);
+    src_addr.getInAddr(host);
     return (ntohl(host.s_addr) & 0xff);
 }
 
 void *
 ClassCNetPool::operator new(size_t size)
 {
@@ -881,17 +881,17 @@
 }
 
 unsigned int
 ClassCNetPool::makeKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
-    if ( !src_addr.IsIPv4() )
+    if ( !src_addr.isIPv4() )
         return 1;
 
     struct in_addr net;
-    src_addr.GetInAddr(net);
+    src_addr.getInAddr(net);
     return ( (ntohl(net.s_addr) >> 8) & 0xff);
 }
 
 ClassCHostPool::ClassCHostPool()
 {
     DelayPools::registerForUpdates (this);
@@ -953,41 +953,41 @@
 }
 
 unsigned char
 ClassCHostPool::makeHostKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
-    if ( !src_addr.IsIPv4() )
+    if ( !src_addr.isIPv4() )
         return 1;
 
     /* Temporary bypass for IPv4-only */
     struct in_addr host;
-    src_addr.GetInAddr(host);
+    src_addr.getInAddr(host);
     return (ntohl(host.s_addr) & 0xff);
 }
 
 unsigned int
 ClassCHostPool::makeKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
-    if ( !src_addr.IsIPv4() )
+    if ( !src_addr.isIPv4() )
         return 1;
 
     struct in_addr net;
-    src_addr.GetInAddr(net);
+    src_addr.getInAddr(net);
     return ( (ntohl(net.s_addr) >> 8) & 0xff);
 }
 
 DelayIdComposite::Pointer
 ClassCHostPool::id(CompositeSelectionDetails &details)
 {
     if (rate()->restore_bps == -1)
         return new NullDelayId;
 
     /* non-IPv4 are not able to provide IPv4-bitmask for this pool type key. */
-    if ( !details.src_addr.IsIPv4() )
+    if ( !details.src_addr.isIPv4() )
         return new NullDelayId;
 
     unsigned int key = makeKey (details.src_addr);
 
     unsigned char host = makeHostKey (details.src_addr);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayPools.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayPools.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayPools.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayPools.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,12 +29,18 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 #ifndef SQUID_DELAYPOOLS_H
 #define SQUID_DELAYPOOLS_H
 
+#include "base/Vector.h"
+
+class DelayPool;
+class Updateable;
+class StoreEntry;
+
 /**
  \defgroup DelayPoolsAPI Delay Pools API
  \ingroup Components
  */
 
 /// \ingroup DelayPoolsAPI
@@ -44,20 +50,12 @@
 public:
     virtual ~Updateable() {}
 
     virtual void update(int) = 0;
 };
 
-/* forward decls */
-class DelayPool;
-class Updateable;
-class StoreEntry;
-
-/* for Vector<> */
-#include "Array.h"
-
 /// \ingroup DelayPoolsAPI
 class DelayPools
 {
 
 public:
     static void Init();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayTagged.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayTagged.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayTagged.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayTagged.h	2015-05-01 18:05:19.000000000 +0800
@@ -38,13 +38,13 @@
 
 #include "auth/Gadgets.h"
 #include "CompositePoolNode.h"
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
 #include "DelaySpec.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
 class DelayTaggedBucket : public RefCountable
 {
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayUser.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayUser.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DelayUser.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DelayUser.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 #include "auth/Gadgets.h"
 #include "auth/User.h"
 #include "CompositePoolNode.h"
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
 #include "DelaySpec.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
 class DelayUserBucket : public RefCountable
 {
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/disk.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/disk.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/disk.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/disk.cc	2015-05-01 18:05:19.000000000 +0800
@@ -122,13 +122,13 @@
          * on some operating systems, you can not delete or rename
          * open files, so we won't allow delayed close.
          */
         while (!diskWriteIsComplete(fd))
             diskHandleWrite(fd, NULL);
 #else
-        F->flags.close_request = 1;
+        F->flags.close_request = true;
         debugs(6, 2, "file_close: FD " << fd << ", delaying close");
         PROF_stop(file_close);
         return;
 #endif
 
     }
@@ -220,22 +220,22 @@
     int len = 0;
     fde *F = &fd_table[fd];
 
     _fde_disk *fdd = &F->disk;
     dwrite_q *q = fdd->write_q;
     int status = DISK_OK;
-    int do_close;
+    bool do_close;
 
     if (NULL == q)
         return;
 
     PROF_start(diskHandleWrite);
 
     debugs(6, 3, "diskHandleWrite: FD " << fd);
 
-    F->flags.write_daemon = 0;
+    F->flags.write_daemon = false;
 
     assert(fdd->write_q != NULL);
 
     assert(fdd->write_q->len > fdd->write_q->buf_offset);
 
     debugs(6, 3, "diskHandleWrite: FD " << fd << " writing " <<
@@ -329,13 +329,13 @@
         /* no more data */
         fdd->write_q_tail = NULL;
     } else {
         /* another block is queued */
         diskCombineWrites(fdd);
         Comm::SetSelect(fd, COMM_SELECT_WRITE, diskHandleWrite, NULL, 0);
-        F->flags.write_daemon = 1;
+        F->flags.write_daemon = true;
     }
 
     do_close = F->flags.close_request;
 
     if (fdd->wrt_handle) {
         DWCB *callback = fdd->wrt_handle;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/AIO/AIODiskFile.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/AIO/AIODiskFile.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/AIO/AIODiskFile.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/AIO/AIODiskFile.cc	2015-05-01 18:05:19.000000000 +0800
@@ -55,24 +55,12 @@
 
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
 
 CBDATA_CLASS_INIT(AIODiskFile);
-void *
-AIODiskFile::operator new(size_t unused)
-{
-    CBDATA_INIT_TYPE(AIODiskFile);
-    return cbdataAlloc(AIODiskFile);
-}
-
-void
-AIODiskFile::operator delete(void *address)
-{
-    cbdataFree(address);
-}
 
 AIODiskFile::AIODiskFile(char const *aPath, AIODiskIOStrategy *aStrategy) : fd(-1), closed(true), error_(false)
 {
     assert (aPath);
     path = aPath;
     strategy = aStrategy;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/AIO/AIODiskFile.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/AIO/AIODiskFile.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/AIO/AIODiskFile.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/AIO/AIODiskFile.h	2015-05-01 18:05:19.000000000 +0800
@@ -43,14 +43,12 @@
 class AIODiskFile : public DiskFile
 {
 
 public:
 
     friend class AIODiskIOStrategy;
-    void * operator new (size_t);
-    void operator delete (void *);
     AIODiskFile (char const *path, AIODiskIOStrategy *);
     ~AIODiskFile();
 
     /// \bug the code has this as "IORequestor::Pointer callback"
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
 
@@ -74,11 +72,11 @@
     int fd;
     String path;
     AIODiskIOStrategy *strategy;
     RefCount<IORequestor> ioRequestor;
     bool closed;
     bool error_;
-    CBDATA_CLASS(AIODiskFile);
+    CBDATA_CLASS2(AIODiskFile);
 };
 
 #endif /* USE_DISKIO_AIO */
 #endif /* SQUID_AIODISKFILE_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/AIO/aio_win32.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/AIO/aio_win32.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/AIO/aio_win32.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/AIO/aio_win32.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,16 +31,12 @@
 
 #ifndef __WIN32_AIO_H__
 #define __WIN32_AIO_H__
 
 #if USE_DISKIO_AIO
 
-#if _SQUID_CYGWIN_
-#include "squid_windows.h"
-#endif
-
 #ifndef off64_t
 typedef int64_t	off64_t;
 #endif
 
 #if _SQUID_WINDOWS_
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/Blocking/BlockingFile.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/Blocking/BlockingFile.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/Blocking/BlockingFile.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/Blocking/BlockingFile.cc	2015-05-01 18:05:19.000000000 +0800
@@ -40,30 +40,14 @@
 #include "DiskIO/WriteRequest.h"
 #include "disk.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
-CBDATA_CLASS_INIT(BlockingFile);
-
-void *
-BlockingFile::operator new(size_t sz)
-{
-    CBDATA_INIT_TYPE(BlockingFile);
-    BlockingFile *result = cbdataAlloc(BlockingFile);
-    /* Mark result as being owned - we want the refcounter to do the delete
-     * call */
-    return result;
-}
 
-void
-BlockingFile::operator delete(void *address)
-{
-    BlockingFile *t = static_cast<BlockingFile *>(address);
-    cbdataFree(t);
-}
+CBDATA_CLASS_INIT(BlockingFile);
 
 BlockingFile::BlockingFile(char const *aPath) : fd (-1), closed (true), error_(false)
 {
     assert(aPath);
     debugs(79, 3, "BlockingFile::BlockingFile: " << aPath);
     path_ = xstrdup (aPath);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/Blocking/BlockingFile.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/Blocking/BlockingFile.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/Blocking/BlockingFile.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/Blocking/BlockingFile.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,14 +39,12 @@
 #include "DiskIO/IORequestor.h"
 
 class BlockingFile : public DiskFile
 {
 
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
     BlockingFile(char const *path);
     ~BlockingFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void create(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void read(ReadRequest *);
     virtual void write(WriteRequest *);
@@ -69,10 +67,10 @@
     RefCount<ReadRequest> readRequest;
     RefCount<WriteRequest> writeRequest;
     void doClose();
     void readDone(int fd, const char *buf, int len, int errflag);
     void writeDone(int fd, int errflag, size_t len);
 
-    CBDATA_CLASS(BlockingFile);
+    CBDATA_CLASS2(BlockingFile);
 };
 
 #endif /* SQUID_BLOCKINGFILE_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/diomsg.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/diomsg.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/diomsg.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/diomsg.h	2015-05-01 18:05:19.000000000 +0800
@@ -14,20 +14,20 @@
     _MQD_CLOSE,
     _MQD_READ,
     _MQD_WRITE,
     _MQD_UNLINK
 };
 
-struct RefCountable_;
+class Lock;
 
 struct diomsg {
     mtyp_t mtype;
     int id;
     int seq_no;
     void * callback_data;
-    RefCountable_ * requestor;
+    Lock * requestor;
     size_t size;
     off_t offset;
     int status;
     bool newstyle;
     int shm_offset;
     static const int msg_snd_rcv_sz;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/diskd.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/diskd.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/diskd.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/diskd.cc	2015-05-01 18:05:19.000000000 +0800
@@ -34,15 +34,21 @@
 #include "DiskIO/DiskDaemon/diomsg.h"
 #include "hash.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
+#if HAVE_SYS_IPC_H
 #include <sys/ipc.h>
+#endif
+#if HAVE_SYS_MSG_H
 #include <sys/msg.h>
+#endif
+#if HAVE_SYS_SHM_H
 #include <sys/shm.h>
+#endif
 #if HAVE_IOSTREAM
 #include <iostream>
 #endif
 
 void
 xassert(const char *msg, const char *file, int line)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/DiskdFile.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/DiskdFile.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/DiskdFile.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/DiskdFile.cc	2015-05-01 18:05:19.000000000 +0800
@@ -38,37 +38,24 @@
 #include "DiskdIOStrategy.h"
 #include "DiskIO/IORequestor.h"
 #include "DiskIO/ReadRequest.h"
 #include "DiskIO/WriteRequest.h"
 #include "StatCounters.h"
 
+#if HAVE_SYS_IPC_H
 #include <sys/ipc.h>
+#endif
+#if HAVE_SYS_MSG_H
 #include <sys/msg.h>
+#endif
+#if HAVE_SYS_SHM_H
 #include <sys/shm.h>
+#endif
 
 CBDATA_CLASS_INIT(DiskdFile);
 
-void *
-DiskdFile::operator new(size_t unused)
-{
-    CBDATA_INIT_TYPE(DiskdFile);
-    DiskdFile *result = cbdataAlloc(DiskdFile);
-    /* Mark result as being owned - we want the refcounter to do the delete
-     * call */
-    debugs(79, 3, "diskdFile with base " << result << " allocating");
-    return result;
-}
-
-void
-DiskdFile::operator delete(void *address)
-{
-    DiskdFile *t = static_cast<DiskdFile *>(address);
-    debugs(79, 3, "diskdFile with base " << t << " deleting");
-    cbdataFree(t);
-}
-
 DiskdFile::DiskdFile(char const *aPath, DiskdIOStrategy *anIO) :
         errorOccured(false),
         IO(anIO),
         mode(0),
         inProgressIOs(0)
 {
@@ -382,13 +369,13 @@
     debugs(79, 3, "DiskdFile::readDone: status " << M->status);
     assert (M->requestor);
     ReadRequest::Pointer readRequest = dynamic_cast<ReadRequest *>(M->requestor);
 
     /* remove the free protection */
     if (readRequest != NULL)
-        readRequest->RefCountDereference();
+        readRequest->unlock();
 
     if (M->status < 0) {
         ++diskd_stats.read.fail;
         ioCompleted();
         errorOccured = true;
         ioRequestor->readCompleted(NULL, -1, DISK_ERROR, readRequest);
@@ -407,13 +394,13 @@
     ++statCounter.syscalls.disk.writes;
     debugs(79, 3, "storeDiskdWriteDone: status " << M->status);
     assert (M->requestor);
     WriteRequest::Pointer writeRequest = dynamic_cast<WriteRequest *>(M->requestor);
     /* remove the free protection */
     if (writeRequest != NULL)
-        writeRequest->RefCountDereference();
+        writeRequest->unlock();
 
     if (M->status < 0) {
         errorOccured = true;
         ++diskd_stats.write.fail;
         ioCompleted();
         ioRequestor->writeCompleted (DISK_ERROR,0, writeRequest);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/DiskdFile.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/DiskdFile.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/DiskdFile.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/DiskdFile.h	2015-05-01 18:05:19.000000000 +0800
@@ -45,14 +45,12 @@
  \ingroup diskd
  */
 class DiskdFile : public DiskFile
 {
 
 public:
-    void * operator new(size_t);
-    void operator delete(void *);
     DiskdFile(char const *path, DiskdIOStrategy *);
     ~DiskdFile();
     virtual void open(int flags, mode_t aMode, RefCount<IORequestor> callback);
     virtual void create(int flags, mode_t aMode, RefCount<IORequestor> callback);
     virtual void read(ReadRequest *);
     virtual void write(WriteRequest *);
@@ -81,10 +79,10 @@
     void notifyClient();
     bool canNotifyClient() const;
     void ioAway();
     void ioCompleted();
     size_t inProgressIOs;
 
-    CBDATA_CLASS(DiskdFile);
+    CBDATA_CLASS2(DiskdFile);
 };
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/DiskdIOStrategy.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/DiskdIOStrategy.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/DiskdIOStrategy.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/DiskdIOStrategy.cc	2015-05-01 18:05:19.000000000 +0800
@@ -43,15 +43,21 @@
 #include "StatCounters.h"
 #include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "SquidTime.h"
 #include "unlinkd.h"
 
+#if HAVE_SYS_IPC_H
 #include <sys/ipc.h>
+#endif
+#if HAVE_SYS_MSG_H
 #include <sys/msg.h>
+#endif
+#if HAVE_SYS_SHM_H
 #include <sys/shm.h>
+#endif
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
 
 diskd_stats_t diskd_stats;
 
@@ -186,13 +192,13 @@
     snprintf(skey3, 32, "%d", ikey + 2);
     args[0] = "diskd";
     args[1] = skey1;
     args[2] = skey2;
     args[3] = skey3;
     args[4] = NULL;
-    localhost.SetLocalhost();
+    localhost.setLocalhost();
     pid = ipcCreate(IPC_STREAM,
                     Config.Program.diskd,
                     args,
                     "diskd",
                     localhost,
                     &rfd,
@@ -315,13 +321,13 @@
     /* set errno passed from diskd.  makes debugging more meaningful */
     if (M->status < 0)
         errno = -M->status;
 
     if (M->newstyle) {
         DiskdFile *theFile = (DiskdFile *)M->callback_data;
-        theFile->RefCountDereference();
+        theFile->unlock();
         theFile->completed (M);
     } else
         switch (M->mtype) {
 
         case _MQD_OPEN:
 
@@ -345,22 +351,22 @@
         }
 
     cbdataReferenceDone (M->callback_data);
 }
 
 int
-DiskdIOStrategy::send(int mtype, int id, DiskdFile *theFile, size_t size, off_t offset, ssize_t shm_offset, RefCountable_ *requestor)
+DiskdIOStrategy::send(int mtype, int id, DiskdFile *theFile, size_t size, off_t offset, ssize_t shm_offset, Lock *requestor)
 {
     diomsg M;
     M.callback_data = cbdataReference(theFile);
-    theFile->RefCountReference();
+    theFile->lock();
     M.requestor = requestor;
     M.newstyle = true;
 
     if (requestor)
-        requestor->RefCountReference();
+        requestor->lock();
 
     return SEND(&M, mtype, id, size, offset, shm_offset);
 }
 
 int
 DiskdIOStrategy::send(int mtype, int id, RefCount<StoreIOState> sio, size_t size, off_t offset, ssize_t shm_offset)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/DiskdIOStrategy.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/DiskdIOStrategy.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskDaemon/DiskdIOStrategy.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskDaemon/DiskdIOStrategy.h	2015-05-01 18:05:19.000000000 +0800
@@ -59,13 +59,13 @@
 #include "DiskIO/DiskIOStrategy.h"
 #include "StoreIOState.h"
 
 class DiskFile;
 
 class DiskdFile;
-
+class Lock;
 class ReadRequest;
 
 /// \ingroup diskd
 class DiskdIOStrategy : public DiskIOStrategy
 {
 
@@ -77,14 +77,14 @@
     virtual bool unlinkdUseful() const;
     virtual void unlinkFile (char const *);
     virtual ConfigOption *getOptionTree() const;
     virtual void init();
     virtual void sync();
     virtual int callback();
-    virtual void statfs(StoreEntry & sentry)const;
-    int send(int mtype, int id, DiskdFile *theFile, size_t size, off_t offset, ssize_t shm_offset, RefCountable_ *requestor);
+    virtual void statfs(StoreEntry & sentry) const;
+    int send(int mtype, int id, DiskdFile *theFile, size_t size, off_t offset, ssize_t shm_offset, Lock *requestor);
 
     /** public for accessing return address's */
     SharedMemory shm;
 
 private:
     static size_t newInstance();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskFile.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskFile.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskFile.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskFile.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,16 +28,15 @@
  * Copyright (c) 2003 Robert Collins <robertc@squid-cache.org>
  */
 
 #ifndef SQUID_DISKFILE_H
 #define SQUID_DISKFILE_H
 
+#include "base/RefCount.h"
 #include "typedefs.h"
 
-#include "RefCount.h"
-
 class IORequestor;
 
 class ReadRequest;
 
 class WriteRequest;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskIOModule.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskIOModule.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskIOModule.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskIOModule.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,13 +29,13 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #ifndef SQUID_DISKIOMODULE_H
 #define SQUID_DISKIOMODULE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* forward decls */
 
 class CacheManager;
 
 class DiskIOStrategy;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskIOStrategy.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskIOStrategy.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskIOStrategy.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskIOStrategy.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,14 +28,14 @@
  * Copyright (c) 2003 Robert Collins <robertc@squid-cache.org>
  */
 
 #ifndef SQUID_DISKIOSTRATEGY_H
 #define SQUID_DISKIOSTRATEGY_H
 
+#include "base/RefCount.h"
 #include "Store.h"
-#include "RefCount.h"
 
 class DiskFile;
 
 class ConfigOption;
 
 class DiskIOStrategy
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskThreads/aiops_win32.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskThreads/aiops_win32.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskThreads/aiops_win32.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskThreads/aiops_win32.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,13 +30,12 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #include "squid.h"
-#include "squid_windows.h"
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "DiskThreads.h"
 #include "fd.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskThreads/DiskThreadsDiskFile.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskThreads/DiskThreadsDiskFile.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskThreads/DiskThreadsDiskFile.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskThreads/DiskThreadsDiskFile.cc	2015-05-01 18:05:19.000000000 +0800
@@ -47,32 +47,12 @@
 #include <errno.h>
 #endif
 
 /* === PUBLIC =========================================================== */
 
 CBDATA_CLASS_INIT(DiskThreadsDiskFile);
-void *
-DiskThreadsDiskFile::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(DiskThreadsDiskFile);
-    DiskThreadsDiskFile *result = cbdataAlloc(DiskThreadsDiskFile);
-    /*
-     * We used to call squidaio_init() here, but if the first transaction
-     * is to unlink a file (e.g., if Squid starts up over the disk space
-     * limit) then "squidaio" won't be initialized yet.
-     */
-
-    return result;
-}
-
-void
-DiskThreadsDiskFile::operator delete(void *address)
-{
-    DiskThreadsDiskFile *t = static_cast<DiskThreadsDiskFile *>(address);
-    cbdataFree(t);
-}
 
 DiskThreadsDiskFile::DiskThreadsDiskFile(char const *aPath, DiskThreadsIOStrategy *anIO):fd(-1), errorOccured (false), IO(anIO),
         inProgressIOs (0)
 {
     assert (aPath);
     debugs(79, 3, "UFSFile::UFSFile: " << aPath);
@@ -371,22 +351,6 @@
 }
 
 /** \cond AUTODOCS-IGNORE */
 template <class RT>
 cbdata_type IoResult<RT>::CBDATA_IoResult = CBDATA_UNKNOWN;
 /** \endcond */
-
-template<class RT>
-void *
-IoResult<RT>::operator new(size_t unused)
-{
-    CBDATA_INIT_TYPE(IoResult);
-    IoResult<RT> *result = cbdataAlloc(IoResult);
-    return result;
-}
-
-template <class RT>
-void
-IoResult<RT>::operator delete(void *address)
-{
-    cbdataFree(address);
-}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskThreads/DiskThreadsDiskFile.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskThreads/DiskThreadsDiskFile.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskThreads/DiskThreadsDiskFile.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskThreads/DiskThreadsDiskFile.h	2015-05-01 18:05:19.000000000 +0800
@@ -38,14 +38,12 @@
 #include "DiskThreads.h"
 
 class DiskThreadsDiskFile : public DiskFile
 {
 
 public:
-    void * operator new(size_t);
-    void operator delete(void *);
     DiskThreadsDiskFile(char const *path, DiskThreadsIOStrategy *);
     ~DiskThreadsDiskFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void create(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void read(ReadRequest *);
     virtual void write(WriteRequest *);
@@ -83,31 +81,29 @@
     RefCount<IORequestor> ioRequestor;
     void doClose();
 
     void readDone(int fd, const char *buf, int len, int errflag, RefCount<ReadRequest> request);
     void writeDone(int fd, int errflag, size_t len, RefCount<WriteRequest> request);
 
-    CBDATA_CLASS(DiskThreadsDiskFile);
+    CBDATA_CLASS2(DiskThreadsDiskFile);
 };
 
 #include "DiskIO/ReadRequest.h"
 
 template <class RT>
 class IoResult
 {
 
 public:
-    void * operator new (size_t);
-    void operator delete (void *);
     IoResult(RefCount<DiskThreadsDiskFile> aFile, RefCount<RT> aRequest) : file(aFile), request(aRequest) {}
 
     RefCount<DiskThreadsDiskFile> file;
     RefCount<RT> request;
 
 private:
-    CBDATA_CLASS(IoResult);
+    CBDATA_CLASS2(IoResult);
 };
 
 template <class RT>
 IoResult<RT>
 IOResult(RefCount<RT> aRequest, RefCount<DiskThreadsDiskFile> aFile) { return IoResult<RT>(aFile, aRequest);}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskThreads/DiskThreads.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskThreads/DiskThreads.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/DiskThreads/DiskThreads.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/DiskThreads/DiskThreads.h	2015-05-01 18:05:19.000000000 +0800
@@ -7,12 +7,18 @@
 #ifndef __DISKTHREADS_H__
 #define __DISKTHREADS_H__
 
 #include "dlink.h"
 #include "typedefs.h"
 
+/* this non-standard-conformant include is needed in order to have stat(2) and struct stat
+   properly defined on some systems (e.g. OpenBSD 5.4) */
+#if HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+
 #if AUFS_IO_THREADS
 #define NUMTHREADS AUFS_IO_THREADS
 #else
 #define NUMTHREADS (Config.cacheSwap.n_configured*16)
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/IORequestor.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/IORequestor.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/IORequestor.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/IORequestor.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,13 +29,13 @@
  * Copyright (c) 2003 Robert Collins <robertc@squid-cache.org>
  */
 
 #ifndef SQUID_IOREQUESTOR_H
 #define SQUID_IOREQUESTOR_H
 
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 class ReadRequest;
 
 class WriteRequest;
 
 class IORequestor : public RefCountable
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/IpcIo/IpcIoFile.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/IpcIo/IpcIoFile.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/IpcIo/IpcIoFile.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/IpcIo/IpcIoFile.cc	2015-05-01 18:05:19.000000000 +0800
@@ -298,33 +298,38 @@
 {
     return !olderRequests->empty() || !newerRequests->empty();
 }
 
 /// track a new pending request
 void
-IpcIoFile::trackPendingRequest(IpcIoPendingRequest *const pending)
+IpcIoFile::trackPendingRequest(const unsigned int id, IpcIoPendingRequest *const pending)
 {
-    newerRequests->insert(std::make_pair(lastRequestId, pending));
+    const std::pair<RequestMap::iterator,bool> result =
+        newerRequests->insert(std::make_pair(id, pending));
+    Must(result.second); // failures means that id was not unique
     if (!timeoutCheckScheduled)
         scheduleTimeoutCheck();
 }
 
 /// push an I/O request to disker
 void
 IpcIoFile::push(IpcIoPendingRequest *const pending)
 {
     // prevent queue overflows: check for responses to earlier requests
+    // warning: this call may result in indirect push() recursion
     HandleResponses("before push");
 
     debugs(47, 7, HERE);
     Must(diskId >= 0);
     Must(pending);
     Must(pending->readRequest || pending->writeRequest);
 
     IpcIoMsg ipcIo;
     try {
+        if (++lastRequestId == 0) // don't use zero value as requestId
+            ++lastRequestId;
         ipcIo.requestId = lastRequestId;
         ipcIo.start = current_time;
         if (pending->readRequest) {
             ipcIo.command = IpcIo::cmdRead;
             ipcIo.offset = pending->readRequest->offset;
             ipcIo.len = pending->readRequest->len;
@@ -342,13 +347,13 @@
         }
 
         debugs(47, 7, HERE << "pushing " << SipcIo(KidIdentifier, ipcIo, diskId));
 
         if (queue->push(diskId, ipcIo))
             Notify(diskId); // must notify disker
-        trackPendingRequest(pending);
+        trackPendingRequest(ipcIo.requestId, pending);
     } catch (const Queue::Full &) {
         debugs(47, DBG_IMPORTANT, "Worker I/O push queue overflow: " <<
                SipcIo(KidIdentifier, ipcIo, diskId)); // TODO: report queue len
         // TODO: grow queue size
 
         pending->completeIo(NULL);
@@ -600,15 +605,12 @@
 
 /* IpcIoPendingRequest */
 
 IpcIoPendingRequest::IpcIoPendingRequest(const IpcIoFile::Pointer &aFile):
         file(aFile), readRequest(NULL), writeRequest(NULL)
 {
-    Must(file != NULL);
-    if (++file->lastRequestId == 0) // don't use zero value as requestId
-        ++file->lastRequestId;
 }
 
 void
 IpcIoPendingRequest::completeIo(IpcIoMsg *const response)
 {
     if (readRequest)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/IpcIo/IpcIoFile.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/IpcIo/IpcIoFile.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/IpcIo/IpcIoFile.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/IpcIo/IpcIoFile.h	2015-05-01 18:05:19.000000000 +0800
@@ -82,13 +82,13 @@
     void openCompleted(const Ipc::StrandSearchResponse *const response);
     void readCompleted(ReadRequest *readRequest, IpcIoMsg *const response);
     void writeCompleted(WriteRequest *writeRequest, const IpcIoMsg *const response);
     bool canWait() const;
 
 private:
-    void trackPendingRequest(IpcIoPendingRequest *const pending);
+    void trackPendingRequest(const unsigned int id, IpcIoPendingRequest *const pending);
     void push(IpcIoPendingRequest *const pending);
     IpcIoPendingRequest *dequeueRequest(const unsigned int requestId);
 
     static void Notify(const int peerId);
 
     static void OpenTimeout(void *const param);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/Mmapped/MmappedFile.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/Mmapped/MmappedFile.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/Mmapped/MmappedFile.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/Mmapped/MmappedFile.cc	2015-05-01 18:05:19.000000000 +0800
@@ -46,29 +46,12 @@
     const off_t offset; ///< user-requested data offset
 
     off_t delta; ///< mapped buffer increment to hit user offset
     void *buf; ///< buffer returned by mmap, needed for munmap
 };
 
-void *
-MmappedFile::operator new(size_t sz)
-{
-    CBDATA_INIT_TYPE(MmappedFile);
-    MmappedFile *result = cbdataAlloc(MmappedFile);
-    /* Mark result as being owned - we want the refcounter to do the delete
-     * call */
-    return result;
-}
-
-void
-MmappedFile::operator delete(void *address)
-{
-    MmappedFile *t = static_cast<MmappedFile *>(address);
-    cbdataFree(t);
-}
-
 MmappedFile::MmappedFile(char const *aPath): fd(-1),
         minOffset(0), maxOffset(-1), error_(false)
 {
     assert(aPath);
     path_ = xstrdup(aPath);
     debugs(79,5, HERE << this << ' ' << path_);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/Mmapped/MmappedFile.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/Mmapped/MmappedFile.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/Mmapped/MmappedFile.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/Mmapped/MmappedFile.h	2015-05-01 18:05:19.000000000 +0800
@@ -6,14 +6,12 @@
 #include "DiskIO/IORequestor.h"
 
 class MmappedFile : public DiskFile
 {
 
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
     MmappedFile(char const *path);
     ~MmappedFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void create(int flags, mode_t mode, RefCount<IORequestor> callback);
     virtual void read(ReadRequest *);
     virtual void write(WriteRequest *);
@@ -37,10 +35,10 @@
     int64_t maxOffset; ///< enforced if not negative (to avoid crashes)
 
     bool error_;
 
     void doClose();
 
-    CBDATA_CLASS(MmappedFile);
+    CBDATA_CLASS2(MmappedFile);
 };
 
 #endif /* SQUID_MMAPPEDFILE_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/ReadRequest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/ReadRequest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/ReadRequest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/ReadRequest.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,14 +29,14 @@
  * Copyright (c) 2003 Robert Collins <robertc@squid-cache.org>
  */
 
 #ifndef SQUID_READREQUEST_H
 #define SQUID_READREQUEST_H
 
+#include "base/RefCount.h"
 #include "cbdata.h"
-#include "RefCount.h"
 
 class ReadRequest : public RefCountable
 {
 
 public:
     typedef RefCount<ReadRequest> Pointer;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/WriteRequest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/WriteRequest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/DiskIO/WriteRequest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/DiskIO/WriteRequest.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,14 +29,14 @@
  * Copyright (c) 2003 Robert Collins <robertc@squid-cache.org>
  */
 
 #ifndef SQUID_WRITEREQUEST_H
 #define SQUID_WRITEREQUEST_H
 
+#include "base/RefCount.h"
 #include "cbdata.h"
-#include "RefCount.h"
 
 class WriteRequest : public RefCountable
 {
 
 public:
     typedef RefCount<WriteRequest> Pointer;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/dns.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/dns.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/dns.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/dns.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,12 +30,13 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #include "squid.h"
 #include "helper.h"
+#include "HelperReply.h"
 #include "mgr/Registration.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "wordlist.h"
 
@@ -130,14 +131,21 @@
 
         if (squid_curtime - first_warn > 3 * 60)
             fatal("DNS servers not responding for 3 minutes");
 
         debugs(34, DBG_IMPORTANT, "dnsSubmit: queue overload, rejecting " << lookup);
 
-        callback(data, (char *)"$fail Temporary network problem, please retry later");
-
+        const char *t = "$fail Temporary network problem, please retry later";
+        HelperReply failReply;
+        /* XXX: upgrade the ipcache and fqdn cache handlers to new syntax
+        failReply.result= HelperReply::BrokenHelper;
+        failReply.notes.add("message","Temporary network problem, please retry later");
+        failReply.notes.add("message","DNS lookup queue overloaded");
+        */
+        failReply.modifiableOther().append(t, strlen(t));
+        callback(data, failReply);
         return;
     }
 
     first_warn = 0;
     helperSubmit(dnsservers, buf, callback, data);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/dns_internal.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/dns_internal.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/dns_internal.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/dns_internal.cc	2015-05-01 18:05:19.000000000 +0800
@@ -34,12 +34,13 @@
 #include "base/InstanceId.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "comm.h"
 #include "comm/Loops.h"
 #include "comm/Write.h"
+#include "dlink.h"
 #include "event.h"
 #include "fd.h"
 #include "fde.h"
 #include "ip/tools.h"
 #include "Mem.h"
 #include "MemBuf.h"
@@ -69,13 +70,12 @@
 /* MS Visual Studio Projects are monolithic, so we need the following
    #ifndef to exclude the internal DNS code from compile process when
    using external DNS process.
  */
 #if !USE_DNSHELPER
 #if _SQUID_WINDOWS_
-#include "squid_windows.h"
 #define REG_TCPIP_PARA_INTERFACES "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces"
 #define REG_TCPIP_PARA "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters"
 #define REG_VXD_MSTCP "SYSTEM\\CurrentControlSet\\Services\\VxD\\MSTCP"
 #endif
 #ifndef _PATH_RESCONF
 #define _PATH_RESCONF "/etc/resolv.conf"
@@ -139,12 +139,13 @@
     ssize_t sz;
     unsigned short query_id; /// random query ID sent to server; changes with every query sent
     InstanceId<idns_query> xact_id; /// identifies our "transaction", stays constant when query is retried
 
     int nsends;
     int need_vc;
+    bool permit_mdns;
     int pending;
 
     struct timeval start_t;
     struct timeval sent_t;
     struct timeval queue_t;
     dlink_node lru;
@@ -177,12 +178,13 @@
     Ip::Address S;
     int nqueries;
     int nreplies;
 #if WHEN_EDNS_RESPONSES_ARE_PARSED
     int last_seen_edns;
 #endif
+    bool mDNSResolver;
     nsvc *vc;
 };
 
 struct _sp {
     char domain[NS_MAXDNAME];
     int queries;
@@ -192,12 +194,13 @@
 CBDATA_TYPE(idns_query);
 
 static ns *nameservers = NULL;
 static sp *searchpath = NULL;
 static int nns = 0;
 static int nns_alloc = 0;
+static int nns_mdns_count = 0;
 static int npc = 0;
 static int npc_alloc = 0;
 static int ndots = 1;
 static dlink_list lru_list;
 static int event_queued = 0;
 static hash_table *idns_lookup_hash = NULL;
@@ -229,21 +232,22 @@
 #if WHEN_EDNS_RESPONSES_ARE_PARSED
 static int max_shared_edns = RFC1035_DEFAULT_PACKET_SZ;
 #endif
 
 static OBJH idnsStats;
 static void idnsAddNameserver(const char *buf);
+static void idnsAddMDNSNameservers();
 static void idnsAddPathComponent(const char *buf);
 static void idnsFreeNameservers(void);
 static void idnsFreeSearchpath(void);
-static void idnsParseNameservers(void);
-#if !_SQUID_WINDOWS_
-static void idnsParseResolvConf(void);
+static bool idnsParseNameservers(void);
+#if _SQUID_WINDOWS_
+static bool idnsParseResolvConf(void);
 #endif
 #if _SQUID_WINDOWS_
-static void idnsParseWIN32Registry(void);
+static bool idnsParseWIN32Registry(void);
 static void idnsParseWIN32SearchList(const char *);
 #endif
 static void idnsStartQuery(idns_query * q, IDNSCB * callback, void *data);
 static void idnsSendQuery(idns_query * q);
 static IOCB idnsReadVCHeader;
 static void idnsDoSendQueryVC(nsvc *vc);
@@ -260,28 +264,64 @@
 static void idnsRcodeCount(int, int);
 static CLCB idnsVCClosed;
 static unsigned short idnsQueryID(void);
 static void idnsSendSlaveAAAAQuery(idns_query *q);
 
 static void
+idnsCheckMDNS(idns_query *q)
+{
+    if (!Config.onoff.dns_mdns || q->permit_mdns)
+        return;
+
+    size_t slen = strlen(q->name);
+    if (slen > 6 && memcmp(q->name +(slen-6),".local", 6) == 0) {
+        q->permit_mdns = true;
+    }
+}
+
+static void
+idnsAddMDNSNameservers()
+{
+    nns_mdns_count=0;
+
+    // mDNS is disabled
+    if (!Config.onoff.dns_mdns)
+        return;
+
+    // mDNS resolver addresses are explicit multicast group IPs
+    if (Ip::EnableIpv6) {
+        idnsAddNameserver("FF02::FB");
+        nameservers[nns-1].S.port(5353);
+        nameservers[nns-1].mDNSResolver = true;
+        ++nns_mdns_count;
+    }
+
+    idnsAddNameserver("224.0.0.251");
+    nameservers[nns-1].S.port(5353);
+    nameservers[nns-1].mDNSResolver = true;
+
+    ++nns_mdns_count;
+}
+
+static void
 idnsAddNameserver(const char *buf)
 {
     Ip::Address A;
 
     if (!(A = buf)) {
         debugs(78, DBG_CRITICAL, "WARNING: rejecting '" << buf << "' as a name server, because it is not a numeric IP address");
         return;
     }
 
-    if (A.IsAnyAddr()) {
+    if (A.isAnyAddr()) {
         debugs(78, DBG_CRITICAL, "WARNING: Squid does not accept " << A << " in DNS server specifications.");
-        A.SetLocalhost();
+        A.setLocalhost();
         debugs(78, DBG_CRITICAL, "Will be using " << A << " instead, assuming you meant that DNS is running on the same machine");
     }
 
-    if (!Ip::EnableIpv6 && !A.SetIPv4()) {
+    if (!Ip::EnableIpv6 && !A.setIPv4()) {
         debugs(78, DBG_IMPORTANT, "WARNING: IPv6 is disabled. Discarding " << A << " in DNS server specifications.");
         return;
     }
 
     if (nns == nns_alloc) {
         int oldalloc = nns_alloc;
@@ -299,13 +339,13 @@
 
         if (oldptr)
             safe_free(oldptr);
     }
 
     assert(nns < nns_alloc);
-    A.SetPort(NS_DEFAULTPORT);
+    A.port(NS_DEFAULTPORT);
     nameservers[nns].S = A;
 #if WHEN_EDNS_RESPONSES_ARE_PARSED
     nameservers[nns].last_seen_edns = RFC1035_DEFAULT_PACKET_SZ;
     // TODO generate a test packet to probe this NS from EDNS size and ability.
 #endif
     debugs(78, 3, "idnsAddNameserver: Added nameserver #" << nns << " (" << A << ")");
@@ -352,78 +392,81 @@
 idnsFreeSearchpath(void)
 {
     safe_free(searchpath);
     npc = npc_alloc = 0;
 }
 
-static void
+static bool
 idnsParseNameservers(void)
 {
-    wordlist *w;
-
-    for (w = Config.dns_nameservers; w; w = w->next) {
+    bool result = false;
+    for (wordlist *w = Config.dns_nameservers; w; w = w->next) {
         debugs(78, DBG_IMPORTANT, "Adding nameserver " << w->key << " from squid.conf");
         idnsAddNameserver(w->key);
+        result = true;
     }
+    return result;
 }
 
 #if !_SQUID_WINDOWS_
-static void
+static bool
 idnsParseResolvConf(void)
 {
     FILE *fp;
     char buf[RESOLV_BUFSZ];
     const char *t;
+    bool result = false;
     fp = fopen(_PATH_RESCONF, "r");
 
     if (fp == NULL) {
         debugs(78, DBG_IMPORTANT, "" << _PATH_RESCONF << ": " << xstrerror());
-        return;
+        return false;
     }
 
 #if _SQUID_CYGWIN_
     setmode(fileno(fp), O_TEXT);
 #endif
 
     while (fgets(buf, RESOLV_BUFSZ, fp)) {
         t = strtok(buf, w_space);
 
         if (NULL == t) {
             continue;
-        } else if (strcasecmp(t, "nameserver") == 0) {
+        } else if (strcmp(t, "nameserver") == 0) {
             t = strtok(NULL, w_space);
 
             if (NULL == t)
                 continue;
 
             debugs(78, DBG_IMPORTANT, "Adding nameserver " << t << " from " << _PATH_RESCONF);
 
             idnsAddNameserver(t);
-        } else if (strcasecmp(t, "domain") == 0) {
+            result = true;
+        } else if (strcmp(t, "domain") == 0) {
             idnsFreeSearchpath();
             t = strtok(NULL, w_space);
 
             if (NULL == t)
                 continue;
 
             debugs(78, DBG_IMPORTANT, "Adding domain " << t << " from " << _PATH_RESCONF);
 
             idnsAddPathComponent(t);
-        } else if (strcasecmp(t, "search") == 0) {
+        } else if (strcmp(t, "search") == 0) {
             idnsFreeSearchpath();
             while (NULL != t) {
                 t = strtok(NULL, w_space);
 
                 if (NULL == t)
                     continue;
 
                 debugs(78, DBG_IMPORTANT, "Adding domain " << t << " from " << _PATH_RESCONF);
 
                 idnsAddPathComponent(t);
             }
-        } else if (strcasecmp(t, "options") == 0) {
+        } else if (strcmp(t, "options") == 0) {
             while (NULL != t) {
                 t = strtok(NULL, w_space);
 
                 if (NULL == t)
                     continue;
 
@@ -442,12 +485,13 @@
         t = strchr(t, '.');
         if (t)
             idnsAddPathComponent(t+1);
     }
 
     fclose(fp);
+    return result;
 }
 
 #endif
 
 #if _SQUID_WINDOWS_
 static void
@@ -491,18 +535,19 @@
         t = strchr(t, '.');
         if (t)
             idnsAddPathComponent(t + 1);
     }
 }
 
-static void
+static bool
 idnsParseWIN32Registry(void)
 {
     char *t;
     char *token;
     HKEY hndKey, hndKey2;
+    bool result = false;
 
     switch (WIN32_OS_version) {
 
     case _WIN_OS_WINNT:
         /* get nameservers from the Windows NT registry */
 
@@ -516,12 +561,13 @@
                 t = (char *) xmalloc(Size);
                 RegQueryValueEx(hndKey, "DhcpNameServer", NULL, &Type, (LPBYTE) t, &Size);
                 token = strtok(t, ", ");
 
                 while (token) {
                     idnsAddNameserver(token);
+                    result = true;
                     debugs(78, DBG_IMPORTANT, "Adding DHCP nameserver " << token << " from Registry");
                     token = strtok(NULL, ",");
                 }
                 xfree(t);
             }
 
@@ -532,12 +578,13 @@
                 RegQueryValueEx(hndKey, "NameServer", NULL, &Type, (LPBYTE) t, &Size);
                 token = strtok(t, ", ");
 
                 while (token) {
                     debugs(78, DBG_IMPORTANT, "Adding nameserver " << token << " from Registry");
                     idnsAddNameserver(token);
+                    result = true;
                     token = strtok(NULL, ", ");
                 }
                 xfree(t);
             }
 
             RegCloseKey(hndKey);
@@ -585,12 +632,13 @@
                                 t = (char *) xmalloc(Size);
                                 RegQueryValueEx(hndKey2, "DhcpNameServer", NULL, &Type, (LPBYTE)t, &Size);
                                 token = strtok(t, ", ");
                                 while (token) {
                                     debugs(78, DBG_IMPORTANT, "Adding DHCP nameserver " << token << " from Registry");
                                     idnsAddNameserver(token);
+                                    result = true;
                                     token = strtok(NULL, ", ");
                                 }
                                 xfree(t);
                             }
 
                             Result = RegQueryValueEx(hndKey2, "NameServer", NULL, &Type, NULL, &Size);
@@ -598,12 +646,13 @@
                                 t = (char *) xmalloc(Size);
                                 RegQueryValueEx(hndKey2, "NameServer", NULL, &Type, (LPBYTE)t, &Size);
                                 token = strtok(t, ", ");
                                 while (token) {
                                     debugs(78, DBG_IMPORTANT, "Adding nameserver " << token << " from Registry");
                                     idnsAddNameserver(token);
+                                    result = true;
                                     token = strtok(NULL, ", ");
                                 }
 
                                 xfree(t);
                             }
 
@@ -642,26 +691,28 @@
                 RegQueryValueEx(hndKey, "NameServer", NULL, &Type, (LPBYTE) t, &Size);
                 token = strtok(t, ", ");
 
                 while (token) {
                     debugs(78, DBG_IMPORTANT, "Adding nameserver " << token << " from Registry");
                     idnsAddNameserver(token);
+                    result = true;
                     token = strtok(NULL, ", ");
                 }
                 xfree(t);
             }
 
             RegCloseKey(hndKey);
         }
 
         break;
 
     default:
         debugs(78, DBG_IMPORTANT, "Failed to read nameserver from Registry: Unknown System Type.");
-        return;
     }
+
+    return result;
 }
 
 #endif
 
 static void
 idnsStats(StoreEntry * sentry)
@@ -671,37 +722,40 @@
     int i;
     int j;
     char buf[MAX_IPSTRLEN];
     storeAppendPrintf(sentry, "Internal DNS Statistics:\n");
     storeAppendPrintf(sentry, "\nThe Queue:\n");
     storeAppendPrintf(sentry, "                       DELAY SINCE\n");
-    storeAppendPrintf(sentry, "  ID   SIZE SENDS FIRST SEND LAST SEND\n");
-    storeAppendPrintf(sentry, "------ ---- ----- ---------- ---------\n");
+    storeAppendPrintf(sentry, "  ID   SIZE SENDS FIRST SEND LAST SEND M FQDN\n");
+    storeAppendPrintf(sentry, "------ ---- ----- ---------- --------- - ----\n");
 
     for (n = lru_list.head; n; n = n->next) {
         q = (idns_query *)n->data;
-        storeAppendPrintf(sentry, "%#06x %4d %5d %10.3f %9.3f\n",
+        storeAppendPrintf(sentry, "%#06x %4d %5d %10.3f %9.3f %c %s\n",
                           (int) q->query_id, (int) q->sz, q->nsends,
                           tvSubDsec(q->start_t, current_time),
-                          tvSubDsec(q->sent_t, current_time));
+                          tvSubDsec(q->sent_t, current_time),
+                          (q->permit_mdns? 'M':' '),
+                          q->name);
     }
 
     if (Config.dns.packet_max > 0)
-        storeAppendPrintf(sentry, "DNS jumbo-grams: %zd Bytes\n", Config.dns.packet_max);
+        storeAppendPrintf(sentry, "\nDNS jumbo-grams: %zd Bytes\n", Config.dns.packet_max);
     else
-        storeAppendPrintf(sentry, "DNS jumbo-grams: not working\n");
+        storeAppendPrintf(sentry, "\nDNS jumbo-grams: not working\n");
 
     storeAppendPrintf(sentry, "\nNameservers:\n");
-    storeAppendPrintf(sentry, "IP ADDRESS                                     # QUERIES # REPLIES\n");
-    storeAppendPrintf(sentry, "---------------------------------------------- --------- ---------\n");
+    storeAppendPrintf(sentry, "IP ADDRESS                                     # QUERIES # REPLIES Type\n");
+    storeAppendPrintf(sentry, "---------------------------------------------- --------- --------- --------\n");
 
     for (i = 0; i < nns; ++i) {
-        storeAppendPrintf(sentry, "%-45s %9d %9d\n",  /* Let's take the maximum: (15 IPv4/45 IPv6) */
-                          nameservers[i].S.NtoA(buf,MAX_IPSTRLEN),
+        storeAppendPrintf(sentry, "%-45s %9d %9d %s\n",  /* Let's take the maximum: (15 IPv4/45 IPv6) */
+                          nameservers[i].S.toStr(buf,MAX_IPSTRLEN),
                           nameservers[i].nqueries,
-                          nameservers[i].nreplies);
+                          nameservers[i].nreplies,
+                          nameservers[i].mDNSResolver?"multicast":"recurse");
     }
 
     storeAppendPrintf(sentry, "\nRcode Matrix:\n");
     storeAppendPrintf(sentry, "RCODE");
 
     for (i = 0; i < MAX_ATTEMPT; ++i)
@@ -806,13 +860,13 @@
 {
     nsvc * vc = (nsvc *)data;
 
     if (status != COMM_OK || !conn) {
         char buf[MAX_IPSTRLEN] = "";
         if (vc->ns < nns)
-            nameservers[vc->ns].S.NtoA(buf,MAX_IPSTRLEN);
+            nameservers[vc->ns].S.toStr(buf,MAX_IPSTRLEN);
         debugs(78, DBG_IMPORTANT, HERE << "Failed to connect to nameserver " << buf << " using TCP.");
         return;
     }
 
     vc->conn = conn;
 
@@ -834,55 +888,55 @@
     if (vc->ns < nns) // XXX: dnsShutdown may have freed nameservers[]
         nameservers[vc->ns].vc = NULL;
     cbdataFree(vc);
 }
 
 static void
-idnsInitVC(int ns)
+idnsInitVC(int nsv)
 {
     nsvc *vc = cbdataAlloc(nsvc);
-    assert(ns < nns);
+    assert(nsv < nns);
     assert(vc->conn == NULL); // MUST be NULL from the construction process!
-    nameservers[ns].vc = vc;
-    vc->ns = ns;
+    nameservers[nsv].vc = vc;
+    vc->ns = nsv;
     vc->queue = new MemBuf;
     vc->msg = new MemBuf;
     vc->busy = 1;
 
     Comm::ConnectionPointer conn = new Comm::Connection();
 
-    if (!Config.Addrs.udp_outgoing.IsNoAddr())
+    if (!Config.Addrs.udp_outgoing.isNoAddr())
         conn->local = Config.Addrs.udp_outgoing;
     else
         conn->local = Config.Addrs.udp_incoming;
 
-    conn->remote = nameservers[ns].S;
+    conn->remote = nameservers[nsv].S;
 
-    if (conn->remote.IsIPv4()) {
-        conn->local.SetIPv4();
+    if (conn->remote.isIPv4()) {
+        conn->local.setIPv4();
     }
 
     AsyncCall::Pointer call = commCbCall(78,3, "idnsInitVCConnected", CommConnectCbPtrFun(idnsInitVCConnected, vc));
 
     Comm::ConnOpener *cs = new Comm::ConnOpener(conn, call, Config.Timeout.connect);
     cs->setHost("DNS TCP Socket");
     AsyncJob::Start(cs);
 }
 
 static void
-idnsSendQueryVC(idns_query * q, int ns)
+idnsSendQueryVC(idns_query * q, int nsn)
 {
-    assert(ns < nns);
-    if (nameservers[ns].vc == NULL)
-        idnsInitVC(ns);
+    assert(nsn < nns);
+    if (nameservers[nsn].vc == NULL)
+        idnsInitVC(nsn);
 
-    nsvc *vc = nameservers[ns].vc;
+    nsvc *vc = nameservers[nsn].vc;
 
     if (!vc) {
         char buf[MAX_IPSTRLEN];
-        debugs(78, DBG_IMPORTANT, "idnsSendQuery: Failed to initiate TCP connection to nameserver " << nameservers[ns].S.NtoA(buf,MAX_IPSTRLEN) << "!");
+        debugs(78, DBG_IMPORTANT, "idnsSendQuery: Failed to initiate TCP connection to nameserver " << nameservers[nsn].S.toStr(buf,MAX_IPSTRLEN) << "!");
 
         return;
     }
 
     vc->queue->reset();
 
@@ -910,46 +964,50 @@
 
     assert(q->lru.next == NULL);
 
     assert(q->lru.prev == NULL);
 
     int x = -1, y = -1;
-    int ns;
+    int nsn;
 
     do {
-        ns = q->nsends % nns;
+        // only use mDNS resolvers for mDNS compatible queries
+        if (!q->permit_mdns)
+            nsn = nns_mdns_count + q->nsends % (nns-nns_mdns_count);
+        else
+            nsn = q->nsends % nns;
 
         if (q->need_vc) {
-            idnsSendQueryVC(q, ns);
+            idnsSendQueryVC(q, nsn);
             x = y = 0;
         } else {
-            if (DnsSocketB >= 0 && nameservers[ns].S.IsIPv6())
-                y = comm_udp_sendto(DnsSocketB, nameservers[ns].S, q->buf, q->sz);
+            if (DnsSocketB >= 0 && nameservers[nsn].S.isIPv6())
+                y = comm_udp_sendto(DnsSocketB, nameservers[nsn].S, q->buf, q->sz);
             else if (DnsSocketA >= 0)
-                x = comm_udp_sendto(DnsSocketA, nameservers[ns].S, q->buf, q->sz);
+                x = comm_udp_sendto(DnsSocketA, nameservers[nsn].S, q->buf, q->sz);
         }
 
         ++ q->nsends;
 
         q->sent_t = current_time;
 
-        if (y < 0 && nameservers[ns].S.IsIPv6())
+        if (y < 0 && nameservers[nsn].S.isIPv6())
             debugs(50, DBG_IMPORTANT, "idnsSendQuery: FD " << DnsSocketB << ": sendto: " << xstrerror());
-        if (x < 0 && nameservers[ns].S.IsIPv4())
+        if (x < 0 && nameservers[nsn].S.isIPv4())
             debugs(50, DBG_IMPORTANT, "idnsSendQuery: FD " << DnsSocketA << ": sendto: " << xstrerror());
 
     } while ( (x<0 && y<0) && q->nsends % nns != 0);
 
     if (y > 0) {
         fd_bytes(DnsSocketB, y, FD_WRITE);
     }
     if (x > 0) {
         fd_bytes(DnsSocketA, x, FD_WRITE);
     }
 
-    ++ nameservers[ns].nqueries;
+    ++ nameservers[nsn].nqueries;
     q->queue_t = current_time;
     dlinkAdd(q, &q->lru, &lru_list);
     q->pending = 1;
     idnsTickleQueue();
 }
 
@@ -959,13 +1017,13 @@
     int i;
 
     for (i = 0; i < nns; ++i) {
         if (nameservers[i].S != from)
             continue;
 
-        if (nameservers[i].S.GetPort() != from.GetPort())
+        if (nameservers[i].S.port() != from.port())
             continue;
 
         return i;
     }
 
     return -1;
@@ -1014,27 +1072,26 @@
     if (error)
         q->error = error;
 
     if (q->master)
         q = q->master;
 
-    idns_query *q2;
     // If any of our subqueries are still pending then wait for them to complete before continuing
-    for ( q2 = q; q2; q2 = q2->slave) {
+    for (idns_query *q2 = q; q2; q2 = q2->slave) {
         if (q2->pending) {
             return;
         }
     }
 
     /* Merge results */
     rfc1035_message *message = q->message;
     q->message = NULL;
     int n = q->ancount;
     error = q->error;
 
-    while ( (q2 = q->slave) ) {
+    while ( idns_query *q2 = q->slave ) {
         debugs(78, 6, HERE << "Merging DNS results " << q->name << " A has " << n << " RR, AAAA has " << q2->ancount << " RR");
         q->slave = q2->slave;
         if ( !q2->error ) {
             if (n > 0) {
                 // two sets of RR need merging
                 rfc1035_rr *result = (rfc1035_rr*) xmalloc( sizeof(rfc1035_rr)*(n + q2->ancount) );
@@ -1226,12 +1283,13 @@
                 idnsCallback(q, "Internal error");
                 return;
             }
 
             q->nsends = 0;
 
+            idnsCheckMDNS(q);
             idnsSendQuery(q);
             if (Ip::EnableIpv6)
                 idnsSendSlaveAAAAQuery(q);
             return;
         }
     }
@@ -1250,13 +1308,12 @@
 idnsRead(int fd, void *data)
 {
     int *N = &incoming_sockets_accepted;
     int len;
     int max = INCOMING_DNS_MAX;
     static char rbuf[SQUID_UDP_SO_RCVBUF];
-    int ns;
     Ip::Address from;
 
     debugs(78, 3, "idnsRead: starting with FD " << fd);
 
     // Always keep reading. This stops (or at least makes harder) several
     // attacks on the DNS client.
@@ -1302,36 +1359,36 @@
         assert(N);
         ++(*N);
 
         debugs(78, 3, "idnsRead: FD " << fd << ": received " << len << " bytes from " << from);
 
         /* BUG: see above. Its here that it becomes apparent that the content of bugbypass is gone. */
-        ns = idnsFromKnownNameserver(from);
+        int nsn = idnsFromKnownNameserver(from);
 
-        if (ns >= 0) {
-            ++ nameservers[ns].nreplies;
+        if (nsn >= 0) {
+            ++ nameservers[nsn].nreplies;
         }
 
         // Before unknown_nameservers check to avoid flooding cache.log on attacks,
         // but after the ++ above to keep statistics right.
         if (!lru_list.head)
             continue; // Don't process replies if there is no pending query.
 
-        if (ns < 0 && Config.onoff.ignore_unknown_nameservers) {
+        if (nsn < 0 && Config.onoff.ignore_unknown_nameservers) {
             static time_t last_warning = 0;
 
             if (squid_curtime - last_warning > 60) {
                 debugs(78, DBG_IMPORTANT, "WARNING: Reply from unknown nameserver " << from);
                 last_warning = squid_curtime;
             } else {
                 debugs(78, DBG_IMPORTANT, "WARNING: Reply from unknown nameserver " << from << " (retrying..." <<  (squid_curtime-last_warning) << "<=60)" );
             }
             continue;
         }
 
-        idnsGrokReply(rbuf, len, ns);
+        idnsGrokReply(rbuf, len, nsn);
     }
 }
 
 static void
 idnsCheckQueue(void *unused)
 {
@@ -1445,12 +1502,18 @@
     }
 
     vc->read_msglen = 0;
 
     vc->msglen = ntohs(vc->msglen);
 
+    if (!vc->msglen) {
+        if (Comm::IsConnOpen(conn))
+            conn->close();
+        return;
+    }
+
     vc->msg->init(vc->msglen, vc->msglen);
     AsyncCall::Pointer call = commCbCall(5,4, "idnsReadVC",
                                          CommIoCbPtrFun(idnsReadVC, vc));
     comm_read(conn, vc->msg->buf, vc->msglen, call);
 }
 
@@ -1486,30 +1549,30 @@
     CBDATA_INIT_TYPE(nsvc);
     CBDATA_INIT_TYPE(idns_query);
 
     if (DnsSocketA < 0 && DnsSocketB < 0) {
         Ip::Address addrV6; // since we don't want to alter Config.Addrs.udp_* and dont have one of our own.
 
-        if (!Config.Addrs.udp_outgoing.IsNoAddr())
+        if (!Config.Addrs.udp_outgoing.isNoAddr())
             addrV6 = Config.Addrs.udp_outgoing;
         else
             addrV6 = Config.Addrs.udp_incoming;
 
         Ip::Address addrV4 = addrV6;
-        addrV4.SetIPv4();
+        addrV4.setIPv4();
 
-        if (Ip::EnableIpv6 && addrV6.IsIPv6()) {
+        if (Ip::EnableIpv6 && addrV6.isIPv6()) {
             debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addrV6);
             DnsSocketB = comm_open_listener(SOCK_DGRAM,
                                             IPPROTO_UDP,
                                             addrV6,
                                             COMM_NONBLOCKING,
                                             "DNS Socket IPv6");
         }
 
-        if (addrV4.IsIPv4()) {
+        if (addrV4.isIPv4()) {
             debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addrV4);
             DnsSocketA = comm_open_listener(SOCK_DGRAM,
                                             IPPROTO_UDP,
                                             addrV4,
                                             COMM_NONBLOCKING,
                                             "DNS Socket IPv4");
@@ -1531,25 +1594,26 @@
             debugs(78, DBG_IMPORTANT, "DNS Socket created at " << addrV4 << ", FD " << DnsSocketA);
             Comm::SetSelect(DnsSocketA, COMM_SELECT_READ, idnsRead, NULL, 0);
         }
     }
 
     assert(0 == nns);
-    idnsParseNameservers();
+    idnsAddMDNSNameservers();
+    bool nsFound = idnsParseNameservers();
 #if !_SQUID_WINDOWS_
 
-    if (0 == nns)
-        idnsParseResolvConf();
+    if (!nsFound)
+        nsFound = idnsParseResolvConf();
 
 #endif
 #if _SQUID_WINDOWS_
-    if (0 == nns)
-        idnsParseWIN32Registry();
+    if (!nsFound)
+        nsFound = idnsParseWIN32Registry();
 #endif
 
-    if (0 == nns) {
+    if (!nsFound) {
         debugs(78, DBG_IMPORTANT, "Warning: Could not find any nameservers. Trying to use localhost");
 #if _SQUID_WINDOWS_
         debugs(78, DBG_IMPORTANT, "Please check your TCP-IP settings or /etc/resolv.conf file");
 #else
         debugs(78, DBG_IMPORTANT, "Please check your /etc/resolv.conf file");
 #endif
@@ -1659,12 +1723,13 @@
     debugs(78, 3, HERE << "buf is " << q->sz << " bytes for " << q->name <<
            ", id = 0x" << std::hex << q->query_id);
     if (!q->sz) {
         cbdataFree(q);
         return;
     }
+    idnsCheckMDNS(q);
     master->slave = q;
     idnsSendQuery(q);
 }
 
 void
 idnsALookup(const char *name, IDNSCB * callback, void *data)
@@ -1717,12 +1782,13 @@
         return;
     }
 
     debugs(78, 3, "idnsALookup: buf is " << q->sz << " bytes for " << q->name <<
            ", id = 0x" << std::hex << q->query_id);
 
+    idnsCheckMDNS(q);
     idnsStartQuery(q, callback, data);
 
     if (Ip::EnableIpv6)
         idnsSendSlaveAAAAQuery(q);
 
 }
@@ -1731,27 +1797,27 @@
 idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
 {
     idns_query *q;
 
     char ip[MAX_IPSTRLEN];
 
-    addr.NtoA(ip,MAX_IPSTRLEN);
+    addr.toStr(ip,MAX_IPSTRLEN);
 
     q = cbdataAlloc(idns_query);
 
     // idns_query is POD so no constructors are called after allocation
     q->xact_id.change();
     q->query_id = idnsQueryID();
 
-    if (addr.IsIPv6()) {
+    if (addr.isIPv6()) {
         struct in6_addr addr6;
-        addr.GetInAddr(addr6);
+        addr.getInAddr(addr6);
         q->sz = rfc3596BuildPTRQuery6(addr6, q->buf, sizeof(q->buf), q->query_id, &q->query, Config.dns.packet_max);
     } else {
         struct in_addr addr4;
-        addr.GetInAddr(addr4);
+        addr.getInAddr(addr4);
         // see EDNS notes at top of file why this sends 0
         q->sz = rfc3596BuildPTRQuery4(addr4, q->buf, sizeof(q->buf), q->query_id, &q->query, 0);
     }
 
     if (q->sz < 0) {
         /* problem with query data -- query not sent */
@@ -1765,12 +1831,13 @@
         return;
     }
 
     debugs(78, 3, "idnsPTRLookup: buf is " << q->sz << " bytes for " << ip <<
            ", id = 0x" << std::hex << q->query_id);
 
+    q->permit_mdns = Config.onoff.dns_mdns;
     idnsStartQuery(q, callback, data);
 }
 
 #if SQUID_SNMP
 /*
  * The function to return the DNS via SNMP
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/enums.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/enums.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/enums.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/enums.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,38 +29,12 @@
  *
  */
 
 #ifndef SQUID_ENUMS_H
 #define SQUID_ENUMS_H
 
-typedef enum {
-    LOG_TAG_NONE,
-    LOG_TCP_HIT,
-    LOG_TCP_MISS,
-    LOG_TCP_REFRESH_UNMODIFIED, // refresh from origin revalidated existing entry
-    LOG_TCP_REFRESH_FAIL_OLD,   // refresh from origin failed, stale reply sent
-    LOG_TCP_REFRESH_FAIL_ERR,   // refresh from origin failed, error forwarded
-    LOG_TCP_REFRESH_MODIFIED,   // refresh from origin replaced existing entry
-    LOG_TCP_CLIENT_REFRESH_MISS,
-    LOG_TCP_IMS_HIT,
-    LOG_TCP_SWAPFAIL_MISS,
-    LOG_TCP_NEGATIVE_HIT,
-    LOG_TCP_MEM_HIT,
-    LOG_TCP_DENIED,
-    LOG_TCP_DENIED_REPLY,
-    LOG_TCP_OFFLINE_HIT,
-    LOG_TCP_REDIRECT,
-    LOG_UDP_HIT,
-    LOG_UDP_MISS,
-    LOG_UDP_DENIED,
-    LOG_UDP_INVALID,
-    LOG_UDP_MISS_NOFETCH,
-    LOG_ICP_QUERY,
-    LOG_TYPE_MAX
-} log_type;
-
 enum fd_type {
     FD_NONE,
     FD_LOG,
     FD_FILE,
     FD_SOCKET,
     FD_PIPE,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/errorpage.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/errorpage.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/errorpage.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/errorpage.cc	2015-05-01 18:05:19.000000000 +0800
@@ -84,13 +84,13 @@
 /* local types */
 
 /// \ingroup ErrorPageInternal
 typedef struct {
     int id;
     char *page_name;
-    http_status page_redirect;
+    Http::StatusCode page_redirect;
 } ErrorDynamicPageInfo;
 
 /* local constant and vars */
 
 /**
  \ingroup ErrorPageInternal
@@ -207,13 +207,13 @@
              * Index any unknown file names used by deny_info.
              */
             ErrorDynamicPageInfo *info = ErrorDynamicPages.items[i - ERR_MAX];
             assert(info && info->id == i && info->page_name);
 
             const char *pg = info->page_name;
-            if (info->page_redirect != HTTP_STATUS_NONE)
+            if (info->page_redirect != Http::scNone)
                 pg = info->page_name +4;
 
             if (strchr(pg, ':') == NULL) {
                 /** But only if they are not redirection URL. */
                 ErrorPageFile errTmpl(pg, ERR_MAX);
                 error_text[i] = errTmpl.loadDefault() ? xstrdup(errTmpl.text()) : NULL;
@@ -428,13 +428,13 @@
             return true;
     }
     return false;
 }
 
 bool
-TemplateFile::loadFor(HttpRequest *request)
+TemplateFile::loadFor(const HttpRequest *request)
 {
     String hdr;
 
 #if USE_ERR_LOCALES
     if (loaded()) // already loaded?
         return true;
@@ -474,26 +474,26 @@
 static ErrorDynamicPageInfo *
 errorDynamicPageInfoCreate(int id, const char *page_name)
 {
     ErrorDynamicPageInfo *info = new ErrorDynamicPageInfo;
     info->id = id;
     info->page_name = xstrdup(page_name);
-    info->page_redirect = static_cast<http_status>(atoi(page_name));
+    info->page_redirect = static_cast<Http::StatusCode>(atoi(page_name));
 
     /* WARNING on redirection status:
      * 2xx are permitted, but not documented officially.
      * - might be useful for serving static files (PAC etc) in special cases
      * 3xx require a URL suitable for Location: header.
      * - the current design does not allow for a Location: URI as well as a local file template
      *   although this possibility is explicitly permitted in the specs.
      * 4xx-5xx require a local file template.
      * - sending Location: on these codes with no body is invalid by the specs.
      * - current result is Squid crashing or XSS problems as dynamic deny_info load random disk files.
      * - a future redesign of the file loading may result in loading remote objects sent inline as local body.
      */
-    if (info->page_redirect == HTTP_STATUS_NONE)
+    if (info->page_redirect == Http::scNone)
         ; // special case okay.
     else if (info->page_redirect < 200 || info->page_redirect > 599) {
         // out of range
         debugs(0, DBG_CRITICAL, "FATAL: status " << info->page_redirect << " is not valid on '" << page_name << "'");
         self_destruct();
     } else if ( /* >= 200 && */ info->page_redirect < 300 && strchr(&(page_name[4]), ':')) {
@@ -565,13 +565,13 @@
     if (pageId >= ERR_MAX && pageId - ERR_MAX < (ssize_t)ErrorDynamicPages.size())
         return ErrorDynamicPages.items[pageId - ERR_MAX]->page_name;
 
     return "ERR_UNKNOWN";	/* should not happen */
 }
 
-ErrorState::ErrorState(err_type t, http_status status, HttpRequest * req) :
+ErrorState::ErrorState(err_type t, Http::StatusCode status, HttpRequest * req) :
         type(t),
         page_id(t),
         err_language(NULL),
         httpStatus(status),
 #if USE_AUTH
         auth_user_request (NULL),
@@ -590,20 +590,20 @@
         err_msg(NULL),
 #if USE_SSL
         detail(NULL),
 #endif
         detailCode(ERR_DETAIL_NONE)
 {
-    memset(&flags, 0, sizeof(flags));
     memset(&ftp, 0, sizeof(ftp));
 
-    if (page_id >= ERR_MAX && ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect != HTTP_STATUS_NONE)
+    if (page_id >= ERR_MAX && ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect != Http::scNone)
         httpStatus = ErrorDynamicPages.items[page_id - ERR_MAX]->page_redirect;
 
     if (req != NULL) {
-        request = HTTPMSGLOCK(req);
+        request = req;
+        HTTPMSGLOCK(request);
         src_addr = req->client_addr;
     }
 }
 
 void
 errorAppendEntry(StoreEntry * entry, ErrorState * err)
@@ -627,13 +627,13 @@
         return;
     }
 
     if (err->page_id == TCP_RESET) {
         if (err->request) {
             debugs(4, 2, "RSTing this reply");
-            err->request->flags.resetTcp=true;
+            err->request->flags.resetTcp = true;
         }
     }
 
     entry->lock();
     entry->buffer();
     entry->replaceHttpReply( err->BuildHttpReply() );
@@ -650,15 +650,12 @@
 errorSend(const Comm::ConnectionPointer &conn, ErrorState * err)
 {
     HttpReply *rep;
     debugs(4, 3, HERE << conn << ", err=" << err);
     assert(Comm::IsConnOpen(conn));
 
-    /* moved in front of errorBuildBuf @?@ */
-    err->flags.flag_cbdata = 1;
-
     rep = err->BuildHttpReply();
 
     MemBuf *mb = rep->pack();
     AsyncCall::Pointer call = commCbCall(78, 5, "errorSendComplete",
                                          CommIoCbPtrFun(&errorSendComplete, err));
     Comm::Write(conn, mb, call);
@@ -736,23 +733,23 @@
     if (xerrno) {
         str.Printf("Err: (%d) %s\r\n", xerrno, strerror(xerrno));
     } else {
         str.Printf("Err: [none]\r\n");
     }
 #if USE_AUTH
-    if (auth_user_request->denyMessage())
+    if (auth_user_request.getRaw() && auth_user_request->denyMessage())
         str.Printf("Auth ErrMsg: %s\r\n", auth_user_request->denyMessage());
 #endif
     if (dnsError.size() > 0)
         str.Printf("DNS ErrMsg: %s\r\n", dnsError.termedBuf());
 
     /* - TimeStamp */
     str.Printf("TimeStamp: %s\r\n\r\n", mkrfc1123(squid_curtime));
 
     /* - IP stuff */
-    str.Printf("ClientIP: %s\r\n", src_addr.NtoA(ntoabuf,MAX_IPSTRLEN));
+    str.Printf("ClientIP: %s\r\n", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
 
     if (request && request->hier.host[0] != '\0') {
         str.Printf("ServerIP: %s\r\n", request->hier.host);
     }
 
     str.Printf("\r\n");
@@ -906,18 +903,18 @@
                 p = request->GetHost();
         } else if (!building_deny_info_url)
             p = "[unknown host]";
         break;
 
     case 'i':
-        mb.Printf("%s", src_addr.NtoA(ntoabuf,MAX_IPSTRLEN));
+        mb.Printf("%s", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
         break;
 
     case 'I':
         if (request && request->hier.tcpServer != NULL)
-            p = request->hier.tcpServer->remote.NtoA(ntoabuf,MAX_IPSTRLEN);
+            p = request->hier.tcpServer->remote.toStr(ntoabuf,MAX_IPSTRLEN);
         else if (!building_deny_info_url)
             p = "[unknown]";
         break;
 
     case 'l':
         if (building_deny_info_url) break;
@@ -1157,20 +1154,20 @@
     HttpReply *rep = new HttpReply;
     const char *name = errorPageName(page_id);
     /* no LMT for error pages; error pages expire immediately */
 
     if (name[0] == '3' || (name[0] != '2' && name[0] != '4' && name[0] != '5' && strchr(name, ':'))) {
         /* Redirection */
-        http_status status = HTTP_MOVED_TEMPORARILY;
+        Http::StatusCode status = Http::scFound;
         // Use configured 3xx reply status if set.
         if (name[0] == '3')
             status = httpStatus;
         else {
             // Use 307 for HTTP/1.1 non-GET/HEAD requests.
-            if (request->method != METHOD_GET && request->method != METHOD_HEAD && request->http_ver >= HttpVersion(1,1))
-                status = HTTP_TEMPORARY_REDIRECT;
+            if (request->method != Http::METHOD_GET && request->method != Http::METHOD_HEAD && request->http_ver >= Http::ProtocolVersion(1,1))
+                status = Http::scTemporaryRedirect;
         }
 
         rep->setHeaders(status, NULL, "text/html", 0, 0, -1);
 
         if (request) {
             MemBuf redirect_location;
@@ -1304,10 +1301,12 @@
         m = p + 1;			/* advance */
     }
 
     if (*m)
         content->Printf("%s", m);	/* copy tail */
 
+    content->terminate();
+
     assert((size_t)content->contentSize() == strlen(content->content()));
 
     return content;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/errorpage.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/errorpage.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/errorpage.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/errorpage.h	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,13 @@
 #define   SQUID_ERRORPAGE_H
 
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "err_detail_type.h"
 #include "err_type.h"
-#include "HttpStatusCode.h"
+#include "http/StatusCode.h"
 #include "ip/Address.h"
 #include "SquidString.h"
 /* auth/UserRequest.h is empty unless USE_AUTH is defined */
 #include "auth/UserRequest.h"
 #if USE_SSL
 #include "ssl/ErrorDetail.h"
@@ -94,13 +94,13 @@
 class MemBuf;
 
 /// \ingroup ErrorPageAPI
 class ErrorState
 {
 public:
-    ErrorState(err_type type, http_status, HttpRequest * request);
+    ErrorState(err_type type, Http::StatusCode, HttpRequest * request);
     ErrorState(); // not implemented.
     ~ErrorState();
 
     /**
      * Allocates and initializes an error response
      */
@@ -150,13 +150,13 @@
     int Dump(MemBuf * mb);
 
 public:
     err_type type;
     int page_id;
     char *err_language;
-    http_status httpStatus;
+    Http::StatusCode httpStatus;
 #if USE_AUTH
     Auth::UserRequest::Pointer auth_user_request;
 #endif
     HttpRequest *request;
     char *url;
     int xerrno;
@@ -167,16 +167,12 @@
     Ip::Address src_addr;
     char *redirect_url;
     ERCB *callback;
     void *callback_data;
 
     struct {
-        unsigned int flag_cbdata:1;
-    } flags;
-
-    struct {
         wordlist *server_msg;
         char *request;
         char *reply;
         char *cwd_msg;
         MemBuf *listing;
     } ftp;
@@ -279,13 +275,13 @@
     /**
      * Load an error template for a given HTTP request. This function examines the
      * Accept-Language header and select the first available template. If the default
      * template selected (eg because of a "Accept-Language: *"), or not available
      * template found this function return false.
      */
-    bool loadFor(HttpRequest *request);
+    bool loadFor(const HttpRequest *request);
 
     /**
      * Load the file given by "path". It uses the "parse()" method.
      * On success return true and sets the "defined" member
      */
     bool loadFromFile(const char *path);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Context.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Context.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Context.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Context.h	2015-05-01 18:05:19.000000000 +0800
@@ -33,31 +33,29 @@
 #define SQUID_ESICONTEXT_H
 
 #include "esi/Parser.h"
 #include "esi/Element.h"
 #include "clientStream.h"
 #include "err_type.h"
-#include "HttpStatusCode.h"
+#include "http/StatusCode.h"
 
 class ESIVarState;
 class ClientHttpRequest;
 
 /* ESIContext */
 
 class ESIContext : public esiTreeParent, public ESIParserClient
 {
 
 public:
     typedef RefCount<ESIContext> Pointer;
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
     ESIContext() :
             thisNode(NULL),
             http(NULL),
             errorpage(ERR_NONE),
-            errorstatus(HTTP_STATUS_NONE),
+            errorstatus(Http::scNone),
             errormessage(NULL),
             rep(NULL),
             outbound_offset(0),
             readpos(0),
             pos(0),
             varState(NULL),
@@ -111,13 +109,13 @@
         int clientwantsdata:1; /* we need to satisfy a read request */
         int kicked:1; /* note on reentering the kick routine */
         int detached:1; /* our downstream has detached */
     } flags;
 
     err_type errorpage; /* if we error what page to use */
-    http_status errorstatus; /* if we error, what code to return */
+    Http::StatusCode errorstatus; /* if we error, what code to return */
     char *errormessage; /* error to pass to error page */
     HttpReply *rep; /* buffered until we pass data downstream */
     ESISegment::Pointer buffered; /* unprocessed data - for whatever reason */
     ESISegment::Pointer incoming;
     /* processed data we are waiting to send, or for
      * potential errors to be resolved
@@ -178,10 +176,10 @@
     virtual void start(const char *el, const char **attr, size_t attrCount);
     virtual void end(const char *el);
     virtual void parserDefault (const char *s, int len);
     virtual void parserComment (const char *s);
     bool processing;
 
-    CBDATA_CLASS(ESIContext);
+    CBDATA_CLASS2(ESIContext);
 };
 
 #endif /* SQUID_ESICONTEXT_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/CustomParser.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/CustomParser.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/CustomParser.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/CustomParser.cc	2015-05-01 18:05:19.000000000 +0800
@@ -29,17 +29,17 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #include "squid.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "esi/CustomParser.h"
 #include "Debug.h"
-#include "Trie.h"
-#include "TrieCharTransform.h"
+#include "libTrie/Trie.h"
+#include "libTrie/TrieCharTransform.h"
 
 Trie *ESICustomParser::SearchTrie=NULL;
 
 EsiParserDefinition(ESICustomParser);
 
 Trie *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Element.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Element.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Element.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Element.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,15 +28,15 @@
  *
  */
 
 #ifndef SQUID_ESIELEMENT_H
 #define SQUID_ESIELEMENT_H
 
+#include "base/RefCount.h"
 #include "Debug.h"
 #include "esi/Segment.h"
-#include "RefCount.h"
 
 typedef enum {
     ESI_PROCESS_COMPLETE = 0,
     ESI_PROCESS_PENDING_WONTFAIL = 1,
     ESI_PROCESS_PENDING_MAYFAIL = 2,
     ESI_PROCESS_FAILED = 3
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Esi.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Esi.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Esi.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Esi.cc	2015-05-01 18:05:19.000000000 +0800
@@ -273,33 +273,17 @@
 {}
 
 /* Local functions */
 /* ESIContext */
 static ESIContext *ESIContextNew(HttpReply *, clientStreamNode *, ClientHttpRequest *);
 
-void *
-ESIContext::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (ESIContext));
-    CBDATA_INIT_TYPE(ESIContext);
-    ESIContext *result = cbdataAlloc(ESIContext);
-    return result;
-}
-
-void
-ESIContext::operator delete (void *address)
-{
-    ESIContext *t = static_cast<ESIContext *>(address);
-    cbdataFree(t);
-}
-
 void
 ESIContext::setError()
 {
     errorpage = ERR_ESI;
-    errorstatus = HTTP_INTERNAL_SERVER_ERROR;
+    errorstatus = Http::scInternalServerError;
     flags.error = 1;
 }
 
 void
 ESIContext::appendOutboundData(ESISegment::Pointer theData)
 {
@@ -538,27 +522,27 @@
 
     /* ?? RC: we can't be aborted / fail ? */
     return STREAM_NONE;
 }
 
 static int
-esiAlwaysPassthrough(http_status sline)
+esiAlwaysPassthrough(Http::StatusCode sline)
 {
     int result;
 
     switch (sline) {
 
-    case HTTP_CONTINUE: /* Should never reach us... but squid needs to alter to accomodate this */
+    case Http::scContinue: /* Should never reach us... but squid needs to alter to accomodate this */
 
-    case HTTP_SWITCHING_PROTOCOLS: /* Ditto */
+    case Http::scSwitchingProtocols: /* Ditto */
 
-    case HTTP_PROCESSING: /* Unknown - some extension */
+    case Http::scProcessing: /* Unknown - some extension */
 
-    case HTTP_NO_CONTENT: /* no body, no esi */
+    case Http::scNoContent: /* no body, no esi */
 
-    case HTTP_NOT_MODIFIED: /* ESI does not affect assembled page headers, so 304s are valid */
+    case Http::scNotModified: /* ESI does not affect assembled page headers, so 304s are valid */
         result = 1;
         /* unreached */
         break;
 
     default:
         result = 0;
@@ -885,13 +869,13 @@
 {
     assert (rep);
     ESIContext *rv = new ESIContext;
     rv->rep = rep;
     rv->cbdataLocker = rv;
 
-    if (esiAlwaysPassthrough(rep->sline.status)) {
+    if (esiAlwaysPassthrough(rep->sline.status())) {
         rv->flags.passthrough = 1;
     } else {
         /* remove specific headers for ESI to prevent
          * downstream cache confusion */
         HttpHeader *hdr = &rep->header;
         hdr->delById(HDR_ACCEPT_RANGES);
@@ -1320,13 +1304,13 @@
 esiProcessResult_t
 ESIContext::process ()
 {
     /* parsing:
      * read through buffered, skipping plain text, and skipping any
      * <...> entry that is not an <esi: entry.
-     * when it's found, hand an esiLiteral of the preceeding data to our current
+     * when it's found, hand an esiLiteral of the preceding data to our current
      * context
      */
 
     if (parserState.parsing) {
         /* in middle of parsing - finish here */
         return ESI_PROCESS_PENDING_MAYFAIL;
@@ -1448,13 +1432,13 @@
     ESISegmentFreeList (outboundtail);
     delete varState;
     varState=NULL;
     /* don't touch incoming, it's a pointer into buffered anyway */
 }
 
-ErrorState *clientBuildError (err_type, http_status, char const *, Ip::Address &, HttpRequest *);
+ErrorState *clientBuildError (err_type, Http::StatusCode, char const *, Ip::Address &, HttpRequest *);
 
 /* This can ONLY be used before we have sent *any* data to the client */
 void
 ESIContext::fail ()
 {
     debugs(86, 5, "ESIContext::fail: this=" << this);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Include.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Include.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Include.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Include.cc	2015-05-01 18:05:19.000000000 +0800
@@ -111,13 +111,13 @@
     /* trivial case */
 
     if (http->out.offset != 0) {
         assert(rep == NULL);
     } else {
         if (rep) {
-            if (rep->sline.status != HTTP_OK) {
+            if (rep->sline.status() != Http::scOkay) {
                 rep = NULL;
                 esiStream->include->includeFail (esiStream);
                 esiStream->finished = 1;
                 httpRequestFree (http);
                 return;
             }
@@ -232,28 +232,12 @@
     debugs(86, 5, "Freeing stream context resources.");
     buffer = NULL;
     localbuffer = NULL;
     include = NULL;
 }
 
-void *
-ESIStreamContext::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (ESIStreamContext));
-    CBDATA_INIT_TYPE(ESIStreamContext);
-    ESIStreamContext *result = cbdataAlloc(ESIStreamContext);
-    return result;
-}
-
-void
-ESIStreamContext::operator delete (void *address)
-{
-    ESIStreamContext *t = static_cast<ESIStreamContext *>(address);
-    cbdataFree(t);
-}
-
 ESIStreamContext *
 ESIStreamContextNew (ESIIncludePtr include)
 {
     ESIStreamContext *rv = new ESIStreamContext;
     rv->include = include;
     return rv;
@@ -337,16 +321,15 @@
     /* Ensure variable state is clean */
     vars->feedData(url, strlen (url));
 
     /* tempUrl is eaten by the request */
     char const *tempUrl = vars->extractChar ();
 
-    debugs(86, 5, "ESIIncludeStart: Starting subrequest with url '" << tempUrl <<
-           "'");
+    debugs(86, 5, "ESIIncludeStart: Starting subrequest with url '" << tempUrl << "'");
 
-    if (clientBeginRequest(METHOD_GET, tempUrl, esiBufferRecipient, esiBufferDetach, stream.getRaw(), &tempheaders, stream->localbuffer->buf, HTTP_REQBUF_SZ)) {
+    if (clientBeginRequest(Http::METHOD_GET, tempUrl, esiBufferRecipient, esiBufferDetach, stream.getRaw(), &tempheaders, stream->localbuffer->buf, HTTP_REQBUF_SZ)) {
         debugs(86, DBG_CRITICAL, "starting new ESI subrequest failed");
     }
 
     tempheaders.clean();
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Include.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Include.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Include.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Include.h	2015-05-01 18:05:19.000000000 +0800
@@ -43,24 +43,22 @@
 
 class ESIStreamContext : public RefCountable
 {
 
 public:
     typedef RefCount<ESIStreamContext> Pointer;
-    void *operator new(size_t);
-    void operator delete(void *);
     ESIStreamContext();
     ~ESIStreamContext();
     void freeResources();
     int finished;
     ESIIncludePtr include;
     ESISegment::Pointer localbuffer;
     ESISegment::Pointer buffer;
 
 private:
-    CBDATA_CLASS(ESIStreamContext);
+    CBDATA_CLASS2(ESIStreamContext);
 };
 
 /* ESIInclude */
 
 class ESIInclude : public ESIElement
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -44,11 +44,6 @@
 	Segment.h \
 	Sequence.cc \
 	Sequence.h \
 	Var.h \
 	VarState.cc \
 	VarState.h
-
-INCLUDES += \
-	-I$(top_srcdir)/lib/libTrie/include \
-	-I$(top_builddir)/lib/libTrie/include
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Makefile.in	2015-05-01 16:51:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Makefile.in	2015-05-01 18:06:53.000000000 +0800
@@ -98,14 +98,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -471,12 +517,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -514,12 +561,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -546,27 +594,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -630,18 +681,16 @@
 AM_CFLAGS = $(SQUID_CFLAGS)
 AM_CXXFLAGS = $(SQUID_CXXFLAGS)
 CLEANFILES = testHeaders
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
-	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) \
-	-I$(top_srcdir)/lib/libTrie/include \
-	-I$(top_builddir)/lib/libTrie/include
+	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libesi.la
 ESI_PARSER_SOURCES = CustomParser.cc CustomParser.h $(am__append_2) \
 	$(am__append_3)
 libesi_la_SOURCES = \
 	Assign.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Parser.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Parser.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Parser.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Parser.h	2015-05-01 18:05:19.000000000 +0800
@@ -37,14 +37,13 @@
     virtual void end(const char *el) = 0;
     virtual void parserDefault (const char *s, int len) =0;
     virtual void parserComment (const char *s) = 0;
     virtual ~ESIParserClient() {};
 };
 
-/* for RefCountable */
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 class ESIParser : public RefCountable
 {
 public:
     class Register;
     typedef RefCount<ESIParser> Pointer;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Segment.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Segment.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/Segment.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/Segment.h	2015-05-01 18:05:19.000000000 +0800
@@ -32,15 +32,15 @@
 #define SQUID_ESISEGMENT_H
 
 /* TODO: Factor the store memory segment management into a reusable code block
  * or perhaps use membuffers here?
  */
 
+#include "base/RefCount.h"
 #include "cbdata.h"
 #include "defines.h"
-#include "RefCount.h"
 #include "SquidString.h"
 
 class ESISegment : public RefCountable
 {
 
 public:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/VarState.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/VarState.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/esi/VarState.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/esi/VarState.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,14 +30,14 @@
  */
 
 #ifndef SQUID_ESIVARSTATE_H
 #define SQUID_ESIVARSTATE_H
 
 #include "esi/Segment.h"
-#include "Trie.h"
-#include "Array.h"
+#include "libTrie/Trie.h"
+#include "base/Vector.h"
 #include "HttpHeader.h"
 
 class HttpReply;
 
 /* esi variable replacement logic */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Eui48.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Eui48.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Eui48.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Eui48.cc	2015-05-01 18:05:19.000000000 +0800
@@ -41,15 +41,12 @@
 #include "globals.h"
 #include "ip/Address.h"
 
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
-#if _SQUID_CYGWIN_
-#include <squid_windows.h>
-#endif
 
 /* START Legacy includes pattern */
 /* TODO: clean this up so we dont have per-OS requirements.
          The files are checked for existence individually
          and can be wrapped
  */
@@ -59,19 +56,17 @@
 
     Ip::Address arp_pa;   /* protocol address */
 
     struct sockaddr arp_ha;   /* hardware address */
     int arp_flags;            /* flags */
 };
-
-#include <Iphlpapi.h>
+#if HAVE_IPHLPAPI_H
+#include <iphlpapi.h>
 #endif
-
-#if HAVE_SYS_TYPES_H
-#include <sys/types.h>
 #endif
+
 #if HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #if HAVE_SYS_SOCKIO_H
 /* required by Solaris */
 #include <sys/sockio.h>
@@ -138,36 +133,38 @@
     eui[0] = (u_char) a1;
     eui[1] = (u_char) a2;
     eui[2] = (u_char) a3;
     eui[3] = (u_char) a4;
     eui[4] = (u_char) a5;
     eui[5] = (u_char) a6;
+
+    debugs(28, 4, "id=" << (void*)this << " decoded " << asc);
     return true;
 }
 
 bool
 Eui::Eui48::encode(char *buf, const int len)
 {
-    if (len < SZ_EUI48_BUF) return false;
+    if (len < SZ_EUI48_BUF)
+        return false;
 
     snprintf(buf, len, "%02x:%02x:%02x:%02x:%02x:%02x",
              eui[0] & 0xff, eui[1] & 0xff,
              eui[2] & 0xff, eui[3] & 0xff,
              eui[4] & 0xff, eui[5] & 0xff);
+
+    debugs(28, 4, "id=" << (void*)this << " encoded " << buf);
     return true;
 }
 
 // return binary representation of the EUI
 bool
 Eui::Eui48::lookup(const Ip::Address &c)
 {
-#if !_SQUID_WINDOWS_
-#endif /* !_SQUID_WINDOWS_ */
-
     Ip::Address ipAddr = c;
-    ipAddr.SetPort(0);
+    ipAddr.port(0);
 
 #if _SQUID_LINUX_
 
     unsigned char ifbuffer[sizeof(struct ifreq) * 64];
     struct ifconf ifc;
 
@@ -198,25 +195,26 @@
      * Set up structures for ARP lookup with blank interface name
      */
     struct arpreq arpReq;
     memset(&arpReq, '\0', sizeof(arpReq));
 
     struct sockaddr_in *sa = (struct sockaddr_in*)&arpReq.arp_pa;
-    ipAddr.GetSockAddr(*sa);
+    ipAddr.getSockAddr(*sa);
 
     /* Query ARP table */
+    debugs(28, 4, "id=" << (void*)this << " query ARP table");
     if (ioctl(tmpSocket, SIOCGARP, &arpReq) != -1) {
         /* Skip non-ethernet interfaces */
         close(tmpSocket);
 
         if (arpReq.arp_ha.sa_family != ARPHRD_ETHER) {
             clear();
             return false;
         }
 
-        debugs(28, 4, "Got address "<< std::setfill('0') << std::hex <<
+        debugs(28, 4, "id=" << (void*)this << " got address "<< std::setfill('0') << std::hex <<
                std::setw(2) << (arpReq.arp_ha.sa_data[0] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[1] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[2] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[3] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[4] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[5] & 0xff));
@@ -243,33 +241,35 @@
         close(tmpSocket);
         return false;
     }
 
     /* Attempt ARP lookup on each interface */
     offset = 0;
-
+    debugs(28, 4, "id=" << (void*)this << " query ARP on each interface (" << ifc.ifc_len << " found)");
     while (offset < ifc.ifc_len) {
 
         ifr = (struct ifreq *) (ifbuffer + offset);
         offset += sizeof(*ifr);
-        /* Skip loopback and aliased interfaces */
 
-        if (0 == strncmp(ifr->ifr_name, "lo", 2))
+        debugs(28, 4, "id=" << (void*)this << " found interface " << ifr->ifr_name);
+
+        /* Skip loopback and aliased interfaces */
+        if (!strncmp(ifr->ifr_name, "lo", 2))
             continue;
 
-        if (NULL != strchr(ifr->ifr_name, ':'))
+        if (strchr(ifr->ifr_name, ':'))
             continue;
 
-        debugs(28, 4, "Looking up ARP address for " << ipAddr << " on " << ifr->ifr_name);
+        debugs(28, 4, "id=" << (void*)this << " looking up ARP address for " << ipAddr << " on " << ifr->ifr_name);
 
         /* Set up structures for ARP lookup */
 
         memset(&arpReq, '\0', sizeof(arpReq));
 
         sa = (sockaddr_in*)&arpReq.arp_pa;
-        ipAddr.GetSockAddr(*sa);
+        ipAddr.getSockAddr(*sa);
 
         strncpy(arpReq.arp_dev, ifr->ifr_name, sizeof(arpReq.arp_dev) - 1);
 
         arpReq.arp_dev[sizeof(arpReq.arp_dev) - 1] = '\0';
 
         /* Query ARP table */
@@ -287,16 +287,18 @@
                 debugs(28, DBG_IMPORTANT, "ARP query " << ipAddr << " failed: " << ifr->ifr_name << ": " << xstrerror());
 
             continue;
         }
 
         /* Skip non-ethernet interfaces */
-        if (arpReq.arp_ha.sa_family != ARPHRD_ETHER)
+        if (arpReq.arp_ha.sa_family != ARPHRD_ETHER) {
+            debugs(28, 4, "id=" << (void*)this << "... not an Ethernet interface");
             continue;
+        }
 
-        debugs(28, 4, "Got address "<< std::setfill('0') << std::hex <<
+        debugs(28, 4, "id=" << (void*)this << " got address "<< std::setfill('0') << std::hex <<
                std::setw(2) << (arpReq.arp_ha.sa_data[0] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[1] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[2] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[3] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[4] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[5] & 0xff)  << " on "<<
@@ -328,13 +330,13 @@
 
     /* Set up structures for ARP lookup with blank interface name */
     struct arpreq arpReq;
     memset(&arpReq, '\0', sizeof(arpReq));
 
     struct sockaddr_in *sa = (struct sockaddr_in*)&arpReq.arp_pa;
-    ipAddr.GetSockAddr(*sa);
+    ipAddr.getSockAddr(*sa);
 
     /* Query ARP table */
     if (ioctl(tmpSocket, SIOCGARP, &arpReq) != -1) {
         /*
         *  Solaris (at least 2.6/x86) does not use arp_ha.sa_family -
         * it returns 00:00:00:00:00:00 for non-ethernet media
@@ -357,12 +359,14 @@
                std::setw(2) << (arpReq.arp_ha.sa_data[3] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[4] & 0xff)  << ":" <<
                std::setw(2) << (arpReq.arp_ha.sa_data[5] & 0xff));
 
         set(arpReq.arp_ha.sa_data, 6);
         return true;
+    } else {
+        close(tmpSocket);
     }
 
 #elif _SQUID_FREEBSD_ || _SQUID_NETBSD_ || _SQUID_OPENBSD_ || _SQUID_DRAGONFLY_ || _SQUID_KFREEBSD_
 
     int mib[6];
 
@@ -380,13 +384,13 @@
     * Set up structures for ARP lookup with blank interface name
     */
     struct arpreq arpReq;
     memset(&arpReq, '\0', sizeof(arpReq));
 
     struct sockaddr_in *sa = (struct sockaddr_in*)&arpReq.arp_pa;
-    ipAddr.GetSockAddr(*sa);
+    ipAddr.getSockAddr(*sa);
 
     /* Query ARP table */
     mib[0] = CTL_NET;
 
     mib[1] = PF_ROUTE;
 
@@ -531,13 +535,13 @@
     debugs(28, DBG_CRITICAL, "ERROR: ARP / MAC / EUI-* operations not supported on this operating system.");
 
 #endif
     /*
      * Address was not found on any interface
      */
-    debugs(28, 3, HERE << ipAddr << " NOT found");
+    debugs(28, 3, "id=" << (void*)this << ' ' << ipAddr << " NOT found");
 
     clear();
     return false;
 }
 
 /* ==== END EUI LOOKUP SUPPORT =============================================== */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Eui48.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Eui48.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Eui48.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Eui48.h	2015-05-01 18:05:19.000000000 +0800
@@ -24,26 +24,26 @@
 {
 
 class Eui48
 {
 
 public:
-    Eui48() { clear(); };
-    Eui48(const Eui48 &t) { memcpy(this, &t, sizeof(Eui48)); };
-    ~Eui48() {};
+    Eui48() { clear(); }
+    Eui48(const Eui48 &t) { memcpy(this, &t, sizeof(Eui48)); }
+    ~Eui48() {}
 
     const unsigned char *get(void);
 
     bool set(const char *src, const int len) {
         if (len > SZ_EUI48_BUF) return false;
         if (len < SZ_EUI48_BUF) clear();
         memcpy(eui, src, len);
         return true;
-    };
+    }
 
-    void clear() { memset(eui, 0, SZ_EUI48_BUF); };
+    void clear() { memset(eui, 0, SZ_EUI48_BUF); }
 
     /**
      * Decode an ascii representation of an EUI-48 ethernet address.
      *
      * \param asc   ASCII representation of an ethernet (MAC) address
      * \param eth   Binary representation of the ethernet address
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Eui64.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Eui64.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Eui64.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Eui64.cc	2015-05-01 18:05:19.000000000 +0800
@@ -15,52 +15,61 @@
 #include "globals.h"
 #include "ip/Address.h"
 
 bool
 Eui::Eui64::decode(const char *asc)
 {
-    if (eui64_aton(asc, (struct eui64 *)eui) != 0) return false;
+    if (eui64_aton(asc, (struct eui64 *)eui) != 0) {
+        debugs(28, 4, "id=" << (void*)this << " decode fail on " << asc);
+        return false;
+    }
 
+    debugs(28, 4, "id=" << (void*)this << " ATON decoded " << asc);
     return true;
 }
 
 bool
 Eui::Eui64::encode(char *buf, const int len)
 {
     if (len < SZ_EUI64_BUF) return false;
 
     snprintf(buf, len, "%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x",
              eui[0], eui[1], eui[2], eui[3],
              eui[4], eui[5], eui[6], eui[7]);
+    debugs(28, 4, "id=" << (void*)this << " encoded " << buf);
     return true;
 }
 
 // return binary representation of the EUI
 bool
 Eui::Eui64::lookup(const Ip::Address &c)
 {
     /* try to short-circuit slow OS lookups by using SLAAC data */
-    if (lookupSlaac(c)) return true;
+    if (lookupSlaac(c))
+        return true;
 
     // find EUI-64 some other way. NDP table lookup?
     return lookupNdp(c);
 }
 
 bool
 Eui::Eui64::lookupSlaac(const Ip::Address &c)
 {
     /* RFC 4291 Link-Local unicast addresses which contain SLAAC - usually trustable. */
-    if (c.IsSiteLocal6() && c.IsSlaac() ) {
+    if (c.isSiteLocal6() && c.isSiteLocalAuto()) {
 
         // strip the final 64 bits of the address...
         struct in6_addr tmp;
-        c.GetInAddr(tmp);
+        c.getInAddr(tmp);
         memcpy(eui, &(tmp.s6_addr[8]), SZ_EUI64_BUF);
-
+        debugs(28, 4, "id=" << (void*)this << " SLAAC decoded " << c);
         return true;
     }
+
+    debugs(28, 4, "id=" << (void*)this << " SLAAC fail on " << c << " SL-6="
+           << (c.isSiteLocal6()?'T':'F') << " AAC-6=" << (c.isSiteLocalAuto()?'T':'F'));
     return false;
 }
 
 // return binary representation of the EUI
 bool
 Eui::Eui64::lookupNdp(const Ip::Address &c)
@@ -70,13 +79,13 @@
     /* no OS yet supported for NDP protocol lookup */
     debugs(28, DBG_CRITICAL, "ERROR: ARP / MAC / EUI-* operations not supported on this operating system.");
 
     /*
      * Address was not found on any interface
      */
-    debugs(28, 3, HERE << c << " NOT found");
+    debugs(28, 3, "id=" << (void*)this << ' ' << c << " NOT found");
 #endif /* 0 */
 
     clear();
     return false;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Eui64.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Eui64.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Eui64.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Eui64.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,26 +31,26 @@
 #endif
 
 class Eui64
 {
 
 public:
-    Eui64() { clear(); };
-    Eui64(const Eui64 &t) { memcpy(this, &t, sizeof(Eui64)); };
-    ~Eui64() {};
+    Eui64() { clear(); }
+    Eui64(const Eui64 &t) { memcpy(this, &t, sizeof(Eui64)); }
+    ~Eui64() {}
 
     const unsigned char *get(void);
 
     bool set(const char *src, const int len) {
         if (len > SZ_EUI64_BUF) return false;
         if (len < SZ_EUI64_BUF) clear();
         memcpy(eui, src, len);
         return true;
-    };
+    }
 
-    void clear() { memset(eui, 0, SZ_EUI64_BUF); };
+    void clear() { memset(eui, 0, SZ_EUI64_BUF); }
 
     /**
      * Decode an ascii representation of an EUI-64 address.
      *
      * \param asc   ASCII representation of an EUI-64 address
      * \param eth   Binary representation of the EUI_64 address
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/eui/Makefile.in	2015-05-01 16:51:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/eui/Makefile.in	2015-05-01 18:06:54.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -452,12 +498,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -495,12 +542,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -527,27 +575,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -614,13 +665,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libeui.la
 libeui_la_SOURCES = \
 	Config.h \
 	Config.cc \
 	Eui48.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/event.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/event.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/event.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/event.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,13 +29,13 @@
  *
  */
 
 #ifndef SQUID_EVENT_H
 #define SQUID_EVENT_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "AsyncEngine.h"
 #include "MemPool.h"
 
 class StoreEntry;
 
 /* event scheduling facilities - run a callback after a given time period. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/EventLoop.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/EventLoop.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/EventLoop.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/EventLoop.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,16 @@
 #include "Debug.h"
 #include "EventLoop.h"
 #include "base/AsyncCallQueue.h"
 #include "SquidTime.h"
 
 EventLoop::EventLoop() : errcount(0), last_loop(false), timeService(NULL),
-        primaryEngine(NULL)
+        primaryEngine(NULL),
+        loop_delay(EVENT_LOOP_TIMEOUT),
+        error(false),
+        runOnceResult(false)
 {}
 
 void
 EventLoop::checkEngine(AsyncEngine * engine, bool const primary)
 {
     int requested_delay;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/EventLoop.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/EventLoop.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/EventLoop.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/EventLoop.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,13 +28,13 @@
  *
  */
 
 #ifndef SQUID_EVENTLOOP_H
 #define SQUID_EVENTLOOP_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 #define EVENT_LOOP_TIMEOUT	1000 /* 1s timeout */
 
 class AsyncEngine;
 class TimeEngine;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/external_acl.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/external_acl.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/external_acl.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/external_acl.cc	2015-05-01 18:05:19.000000000 +0800
@@ -82,29 +82,29 @@
 #define DEFAULT_EXTERNAL_ACL_CHILDREN 5
 #endif
 
 typedef struct _external_acl_format external_acl_format;
 
 static char *makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data);
-static void external_acl_cache_delete(external_acl * def, external_acl_entry * entry);
-static int external_acl_entry_expired(external_acl * def, external_acl_entry * entry);
-static int external_acl_grace_expired(external_acl * def, external_acl_entry * entry);
-static void external_acl_cache_touch(external_acl * def, external_acl_entry * entry);
-static external_acl_entry *external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const &data);
+static void external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &entry);
+static int external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry);
+static int external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry);
+static void external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry);
+static ExternalACLEntryPointer external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const &data);
 
 /******************************************************************
  * external_acl directive
  */
 
 class external_acl
 {
 
 public:
     external_acl *next;
 
-    void add(ExternalACLEntry *);
+    void add(const ExternalACLEntryPointer &);
 
     void trimCache();
 
     int ttl;
 
     int negative_ttl;
@@ -236,14 +236,16 @@
     if (p->theHelper) {
         helperShutdown(p->theHelper);
         delete p->theHelper;
         p->theHelper = NULL;
     }
 
-    while (p->lru_list.tail)
-        external_acl_cache_delete(p, static_cast<external_acl_entry *>(p->lru_list.tail->data));
+    while (p->lru_list.tail) {
+        ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(p->lru_list.tail->data));
+        external_acl_cache_delete(p, e);
+    }
     if (p->cache)
         hashFreeMemory(p->cache);
 }
 
 /**
  * Parse the External ACL format %<{.*} and %>{.*} token(s) to pass a specific
@@ -324,13 +326,13 @@
     a->ttl = DEFAULT_EXTERNAL_ACL_TTL;
     a->negative_ttl = -1;
     a->cache_size = 256*1024;
     a->children.n_max = DEFAULT_EXTERNAL_ACL_CHILDREN;
     a->children.n_startup = a->children.n_max;
     a->children.n_idle = 1;
-    a->local_addr.SetLocalhost();
+    a->local_addr.setLocalhost();
     a->quote = external_acl::QUOTE_METHOD_URL;
 
     token = strtok(NULL, w_space);
 
     if (!token)
         self_destruct();
@@ -360,22 +362,25 @@
             a->cache_size = atoi(token + 6);
         } else if (strncmp(token, "grace=", 6) == 0) {
             a->grace = atoi(token + 6);
         } else if (strcmp(token, "protocol=2.5") == 0) {
             a->quote = external_acl::QUOTE_METHOD_SHELL;
         } else if (strcmp(token, "protocol=3.0") == 0) {
+            debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option protocol=3.0 is deprecated. Remove this from your config.");
             a->quote = external_acl::QUOTE_METHOD_URL;
         } else if (strcmp(token, "quote=url") == 0) {
+            debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=url is deprecated. Remove this from your config.");
             a->quote = external_acl::QUOTE_METHOD_URL;
         } else if (strcmp(token, "quote=shell") == 0) {
+            debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=shell is deprecated. Use protocol=2.5 if still needed.");
             a->quote = external_acl::QUOTE_METHOD_SHELL;
 
             /* INET6: allow admin to configure some helpers explicitly to
                       bind to IPv4/v6 localhost port. */
         } else if (strcmp(token, "ipv4") == 0) {
-            if ( !a->local_addr.SetIPv4() ) {
+            if ( !a->local_addr.setIPv4() ) {
                 debugs(3, DBG_CRITICAL, "WARNING: Error converting " << a->local_addr << " to IPv4 in " << a->name );
             }
         } else if (strcmp(token, "ipv6") == 0) {
             if (!Ip::EnableIpv6)
                 debugs(3, DBG_CRITICAL, "WARNING: --enable-ipv6 required for external ACL helpers to use IPv6: " << a->name );
             // else nothing to do.
@@ -417,18 +422,18 @@
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %{...} is being replaced by %>ha{...} for : " << token);
             parse_header_token(format, (token+2), _external_acl_format::EXT_ACL_HEADER_REQUEST);
         } else if (strncmp(token, "%>{", 3) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %>{...} is being replaced by %>ha{...} for : " << token);
             parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REQUEST);
         } else if (strncmp(token, "%>ha{", 5) == 0) {
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REQUEST);
+            parse_header_token(format, (token+5), _external_acl_format::EXT_ACL_HEADER_REQUEST);
         } else if (strncmp(token, "%<{", 3) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %<{...} is being replaced by %<h{...} for : " << token);
             parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REPLY);
         } else if (strncmp(token, "%<h{", 4) == 0) {
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REPLY);
+            parse_header_token(format, (token+4), _external_acl_format::EXT_ACL_HEADER_REPLY);
 #if USE_AUTH
         } else if (strcmp(token, "%LOGIN") == 0 || strcmp(token, "%ul") == 0) {
             format->type = _external_acl_format::EXT_ACL_LOGIN;
             a->require_auth = true;
 #endif
         }
@@ -467,19 +472,19 @@
             format->type = _external_acl_format::EXT_ACL_USER_CERT_RAW;
         else if (strcmp(token, "%USER_CERTCHAIN") == 0)
             format->type = _external_acl_format::EXT_ACL_USER_CERTCHAIN_RAW;
         else if (strncmp(token, "%USER_CERT_", 11) == 0) {
             format->type = _external_acl_format::EXT_ACL_USER_CERT;
             format->header = xstrdup(token + 11);
-        } else if (strncmp(token, "%USER_CA_CERT_", 11) == 0) {
+        } else if (strncmp(token, "%USER_CA_CERT_", 14) == 0) {
             format->type = _external_acl_format::EXT_ACL_USER_CA_CERT;
-            format->header = xstrdup(token + 11);
-        } else if (strncmp(token, "%CA_CERT_", 11) == 0) {
+            format->header = xstrdup(token + 14);
+        } else if (strncmp(token, "%CA_CERT_", 9) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type %CA_CERT_* code is obsolete. Use %USER_CA_CERT_* instead");
             format->type = _external_acl_format::EXT_ACL_USER_CA_CERT;
-            format->header = xstrdup(token + 11);
+            format->header = xstrdup(token + 9);
         }
 #endif
 #if USE_AUTH
         else if (strcmp(token, "%EXT_USER") == 0)
             format->type = _external_acl_format::EXT_ACL_EXT_USER;
 #endif
@@ -529,13 +534,13 @@
     const external_acl_format *format;
     const wordlist *word;
 
     for (node = list; node; node = node->next) {
         storeAppendPrintf(sentry, "%s %s", name, node->name);
 
-        if (!node->local_addr.IsIPv6())
+        if (!node->local_addr.isIPv6())
             storeAppendPrintf(sentry, " ipv4");
         else
             storeAppendPrintf(sentry, " ipv6");
 
         if (node->ttl != DEFAULT_EXTERNAL_ACL_TTL)
             storeAppendPrintf(sentry, " ttl=%d", node->ttl);
@@ -558,12 +563,15 @@
         if (node->children.concurrency)
             storeAppendPrintf(sentry, " concurrency=%d", node->children.concurrency);
 
         if (node->cache)
             storeAppendPrintf(sentry, " cache=%d", node->cache_size);
 
+        if (node->quote == external_acl::QUOTE_METHOD_SHELL)
+            storeAppendPrintf(sentry, " protocol=2.5");
+
         for (format = node->format; format; format = format->next) {
             switch (format->type) {
 
             case _external_acl_format::EXT_ACL_HEADER_REQUEST:
             case _external_acl_format::EXT_ACL_HEADER_REQUEST_ID:
                 storeAppendPrintf(sentry, " %%>{%s}", format->header);
@@ -661,27 +669,32 @@
     }
 
     return NULL;
 }
 
 void
-external_acl::add(ExternalACLEntry *anEntry)
+external_acl::add(const ExternalACLEntryPointer &anEntry)
 {
     trimCache();
+    assert(anEntry != NULL);
     assert (anEntry->def == NULL);
     anEntry->def = this;
-    hash_join(cache, anEntry);
-    dlinkAdd(anEntry, &anEntry->lru, &lru_list);
+    ExternalACLEntry *e = const_cast<ExternalACLEntry *>(anEntry.getRaw()); // XXX: make hash a std::map of Pointer.
+    hash_join(cache, e);
+    dlinkAdd(e, &e->lru, &lru_list);
+    e->lock(); //cbdataReference(e); // lock it on behalf of the hash
     ++cache_entries;
 }
 
 void
 external_acl::trimCache()
 {
-    if (cache_size && cache_entries >= cache_size)
-        external_acl_cache_delete(this, static_cast<external_acl_entry *>(lru_list.tail->data));
+    if (cache_size && cache_entries >= cache_size) {
+        ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(lru_list.tail->data));
+        external_acl_cache_delete(this, e);
+    }
 }
 
 /******************************************************************
  * external acl type
  */
 
@@ -710,13 +723,13 @@
         self_destruct();
 
     CBDATA_INIT_TYPE_FREECB(external_acl_data, free_external_acl_data);
 
     data = cbdataAlloc(external_acl_data);
 
-    token = strtok(NULL, w_space);
+    token = strtokFile();
 
     if (!token)
         self_destruct();
 
     data->def = cbdataReference(find_externalAclHelper(token));
 
@@ -762,13 +775,13 @@
 {
     cbdataFree(data);
     safe_free (class_);
 }
 
 static void
-copyResultsFromEntry(HttpRequest *req, external_acl_entry *entry)
+copyResultsFromEntry(HttpRequest *req, const ExternalACLEntryPointer &entry)
 {
     if (req) {
 #if USE_AUTH
         if (entry->user.size())
             req->extacl_user = entry->user;
 
@@ -786,41 +799,40 @@
     }
 }
 
 static allow_t
 aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
 {
-    const char *key = "";
     debugs(82, 9, HERE << "acl=\"" << acl->def->name << "\"");
-    external_acl_entry *entry = ch->extacl_entry;
+    ExternalACLEntryPointer entry = ch->extacl_entry;
 
-    if (entry) {
-        if (cbdataReferenceValid(entry) && entry->def == acl->def) {
+    external_acl_message = "MISSING REQUIRED INFORMATION";
+
+    if (entry != NULL) {
+        if (entry->def == acl->def) {
             /* Ours, use it.. if the key matches */
-            key = makeExternalAclKey(ch, acl);
+            const char *key = makeExternalAclKey(ch, acl);
+            if (!key)
+                return ACCESS_DUNNO; // insufficent data to continue
             if (strcmp(key, (char*)entry->key) != 0) {
-                debugs(82, 9, HERE << "entry key='" << (char *)entry->key << "', our key='" << key << "' dont match. Discarded.");
+                debugs(82, 9, "entry key='" << (char *)entry->key << "', our key='" << key << "' dont match. Discarded.");
                 // too bad. need a new lookup.
-                cbdataReferenceDone(ch->extacl_entry);
-                entry = NULL;
+                entry = ch->extacl_entry = NULL;
             }
         } else {
-            /* Not valid, or not ours.. get rid of it */
-            debugs(82, 9, HERE << "entry " << entry << " not valid or not ours. Discarded.");
-            if (entry) {
-                debugs(82, 9, HERE << "entry def=" << entry->def << ", our def=" << acl->def);
-                key = makeExternalAclKey(ch, acl);
-                debugs(82, 9, HERE << "entry key='" << (char *)entry->key << "', our key='" << key << "'");
+            /* Not ours.. get rid of it */
+            debugs(82, 9, "entry " << entry << " not valid or not ours. Discarded.");
+            if (entry != NULL) {
+                debugs(82, 9, "entry def=" << entry->def << ", our def=" << acl->def);
+                const char *key = makeExternalAclKey(ch, acl); // may be nil
+                debugs(82, 9, "entry key='" << (char *)entry->key << "', our key='" << key << "'");
             }
-            cbdataReferenceDone(ch->extacl_entry);
-            entry = NULL;
+            entry = ch->extacl_entry = NULL;
         }
     }
 
-    external_acl_message = "MISSING REQUIRED INFORMATION";
-
     if (!entry) {
         debugs(82, 9, HERE << "No helper entry available");
 #if USE_AUTH
         if (acl->def->require_auth) {
             /* Make sure the user is authenticated */
             debugs(82, 3, HERE << acl->def->name << " check user authenticated.");
@@ -829,40 +841,39 @@
                 debugs(82, 2, HERE << acl->def->name << " user not authenticated (" << ti << ")");
                 return ti;
             }
             debugs(82, 3, HERE << acl->def->name << " user is authenticated.");
         }
 #endif
-        key = makeExternalAclKey(ch, acl);
+        const char *key = makeExternalAclKey(ch, acl);
 
         if (!key) {
             /* Not sufficient data to process */
             return ACCESS_DUNNO;
         }
 
-        entry = static_cast<external_acl_entry *>(hash_lookup(acl->def->cache, key));
+        entry = static_cast<ExternalACLEntry *>(hash_lookup(acl->def->cache, key));
 
-        external_acl_entry *staleEntry = entry;
-        if (entry && external_acl_entry_expired(acl->def, entry))
+        const ExternalACLEntryPointer staleEntry = entry;
+        if (entry != NULL && external_acl_entry_expired(acl->def, entry))
             entry = NULL;
 
-        if (entry && external_acl_grace_expired(acl->def, entry)) {
+        if (entry != NULL && external_acl_grace_expired(acl->def, entry)) {
             // refresh in the background
             ExternalACLLookup::Start(ch, acl, true);
             debugs(82, 4, HERE << "no need to wait for the refresh of '" <<
                    key << "' in '" << acl->def->name << "' (ch=" << ch << ").");
         }
 
         if (!entry) {
             debugs(82, 2, HERE << acl->def->name << "(\"" << key << "\") = lookup needed");
-            debugs(82, 2, HERE << "\"" << key << "\": entry=@" <<
-                   entry << ", age=" << (entry ? (long int) squid_curtime - entry->date : 0));
 
             if (acl->def->theHelper->stats.queue_size < (int)acl->def->theHelper->childs.n_active) {
                 debugs(82, 2, HERE << "\"" << key << "\": queueing a call.");
-                ch->changeState(ExternalACLLookup::Instance());
+                if (!ch->goAsync(ExternalACLLookup::Instance()))
+                    debugs(82, 2, "\"" << key << "\": no async support!");
                 debugs(82, 2, HERE << "\"" << key << "\": return -1.");
                 return ACCESS_DUNNO; // expired cached or simply absent entry
             } else {
                 if (!staleEntry) {
                     debugs(82, DBG_IMPORTANT, "WARNING: external ACL '" << acl->def->name <<
                            "' queue overload. Request rejected '" << key << "'.");
@@ -909,14 +920,14 @@
         return 0; // non-match
 
     case ACCESS_DUNNO:
     case ACCESS_AUTH_REQUIRED:
     default:
         // If the answer is not allowed or denied (matches/not matches) and
-        // async authentication is not needed (asyncNeeded), then we are done.
-        if (!checklist->asyncNeeded())
+        // async authentication is not in progress, then we are done.
+        if (checklist->keepMatching())
             checklist->markFinished(answer, "aclMatchExternal exception");
         return -1; // other
     }
 }
 
 wordlist *
@@ -940,20 +951,21 @@
 
 /******************************************************************
  * external_acl cache
  */
 
 static void
-external_acl_cache_touch(external_acl * def, external_acl_entry * entry)
+external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     // this must not be done when nothing is being cached.
     if (def->cache_size <= 0 || (def->ttl <= 0 && entry->result == 1) || (def->negative_ttl <= 0 && entry->result != 1))
         return;
 
     dlinkDelete(&entry->lru, &def->lru_list);
-    dlinkAdd(entry, &entry->lru, &def->lru_list);
+    ExternalACLEntry *e = const_cast<ExternalACLEntry *>(entry.getRaw()); // XXX: make hash a std::map of Pointer.
+    dlinkAdd(e, &entry->lru, &def->lru_list);
 }
 
 static char *
 makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 {
     static MemBuf mb;
@@ -984,25 +996,27 @@
 #endif
 #if USE_IDENT
         case _external_acl_format::EXT_ACL_IDENT:
             str = ch->rfc931;
 
             if (!str || !*str) {
-                ch->changeState(IdentLookup::Instance());
+                // if we fail to go async, we still return NULL and the caller
+                // will detect the failure in ACLExternal::match().
+                (void)ch->goAsync(IdentLookup::Instance());
                 return NULL;
             }
 
             break;
 #endif
 
         case _external_acl_format::EXT_ACL_SRC:
-            str = ch->src_addr.NtoA(buf,sizeof(buf));
+            str = ch->src_addr.toStr(buf,sizeof(buf));
             break;
 
         case _external_acl_format::EXT_ACL_SRCPORT:
-            snprintf(buf, sizeof(buf), "%d", request->client_addr.GetPort());
+            snprintf(buf, sizeof(buf), "%d", request->client_addr.port());
             str = buf;
             break;
 
 #if USE_SQUID_EUI
         case _external_acl_format::EXT_ACL_SRCEUI48:
             if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
@@ -1015,17 +1029,17 @@
                     request->clientConnectionManager->clientConnection->remoteEui64.encode(buf, sizeof(buf)))
                 str = buf;
             break;
 #endif
 
         case _external_acl_format::EXT_ACL_MYADDR:
-            str = request->my_addr.NtoA(buf, sizeof(buf));
+            str = request->my_addr.toStr(buf, sizeof(buf));
             break;
 
         case _external_acl_format::EXT_ACL_MYPORT:
-            snprintf(buf, sizeof(buf), "%d", request->my_addr.GetPort());
+            snprintf(buf, sizeof(buf), "%d", request->my_addr.port());
             str = buf;
             break;
 
         case _external_acl_format::EXT_ACL_URI:
             str = urlCanonical(request);
             break;
@@ -1227,25 +1241,25 @@
     }
 
     return mb.buf;
 }
 
 static int
-external_acl_entry_expired(external_acl * def, external_acl_entry * entry)
+external_acl_entry_expired(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     if (def->cache_size <= 0)
         return 1;
 
     if (entry->date + (entry->result == 1 ? def->ttl : def->negative_ttl) < squid_curtime)
         return 1;
     else
         return 0;
 }
 
 static int
-external_acl_grace_expired(external_acl * def, external_acl_entry * entry)
+external_acl_grace_expired(external_acl * def, const ExternalACLEntryPointer &entry)
 {
     if (def->cache_size <= 0)
         return 1;
 
     int ttl;
     ttl = entry->result == 1 ? def->ttl : def->negative_ttl;
@@ -1254,16 +1268,16 @@
     if (entry->date + ttl <= squid_curtime)
         return 1;
     else
         return 0;
 }
 
-static external_acl_entry *
+static ExternalACLEntryPointer
 external_acl_cache_add(external_acl * def, const char *key, ExternalACLEntryData const & data)
 {
-    ExternalACLEntry *entry;
+    ExternalACLEntryPointer entry;
 
     // do not bother caching this result if TTL is going to expire it immediately
     if (def->cache_size <= 0 || (def->ttl <= 0 && data.result == 1) || (def->negative_ttl <= 0 && data.result != 1)) {
         debugs(82,6, HERE);
         entry = new ExternalACLEntry;
         entry->key = xstrdup(key);
@@ -1272,17 +1286,16 @@
         return entry;
     }
 
     entry = static_cast<ExternalACLEntry *>(hash_lookup(def->cache, key));
     debugs(82, 2, "external_acl_cache_add: Adding '" << key << "' = " << data.result);
 
-    if (entry) {
-        debugs(82, 3, "ExternalACLEntry::update: updating existing entry");
+    if (entry != NULL) {
+        debugs(82, 3, "updating existing entry");
         entry->update(data);
         external_acl_cache_touch(def, entry);
-
         return entry;
     }
 
     entry = new ExternalACLEntry;
     entry->key = xstrdup(key);
     entry->update(data);
@@ -1290,19 +1303,21 @@
     def->add(entry);
 
     return entry;
 }
 
 static void
-external_acl_cache_delete(external_acl * def, external_acl_entry * entry)
+external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &entry)
 {
+    assert(entry != NULL);
     assert(def->cache_size > 0 && entry->def == def);
-    hash_remove_link(def->cache, entry);
-    dlinkDelete(&entry->lru, &def->lru_list);
+    ExternalACLEntry *e = const_cast<ExternalACLEntry *>(entry.getRaw()); // XXX: make hash a std::map of Pointer.
+    hash_remove_link(def->cache, e);
+    dlinkDelete(&e->lru, &def->lru_list);
+    e->unlock(); // unlock on behalf of the hash
     def->cache_entries -= 1;
-    delete entry;
 }
 
 /******************************************************************
  * external_acl helpers
  */
 
@@ -1343,79 +1358,66 @@
  *   		applies to both OK and ERR responses.
  *   		Won't override existing request tags.
  *   log=	A string to be used in access logging
  *
  * Other keywords may be added to the protocol later
  *
- * value needs to be enclosed in quotes if it may contain whitespace, or
- * the whitespace escaped using \ (\ escaping obviously also applies to
- * any " characters)
+ * value needs to be URL-encoded or enclosed in double quotes (")
+ * with \-escaping on any whitespace, quotes, or slashes (\).
  */
-
 static void
-externalAclHandleReply(void *data, char *reply)
+externalAclHandleReply(void *data, const HelperReply &reply)
 {
     externalAclState *state = static_cast<externalAclState *>(data);
     externalAclState *next;
-    char *status;
-    char *token;
-    char *value;
-    char *t = NULL;
     ExternalACLEntryData entryData;
     entryData.result = ACCESS_DENIED;
-    external_acl_entry *entry = NULL;
 
-    debugs(82, 2, "externalAclHandleReply: reply=\"" << reply << "\"");
+    debugs(82, 2, HERE << "reply=" << reply);
+
+    if (reply.result == HelperReply::Okay)
+        entryData.result = ACCESS_ALLOWED;
+    // XXX: handle other non-DENIED results better
+
+    // XXX: make entryData store a proper HelperReply object instead of copying.
 
-    if (reply) {
-        status = strwordtok(reply, &t);
+    entryData.notes.append(&reply.notes);
+
+    const char *label = reply.notes.findFirst("tag");
+    if (label != NULL && *label != '\0')
+        entryData.tag = label;
+
+    label = reply.notes.findFirst("message");
+    if (label != NULL && *label != '\0')
+        entryData.message = label;
+
+    label = reply.notes.findFirst("log");
+    if (label != NULL && *label != '\0')
+        entryData.log = label;
 
-        if (status && strcmp(status, "OK") == 0)
-            entryData.result = ACCESS_ALLOWED;
-
-        while ((token = strwordtok(NULL, &t))) {
-            value = strchr(token, '=');
-
-            if (value) {
-                *value = '\0';	/* terminate the token, and move up to the value */
-                ++value;
-
-                if (state->def->quote == external_acl::QUOTE_METHOD_URL)
-                    rfc1738_unescape(value);
-
-                if (strcmp(token, "message") == 0)
-                    entryData.message = value;
-                else if (strcmp(token, "error") == 0)
-                    entryData.message = value;
-                else if (strcmp(token, "tag") == 0)
-                    entryData.tag = value;
-                else if (strcmp(token, "log") == 0)
-                    entryData.log = value;
 #if USE_AUTH
-                else if (strcmp(token, "user") == 0)
-                    entryData.user = value;
-                else if (strcmp(token, "password") == 0)
-                    entryData.password = value;
-                else if (strcmp(token, "passwd") == 0)
-                    entryData.password = value;
-                else if (strcmp(token, "login") == 0)
-                    entryData.user = value;
+    label = reply.notes.findFirst("user");
+    if (label != NULL && *label != '\0')
+        entryData.user = label;
+
+    label = reply.notes.findFirst("password");
+    if (label != NULL && *label != '\0')
+        entryData.password = label;
 #endif
-            }
-        }
-    }
 
     dlinkDelete(&state->list, &state->def->queue);
 
+    ExternalACLEntryPointer entry;
     if (cbdataReferenceValid(state->def)) {
-        if (reply)
+        // only cache OK and ERR results.
+        if (reply.result == HelperReply::Okay || reply.result == HelperReply::Error)
             entry = external_acl_cache_add(state->def, state->key, entryData);
         else {
-            external_acl_entry *oldentry = (external_acl_entry *)hash_lookup(state->def->cache, state->key);
+            const ExternalACLEntryPointer oldentry = static_cast<ExternalACLEntry *>(hash_lookup(state->def->cache, state->key));
 
-            if (oldentry)
+            if (oldentry != NULL)
                 external_acl_cache_delete(state->def, oldentry);
         }
     }
 
     do {
         void *cbdata;
@@ -1442,13 +1444,13 @@
 ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool inBackground)
 {
     external_acl *def = acl->def;
 
     ACLFilledChecklist *ch = Filled(checklist);
     const char *key = makeExternalAclKey(ch, acl);
-    assert(key);
+    assert(key); // XXX: will fail if EXT_ACL_IDENT case needs an async lookup
 
     debugs(82, 2, HERE << (inBackground ? "bg" : "fg") << " lookup in '" <<
            def->name << "' for '" << key << "'");
 
     /* Check for a pending lookup to hook into */
     // only possible if we are caching results.
@@ -1592,25 +1594,36 @@
     /* TODO: optimise this - we probably have a pointer to this
      * around somewhere */
     ACL *acl = ACL::FindByName(AclMatchedName);
     assert(acl);
     ACLExternal *me = dynamic_cast<ACLExternal *> (acl);
     assert (me);
-    checklist->asyncInProgress(true);
     ACLExternal::ExternalAclLookup(checklist, me);
 }
 
 /// Called when an async lookup returns
 void
-ExternalACLLookup::LookupDone(void *data, void *result)
+ExternalACLLookup::LookupDone(void *data, const ExternalACLEntryPointer &result)
 {
     ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
-    checklist->extacl_entry = cbdataReference((external_acl_entry *)result);
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
-    checklist->matchNonBlocking();
+    checklist->extacl_entry = result;
+
+    // attach the helper kv-pair to the transaction
+    if (checklist->extacl_entry != NULL) {
+        if (HttpRequest * req = checklist->request) {
+            // XXX: we have no access to the transaction / AccessLogEntry so cant SyncNotes().
+            // workaround by using anything already set in HttpRequest
+            // OR use new and rely on a later Sync copying these to AccessLogEntry
+            if (!req->notes)
+                req->notes = new NotePairs;
+
+            req->notes->appendNewOnly(&checklist->extacl_entry->notes);
+        }
+    }
+
+    checklist->resumeNonBlockingCheck(ExternalACLLookup::Instance());
 }
 
 /* This registers "external" in the registry. To do dynamic definitions
  * of external ACL's, rather than a static prototype, have a Prototype instance
  * prototype in the class that defines each external acl 'class'.
  * Then, then the external acl instance is created, it self registers under
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ExternalACLEntry.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ExternalACLEntry.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ExternalACLEntry.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ExternalACLEntry.cc	2015-05-01 18:05:19.000000000 +0800
@@ -44,30 +44,14 @@
 #include "SquidTime.h"
 
 /******************************************************************
  * external_acl cache
  */
 
-CBDATA_CLASS_INIT(ExternalACLEntry);
-
-void *
-ExternalACLEntry::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (ExternalACLEntry));
-    CBDATA_INIT_TYPE(ExternalACLEntry);
-    return cbdataAlloc(ExternalACLEntry);
-}
-
-void
-ExternalACLEntry::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-ExternalACLEntry::ExternalACLEntry()
+ExternalACLEntry::ExternalACLEntry() :
+        notes()
 {
     lru.next = lru.prev = NULL;
     result = ACCESS_DENIED;
     date = 0;
     def = NULL;
 }
@@ -79,12 +63,17 @@
 
 void
 ExternalACLEntry::update(ExternalACLEntryData const &someData)
 {
     date = squid_curtime;
     result = someData.result;
+
+    // replace all notes. not combine
+    notes.entries.clean();
+    notes.append(&someData.notes);
+
 #if USE_AUTH
     user = someData.user;
     password = someData.password;
 #endif
     message = someData.message;
     tag = someData.tag;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ExternalACLEntry.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ExternalACLEntry.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ExternalACLEntry.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ExternalACLEntry.h	2015-05-01 18:05:19.000000000 +0800
@@ -40,14 +40,15 @@
  */
 
 #ifndef SQUID_EXTERNALACLENTRY_H
 #define SQUID_EXTERNALACLENTRY_H
 
 #include "acl/Acl.h"
-#include "cbdata.h"
+#include "acl/forward.h"
 #include "hash.h"
+#include "Notes.h"
 #include "SquidString.h"
 
 class external_acl;
 /******************************************************************
  * ExternalACLEntryData
  * Core data that ExternalACLEntry manages.
@@ -59,12 +60,16 @@
 {
 
 public:
     ExternalACLEntryData() : result(ACCESS_DUNNO) {}
 
     allow_t result;
+
+    /// list of all kv-pairs returned by the helper
+    NotePairs notes;
+
 #if USE_AUTH
     // TODO use an AuthUser to hold this info
     String user;
     String password;
 #endif
     String message;
@@ -74,36 +79,35 @@
 
 /*******************************************************************
  * external_acl cache entry
  * Used opaqueue in the interface
  */
 
-class ExternalACLEntry: public hash_link
+class ExternalACLEntry: public hash_link, public RefCountable
 {
-
 public:
-    void *operator new (size_t bytesToAllocate);
-    void operator delete (void *address);
-
     ExternalACLEntry();
     ~ExternalACLEntry();
 
     void update(ExternalACLEntryData const &);
     dlink_node lru;
     allow_t result;
     time_t date;
+
+    /// list of all kv-pairs returned by the helper
+    NotePairs notes;
+
 #if USE_AUTH
     String user;
     String password;
 #endif
     String message;
     String tag;
     String log;
     external_acl *def;
 
-private:
-    CBDATA_CLASS(ExternalACLEntry);
+    MEMPROXY_CLASS(ExternalACLEntry);
 };
 
-typedef class ExternalACLEntry external_acl_entry;
+MEMPROXY_CLASS_INLINE(ExternalACLEntry);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ExternalACL.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ExternalACL.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ExternalACL.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ExternalACL.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,12 +30,14 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 #ifndef SQUID_EXTERNALACL_H
 #define SQUID_EXTERNALACL_H
 
 #include "acl/Checklist.h"
+#include "base/RefCount.h"
+
 class external_acl;
 class StoreEntry;
 
 /** \todo CLEANUP: kill this typedef. */
 typedef struct _external_acl_data external_acl_data;
 
@@ -49,13 +51,13 @@
     // If possible, starts an asynchronous lookup of an external ACL.
     // Otherwise, asserts (or bails if background refresh is requested).
     static void Start(ACLChecklist *checklist, external_acl_data *acl, bool bg);
 
 private:
     static ExternalACLLookup instance_;
-    static void LookupDone(void *data, void *result);
+    static void LookupDone(void *data, const ExternalACLEntryPointer &result);
 };
 
 #include "acl/Acl.h"
 
 class ACLExternal : public ACL
 {
@@ -93,12 +95,12 @@
 
 MEMPROXY_CLASS_INLINE(ACLExternal);
 
 void parse_externalAclHelper(external_acl **);
 void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
 void free_externalAclHelper(external_acl **);
-typedef void EAH(void *data, void *result);
+typedef void EAH(void *data, const ExternalACLEntryPointer &result);
 void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
 void externalAclInit(void);
 void externalAclShutdown(void);
 
 #endif /* SQUID_EXTERNALACL_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/FadingCounter.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/FadingCounter.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/FadingCounter.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/FadingCounter.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,10 @@
 #ifndef SQUID_FADING_COUNTER_H
 #define SQUID_FADING_COUNTER_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /// Counts events, forgetting old ones. Usefull for "3 errors/minute" limits.
 class FadingCounter
 {
 public:
     FadingCounter();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fatal.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fatal.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fatal.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fatal.cc	2015-05-01 18:05:19.000000000 +0800
@@ -34,15 +34,12 @@
 #include "SwapDir.h"
 #include "tools.h"
 
 #if HAVE_STDIO_H
 #include <stdio.h>
 #endif
-#if HAVE_STDLIB_H
-#include <stdlib.h>
-#endif
 
 static void
 fatal_common(const char *message)
 {
 #if HAVE_SYSLOG
     syslog(LOG_ALERT, "%s", message);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fd.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fd.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fd.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fd.cc	2015-05-01 18:05:19.000000000 +0800
@@ -39,13 +39,13 @@
 #include "globals.h"
 #include "profiler/Profiler.h"
 #include "SquidTime.h"
 
 // Solaris and possibly others lack MSG_NOSIGNAL optimization
 // TODO: move this into compat/? Use a dedicated compat file to avoid dragging
-// sys/types.h and sys/socket.h into the rest of Squid??
+// sys/socket.h into the rest of Squid??
 #ifndef MSG_NOSIGNAL
 #define MSG_NOSIGNAL 0
 #endif
 
 int default_read_method(int, char *, int);
 int default_write_method(int, const char *, int);
@@ -103,23 +103,23 @@
 void
 fd_close(int fd)
 {
     fde *F = &fd_table[fd];
 
     assert(fd >= 0);
-    assert(F->flags.open == 1);
+    assert(F->flags.open);
 
     if (F->type == FD_FILE) {
         assert(F->read_handler == NULL);
         assert(F->write_handler == NULL);
     }
 
     debugs(51, 3, "fd_close FD " << fd << " " << F->desc);
     Comm::SetSelect(fd, COMM_SELECT_READ, NULL, NULL, 0);
     Comm::SetSelect(fd, COMM_SELECT_WRITE, NULL, NULL, 0);
-    F->flags.open = 0;
+    F->flags.open = false;
     fdUpdateBiggest(fd, 0);
     --Number_FD;
     *F = fde();
 }
 
 #if _SQUID_WINDOWS_
@@ -217,13 +217,13 @@
         fd_close(fd);
     }
 
     assert(!F->flags.open);
     debugs(51, 3, "fd_open() FD " << fd << " " << desc);
     F->type = type;
-    F->flags.open = 1;
+    F->flags.open = true;
     F->epoll_state = 0;
 #if _SQUID_WINDOWS_
 
     F->win32.handle = _get_osfhandle(fd);
 
     switch (type) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fde.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fde.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fde.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fde.cc	2015-05-01 18:05:19.000000000 +0800
@@ -113,13 +113,13 @@
     if (type != FD_SOCKET)
         return null_string;
 
     if ( *ipaddr )
         snprintf( buf, MAX_IPSTRLEN, "%s:%d", ipaddr, (int)remote_port);
     else
-        local_addr.ToURL(buf,MAX_IPSTRLEN); // ToHostname does not include port.
+        local_addr.toUrl(buf,MAX_IPSTRLEN); // toHostStr does not include port.
 
     return buf;
 }
 
 void
 fde::noteUse(PconnPool *pool)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fde.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fde.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fde.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fde.h	2015-05-01 18:05:19.000000000 +0800
@@ -87,25 +87,25 @@
                                         See also nfmarkFromServer. */
     int sock_family;
     char ipaddr[MAX_IPSTRLEN];            /* dotted decimal address of peer */
     char desc[FD_DESC_SZ];
 
     struct _fde_flags {
-        unsigned int open:1;
-        unsigned int close_request:1; // file_ or comm_close has been called
-        unsigned int write_daemon:1;
-        unsigned int socket_eof:1;
-        unsigned int nolinger:1;
-        unsigned int nonblocking:1;
-        unsigned int ipc:1;
-        unsigned int called_connect:1;
-        unsigned int nodelay:1;
-        unsigned int close_on_exec:1;
-        unsigned int read_pending:1;
-        unsigned int write_pending:1;
-        unsigned int transparent:1;
+        bool open;
+        bool close_request; ///< true if file_ or comm_close has been called
+        bool write_daemon;
+        bool socket_eof;
+        bool nolinger;
+        bool nonblocking;
+        bool ipc;
+        bool called_connect;
+        bool nodelay;
+        bool close_on_exec;
+        bool read_pending;
+        //bool write_pending; //XXX seems not to be used
+        bool transparent;
     } flags;
 
     int64_t bytes_read;
     int64_t bytes_written;
 
     struct {
@@ -154,13 +154,13 @@
 
 private:
     /** Clear the fde class back to NULL equivalent. */
     inline void clear() {
         type = 0;
         remote_port = 0;
-        local_addr.SetEmpty();
+        local_addr.setEmpty();
         tosToServer = '\0';
         nfmarkToServer = 0;
         sock_family = 0;
         memset(ipaddr, '\0', MAX_IPSTRLEN);
         memset(desc,'\0',FD_DESC_SZ);
         memset(&flags,0,sizeof(_fde_flags));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/ByteCode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/ByteCode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/ByteCode.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/ByteCode.h	2015-05-01 18:05:19.000000000 +0800
@@ -32,12 +32,14 @@
     LFT_CLIENT_EUI,
 
     /* client TCP connection local end details */
     LFT_CLIENT_LOCAL_IP,
     LFT_CLIENT_LOCAL_PORT,
     /*LFT_CLIENT_LOCAL_FQDN, (rDNS) */
+    LFT_CLIENT_LOCAL_TOS,
+    LFT_CLIENT_LOCAL_NFMARK,
 
     /* client connection local squid.conf details */
     LFT_LOCAL_LISTENING_IP,
     LFT_LOCAL_LISTENING_PORT,
     /*LFT_LOCAL_LISTENING_NAME, (myportname) */
 
@@ -47,12 +49,14 @@
     LFT_SERVER_PORT,
 
     /* server TCP connection local end details */
     LFT_SERVER_LOCAL_IP,
     LFT_SERVER_LOCAL_IP_OLD_27,
     LFT_SERVER_LOCAL_PORT,
+    LFT_SERVER_LOCAL_TOS,
+    LFT_SERVER_LOCAL_NFMARK,
 
     /* original Request-Line details recieved from client */
     LFT_CLIENT_REQ_METHOD,
     LFT_CLIENT_REQ_URI,
     LFT_CLIENT_REQ_URLPATH,
     /* LFT_CLIENT_REQ_QUERY, */
@@ -193,23 +197,22 @@
 #if USE_SSL
     LFT_SSL_BUMP_MODE,
     LFT_SSL_USER_CERT_SUBJECT,
     LFT_SSL_USER_CERT_ISSUER,
 #endif
 
+    LFT_NOTE,
     LFT_PERCENT			/* special string cases for escaped chars */
 } ByteCode_t;
 
 /// Quoting style for a format output.
 enum Quoting {
     LOG_QUOTE_NONE = 0,
     LOG_QUOTE_QUOTES,
     LOG_QUOTE_MIMEBLOB,
     LOG_QUOTE_URL,
     LOG_QUOTE_RAW
 };
 
-extern const char *log_tags[];
-
 } // namespace Format
 
 #endif /* _SQUID_FMT_BYTECODE_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Format.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Format.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Format.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Format.cc	2015-05-01 18:05:19.000000000 +0800
@@ -76,22 +76,22 @@
     }
 
     return true;
 }
 
 void
-Format::Format::dump(StoreEntry * entry, const char *name)
+Format::Format::dump(StoreEntry * entry, const char *directiveName)
 {
     debugs(46, 4, HERE);
 
     // loop rather than recursing to conserve stack space.
-    for (Format *format = this; format; format = format->next) {
-        debugs(46, 3, HERE << "Dumping format definition for " << format->name);
-        storeAppendPrintf(entry, "format %s ", format->name);
+    for (Format *fmt = this; fmt; fmt = fmt->next) {
+        debugs(46, 3, HERE << "Dumping format definition for " << fmt->name);
+        storeAppendPrintf(entry, "%s %s ", directiveName, fmt->name);
 
-        for (Token *t = format->format; t; t = t->next) {
+        for (Token *t = fmt->format; t; t = t->next) {
             if (t->type == LFT_STRING)
                 storeAppendPrintf(entry, "%s", t->data.string);
             else {
                 char argbuf[256];
                 char *arg = NULL;
                 ByteCode_t type = t->type;
@@ -328,111 +328,139 @@
         case LFT_CLIENT_IP_ADDRESS:
             al->getLogClientIp(tmp, sizeof(tmp));
             out = tmp;
             break;
 
         case LFT_CLIENT_FQDN:
-            if (al->cache.caddr.IsAnyAddr()) // e.g., ICAP OPTIONS lack client
+            if (al->cache.caddr.isAnyAddr()) // e.g., ICAP OPTIONS lack client
                 out = "-";
             else
                 out = fqdncache_gethostbyaddr(al->cache.caddr, FQDN_LOOKUP_IF_MISS);
             if (!out) {
-                out = al->cache.caddr.NtoA(tmp,1024);
+                out = al->cache.caddr.toStr(tmp,1024);
             }
 
             break;
 
         case LFT_CLIENT_PORT:
             if (al->request) {
-                outint = al->request->client_addr.GetPort();
+                outint = al->request->client_addr.port();
                 doint = 1;
             }
             break;
 
         case LFT_CLIENT_EUI:
 #if USE_SQUID_EUI
             // TODO make the ACL checklist have a direct link to any TCP details.
             if (al->request && al->request->clientConnectionManager.valid() && al->request->clientConnectionManager->clientConnection != NULL) {
-                if (al->request->clientConnectionManager->clientConnection->remote.IsIPv4())
+                if (al->request->clientConnectionManager->clientConnection->remote.isIPv4())
                     al->request->clientConnectionManager->clientConnection->remoteEui48.encode(tmp, 1024);
                 else
                     al->request->clientConnectionManager->clientConnection->remoteEui64.encode(tmp, 1024);
                 out = tmp;
             }
 #else
             out = "-";
 #endif
             break;
 
         case LFT_SERVER_IP_ADDRESS:
             if (al->hier.tcpServer != NULL) {
-                out = al->hier.tcpServer->remote.NtoA(tmp,sizeof(tmp));
+                out = al->hier.tcpServer->remote.toStr(tmp,sizeof(tmp));
             }
             break;
 
         case LFT_SERVER_FQDN_OR_PEER_NAME:
             out = al->hier.host;
             break;
 
         case LFT_SERVER_PORT:
             if (al->hier.tcpServer != NULL) {
-                outint = al->hier.tcpServer->remote.GetPort();
+                outint = al->hier.tcpServer->remote.port();
                 doint = 1;
             }
             break;
 
         case LFT_LOCAL_LISTENING_IP: {
             // avoid logging a dash if we have reliable info
             const bool interceptedAtKnownPort = al->request ?
-                                                (al->request->flags.spoofClientIp ||
+                                                (al->request->flags.interceptTproxy ||
                                                  al->request->flags.intercepted) && al->cache.port :
                                                 false;
             if (interceptedAtKnownPort) {
-                const bool portAddressConfigured = !al->cache.port->s.IsAnyAddr();
+                const bool portAddressConfigured = !al->cache.port->s.isAnyAddr();
                 if (portAddressConfigured)
-                    out = al->cache.port->s.NtoA(tmp, sizeof(tmp));
+                    out = al->cache.port->s.toStr(tmp, sizeof(tmp));
             } else if (al->tcpClient != NULL)
-                out = al->tcpClient->local.NtoA(tmp, sizeof(tmp));
+                out = al->tcpClient->local.toStr(tmp, sizeof(tmp));
         }
         break;
 
         case LFT_CLIENT_LOCAL_IP:
             if (al->tcpClient != NULL) {
-                out = al->tcpClient->local.NtoA(tmp,sizeof(tmp));
+                out = al->tcpClient->local.toStr(tmp,sizeof(tmp));
+            }
+            break;
+
+        case LFT_CLIENT_LOCAL_TOS:
+            if (al->tcpClient != NULL) {
+                snprintf(tmp, sizeof(tmp), "0x%x", (uint32_t)al->tcpClient->tos);
+                out = tmp;
+            }
+            break;
+
+        case LFT_CLIENT_LOCAL_NFMARK:
+            if (al->tcpClient != NULL) {
+                snprintf(tmp, sizeof(tmp), "0x%x", al->tcpClient->nfmark);
+                out = tmp;
             }
             break;
 
         case LFT_LOCAL_LISTENING_PORT:
             if (al->cache.port) {
-                outint = al->cache.port->s.GetPort();
+                outint = al->cache.port->s.port();
                 doint = 1;
             }
             break;
 
         case LFT_CLIENT_LOCAL_PORT:
             if (al->tcpClient != NULL) {
-                outint = al->tcpClient->local.GetPort();
+                outint = al->tcpClient->local.port();
                 doint = 1;
             }
             break;
 
         case LFT_SERVER_LOCAL_IP_OLD_27:
         case LFT_SERVER_LOCAL_IP:
             if (al->hier.tcpServer != NULL) {
-                out = al->hier.tcpServer->local.NtoA(tmp,sizeof(tmp));
+                out = al->hier.tcpServer->local.toStr(tmp,sizeof(tmp));
             }
             break;
 
         case LFT_SERVER_LOCAL_PORT:
             if (al->hier.tcpServer != NULL) {
-                outint = al->hier.tcpServer->local.GetPort();
+                outint = al->hier.tcpServer->local.port();
                 doint = 1;
             }
 
             break;
 
+        case LFT_SERVER_LOCAL_TOS:
+            if (al->hier.tcpServer != NULL) {
+                snprintf(tmp, sizeof(tmp), "0x%x", (uint32_t)al->hier.tcpServer->tos);
+                out = tmp;
+            }
+            break;
+
+        case LFT_SERVER_LOCAL_NFMARK:
+            if (al->hier.tcpServer != NULL) {
+                snprintf(tmp, sizeof(tmp), "0x%x", al->hier.tcpServer->nfmark);
+                out = tmp;
+            }
+            break;
+
         case LFT_TIME_SECONDS_SINCE_EPOCH:
             // some platforms store time in 32-bit, some 64-bit...
             outoff = static_cast<int64_t>(current_time.tv_sec);
             dooff = 1;
             break;
 
@@ -444,13 +472,13 @@
         case LFT_TIME_LOCALTIME:
 
         case LFT_TIME_GMT: {
             const char *spec;
 
             struct tm *t;
-            spec = fmt->data.timespec;
+            spec = fmt->data.string;
 
             if (fmt->type == LFT_TIME_LOCALTIME) {
                 if (!spec)
                     spec = "%d/%b/%Y:%H:%M:%S %z";
                 t = localtime(&squid_curtime);
             } else {
@@ -583,13 +611,13 @@
             break;
 #endif
 
 #if ICAP_CLIENT
         case LFT_ICAP_ADDR:
             if (!out)
-                out = al->icap.hostAddr.NtoA(tmp,1024);
+                out = al->icap.hostAddr.toStr(tmp,1024);
             break;
 
         case LFT_ICAP_SERV_NAME:
             out = al->icap.serviceName.termedBuf();
             break;
 
@@ -800,13 +828,13 @@
 
             doint = 1;
 
             break;
 
         case LFT_HTTP_RECEIVED_STATUS_CODE:
-            if (al->hier.peer_reply_status == HTTP_STATUS_NONE) {
+            if (al->hier.peer_reply_status == Http::scNone) {
                 out = "-";
             } else {
                 outint = al->hier.peer_reply_status;
                 doint = 1;
             }
             break;
@@ -824,17 +852,17 @@
             // a peer server so just print a "-" (eg requests served from cache,
             // or internal error messages).
             break;
 
         case LFT_SQUID_STATUS:
             if (al->http.timedout || al->http.aborted) {
-                snprintf(tmp, sizeof(tmp), "%s%s", log_tags[al->cache.code],
+                snprintf(tmp, sizeof(tmp), "%s%s", LogTags_str[al->cache.code],
                          al->http.statusSfx());
                 out = tmp;
             } else {
-                out = log_tags[al->cache.code];
+                out = LogTags_str[al->cache.code];
             }
 
             break;
 
         case LFT_SQUID_ERROR:
             if (al->request && al->request->errType != ERR_NONE)
@@ -1044,12 +1072,49 @@
                     out = tmp;
                 }
             }
             break;
 #endif
 
+        case LFT_NOTE:
+            tmp[0] = fmt->data.header.separator;
+            tmp[1] = '\0';
+            if (fmt->data.header.header && *fmt->data.header.header) {
+                const char *separator = tmp;
+#if USE_ADAPTATION
+                Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
+                if (ah != NULL && ah->metaHeaders != NULL) {
+                    if (const char *meta = ah->metaHeaders->find(fmt->data.header.header, separator))
+                        sb.append(meta);
+                }
+#endif
+                if (al->notes != NULL) {
+                    if (const char *note = al->notes->find(fmt->data.header.header, separator)) {
+                        if (sb.size())
+                            sb.append(separator);
+                        sb.append(note);
+                    }
+                }
+                out = sb.termedBuf();
+                quote = 1;
+            } else {
+                // if no argument given use default "\r\n" as notes separator
+                const char *separator = fmt->data.string ? tmp : "\r\n";
+#if USE_ADAPTATION
+                Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
+                if (ah != NULL && ah->metaHeaders != NULL && !ah->metaHeaders->empty())
+                    sb.append(ah->metaHeaders->toString(separator));
+#endif
+                if (al->notes != NULL && !al->notes->empty())
+                    sb.append(al->notes->toString(separator));
+
+                out = sb.termedBuf();
+                quote = 1;
+            }
+            break;
+
         case LFT_PERCENT:
             out = "%";
 
             break;
         }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Format.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Format.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Format.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Format.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,10 @@
 #ifndef _SQUID_FORMAT_FORMAT_H
 #define _SQUID_FORMAT_FORMAT_H
 
-#include "RefCount.h"
+#include "base/RefCount.h"
 /*
  * Squid configuration allows users to define custom formats in
  * several components.
  * - logging
  * - external ACL input
  * - deny page URL
@@ -38,13 +38,13 @@
     bool parse(const char *def);
 
     /// assemble the state information into a formatted line.
     void assemble(MemBuf &mb, const AccessLogEntryPointer &al, int logSequenceNumber) const;
 
     /// dump this whole list of formats into the provided StoreEntry
-    void dump(StoreEntry * entry, const char *name);
+    void dump(StoreEntry * entry, const char *directiveName);
 
     char *name;
     Token *format;
     Format *next;
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Makefile.in	2015-05-01 16:51:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Makefile.in	2015-05-01 18:06:54.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -451,12 +497,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -494,12 +541,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -526,27 +574,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -613,13 +664,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libformat.la
 libformat_la_SOURCES = \
 	ByteCode.h \
 	Config.cc \
 	Config.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Token.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Token.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Token.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Token.cc	2015-05-01 18:05:19.000000000 +0800
@@ -3,38 +3,12 @@
 #include "format/Token.h"
 #include "format/TokenTableEntry.h"
 #include "globals.h"
 #include "SquidConfig.h"
 #include "Store.h"
 
-const char *Format::log_tags[] = {
-    "NONE",
-    "TCP_HIT",
-    "TCP_MISS",
-    "TCP_REFRESH_UNMODIFIED",
-    "TCP_REFRESH_FAIL", // same tag logged for LOG_TCP_REFRESH_FAIL_OLD and
-    "TCP_REFRESH_FAIL", // LOG_TCP_REFRESH_FAIL_ERR for backward-compatibility
-    "TCP_REFRESH_MODIFIED",
-    "TCP_CLIENT_REFRESH_MISS",
-    "TCP_IMS_HIT",
-    "TCP_SWAPFAIL_MISS",
-    "TCP_NEGATIVE_HIT",
-    "TCP_MEM_HIT",
-    "TCP_DENIED",
-    "TCP_DENIED_REPLY",
-    "TCP_OFFLINE_HIT",
-    "TCP_REDIRECT",
-    "UDP_HIT",
-    "UDP_MISS",
-    "UDP_DENIED",
-    "UDP_INVALID",
-    "UDP_MISS_NOFETCH",
-    "ICP_QUERY",
-    "LOG_TYPE_MAX"
-};
-
 // Due to token overlaps between 1 and 2 letter tokens (Bug 3310)
 // We split the token table into sets determined by the token length
 namespace Format
 {
 
 /// 1-char tokens.
@@ -69,13 +43,12 @@
     {"lp", LFT_LOCAL_LISTENING_PORT},
     /*{ "lA", LFT_LOCAL_NAME }, */
 
     {"<la", LFT_SERVER_LOCAL_IP},
     {"oa", LFT_SERVER_LOCAL_IP_OLD_27},
     {"<lp", LFT_SERVER_LOCAL_PORT},
-    /* {"ot", LFT_PEER_OUTGOING_TOS}, */
 
     {"ts", LFT_TIME_SECONDS_SINCE_EPOCH},
     {"tu", LFT_TIME_SUBSECOND},
     {"tl", LFT_TIME_LOCALTIME},
     {"tg", LFT_TIME_GMT},
     {"tr", LFT_TIME_TO_HANDLE_REQUEST},
@@ -145,14 +118,19 @@
     {NULL, LFT_NONE}		/* this must be last */
 };
 
 /// Miscellaneous >2 byte tokens
 static TokenTableEntry TokenTableMisc[] = {
     {">eui", LFT_CLIENT_EUI},
+    {">qos", LFT_CLIENT_LOCAL_TOS},
+    {"<qos", LFT_SERVER_LOCAL_TOS},
+    {">nfmark", LFT_CLIENT_LOCAL_NFMARK},
+    {"<nfmark", LFT_SERVER_LOCAL_NFMARK},
     {"err_code", LFT_SQUID_ERROR },
     {"err_detail", LFT_SQUID_ERROR_DETAIL },
+    {"note", LFT_NOTE },
     {NULL, LFT_NONE}		/* this must be last */
 };
 
 #if USE_ADAPTATION
 static TokenTableEntry TokenTableAdapt[] = {
     {"all_trs", LFT_ADAPTATION_ALL_XACT_TIMES},
@@ -318,18 +296,18 @@
     default:
         quote = *quoting;
         break;
     }
 
     if (*cur == '-') {
-        left = 1;
+        left = true;
         ++cur;
     }
 
     if (*cur == '0') {
-        zero = 1;
+        zero = true;
         ++cur;
     }
 
     char *endp;
     if (xisdigit(*cur)) {
         widthMin = strtol(cur, &endp, 10);
@@ -399,13 +377,13 @@
 
     if (type == LFT_NONE) {
         fatalf("Can't parse configuration token: '%s'\n", def);
     }
 
     if (*cur == ' ') {
-        space = 1;
+        space = true;
         ++cur;
     }
 
 done:
 
     switch (type) {
@@ -423,12 +401,14 @@
     case LFT_ADAPTED_REQUEST_HEADER:
 
     case LFT_REQUEST_HEADER:
 
     case LFT_REPLY_HEADER:
 
+    case LFT_NOTE:
+
         if (data.string) {
             char *header = data.string;
             char *cp = strchr(header, ':');
 
             if (cp) {
                 *cp = '\0';
@@ -557,12 +537,29 @@
         break;
     }
 
     return (cur - def);
 }
 
+Format::Token::Token() : type(LFT_NONE),
+        label(NULL),
+        widthMin(-1),
+        widthMax(-1),
+        quote(LOG_QUOTE_NONE),
+        left(false),
+        space(false),
+        zero(false),
+        divisor(1),
+        next(NULL)
+{
+    data.string = NULL;
+    data.header.header = NULL;
+    data.header.element = NULL;
+    data.header.separator = ',';
+}
+
 Format::Token::~Token()
 {
     label = NULL; // drop reference to global static.
     safe_free(data.string);
     while (next) {
         Token *tokens = next;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Token.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Token.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/format/Token.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/format/Token.h	2015-05-01 18:05:19.000000000 +0800
@@ -24,24 +24,13 @@
 #define LOG_BUF_SZ (MAX_URL<<2)
 
 // XXX: inherit from linked list
 class Token
 {
 public:
-    Token() : type(LFT_NONE),
-            label(NULL),
-            widthMin(-1),
-            widthMax(-1),
-            quote(LOG_QUOTE_NONE),
-            left(0),
-            space(0),
-            zero(0),
-            divisor(0),
-            next(NULL)
-    { data.string = NULL; }
-
+    Token();
     ~Token();
 
     /// Initialize the format token registrations
     static void Init();
 
     /** parses a single token. Returns the token length in characters,
@@ -49,34 +38,31 @@
      * def is for sure null-terminated.
      */
     int parse(const char *def, enum Quoting *quote);
 
     ByteCode_t type;
     const char *label;
-    union {
+    struct {
         char *string;
 
         struct {
             char *header;
             char *element;
             char separator;
         } header;
-        char *timespec;
     } data;
     int widthMin; ///< minimum field width
     int widthMax; ///< maximum field width
     enum Quoting quote;
-    unsigned int left:1;
-    unsigned int space:1;
-    unsigned int zero:1;
-    int divisor;
+    bool left;
+    bool space;
+    bool zero;
+    int divisor;    // class invariant: MUST NOT be zero.
     Token *next;	/* todo: move from linked list to array */
 
 private:
     const char *scanForToken(TokenTableEntry const table[], const char *cur);
 };
 
-extern const char *log_tags[];
-
 } // namespace Format
 
 #endif /* _SQUID_FORMAT_TOKEN_H */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src: forward.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src: forward.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fqdncache.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fqdncache.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fqdncache.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fqdncache.cc	2015-05-01 18:05:19.000000000 +0800
@@ -31,12 +31,14 @@
  */
 
 #include "squid.h"
 #include "cbdata.h"
 #include "DnsLookupDetails.h"
 #include "event.h"
+#include "helper.h"
+#include "HelperReply.h"
 #include "Mem.h"
 #include "mgr/Registration.h"
 #include "SquidConfig.h"
 #include "SquidDns.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
@@ -111,14 +113,14 @@
 
     struct timeval request_time;
     dlink_node lru;
     unsigned short locks;
 
     struct {
-        unsigned int negcached:1;
-        unsigned int fromhosts:1;
+        bool negcached;
+        bool fromhosts;
     } flags;
 
     int age() const; ///< time passed since request_time or -1 if unknown
 };
 
 /// \ingroup FQDNCacheInternal
@@ -423,13 +425,13 @@
 fqdncacheParse(fqdncache_entry *f, const rfc1035_rr * answers, int nr, const char *error_message)
 {
     int k;
     int ttl = 0;
     const char *name = (const char *)f->hash.key;
     f->expires = squid_curtime + Config.negativeDnsTtl;
-    f->flags.negcached = 1;
+    f->flags.negcached = true;
 
     if (nr < 0) {
         debugs(35, 3, "fqdncacheParse: Lookup of '" << name << "' failed (" << error_message << ")");
         f->error_message = xstrdup(error_message);
         return -1;
     }
@@ -480,13 +482,13 @@
 
     if (ttl < Config.negativeDnsTtl)
         ttl = Config.negativeDnsTtl;
 
     f->expires = squid_curtime + ttl;
 
-    f->flags.negcached = 0;
+    f->flags.negcached = false;
 
     return f->name_count;
 }
 
 #endif
 
@@ -494,25 +496,25 @@
  \ingroup FQDNCacheAPI
  *
  * Callback for handling DNS results.
  */
 static void
 #if USE_DNSHELPER
-fqdncacheHandleReply(void *data, char *reply)
+fqdncacheHandleReply(void *data, const HelperReply &reply)
 #else
 fqdncacheHandleReply(void *data, const rfc1035_rr * answers, int na, const char *error_message)
 #endif
 {
     fqdncache_entry *f;
     static_cast<generic_cbdata *>(data)->unwrap(&f);
     ++FqdncacheStats.replies;
     const int age = f->age();
     statCounter.dns.svcTime.count(age);
 #if USE_DNSHELPER
 
-    fqdncacheParse(f, reply);
+    fqdncacheParse(f, reply.other().content());
 #else
 
     fqdncacheParse(f, answers, na, error_message);
 #endif
 
     fqdncacheAddEntry(f);
@@ -533,13 +535,13 @@
 void
 fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handlerData)
 {
     fqdncache_entry *f = NULL;
     char name[MAX_IPSTRLEN];
     generic_cbdata *c;
-    addr.NtoA(name,MAX_IPSTRLEN);
+    addr.toStr(name,MAX_IPSTRLEN);
     debugs(35, 4, "fqdncache_nbgethostbyaddr: Name '" << name << "'.");
     ++FqdncacheStats.requests;
 
     if (name[0] == '\0') {
         debugs(35, 4, "fqdncache_nbgethostbyaddr: Invalid name!");
         const DnsLookupDetails details("Invalid hostname", -1); // error, no lookup
@@ -604,17 +606,17 @@
 const char *
 fqdncache_gethostbyaddr(const Ip::Address &addr, int flags)
 {
     char name[MAX_IPSTRLEN];
     fqdncache_entry *f = NULL;
 
-    if (addr.IsAnyAddr() || addr.IsNoAddr()) {
+    if (addr.isAnyAddr() || addr.isNoAddr()) {
         return NULL;
     }
 
-    addr.NtoA(name,MAX_IPSTRLEN);
+    addr.toStr(name,MAX_IPSTRLEN);
     ++ FqdncacheStats.requests;
     f = fqdncache_get(name);
 
     if (NULL == f) {
         (void) 0;
     } else if (fqdncacheExpiredEntry(f)) {
@@ -697,31 +699,12 @@
             storeAppendPrintf(sentry, " %s", f->names[k]);
 
         storeAppendPrintf(sentry, "\n");
     }
 }
 
-/// \ingroup FQDNCacheAPI
-#if 0
-const char *
-fqdnFromAddr(const Ip::Address &addr)
-{
-    const char *n;
-    static char buf[MAX_IPSTRLEN];
-
-    if (Config.onoff.log_fqdn && (n = fqdncache_gethostbyaddr(addr, 0)))
-        return n;
-
-/// \todo Perhapse this should use toHostname() instead of straight NtoA.
-///       that would wrap the IPv6 properly when raw.
-    addr.NtoA(buf, MAX_IPSTRLEN);
-
-    return buf;
-}
-#endif
-
 /// \ingroup FQDNCacheInternal
 static void
 fqdncacheLockEntry(fqdncache_entry * f)
 {
     if (f->locks++ == 0) {
         dlinkDelete(&f->lru, &lru_list);
@@ -822,13 +805,13 @@
         if (j >= FQDN_MAX_NAMES)
             break;
     }
 
     fce->name_count = j;
     fce->names[j] = NULL;	/* it's safe */
-    fce->flags.fromhosts = 1;
+    fce->flags.fromhosts = true;
     fqdncacheAddEntry(fce);
     fqdncacheLockEntry(fce);
 }
 
 /// \ingroup FQDNCacheInternal
 static void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/coss/store_coss.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/coss/store_coss.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/coss/store_coss.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/coss/store_coss.h	2015-05-01 18:05:19.000000000 +0800
@@ -33,14 +33,15 @@
     off_t diskend;		/* in blocks */
     CossSwapDir *SD;
     int lockcount;
     char buffer[COSS_MEMBUF_SZ];
 
     struct _cossmembuf_flags {
-        unsigned int full:1;
-        unsigned int writing:1;
+        _cossmembuf_flags() : full(false), writing(false) {}
+        bool full;
+        bool writing;
     } flags;
 };
 
 /// \ingroup COSS
 struct _cossindex {
     /**
@@ -65,15 +66,15 @@
     char *readbuffer;
     char *requestbuf;
     size_t requestlen;
     size_t requestoffset;	/* in blocks */
     int64_t reqdiskoffset;	/* in blocks */
 
-    struct {
-        unsigned int reading:1;
-        unsigned int writing:1;
+    struct CossFlags {
+        bool reading;
+        bool writing;
     } flags;
 
     CossMemBuf *locked_membuf;
     off_t st_size;
     void read_(char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data);
     void write(char const *buf, size_t size, off_t offset, FREE * free_func);
@@ -103,34 +104,30 @@
 
 /// \ingroup COSS
 class CossRead : public ReadRequest
 {
 
 public:
-    void * operator new (size_t);
-    void operator delete (void *);
     CossRead(ReadRequest const &base, StoreIOState::Pointer anSio) : ReadRequest(base) , sio(anSio) {}
 
     StoreIOState::Pointer sio;
 
 private:
-    CBDATA_CLASS(CossRead);
+    CBDATA_CLASS2(CossRead);
 };
 
 #include "DiskIO/WriteRequest.h"
 
 /// \ingroup COSS
 class CossWrite : public WriteRequest
 {
 
 public:
-    void * operator new (size_t);
-    void operator delete (void *);
     CossWrite(WriteRequest const &base, CossMemBuf *aBuf) : WriteRequest(base) , membuf(aBuf) {}
 
     CossMemBuf *membuf;
 
 private:
-    CBDATA_CLASS(CossWrite);
+    CBDATA_CLASS2(CossWrite);
 };
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/coss/store_dir_coss.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/coss/store_dir_coss.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/coss/store_dir_coss.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/coss/store_dir_coss.cc	2015-05-01 18:05:19.000000000 +0800
@@ -173,13 +173,13 @@
     StoreIOState::STRCB *callback = sio->read.callback;
     char *p;
     CossState *cstate = dynamic_cast<CossState *>(sio.getRaw());
     ssize_t rlen;
 
     debugs(79, 3, "storeCossReadDone: fileno " << sio->swap_filen << ", len " << len);
-    cstate->flags.reading = 0;
+    cstate->flags.reading = false;
 
     if (errflag) {
         ++ StoreFScoss::GetInstance().stats.read.fail;
 
         if (errflag > 0) {
             errno = errflag;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/coss/store_io_coss.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/coss/store_io_coss.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/coss/store_io_coss.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/coss/store_io_coss.cc	2015-05-01 18:05:19.000000000 +0800
@@ -84,13 +84,13 @@
     if (current_offset + allocsize > static_cast<int64_t>(maxSize())) {
         /*
          * tried to allocate past the end of the disk, so wrap
          * back to the beginning
          */
         ++ StoreFScoss::GetInstance().stats.disk_overflows;
-        current_membuf->flags.full = 1;
+        current_membuf->flags.full = true;
         current_membuf->diskend = current_offset;
         current_membuf->maybeWrite(this);
         current_offset = 0;	/* wrap back to beginning */
         debugs(79, 2, "CossSwapDir::allocate: wrap to 0");
 
         newmb = createMemBuf(0, checkf, &coll);
@@ -99,13 +99,13 @@
         /* Check if we have overflowed the MemBuf */
     } else if ((current_offset + allocsize) >= current_membuf->diskend) {
         /*
          * Skip the blank space at the end of the stripe. start over.
          */
         ++ StoreFScoss::GetInstance().stats.stripe_overflows;
-        current_membuf->flags.full = 1;
+        current_membuf->flags.full = true;
         current_offset = current_membuf->diskend;
         current_membuf->maybeWrite(this);
         debugs(79, 2, "CossSwapDir::allocate: New offset - " << current_offset);
         newmb = createMemBuf(current_offset, checkf, &coll);
         current_membuf = newmb;
     }
@@ -180,14 +180,14 @@
 
     sio->callback = callback;
     sio->file_callback = file_callback;
     sio->callback_data = cbdataReference(callback_data);
     sio->e = &e;
 
-    cstate->flags.writing = 0;
-    cstate->flags.reading = 0;
+    cstate->flags.writing = false;
+    cstate->flags.reading = false;
     cstate->readbuffer = NULL;
     cstate->reqdiskoffset = -1;
 
     /* Now add it into the index list */
     storeCossAdd(this, &e);
 
@@ -217,14 +217,14 @@
     sio->callback = callback;
     sio->file_callback = file_callback;
     sio->callback_data = cbdataReference(callback_data);
     cstate->st_size = e.swap_file_sz;
     sio->e = &e;
 
-    cstate->flags.writing = 0;
-    cstate->flags.reading = 0;
+    cstate->flags.writing = false;
+    cstate->flags.reading = false;
     cstate->readbuffer = NULL;
     cstate->reqdiskoffset = -1;
     p = storeCossMemPointerFromDiskOffset(storeCossFilenoToDiskOffset(f), NULL);
     /* make local copy so we don't have to lock membuf */
 
     if (p) {
@@ -305,13 +305,13 @@
     assert(read.callback == NULL);
     assert(read.callback_data == NULL);
     read.callback = callback;
     read.callback_data = cbdataReference(callback_data);
     debugs(79, 3, "storeCossRead: offset " << offset);
     offset_ = offset;
-    flags.reading = 1;
+    flags.reading = true;
 
     if ((offset + (off_t)size) > st_size)
         size = st_size - offset;
 
     requestlen = size;
 
@@ -393,40 +393,13 @@
     return t;
 }
 
 /*  === STATIC =========================================================== */
 
 CBDATA_CLASS_INIT(CossRead);
-void *
-CossRead::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(CossRead);
-    CossRead *result = cbdataAlloc(CossRead);
-    return result;
-}
-
-void
-CossRead::operator delete (void *address)
-{
-    cbdataFree(address);
-}
-
 CBDATA_CLASS_INIT(CossWrite);
-void *
-CossWrite::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(CossWrite);
-    CossWrite *result = cbdataAlloc(CossWrite);
-    return result;
-}
-
-void
-CossWrite::operator delete (void *address)
-{
-    cbdataFree(address);
-}
 
 void
 CossState::doCallback(int errflag)
 {
     STIOCB *callback = this->callback;
     void *cbdata;
@@ -539,13 +512,13 @@
 
 void
 CossMemBuf::write(CossSwapDir * SD)
 {
     ++ StoreFScoss::GetInstance().stats.stripe_write.ops;
     debugs(79, 3, "CossMemBuf::write: offset " << diskstart << ", len " << (diskend - diskstart));
-    flags.writing = 1;
+    flags.writing = true;
     /* XXX Remember that diskstart/diskend are block offsets! */
     SD->theFile->write(new CossWrite(WriteRequest((char const *)&buffer, diskstart, diskend - diskstart, NULL), this));
 }
 
 CossMemBuf *
 CossSwapDir::createMemBuf(off_t start, sfileno curfn, int *collision)
@@ -559,14 +532,12 @@
     CBDATA_INIT_TYPE_FREECB(CossMemBuf, NULL);
     newmb = cbdataAlloc(CossMemBuf);
     newmb->diskstart = start;
     debugs(79, 3, "CossSwapDir::createMemBuf: creating new membuf at " << newmb->diskstart);
     debugs(79, 3, "CossSwapDir::createMemBuf: at " << newmb);
     newmb->diskend = newmb->diskstart + COSS_MEMBUF_SZ;
-    newmb->flags.full = 0;
-    newmb->flags.writing = 0;
     newmb->lockcount = 0;
     newmb->SD = this;
     /* XXX This should be reversed, with the new buffer last in the chain */
     dlinkAdd(newmb, &newmb->node, &membufs);
 
     /* Print out the list of membufs */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/Makefile.in	2015-05-01 16:51:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/Makefile.in	2015-05-01 18:06:55.000000000 +0800
@@ -89,14 +89,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -473,12 +519,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -516,12 +563,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -548,27 +596,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -635,13 +686,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 EXTRA_LTLIBRARIES = libaufs.la libdiskd.la libcoss.la libufs.la librock.la
 noinst_LTLIBRARIES = $(STORE_LIBS_TO_BUILD) libfs.la
 
 # aufs is a "fake" legacy store
 libaufs_la_SOURCES = \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/rock/RockSwapDir.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/rock/RockSwapDir.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/rock/RockSwapDir.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/rock/RockSwapDir.cc	2015-05-01 18:05:19.000000000 +0800
@@ -226,13 +226,13 @@
 Rock::SwapDir::init()
 {
     debugs(47,2, HERE);
 
     // XXX: SwapDirs aren't refcounted. We make IORequestor calls, which
     // are refcounted. We up our count once to avoid implicit delete's.
-    RefCountReference();
+    lock();
 
     Must(!map);
     map = new DirMap(path);
 
     const char *ioModule = needsDiskStrand() ? "IpcIo" : "Blocking";
     if (DiskIOModule *m = DiskIOModule::Find(ioModule)) {
@@ -294,20 +294,20 @@
     // TODO: can we reconfigure the replacement policy (repl)?
     validateOptions();
 }
 
 /// parse maximum db disk size
 void
-Rock::SwapDir::parseSize(const bool reconfiguring)
+Rock::SwapDir::parseSize(const bool reconfig)
 {
     const int i = GetInteger();
     if (i < 0)
         fatal("negative Rock cache_dir size value");
     const uint64_t new_max_size =
         static_cast<uint64_t>(i) << 20; // MBytes to Bytes
-    if (!reconfiguring)
+    if (!reconfig)
         max_size = new_max_size;
     else if (new_max_size != max_size) {
         debugs(3, DBG_IMPORTANT, "WARNING: cache_dir '" << path << "' size "
                "cannot be changed dynamically, value left unchanged (" <<
                (max_size >> 20) << " MB)");
     }
@@ -329,13 +329,13 @@
     return strcmp(option, "max-size") != 0 &&
            ::SwapDir::allowOptionReconfigure(option);
 }
 
 /// parses time-specific options; mimics ::SwapDir::optionObjectSizeParse()
 bool
-Rock::SwapDir::parseTimeOption(char const *option, const char *value, int reconfiguring)
+Rock::SwapDir::parseTimeOption(char const *option, const char *value, int reconfig)
 {
     // TODO: ::SwapDir or, better, Config should provide time-parsing routines,
     // including time unit handling. Same for size.
 
     time_msec_t *storedTime;
     if (strcmp(option, "swap-timeout") == 0)
@@ -352,13 +352,13 @@
         debugs(3, DBG_CRITICAL, "FATAL: cache_dir " << path << ' ' << option << " must not be negative but is: " << parsedValue);
         self_destruct();
     }
 
     const time_msec_t newTime = static_cast<time_msec_t>(parsedValue);
 
-    if (!reconfiguring)
+    if (!reconfig)
         *storedTime = newTime;
     else if (*storedTime != newTime) {
         debugs(3, DBG_IMPORTANT, "WARNING: cache_dir " << path << ' ' << option
                << " cannot be changed dynamically, value left unchanged: " <<
                *storedTime);
     }
@@ -651,18 +651,18 @@
     IoState::Pointer sio = request->sio;
 
     if (errflag == DISK_OK && rlen > 0)
         sio->offset_ += rlen;
     assert(sio->diskOffset + sio->offset_ <= diskOffsetLimit()); // post-factum
 
-    StoreIOState::STRCB *callback = sio->read.callback;
-    assert(callback);
+    StoreIOState::STRCB *callb = sio->read.callback;
+    assert(callb);
     sio->read.callback = NULL;
     void *cbdata;
     if (cbdataReferenceValidDone(sio->read.callback_data, &cbdata))
-        callback(cbdata, r->buf, rlen, sio.getRaw());
+        callb(cbdata, r->buf, rlen, sio.getRaw());
 }
 
 void
 Rock::SwapDir::writeCompleted(int errflag, size_t rlen, RefCount< ::WriteRequest> r)
 {
     Rock::WriteRequest *request = dynamic_cast<Rock::WriteRequest*>(r.getRaw());
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/RebuildState.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/RebuildState.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/RebuildState.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/RebuildState.cc	2015-05-01 18:05:19.000000000 +0800
@@ -60,13 +60,13 @@
     /*
      * If the swap.state file exists in the cache_dir, then
      * we'll use commonUfsDirRebuildFromSwapLog(), otherwise we'll
      * use commonUfsDirRebuildFromDirectory() to open up each file
      * and suck in the meta data.
      */
-    int clean = 0;
+    int clean = 0; //TODO: change to bool
     int zeroLengthLog = 0;
     FILE *fp = sd->openTmpSwapLog(&clean, &zeroLengthLog);
 
     if (fp && !zeroLengthLog)
         LogParser = Fs::Ufs::UFSSwapLogParser::GetUFSSwapLogParser(fp);
 
@@ -75,17 +75,17 @@
 
         if (fp != NULL)
             fclose(fp);
 
     } else {
         fromLog = true;
-        flags.clean = (unsigned int) clean;
+        flags.clean = (clean != 0);
     }
 
     if (!clean)
-        flags.need_to_validate = 1;
+        flags.need_to_validate = true;
 
     debugs(47, DBG_IMPORTANT, "Rebuilding storage in " << sd->path << " (" <<
            (clean ? "clean log" : (LogParser ? "dirty log" : "no log")) << ")");
 }
 
 Fs::Ufs::RebuildState::~RebuildState()
@@ -446,18 +446,18 @@
     if (done)
         return -2;
 
     while (fd < 0 && done == 0) {
         fd = -1;
 
-        if (0 == flags.init) {  /* initialize, open first file */
+        if (!flags.init) {  /* initialize, open first file */
             done = 0;
             curlvl1 = 0;
             curlvl2 = 0;
             in_dir = 0;
-            flags.init = 1;
+            flags.init = true;
             assert(Config.cacheSwap.n_configured > 0);
         }
 
         if (0 == in_dir) {  /* we need to read in a new directory */
             snprintf(fullpath, MAXPATHLEN, "%s/%02X/%02X",
                      sd->path,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/RebuildState.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/RebuildState.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/RebuildState.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/RebuildState.h	2015-05-01 18:05:19.000000000 +0800
@@ -27,13 +27,13 @@
  *
  */
 
 #ifndef SQUID_FS_UFS_REBUILDSTATE_H
 #define SQUID_FS_UFS_REBUILDSTATE_H
 
-#include "RefCount.h"
+#include "base/RefCount.h"
 #include "UFSSwapDir.h"
 #include "UFSSwapLogParser.h"
 #include "store_rebuild.h"
 
 class StoreEntry;
 
@@ -59,16 +59,17 @@
     int n_read;
     /*    FILE *log;*/
     Fs::Ufs::UFSSwapLogParser *LogParser;
     int curlvl1;
     int curlvl2;
 
-    struct {
-        unsigned int need_to_validate:1;
-        unsigned int clean:1;
-        unsigned int init:1;
+    struct Flags {
+        Flags() : need_to_validate(false), clean(false), init(false) {}
+        bool need_to_validate;
+        bool clean;
+        bool init;
     } flags;
     int in_dir;
     int done;
     int fn;
 
     dirent_t *entry;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/StoreFSufs.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/StoreFSufs.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/StoreFSufs.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/StoreFSufs.cc	2015-05-01 18:05:19.000000000 +0800
@@ -31,19 +31,11 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 /*TODO: remove this file as unused*/
 
 #include "squid.h"
-#if 0
-#include "StoreFileSystem.h"
-#endif
-
 #include "fs/ufs/StoreFSufs.h"
 #include "fs/ufs/UFSSwapDir.h"
 
-#if 0
-#include "DiskIO/DiskIOModule.h"
-#endif
-
 /* Unused variable: */
 Fs::Ufs::StoreFSufs<Fs::Ufs::UFSSwapDir> *UfsInstance_foo = NULL;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/UFSStoreState.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/UFSStoreState.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/UFSStoreState.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/UFSStoreState.cc	2015-05-01 18:05:19.000000000 +0800
@@ -42,25 +42,12 @@
 #include "SwapDir.h"
 #include "UFSStrategy.h"
 #include "UFSStoreState.h"
 
 CBDATA_NAMESPACED_CLASS_INIT(Fs::Ufs,UFSStoreState);
 
-void *
-Fs::Ufs::UFSStoreState::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(UFSStoreState);
-    return cbdataAlloc(UFSStoreState);
-}
-
-void
-Fs::Ufs::UFSStoreState::operator delete (void *address)
-{
-    cbdataFree(address);
-}
-
 void
 Fs::Ufs::UFSStoreState::ioCompletedNotification()
 {
     if (opening) {
         opening = false;
         debugs(79, 3, "UFSStoreState::ioCompletedNotification: dirno " <<
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/UFSStoreState.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/UFSStoreState.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/UFSStoreState.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/UFSStoreState.h	2015-05-01 18:05:19.000000000 +0800
@@ -39,14 +39,12 @@
 namespace Ufs
 {
 /// \ingroup UFS
 class UFSStoreState : public StoreIOState, public IORequestor
 {
 public:
-    void * operator new (size_t);
-    void operator delete (void *);
     UFSStoreState(SwapDir * SD, StoreEntry * anEntry, STIOCB * callback_, void *callback_data_);
     ~UFSStoreState();
     virtual void close(int how);
     virtual void closeCompleted();
     // protected:
     virtual void ioCompletedNotification();
@@ -115,13 +113,13 @@
     char *read_buf;
 
 private:
     void openDone();
     void freePending();
     void doWrite();
-    CBDATA_CLASS(UFSStoreState);
+    CBDATA_CLASS2(UFSStoreState);
 };
 
 MEMPROXY_CLASS_INLINE(UFSStoreState::_queued_read);
 MEMPROXY_CLASS_INLINE(UFSStoreState::_queued_write);
 
 } //namespace Ufs
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/UFSSwapDir.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/UFSSwapDir.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/fs/ufs/UFSSwapDir.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/fs/ufs/UFSSwapDir.cc	2015-05-01 18:05:19.000000000 +0800
@@ -338,21 +338,16 @@
 Fs::Ufs::UFSSwapDir::~UFSSwapDir()
 {
     if (swaplog_fd > -1) {
         file_close(swaplog_fd);
         swaplog_fd = -1;
     }
-
-    delete map;
-
-    if (IO)
-        delete IO;
-
-    IO = NULL;
-
     safe_free(ioType);
+    delete map;
+    delete IO;
+    delete currentIOOptions;
 }
 
 void
 Fs::Ufs::UFSSwapDir::dumpEntry(StoreEntry &e) const
 {
     debugs(47, DBG_CRITICAL, HERE << "FILENO "<< std::setfill('0') << std::hex << std::uppercase << std::setw(8) << e.swap_filen);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ftp.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ftp.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ftp.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ftp.cc	2015-05-01 18:05:19.000000000 +0800
@@ -37,13 +37,13 @@
 #include "comm/Write.h"
 #include "CommCalls.h"
 #include "compat/strtoll.h"
 #include "errorpage.h"
 #include "fd.h"
 #include "fde.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "html_quote.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
 #include "HttpHeaderRange.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -179,18 +179,13 @@
     AsyncCall::Pointer closer; ///< Comm close handler callback
 };
 
 /// \ingroup ServerProtocolFTPInternal
 class FtpStateData : public ServerStateData
 {
-
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
-    void *toCbdata() { return this; }
-
     FtpStateData(FwdState *, const Comm::ConnectionPointer &conn);
     ~FtpStateData();
     char user[MAX_URL];
     char password[MAX_URL];
     int password_url;
     char *reply_hdr;
@@ -235,15 +230,12 @@
         unsigned short port;
         bool read_pending;
     } data;
 
     struct _ftp_flags flags;
 
-private:
-    CBDATA_CLASS(FtpStateData);
-
 public:
     // these should all be private
     virtual void start();
     void loginParser(const char *, int escaped);
     int restartable();
     void appendSuccessHeader();
@@ -306,31 +298,18 @@
     AsyncCall::Pointer dataCloser(); /// creates a Comm close callback
     AsyncCall::Pointer dataOpener(); /// creates a Comm connect callback
 
 private:
     // BodyConsumer for HTTP: consume request body.
     virtual void handleRequestBodyProducerAborted();
+
+    CBDATA_CLASS2(FtpStateData);
 };
 
 CBDATA_CLASS_INIT(FtpStateData);
 
-void *
-FtpStateData::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(FtpStateData);
-    FtpStateData *result = cbdataAlloc(FtpStateData);
-    return result;
-}
-
-void
-FtpStateData::operator delete (void *address)
-{
-    FtpStateData *t = static_cast<FtpStateData *>(address);
-    cbdataFree(t);
-}
-
 /// \ingroup ServerProtocolFTPInternal
 typedef struct {
     char type;
     int64_t size;
     char *date;
     char *name;
@@ -504,13 +483,13 @@
     flags.rest_supported = 1;
 
     typedef CommCbMemFunT<FtpStateData, CommCloseCbParams> Dialer;
     AsyncCall::Pointer closer = JobCallback(9, 5, Dialer, this, FtpStateData::ctrlClosed);
     ctrl.opened(conn, closer);
 
-    if (request->method == METHOD_PUT)
+    if (request->method == Http::METHOD_PUT)
         flags.put = 1;
 }
 
 FtpStateData::~FtpStateData()
 {
     debugs(9, 3, HERE << entry->url()  );
@@ -695,28 +674,12 @@
     }
 
     failed(ERR_READ_TIMEOUT, 0);
     /* failed() closes ctrl.conn and frees ftpState */
 }
 
-#if DEAD_CODE // obsoleted by ERR_DIR_LISTING
-void
-FtpStateData::listingFinish()
-{
-    // TODO: figure out what this means and how to show it ...
-
-    if (flags.listformat_unknown && !flags.tried_nlst) {
-        printfReplyBody("<a href=\"%s/;type=d\">[As plain directory]</a>\n",
-                        flags.dir_slash ? rfc1738_escape_part(old_filepath) : ".");
-    } else if (typecode == 'D') {
-        const char *path = flags.dir_slash ? filepath : ".";
-        printfReplyBody("<a href=\"%s/\">[As extended directory]</a>\n", rfc1738_escape_part(path));
-    }
-}
-#endif /* DEAD_CODE */
-
 /// \ingroup ServerProtocolFTPInternal
 static const char *Month[] = {
     "Jan", "Feb", "Mar", "Apr", "May", "Jun",
     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
 };
 
@@ -1340,13 +1303,13 @@
 
 void
 FtpStateData::processReplyBody()
 {
     debugs(9, 3, HERE << "FtpStateData::processReplyBody starting.");
 
-    if (request->method == METHOD_HEAD && (flags.isdir || theSize != -1)) {
+    if (request->method == Http::METHOD_HEAD && (flags.isdir || theSize != -1)) {
         serverComplete();
         return;
     }
 
     /* Directory listings are special. They write ther own headers via the error objects */
     if (!flags.http_header_sent && data.readBuf->contentSize() >= 0 && !flags.isdir)
@@ -1916,22 +1879,22 @@
     ErrorState *err = NULL;
     const char *command, *reply;
 
     if ((state == SENT_USER || state == SENT_PASS) && ctrl.replycode >= 400) {
         if (ctrl.replycode == 421 || ctrl.replycode == 426) {
             // 421/426 - Service Overload - retry permitted.
-            err = new ErrorState(ERR_FTP_UNAVAILABLE, HTTP_SERVICE_UNAVAILABLE, fwd->request);
+            err = new ErrorState(ERR_FTP_UNAVAILABLE, Http::scServiceUnavailable, fwd->request);
         } else if (ctrl.replycode >= 430 && ctrl.replycode <= 439) {
             // 43x - Invalid or Credential Error - retry challenge required.
-            err = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_UNAUTHORIZED, fwd->request);
+            err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd->request);
         } else if (ctrl.replycode >= 530 && ctrl.replycode <= 539) {
             // 53x - Credentials Missing - retry challenge required
             if (password_url) // but they were in the URI! major fail.
-                err = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_FORBIDDEN, fwd->request);
+                err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scForbidden, fwd->request);
             else
-                err = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_UNAUTHORIZED, fwd->request);
+                err = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd->request);
         }
     }
 
     // any other problems are general falures.
     if (!err) {
         ftpFail(this);
@@ -2501,15 +2464,15 @@
 
     ftpState->ctrl.last_command = xstrdup("Connect to server data port");
 
     // Generate a new data channel descriptor to be opened.
     Comm::ConnectionPointer conn = new Comm::Connection;
     conn->local = ftpState->ctrl.conn->local;
-    conn->local.SetPort(0);
+    conn->local.port(0);
     conn->remote = ftpState->ctrl.conn->remote;
-    conn->remote.SetPort(port);
+    conn->remote.port(port);
 
     debugs(9, 3, HERE << "connecting to " << conn->remote);
 
     ftpState->data.opener = commCbCall(9,3, "FtpStateData::ftpPasvCallback", CommConnectCbPtrFun(FtpStateData::ftpPasvCallback, ftpState));
     Comm::ConnOpener *cs = new Comm::ConnOpener(conn, ftpState->data.opener, Config.Timeout.connect);
     cs->setHost(ftpState->data.host);
@@ -2541,13 +2504,13 @@
         ftpFail(ftpState);
         return;
     }
 
     /** \par
       * Checks for 'HEAD' method request and passes off for special handling by FtpStateData::processHeadResponse(). */
-    if (ftpState->request->method == METHOD_HEAD && (ftpState->flags.isdir || ftpState->theSize != -1)) {
+    if (ftpState->request->method == Http::METHOD_HEAD && (ftpState->flags.isdir || ftpState->theSize != -1)) {
         ftpState->processHeadResponse(); // may call serverComplete
         return;
     }
 
     /// Closes any old FTP-Data connection which may exist. */
     ftpState->data.close();
@@ -2568,22 +2531,22 @@
       *  - EPSV 1    is used if EPSV 2 (IPv6) fails or is not available or ctrl channel is IPv4.
       *  - PASV      is used if EPSV 1 fails.
       */
     switch (ftpState->state) {
     case SENT_EPSV_ALL: /* EPSV ALL resulted in a bad response. Try ther EPSV methods. */
         ftpState->flags.epsv_all_sent = true;
-        if (ftpState->ctrl.conn->local.IsIPv6()) {
+        if (ftpState->ctrl.conn->local.isIPv6()) {
             debugs(9, 5, HERE << "FTP Channel is IPv6 (" << ftpState->ctrl.conn->remote << ") attempting EPSV 2 after EPSV ALL has failed.");
             snprintf(cbuf, CTRL_BUFLEN, "EPSV 2\r\n");
             ftpState->state = SENT_EPSV_2;
             break;
         }
         // else fall through to skip EPSV 2
 
     case SENT_EPSV_2: /* EPSV IPv6 failed. Try EPSV IPv4 */
-        if (ftpState->ctrl.conn->local.IsIPv4()) {
+        if (ftpState->ctrl.conn->local.isIPv4()) {
             debugs(9, 5, HERE << "FTP Channel is IPv4 (" << ftpState->ctrl.conn->remote << ") attempting EPSV 1 after EPSV ALL has failed.");
             snprintf(cbuf, CTRL_BUFLEN, "EPSV 1\r\n");
             ftpState->state = SENT_EPSV_1;
             break;
         } else if (ftpState->flags.epsv_all_sent) {
             debugs(9, DBG_IMPORTANT, "FTP does not allow PASV method after 'EPSV ALL' has been sent.");
@@ -2607,18 +2570,18 @@
             debugs(9, 5, HERE << "EPSV ALL manually enabled. Attempting with FTP Channel (" << ftpState->ctrl.conn->remote <<")");
             snprintf(cbuf, CTRL_BUFLEN, "EPSV ALL\r\n");
             ftpState->state = SENT_EPSV_ALL;
             /* block other non-EPSV connections being attempted */
             ftpState->flags.epsv_all_sent = true;
         } else {
-            if (ftpState->ctrl.conn->local.IsIPv6()) {
+            if (ftpState->ctrl.conn->local.isIPv6()) {
                 debugs(9, 5, HERE << "FTP Channel (" << ftpState->ctrl.conn->remote << "). Sending default EPSV 2");
                 snprintf(cbuf, CTRL_BUFLEN, "EPSV 2\r\n");
                 ftpState->state = SENT_EPSV_2;
             }
-            if (ftpState->ctrl.conn->local.IsIPv4()) {
+            if (ftpState->ctrl.conn->local.isIPv4()) {
                 debugs(9, 5, HERE << "Channel (" << ftpState->ctrl.conn->remote <<"). Sending default EPSV 1");
                 snprintf(cbuf, CTRL_BUFLEN, "EPSV 1\r\n");
                 ftpState->state = SENT_EPSV_1;
             }
         }
         break;
@@ -2702,13 +2665,13 @@
     }
 
     snprintf(ipaddr, 1024, "%d.%d.%d.%d", h1, h2, h3, h4);
 
     ipa_remote = ipaddr;
 
-    if ( ipa_remote.IsAnyAddr() ) {
+    if ( ipa_remote.isAnyAddr() ) {
         debugs(9, DBG_IMPORTANT, "Unsafe PASV reply from " <<
                ftpState->ctrl.conn->remote << ": " <<
                ftpState->ctrl.last_reply);
 
         ftpSendEPRT(ftpState);
         return;
@@ -2749,15 +2712,15 @@
     safe_free(ftpState->ctrl.last_reply);
 
     ftpState->ctrl.last_command = xstrdup("Connect to server data port");
 
     Comm::ConnectionPointer conn = new Comm::Connection;
     conn->local = ftpState->ctrl.conn->local;
-    conn->local.SetPort(0);
+    conn->local.port(0);
     conn->remote = ipaddr;
-    conn->remote.SetPort(port);
+    conn->remote.port(port);
 
     debugs(9, 3, HERE << "connecting to " << conn->remote);
 
     ftpState->data.opener = commCbCall(9,3, "FtpStateData::ftpPasvCallback", CommConnectCbPtrFun(FtpStateData::ftpPasvCallback, ftpState));
     Comm::ConnOpener *cs = new Comm::ConnOpener(conn, ftpState->data.opener, Config.Timeout.connect);
     cs->setHost(ftpState->data.host);
@@ -2816,13 +2779,13 @@
         int on = 1;
         setsockopt(ftpState->ctrl.conn->fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on));
         ftpState->ctrl.conn->flags |= COMM_REUSEADDR;
         temp->flags |= COMM_REUSEADDR;
     } else {
         /* if not running in fallback mode a new port needs to be retrieved */
-        temp->local.SetPort(0);
+        temp->local.port(0);
     }
 
     ftpState->listenForDataChannel(temp, ftpState->entry->url());
 }
 
 /// \ingroup ServerProtocolFTPInternal
@@ -2840,13 +2803,13 @@
 
     debugs(9, 3, HERE);
     ftpState->flags.pasv_supported = 0;
     ftpOpenListenSocket(ftpState, 0);
 
     if (!Comm::IsConnOpen(ftpState->data.listenConn)) {
-        if ( ftpState->data.listenConn != NULL && !ftpState->data.listenConn->local.IsIPv4() ) {
+        if ( ftpState->data.listenConn != NULL && !ftpState->data.listenConn->local.isIPv4() ) {
             /* non-IPv4 CANNOT send PORT command.                       */
             /* we got here by attempting and failing an EPRT            */
             /* using the same reply code should simulate a PORT failure */
             ftpReadPORT(ftpState);
             return;
         }
@@ -2857,22 +2820,22 @@
     }
 
     // pull out the internal IP address bytes to send in PORT command...
     // source them from the listen_conn->local
 
     struct addrinfo *AI = NULL;
-    ftpState->data.listenConn->local.GetAddrInfo(AI, AF_INET);
+    ftpState->data.listenConn->local.getAddrInfo(AI, AF_INET);
     unsigned char *addrptr = (unsigned char *) &((struct sockaddr_in*)AI->ai_addr)->sin_addr;
     unsigned char *portptr = (unsigned char *) &((struct sockaddr_in*)AI->ai_addr)->sin_port;
     snprintf(cbuf, CTRL_BUFLEN, "PORT %d,%d,%d,%d,%d,%d\r\n",
              addrptr[0], addrptr[1], addrptr[2], addrptr[3],
              portptr[0], portptr[1]);
     ftpState->writeCommand(cbuf);
     ftpState->state = SENT_PORT;
 
-    ftpState->data.listenConn->local.FreeAddrInfo(AI);
+    Ip::Address::FreeAddrInfo(AI);
 }
 
 /// \ingroup ServerProtocolFTPInternal
 static void
 ftpReadPORT(FtpStateData * ftpState)
 {
@@ -2917,15 +2880,15 @@
 
     char buf[MAX_IPSTRLEN];
 
     /* RFC 2428 defines EPRT as IPv6 equivalent to IPv4 PORT command. */
     /* Which can be used by EITHER protocol. */
     snprintf(cbuf, CTRL_BUFLEN, "EPRT |%d|%s|%d|\r\n",
-             ( ftpState->data.listenConn->local.IsIPv6() ? 2 : 1 ),
-             ftpState->data.listenConn->local.NtoA(buf,MAX_IPSTRLEN),
-             ftpState->data.listenConn->local.GetPort() );
+             ( ftpState->data.listenConn->local.isIPv6() ? 2 : 1 ),
+             ftpState->data.listenConn->local.toStr(buf,MAX_IPSTRLEN),
+             ftpState->data.listenConn->local.port() );
 
     ftpState->writeCommand(cbuf);
     ftpState->state = SENT_EPRT;
 }
 
 static void
@@ -3007,13 +2970,13 @@
     }
 
     /** On COMM_OK start using the accepted data socket and discard the temporary listen socket. */
     data.close();
     data.opened(io.conn, dataCloser());
     static char ntoapeer[MAX_IPSTRLEN];
-    io.conn->remote.NtoA(ntoapeer,sizeof(ntoapeer));
+    io.conn->remote.toStr(ntoapeer,sizeof(ntoapeer));
     data.host = xstrdup(ntoapeer);
 
     debugs(9, 3, HERE << "Connected data socket on " <<
            io.conn << ". FD table says: " <<
            "ctrl-peer= " << fd_table[ctrl.conn->fd].ipaddr << ", " <<
            "data-peer= " << fd_table[data.conn->fd].ipaddr);
@@ -3085,12 +3048,19 @@
 void FtpStateData::readStor()
 {
     int code = ctrl.replycode;
     debugs(9, 3, HERE);
 
     if (code == 125 || (code == 150 && Comm::IsConnOpen(data.conn))) {
+        if (!originalRequest()->body_pipe) {
+            debugs(9, 3, "zero-size STOR?");
+            state = WRITING_DATA; // make ftpWriteTransferDone() responsible
+            dataComplete(); // XXX: keep in sync with doneSendingRequestBody()
+            return;
+        }
+
         if (!startRequestBodyFlow()) { // register to receive body data
             ftpFail(this);
             return;
         }
 
         /* When client status is 125, or 150 and the data connection is open, Begin data transfer. */
@@ -3291,13 +3261,13 @@
  */
 void
 FtpStateData::completedListing()
 {
     assert(entry);
     entry->lock();
-    ErrorState ferr(ERR_DIR_LISTING, HTTP_OK, request);
+    ErrorState ferr(ERR_DIR_LISTING, Http::scOkay, request);
     ferr.ftp.listing = &listing;
     ferr.ftp.cwd_msg = xstrdup(cwd_message.size()? cwd_message.termedBuf() : "");
     ferr.ftp.server_msg = ctrl.message;
     ctrl.message = NULL;
     entry->replaceHttpReply( ferr.BuildHttpReply() );
     EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
@@ -3513,46 +3483,46 @@
         case SENT_USER:
 
         case SENT_PASS:
 
             if (ctrl.replycode > 500)
                 if (password_url)
-                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_FORBIDDEN, fwd->request);
+                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, Http::scForbidden, fwd->request);
                 else
-                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, HTTP_UNAUTHORIZED, fwd->request);
+                    ftperr = new ErrorState(ERR_FTP_FORBIDDEN, Http::scUnauthorized, fwd->request);
 
             else if (ctrl.replycode == 421)
-                ftperr = new ErrorState(ERR_FTP_UNAVAILABLE, HTTP_SERVICE_UNAVAILABLE, fwd->request);
+                ftperr = new ErrorState(ERR_FTP_UNAVAILABLE, Http::scServiceUnavailable, fwd->request);
 
             break;
 
         case SENT_CWD:
 
         case SENT_RETR:
             if (ctrl.replycode == 550)
-                ftperr = new ErrorState(ERR_FTP_NOT_FOUND, HTTP_NOT_FOUND, fwd->request);
+                ftperr = new ErrorState(ERR_FTP_NOT_FOUND, Http::scNotFound, fwd->request);
 
             break;
 
         default:
             break;
         }
 
         break;
 
     case ERR_READ_TIMEOUT:
-        ftperr = new ErrorState(error, HTTP_GATEWAY_TIMEOUT, fwd->request);
+        ftperr = new ErrorState(error, Http::scGatewayTimeout, fwd->request);
         break;
 
     default:
-        ftperr = new ErrorState(error, HTTP_BAD_GATEWAY, fwd->request);
+        ftperr = new ErrorState(error, Http::scBadGateway, fwd->request);
         break;
     }
 
     if (ftperr == NULL)
-        ftperr = new ErrorState(ERR_FTP_FAILURE, HTTP_BAD_GATEWAY, fwd->request);
+        ftperr = new ErrorState(ERR_FTP_FAILURE, Http::scBadGateway, fwd->request);
 
     ftperr->xerrno = xerrno;
 
     ftperr->ftp.server_msg = ctrl.message;
     ctrl.message = NULL;
 
@@ -3581,29 +3551,29 @@
 
 /// \ingroup ServerProtocolFTPInternal
 static void
 ftpSendReply(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    http_status http_code;
+    Http::StatusCode http_code;
     err_type err_code = ERR_NONE;
 
     debugs(9, 3, HERE << ftpState->entry->url() << ", code " << code);
 
     if (cbdataReferenceValid(ftpState))
         debugs(9, 5, HERE << "ftpState (" << ftpState << ") is valid!");
 
     if (code == 226 || code == 250) {
         err_code = (ftpState->mdtm > 0) ? ERR_FTP_PUT_MODIFIED : ERR_FTP_PUT_CREATED;
-        http_code = (ftpState->mdtm > 0) ? HTTP_ACCEPTED : HTTP_CREATED;
+        http_code = (ftpState->mdtm > 0) ? Http::scAccepted : Http::scCreated;
     } else if (code == 227) {
         err_code = ERR_FTP_PUT_CREATED;
-        http_code = HTTP_CREATED;
+        http_code = Http::scCreated;
     } else {
         err_code = ERR_FTP_PUT_ERROR;
-        http_code = HTTP_INTERNAL_SERVER_ERROR;
+        http_code = Http::scInternalServerError;
     }
 
     ErrorState err(err_code, http_code, ftpState->request);
 
     if (ftpState->old_request)
         err.ftp.request = xstrdup(ftpState->old_request);
@@ -3673,31 +3643,31 @@
     }
 
     /* set standard stuff */
 
     if (0 == getCurrentOffset()) {
         /* Full reply */
-        reply->setHeaders(HTTP_OK, "Gatewaying", mime_type, theSize, mdtm, -2);
+        reply->setHeaders(Http::scOkay, "Gatewaying", mime_type, theSize, mdtm, -2);
     } else if (theSize < getCurrentOffset()) {
         /*
          * DPW 2007-05-04
          * offset should not be larger than theSize.  We should
          * not be seeing this condition any more because we'll only
          * send REST if we know the theSize and if it is less than theSize.
          */
         debugs(0,DBG_CRITICAL,HERE << "Whoops! " <<
                " current offset=" << getCurrentOffset() <<
                ", but theSize=" << theSize <<
                ".  assuming full content response");
-        reply->setHeaders(HTTP_OK, "Gatewaying", mime_type, theSize, mdtm, -2);
+        reply->setHeaders(Http::scOkay, "Gatewaying", mime_type, theSize, mdtm, -2);
     } else {
         /* Partial reply */
         HttpHdrRangeSpec range_spec;
         range_spec.offset = getCurrentOffset();
         range_spec.length = theSize - getCurrentOffset();
-        reply->setHeaders(HTTP_PARTIAL_CONTENT, "Gatewaying", mime_type, theSize - getCurrentOffset(), mdtm, -2);
+        reply->setHeaders(Http::scPartialContent, "Gatewaying", mime_type, theSize - getCurrentOffset(), mdtm, -2);
         httpHeaderAddContRange(&reply->header, range_spec, theSize);
     }
 
     /* additional info */
     if (mime_enc)
         reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
@@ -3727,13 +3697,13 @@
     }
 }
 
 HttpReply *
 FtpStateData::ftpAuthRequired(HttpRequest * request, const char *realm)
 {
-    ErrorState err(ERR_CACHE_ACCESS_DENIED, HTTP_UNAUTHORIZED, request);
+    ErrorState err(ERR_CACHE_ACCESS_DENIED, Http::scUnauthorized, request);
     HttpReply *newrep = err.BuildHttpReply();
 #if HAVE_AUTH_MODULE_BASIC
     /* add Authenticate header */
     newrep->header.putAuth("Basic", realm);
 #endif
     return newrep;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: FwdState.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: FwdState.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/globals.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/globals.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/globals.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/globals.h	2015-05-01 18:05:19.000000000 +0800
@@ -44,12 +44,14 @@
 extern char *ConfigFile;	/* NULL */
 extern char *IcpOpcodeStr[];
 extern char tmp_error_buf[ERROR_BUF_SZ];
 extern char ThisCache[RFC2181_MAXHOSTNAMELEN << 1];
 extern char ThisCache2[RFC2181_MAXHOSTNAMELEN << 1];
 extern char config_input_line[BUFSIZ];
+/// During parsing, the name of the current squid.conf directive being parsed.
+extern const char *cfg_directive; /* NULL */
 extern const char *DefaultConfigFile;	/* DEFAULT_CONFIG_FILE */
 extern const char *cfg_filename;	/* NULL */
 extern const char *dash_str;	/* "-" */
 extern const char *null_string;	/* "" */
 extern const char *version_string;	/* VERSION */
 extern const char *appname_string;	/* PACKAGE */
@@ -121,22 +123,21 @@
 extern char *WIN32_OS_string;           /* NULL */
 extern char *WIN32_Service_name;        /* NULL */
 extern char *WIN32_Command_Line;        /* NULL */
 extern char *WIN32_Service_Command_Line; /* NULL */
 extern unsigned int WIN32_run_mode;     /* _WIN_SQUID_RUN_MODE_INTERACTIVE */
 #endif
-#if HAVE_SBRK
-extern void *sbrk_start;	/* 0 */
-#endif
 
 extern int ssl_ex_index_server;	/* -1 */
 extern int ssl_ctx_ex_index_dont_verify_domain; /* -1 */
 extern int ssl_ex_index_cert_error_check;	/* -1 */
 extern int ssl_ex_index_ssl_error_detail;      /* -1 */
 extern int ssl_ex_index_ssl_peeked_cert;      /* -1 */
 extern int ssl_ex_index_ssl_errors;   /* -1 */
+extern int ssl_ex_index_ssl_cert_chain;  /* -1 */
+extern int ssl_ex_index_ssl_validation_counter;  /* -1 */
 
 extern const char *external_acl_message;      /* NULL */
 extern int opt_send_signal;	/* -1 */
 extern int opt_no_daemon; /* 0 */
 extern int opt_parse_cfg_only; /* 0 */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/gopher.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/gopher.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/gopher.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/gopher.cc	2015-05-01 18:05:19.000000000 +0800
@@ -31,13 +31,13 @@
 
 #include "squid.h"
 #include "comm.h"
 #include "comm/Write.h"
 #include "errorpage.h"
 #include "fd.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "html_quote.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "Mem.h"
 #include "MemBuf.h"
@@ -254,13 +254,13 @@
 
     assert(entry->isEmpty());
     EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
 
     HttpReply *reply = new HttpReply;
     entry->buffer();
-    reply->setHeaders(HTTP_OK, "Gatewaying", mime_type, -1, -1, -2);
+    reply->setHeaders(Http::scOkay, "Gatewaying", mime_type, -1, -1, -2);
     if (mime_enc)
         reply->header.putStr(HDR_CONTENT_ENCODING, mime_enc);
 
     entry->replaceHttpReply(reply);
 }
 
@@ -723,13 +723,13 @@
 static void
 gopherTimeout(const CommTimeoutCbParams &io)
 {
     GopherStateData *gopherState = static_cast<GopherStateData *>(io.data);
     debugs(10, 4, HERE << io.conn << ": '" << gopherState->entry->url() << "'" );
 
-    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT, gopherState->fwd->request));
+    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, gopherState->fwd->request));
 
     if (Comm::IsConnOpen(io.conn))
         io.conn->close();
 }
 
 /**
@@ -801,19 +801,19 @@
 
         if (ignoreErrno(xerrno)) {
             AsyncCall::Pointer call = commCbCall(5,4, "gopherReadReply",
                                                  CommIoCbPtrFun(gopherReadReply, gopherState));
             comm_read(conn, buf, read_sz, call);
         } else {
-            ErrorState *err = new ErrorState(ERR_READ_ERROR, HTTP_INTERNAL_SERVER_ERROR, gopherState->fwd->request);
+            ErrorState *err = new ErrorState(ERR_READ_ERROR, Http::scInternalServerError, gopherState->fwd->request);
             err->xerrno = xerrno;
             gopherState->fwd->fail(err);
             gopherState->serverConn->close();
         }
     } else if (len == 0 && entry->isEmpty()) {
-        gopherState->fwd->fail(new ErrorState(ERR_ZERO_SIZE_OBJECT, HTTP_SERVICE_UNAVAILABLE, gopherState->fwd->request));
+        gopherState->fwd->fail(new ErrorState(ERR_ZERO_SIZE_OBJECT, Http::scServiceUnavailable, gopherState->fwd->request));
         gopherState->serverConn->close();
     } else if (len == 0) {
         /* Connection closed; retrieval done. */
         /* flush the rest of data in temp buf if there is one. */
 
         if (gopherState->conversion != gopher_ds::NORMAL)
@@ -851,13 +851,13 @@
         kb_incr(&(statCounter.server.all.kbytes_out), size);
         kb_incr(&(statCounter.server.other.kbytes_out), size);
     }
 
     if (errflag) {
         ErrorState *err;
-        err = new ErrorState(ERR_WRITE_ERROR, HTTP_SERVICE_UNAVAILABLE, gopherState->fwd->request);
+        err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request);
         err->xerrno = xerrno;
         err->port = gopherState->fwd->request->port;
         err->url = xstrdup(entry->url());
         gopherState->fwd->fail(err);
         gopherState->serverConn->close();
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/helper.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/helper.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/helper.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/helper.cc	2015-05-01 18:05:19.000000000 +0800
@@ -82,12 +82,14 @@
 
 CBDATA_CLASS_INIT(helper);
 CBDATA_TYPE(helper_server);
 CBDATA_CLASS_INIT(statefulhelper);
 CBDATA_TYPE(helper_stateful_server);
 
+InstanceIdDefinitions(HelperServerBase, "Hlpr");
+
 void
 HelperServerBase::initStats()
 {
     stats.uses=0;
     stats.replies=0;
     stats.pending=0;
@@ -95,57 +97,53 @@
 }
 
 void
 HelperServerBase::closePipesSafely()
 {
 #if _SQUID_WINDOWS_
-    int no = index + 1;
-
     shutdown(writePipe->fd, SD_BOTH);
 #endif
 
-    flags.closing = 1;
+    flags.closing = true;
     if (readPipe->fd == writePipe->fd)
         readPipe->fd = -1;
     else
         readPipe->close();
     writePipe->close();
 
 #if _SQUID_WINDOWS_
     if (hIpc) {
         if (WaitForSingleObject(hIpc, 5000) != WAIT_OBJECT_0) {
             getCurrentTime();
             debugs(84, DBG_IMPORTANT, "WARNING: " << hlp->id_name <<
-                   " #" << no << " (" << hlp->cmdline->key << "," <<
+                   " #" << index << " (" << hlp->cmdline->key << "," <<
                    (long int)pid << ") didn't exit in 5 seconds");
         }
         CloseHandle(hIpc);
     }
 #endif
 }
 
 void
 HelperServerBase::closeWritePipeSafely()
 {
 #if _SQUID_WINDOWS_
-    int no = index + 1;
-
     shutdown(writePipe->fd, (readPipe->fd == writePipe->fd ? SD_BOTH : SD_SEND));
 #endif
 
-    flags.closing = 1;
+    flags.closing = true;
     if (readPipe->fd == writePipe->fd)
         readPipe->fd = -1;
     writePipe->close();
 
 #if _SQUID_WINDOWS_
     if (hIpc) {
         if (WaitForSingleObject(hIpc, 5000) != WAIT_OBJECT_0) {
             getCurrentTime();
             debugs(84, DBG_IMPORTANT, "WARNING: " << hlp->id_name <<
-                   " #" << no << " (" << hlp->cmdline->key << "," <<
+                   " #" << index << " (" << hlp->cmdline->key << "," <<
                    (long int)pid << ") didn't exit in 5 seconds");
         }
         CloseHandle(hIpc);
     }
 #endif
 }
@@ -225,13 +223,12 @@
         ++ hlp->childs.n_active;
         CBDATA_INIT_TYPE(helper_server);
         srv = cbdataAlloc(helper_server);
         srv->hIpc = hIpc;
         srv->pid = pid;
         srv->initStats();
-        srv->index = k;
         srv->addr = hlp->addr;
         srv->readPipe = new Comm::Connection;
         srv->readPipe->fd = rfd;
         srv->writePipe = new Comm::Connection;
         srv->writePipe->fd = wfd;
         srv->rbuf = (char *)memAllocBuf(ReadBufMinSize, &srv->rbuf_sz);
@@ -345,15 +342,14 @@
         ++ hlp->childs.n_running;
         ++ hlp->childs.n_active;
         CBDATA_INIT_TYPE(helper_stateful_server);
         helper_stateful_server *srv = cbdataAlloc(helper_stateful_server);
         srv->hIpc = hIpc;
         srv->pid = pid;
-        srv->flags.reserved = 0;
+        srv->flags.reserved = false;
         srv->initStats();
-        srv->index = k;
         srv->addr = hlp->addr;
         srv->readPipe = new Comm::Connection;
         srv->readPipe->fd = rfd;
         srv->writePipe = new Comm::Connection;
         srv->writePipe->fd = wfd;
         srv->rbuf = (char *)memAllocBuf(ReadBufMinSize, &srv->rbuf_sz);
@@ -396,13 +392,14 @@
 
 void
 helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperSubmit: hlp == NULL");
-        callback(data, NULL);
+        HelperReply nilReply;
+        callback(data, nilReply);
         return;
     }
 
     helper_request *r = new helper_request;
     helper_server *srv;
 
@@ -412,22 +409,23 @@
 
     if ((srv = GetFirstAvailable(hlp)))
         helperDispatch(srv, r);
     else
         Enqueue(hlp, r);
 
-    debugs(84, 9, "helperSubmit: " << buf);
+    debugs(84, DBG_DATA, Raw("buf", buf, strlen(buf)));
 }
 
 /// lastserver = "server last used as part of a reserved request sequence"
 void
-helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPSCB * callback, void *data, helper_stateful_server * lastserver)
+helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver)
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperStatefulSubmit: hlp == NULL");
-        callback(data, 0, NULL);
+        HelperReply nilReply;
+        callback(data, nilReply);
         return;
     }
 
     helper_stateful_request *r = new helper_stateful_request;
 
     r->callback = callback;
@@ -453,13 +451,14 @@
         if ((srv = StatefulGetFirstAvailable(hlp))) {
             helperStatefulDispatch(srv, r);
         } else
             StatefulEnqueue(hlp, r);
     }
 
-    debugs(84, 9, "helperStatefulSubmit: placeholder: '" << r->placeholder << "', buf '" << buf << "'.");
+    debugs(84, DBG_DATA, "placeholder: '" << r->placeholder <<
+           "', " << Raw("buf", buf, strlen(buf)));
 }
 
 /**
  * DPW 2007-05-08
  *
  * helperStatefulReleaseServer tells the helper that whoever was
@@ -471,13 +470,13 @@
     debugs(84, 3, HERE << "srv-" << srv->index << " flags.reserved = " << srv->flags.reserved);
     if (!srv->flags.reserved)
         return;
 
     ++ srv->stats.releases;
 
-    srv->flags.reserved = 0;
+    srv->flags.reserved = false;
     if (srv->parent->OnEmptyQueue != NULL && srv->data)
         srv->parent->OnEmptyQueue(srv->data);
 
     helperStatefulServerDone(srv);
 }
 
@@ -508,27 +507,27 @@
     storeAppendPrintf(sentry, "queue length: %d\n",
                       hlp->stats.queue_size);
     storeAppendPrintf(sentry, "avg service time: %d msec\n",
                       hlp->stats.avg_svc_time);
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "%7s\t%7s\t%7s\t%11s\t%11s\t%s\t%7s\t%7s\t%7s\n",
-                      "#",
+                      "ID #",
                       "FD",
                       "PID",
                       "# Requests",
                       "# Replies",
                       "Flags",
                       "Time",
                       "Offset",
                       "Request");
 
     for (dlink_node *link = hlp->servers.head; link; link = link->next) {
         helper_server *srv = (helper_server*)link->data;
         double tt = 0.001 * (srv->requests[0] ? tvSubMsec(srv->requests[0]->dispatch_time, current_time) : tvSubMsec(srv->dispatch_time, srv->answer_time));
-        storeAppendPrintf(sentry, "%7d\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c\t%7.3f\t%7d\t%s\n",
-                          srv->index + 1,
+        storeAppendPrintf(sentry, "%7u\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c\t%7.3f\t%7d\t%s\n",
+                          srv->index.value,
                           srv->readPipe->fd,
                           srv->pid,
                           srv->stats.uses,
                           srv->stats.replies,
                           srv->stats.pending ? 'B' : ' ',
                           srv->flags.writing ? 'W' : ' ',
@@ -563,27 +562,27 @@
     storeAppendPrintf(sentry, "queue length: %d\n",
                       hlp->stats.queue_size);
     storeAppendPrintf(sentry, "avg service time: %d msec\n",
                       hlp->stats.avg_svc_time);
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "%7s\t%7s\t%7s\t%11s\t%11s\t%6s\t%7s\t%7s\t%7s\n",
-                      "#",
+                      "ID #",
                       "FD",
                       "PID",
                       "# Requests",
                       "# Replies",
                       "Flags",
                       "Time",
                       "Offset",
                       "Request");
 
     for (dlink_node *link = hlp->servers.head; link; link = link->next) {
         helper_stateful_server *srv = (helper_stateful_server *)link->data;
         double tt = 0.001 * tvSubMsec(srv->dispatch_time, srv->flags.busy ? current_time : srv->answer_time);
-        storeAppendPrintf(sentry, "%7d\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c%c\t%7.3f\t%7d\t%s\n",
-                          srv->index + 1,
+        storeAppendPrintf(sentry, "%7u\t%7d\t%7d\t%11" PRIu64 "\t%11" PRIu64 "\t%c%c%c%c%c\t%7.3f\t%7d\t%s\n",
+                          srv->index.value,
                           srv->readPipe->fd,
                           srv->pid,
                           srv->stats.uses,
                           srv->stats.replies,
                           srv->flags.busy ? 'B' : ' ',
                           srv->flags.closing ? 'C' : ' ',
@@ -611,31 +610,31 @@
     while (link) {
         helper_server *srv;
         srv = (helper_server *)link->data;
         link = link->next;
 
         if (srv->flags.shutdown) {
-            debugs(84, 3, "helperShutdown: " << hlp->id_name << " #" << srv->index + 1 << " has already SHUT DOWN.");
+            debugs(84, 3, "helperShutdown: " << hlp->id_name << " #" << srv->index << " has already SHUT DOWN.");
             continue;
         }
 
         assert(hlp->childs.n_active > 0);
         -- hlp->childs.n_active;
-        srv->flags.shutdown = 1;	/* request it to shut itself down */
+        srv->flags.shutdown = true;	/* request it to shut itself down */
 
         if (srv->flags.closing) {
-            debugs(84, 3, "helperShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is CLOSING.");
+            debugs(84, 3, "helperShutdown: " << hlp->id_name << " #" << srv->index << " is CLOSING.");
             continue;
         }
 
         if (srv->stats.pending) {
-            debugs(84, 3, "helperShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is BUSY.");
+            debugs(84, 3, "helperShutdown: " << hlp->id_name << " #" << srv->index << " is BUSY.");
             continue;
         }
 
-        debugs(84, 3, "helperShutdown: " << hlp->id_name << " #" << srv->index + 1 << " shutting down.");
+        debugs(84, 3, "helperShutdown: " << hlp->id_name << " #" << srv->index << " shutting down.");
         /* the rest of the details is dealt with in the helperServerFree
          * close handler
          */
         srv->closePipesSafely();
     }
 }
@@ -648,40 +647,40 @@
 
     while (link) {
         srv = (helper_stateful_server *)link->data;
         link = link->next;
 
         if (srv->flags.shutdown) {
-            debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index + 1 << " has already SHUT DOWN.");
+            debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index << " has already SHUT DOWN.");
             continue;
         }
 
         assert(hlp->childs.n_active > 0);
         -- hlp->childs.n_active;
-        srv->flags.shutdown = 1;	/* request it to shut itself down */
+        srv->flags.shutdown = true;	/* request it to shut itself down */
 
         if (srv->flags.busy) {
-            debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is BUSY.");
+            debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index << " is BUSY.");
             continue;
         }
 
         if (srv->flags.closing) {
-            debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is CLOSING.");
+            debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index << " is CLOSING.");
             continue;
         }
 
         if (srv->flags.reserved) {
             if (shutting_down) {
-                debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is RESERVED. Closing anyway.");
+                debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index << " is RESERVED. Closing anyway.");
             } else {
-                debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index + 1 << " is RESERVED. Not Shutting Down Yet.");
+                debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index << " is RESERVED. Not Shutting Down Yet.");
                 continue;
             }
         }
 
-        debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index + 1 << " shutting down.");
+        debugs(84, 3, "helperStatefulShutdown: " << hlp->id_name << " #" << srv->index << " shutting down.");
 
         /* the rest of the details is dealt with in the helperStatefulServerFree
          * close handler
          */
         srv->closePipesSafely();
     }
@@ -731,13 +730,13 @@
     assert(hlp->childs.n_running > 0);
     -- hlp->childs.n_running;
 
     if (!srv->flags.shutdown) {
         assert(hlp->childs.n_active > 0);
         -- hlp->childs.n_active;
-        debugs(84, DBG_CRITICAL, "WARNING: " << hlp->id_name << " #" << srv->index + 1 << " exited");
+        debugs(84, DBG_CRITICAL, "WARNING: " << hlp->id_name << " #" << srv->index << " exited");
 
         if (hlp->childs.needNew() > 0) {
             debugs(80, DBG_IMPORTANT, "Too few " << hlp->id_name << " processes are running (need " << hlp->childs.needNew() << "/" << hlp->childs.n_max << ")");
 
             if (hlp->childs.n_active < hlp->childs.n_startup && hlp->last_restart > squid_curtime - 30) {
                 if (srv->stats.replies < 1)
@@ -749,17 +748,20 @@
             debugs(80, DBG_IMPORTANT, "Starting new helpers");
             helperOpenServers(hlp);
         }
     }
 
     for (i = 0; i < concurrency; ++i) {
+        // XXX: re-schedule these on another helper?
         if ((r = srv->requests[i])) {
             void *cbdata;
 
-            if (cbdataReferenceValidDone(r->data, &cbdata))
-                r->callback(cbdata, NULL);
+            if (cbdataReferenceValidDone(r->data, &cbdata)) {
+                HelperReply nilReply;
+                r->callback(cbdata, nilReply);
+            }
 
             helperRequestFree(r);
 
             srv->requests[i] = NULL;
         }
     }
@@ -796,13 +798,13 @@
     assert(hlp->childs.n_running > 0);
     -- hlp->childs.n_running;
 
     if (!srv->flags.shutdown) {
         assert( hlp->childs.n_active > 0);
         -- hlp->childs.n_active;
-        debugs(84, DBG_CRITICAL, "WARNING: " << hlp->id_name << " #" << srv->index + 1 << " exited");
+        debugs(84, DBG_CRITICAL, "WARNING: " << hlp->id_name << " #" << srv->index << " exited");
 
         if (hlp->childs.needNew() > 0) {
             debugs(80, DBG_IMPORTANT, "Too few " << hlp->id_name << " processes are running (need " << hlp->childs.needNew() << "/" << hlp->childs.n_max << ")");
 
             if (hlp->childs.n_active < hlp->childs.n_startup && hlp->last_restart > squid_curtime - 30) {
                 if (srv->stats.replies < 1)
@@ -816,14 +818,17 @@
         }
     }
 
     if ((r = srv->request)) {
         void *cbdata;
 
-        if (cbdataReferenceValidDone(r->data, &cbdata))
-            r->callback(cbdata, srv, NULL);
+        if (cbdataReferenceValidDone(r->data, &cbdata)) {
+            HelperReply nilReply;
+            nilReply.whichServer = srv;
+            r->callback(cbdata, nilReply);
+        }
 
         helperStatefulRequestFree(r);
 
         srv->request = NULL;
     }
 
@@ -833,25 +838,28 @@
     cbdataReferenceDone(srv->parent);
 
     delete srv;
 }
 
 /// Calls back with a pointer to the buffer with the helper output
-static void helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char * msg, char * msg_end)
+static void
+helperReturnBuffer(int request_number, helper_server * srv, helper * hlp, char * msg, char * msg_end)
 {
     helper_request *r = srv->requests[request_number];
     if (r) {
         HLPCB *callback = r->callback;
 
         srv->requests[request_number] = NULL;
 
         r->callback = NULL;
 
         void *cbdata = NULL;
-        if (cbdataReferenceValidDone(r->data, &cbdata))
-            callback(cbdata, msg);
+        if (cbdataReferenceValidDone(r->data, &cbdata)) {
+            HelperReply response(msg, (msg_end-msg));
+            callback(cbdata, response);
+        }
 
         -- srv->stats.pending;
         ++ srv->stats.replies;
 
         ++ hlp->stats.replies;
 
@@ -864,24 +872,21 @@
                              tvSubMsec(r->dispatch_time, current_time),
                              hlp->stats.replies, REDIRECT_AV_FACTOR);
 
         helperRequestFree(r);
     } else {
         debugs(84, DBG_IMPORTANT, "helperHandleRead: unexpected reply on channel " <<
-               request_number << " from " << hlp->id_name << " #" << srv->index + 1 <<
+               request_number << " from " << hlp->id_name << " #" << srv->index <<
                " '" << srv->rbuf << "'");
     }
-    srv->roffset -= (msg_end - srv->rbuf);
-    memmove(srv->rbuf, msg_end, srv->roffset + 1);
 
     if (!srv->flags.shutdown) {
         helperKickQueue(hlp);
     } else if (!srv->flags.closing && !srv->stats.pending) {
-        srv->flags.closing=1;
+        srv->flags.closing=true;
         srv->writePipe->close();
-        return;
     }
 }
 
 static void
 helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, comm_err_t flag, int xerrno, void *data)
 {
@@ -895,53 +900,61 @@
     if (flag == COMM_ERR_CLOSING) {
         return;
     }
 
     assert(conn->fd == srv->readPipe->fd);
 
-    debugs(84, 5, "helperHandleRead: " << len << " bytes from " << hlp->id_name << " #" << srv->index + 1);
+    debugs(84, 5, "helperHandleRead: " << len << " bytes from " << hlp->id_name << " #" << srv->index);
 
     if (flag != COMM_OK || len == 0) {
         srv->closePipesSafely();
         return;
     }
 
     srv->roffset += len;
     srv->rbuf[srv->roffset] = '\0';
-    debugs(84, 9, "helperHandleRead: '" << srv->rbuf << "'");
+    debugs(84, DBG_DATA, Raw("accumulated", srv->rbuf, srv->roffset));
 
     if (!srv->stats.pending) {
         /* someone spoke without being spoken to */
         debugs(84, DBG_IMPORTANT, "helperHandleRead: unexpected read from " <<
-               hlp->id_name << " #" << srv->index + 1 << ", " << (int)len <<
+               hlp->id_name << " #" << srv->index << ", " << (int)len <<
                " bytes '" << srv->rbuf << "'");
 
         srv->roffset = 0;
         srv->rbuf[0] = '\0';
     }
 
     while ((t = strchr(srv->rbuf, hlp->eom))) {
         /* end of reply found */
         char *msg = srv->rbuf;
         int i = 0;
+        int skip = 1;
         debugs(84, 3, "helperHandleRead: end of reply found");
 
-        if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n')
-            t[-1] = '\0';
+        if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n') {
+            *t = '\0';
+            // rewind to the \r octet which is the real terminal now
+            // and remember that we have to skip forward 2 places now.
+            skip = 2;
+            --t;
+        }
 
         *t = '\0';
-        ++t;
 
         if (hlp->childs.concurrency) {
             i = strtol(msg, &msg, 10);
 
             while (*msg && xisspace(*msg))
                 ++msg;
         }
 
         helperReturnBuffer(i, srv, hlp, msg, t);
+        srv->roffset -= (t - srv->rbuf) + skip;
+        memmove(srv->rbuf, t + skip, srv->roffset);
+        srv->rbuf[srv->roffset] = '\0';
     }
 
     if (Comm::IsConnOpen(srv->readPipe) && !fd_table[srv->readPipe->fd].closing()) {
         int spaceSize = srv->rbuf_sz - srv->roffset - 1;
         assert(spaceSize >= 0);
 
@@ -954,14 +967,13 @@
         }
 
         // quit reading if there is no space left
         if (!spaceSize) {
             debugs(84, DBG_IMPORTANT, "ERROR: Disconnecting from a " <<
                    "helper that overflowed " << srv->rbuf_sz << "-byte " <<
-                   "Squid input buffer: " << hlp->id_name << " #" <<
-                   (srv->index + 1));
+                   "Squid input buffer: " << hlp->id_name << " #" << srv->index);
             srv->closePipesSafely();
             return;
         }
 
         AsyncCall::Pointer call = commCbCall(5,4, "helperHandleRead",
                                              CommIoCbPtrFun(helperHandleRead, srv));
@@ -984,50 +996,67 @@
         return;
     }
 
     assert(conn->fd == srv->readPipe->fd);
 
     debugs(84, 5, "helperStatefulHandleRead: " << len << " bytes from " <<
-           hlp->id_name << " #" << srv->index + 1);
+           hlp->id_name << " #" << srv->index);
 
     if (flag != COMM_OK || len == 0) {
         srv->closePipesSafely();
         return;
     }
 
     srv->roffset += len;
     srv->rbuf[srv->roffset] = '\0';
     r = srv->request;
+    debugs(84, DBG_DATA, Raw("accumulated", srv->rbuf, srv->roffset));
 
     if (r == NULL) {
         /* someone spoke without being spoken to */
         debugs(84, DBG_IMPORTANT, "helperStatefulHandleRead: unexpected read from " <<
-               hlp->id_name << " #" << srv->index + 1 << ", " << (int)len <<
+               hlp->id_name << " #" << srv->index << ", " << (int)len <<
                " bytes '" << srv->rbuf << "'");
 
         srv->roffset = 0;
     }
 
     if ((t = strchr(srv->rbuf, hlp->eom))) {
         /* end of reply found */
         int called = 1;
+        int skip = 1;
         debugs(84, 3, "helperStatefulHandleRead: end of reply found");
 
-        if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n')
-            t[-1] = '\0';
+        if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n') {
+            *t = '\0';
+            // rewind to the \r octet which is the real terminal now
+            // and remember that we have to skip forward 2 places now.
+            skip = 2;
+            --t;
+        }
 
         *t = '\0';
 
         if (r && cbdataReferenceValid(r->data)) {
-            r->callback(r->data, srv, srv->rbuf);
+            HelperReply res(srv->rbuf, (t - srv->rbuf));
+            res.whichServer = srv;
+            r->callback(r->data, res);
         } else {
             debugs(84, DBG_IMPORTANT, "StatefulHandleRead: no callback data registered");
             called = 0;
         }
+        // only skip off the \0's _after_ passing its location in HelperReply above
+        t += skip;
 
-        srv->flags.busy = 0;
+        srv->flags.busy = false;
+        /**
+         * BUG: the below assumes that only one response per read() was received and discards any octets remaining.
+         *      Doing this prohibits concurrency support with multiple replies per read().
+         * TODO: check that read() setup on these buffers pays attention to roffest!=0
+         * TODO: check that replies bigger than the buffer are discarded and do not to affect future replies
+         */
         srv->roffset = 0;
         helperStatefulRequestFree(r);
         srv->request = NULL;
 
         -- srv->stats.pending;
         ++ srv->stats.replies;
@@ -1058,14 +1087,13 @@
         }
 
         // quit reading if there is no space left
         if (!spaceSize) {
             debugs(84, DBG_IMPORTANT, "ERROR: Disconnecting from a " <<
                    "helper that overflowed " << srv->rbuf_sz << "-byte " <<
-                   "Squid input buffer: " << hlp->id_name << " #" <<
-                   (srv->index + 1));
+                   "Squid input buffer: " << hlp->id_name << " #" << srv->index);
             srv->closePipesSafely();
             return;
         }
 
         AsyncCall::Pointer call = commCbCall(5,4, "helperStatefulHandleRead",
                                              CommIoCbPtrFun(helperStatefulHandleRead, srv));
@@ -1256,24 +1284,24 @@
 {
     helper_server *srv = (helper_server *)data;
 
     srv->writebuf->clean();
     delete srv->writebuf;
     srv->writebuf = NULL;
-    srv->flags.writing = 0;
+    srv->flags.writing = false;
 
     if (flag != COMM_OK) {
         /* Helper server has crashed */
-        debugs(84, DBG_CRITICAL, "helperDispatch: Helper " << srv->parent->id_name << " #" << srv->index + 1 << " has crashed");
+        debugs(84, DBG_CRITICAL, "helperDispatch: Helper " << srv->parent->id_name << " #" << srv->index << " has crashed");
         return;
     }
 
     if (!srv->wqueue->isNull()) {
         srv->writebuf = srv->wqueue;
         srv->wqueue = new MemBuf;
-        srv->flags.writing = 1;
+        srv->flags.writing = true;
         AsyncCall::Pointer call = commCbCall(5,5, "helperDispatchWriteDone",
                                              CommIoCbPtrFun(helperDispatchWriteDone, srv));
         Comm::Write(srv->writePipe, srv->writebuf->content(), srv->writebuf->contentSize(), call, NULL);
     }
 }
 
@@ -1310,19 +1338,19 @@
         srv->wqueue->append(r->buf, strlen(r->buf));
 
     if (!srv->flags.writing) {
         assert(NULL == srv->writebuf);
         srv->writebuf = srv->wqueue;
         srv->wqueue = new MemBuf;
-        srv->flags.writing = 1;
+        srv->flags.writing = true;
         AsyncCall::Pointer call = commCbCall(5,5, "helperDispatchWriteDone",
                                              CommIoCbPtrFun(helperDispatchWriteDone, srv));
         Comm::Write(srv->writePipe, srv->writebuf->content(), srv->writebuf->contentSize(), call, NULL);
     }
 
-    debugs(84, 5, "helperDispatch: Request sent to " << hlp->id_name << " #" << srv->index + 1 << ", " << strlen(r->buf) << " bytes");
+    debugs(84, 5, "helperDispatch: Request sent to " << hlp->id_name << " #" << srv->index << ", " << strlen(r->buf) << " bytes");
 
     ++ srv->stats.uses;
     ++ srv->stats.pending;
     ++ hlp->stats.requests;
 }
 
@@ -1342,39 +1370,41 @@
         debugs(84, DBG_IMPORTANT, "helperStatefulDispatch: invalid callback data");
         helperStatefulRequestFree(r);
         helperStatefulReleaseServer(srv);
         return;
     }
 
-    debugs(84, 9, "helperStatefulDispatch busying helper " << hlp->id_name << " #" << srv->index + 1);
+    debugs(84, 9, "helperStatefulDispatch busying helper " << hlp->id_name << " #" << srv->index);
 
     if (r->placeholder == 1) {
         /* a callback is needed before this request can _use_ a helper. */
         /* we don't care about releasing this helper. The request NEVER
          * gets to the helper. So we throw away the return code */
-        r->callback(r->data, srv, NULL);
+        HelperReply nilReply;
+        nilReply.whichServer = srv;
+        r->callback(r->data, nilReply);
         /* throw away the placeholder */
         helperStatefulRequestFree(r);
         /* and push the queue. Note that the callback may have submitted a new
-         * request to the helper which is why we test for the request*/
+         * request to the helper which is why we test for the request */
 
         if (srv->request == NULL)
             helperStatefulServerDone(srv);
 
         return;
     }
 
-    srv->flags.busy = 1;
-    srv->flags.reserved = 1;
+    srv->flags.busy = true;
+    srv->flags.reserved = true;
     srv->request = r;
     srv->dispatch_time = current_time;
     AsyncCall::Pointer call = commCbCall(5,5, "helperStatefulDispatchWriteDone",
                                          CommIoCbPtrFun(helperStatefulDispatchWriteDone, hlp));
     Comm::Write(srv->writePipe, r->buf, strlen(r->buf), call, NULL);
     debugs(84, 5, "helperStatefulDispatch: Request sent to " <<
-           hlp->id_name << " #" << srv->index + 1 << ", " <<
+           hlp->id_name << " #" << srv->index << ", " <<
            (int) strlen(r->buf) << " bytes");
 
     ++ srv->stats.uses;
     ++ srv->stats.pending;
     ++ hlp->stats.requests;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/helper.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/helper.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/helper.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/helper.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,21 +31,23 @@
  */
 
 #ifndef SQUID_HELPER_H
 #define SQUID_HELPER_H
 
 #include "base/AsyncCall.h"
+#include "base/InstanceId.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "dlink.h"
 #include "ip/Address.h"
 #include "HelperChildConfig.h"
+#include "HelperReply.h"
 
 class helper_request;
 
-typedef void HLPSCB(void *, void *lastserver, char *buf);
+typedef void HLPCB(void *, const HelperReply &reply);
 
 class helper
 {
 public:
     inline helper(const char *name) :
             cmdline(NULL),
@@ -111,13 +113,15 @@
      * If the read and write sockets are the same the write pipe will
      * also be closed. Otherwise its left open for later handling.
      */
     void closeWritePipeSafely();
 
 public:
-    int index;
+    /// Helper program identifier; does not change when contents do,
+    ///   including during assignment
+    const InstanceId<HelperServerBase> index;
     int pid;
     Ip::Address addr;
     Comm::ConnectionPointer readPipe;
     Comm::ConnectionPointer writePipe;
     void *hIpc;
 
@@ -128,17 +132,17 @@
     struct timeval dispatch_time;
     struct timeval answer_time;
 
     dlink_node link;
 
     struct _helper_flags {
-        unsigned int busy:1;
-        unsigned int writing:1;
-        unsigned int closing:1;
-        unsigned int shutdown:1;
-        unsigned int reserved:1;
+        bool busy;
+        bool writing;
+        bool closing;
+        bool shutdown;
+        bool reserved;
     } flags;
 
     struct {
         uint64_t uses;     //< requests sent to this helper
         uint64_t replies;  //< replies received from this helper
         uint64_t pending;  //< queued lookups waiting to be sent to this helper
@@ -196,24 +200,24 @@
 class helper_stateful_request
 {
 
 public:
     MEMPROXY_CLASS(helper_stateful_request);
     char *buf;
-    HLPSCB *callback;
+    HLPCB *callback;
     int placeholder;		/* if 1, this is a dummy request waiting for a stateful helper to become available */
     void *data;
 };
 
 MEMPROXY_CLASS_INLINE(helper_stateful_request);
 
 /* helper.c */
 void helperOpenServers(helper * hlp);
 void helperStatefulOpenServers(statefulhelper * hlp);
 void helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data);
-void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPSCB * callback, void *data, helper_stateful_server * lastserver);
+void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver);
 void helperStats(StoreEntry * sentry, helper * hlp, const char *label = NULL);
 void helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp, const char *label = NULL);
 void helperShutdown(helper * hlp);
 void helperStatefulShutdown(statefulhelper * hlp);
 void helperStatefulReleaseServer(helper_stateful_server * srv);
 void *helperStatefulServerGetData(helper_stateful_server * srv);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: HelperReply.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: HelperReply.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HierarchyLogEntry.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HierarchyLogEntry.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HierarchyLogEntry.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HierarchyLogEntry.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,21 +30,19 @@
  */
 
 #ifndef SQUID_HTTPHIERARCHYLOGENTRY_H
 #define SQUID_HTTPHIERARCHYLOGENTRY_H
 
 #include "comm/Connection.h"
+#include "enums.h"
 #include "hier_code.h"
-#include "HttpStatusCode.h"
+#include "http/StatusCode.h"
 #include "lookup_t.h"
 #include "rfc2181.h"
 #include "PingData.h"
 
-/* for http_status */
-#include "enums.h"
-
 class HierarchyLogEntry
 {
 
 public:
     HierarchyLogEntry();
     ~HierarchyLogEntry() { tcpServer = NULL; };
@@ -63,13 +61,13 @@
     int n_ichoices;		/* #peers with known rtt we selected from (cd only) */
 
     struct timeval peer_select_start;
 
     struct timeval store_complete_stop;
 
-    http_status peer_reply_status; ///< last HTTP status code received
+    Http::StatusCode peer_reply_status; ///< last HTTP status code received
     timeval peer_http_request_sent; ///< last peer finished writing req
     int64_t peer_response_time; ///< last peer response delay
     timeval first_conn_start; ///< first connection use among all peers
     int64_t total_response_time; ///< cumulative for all peers
     Comm::ConnectionPointer tcpServer; ///< TCP/IP level details of the last server-side connection
     int64_t bodyBytesRead;  ///< number of body bytes received from the next hop or -1
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/htcp.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/htcp.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/htcp.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/htcp.cc	2015-05-01 18:05:19.000000000 +0800
@@ -264,13 +264,13 @@
 static ssize_t htcpBuildTstOpData(char *buf, size_t buflen, htcpStuff * stuff);
 static void htcpFreeSpecifier(htcpSpecifier * s);
 static void htcpFreeDetail(htcpDetail * s);
 
 static void htcpHandleMsg(char *buf, int sz, Ip::Address &from);
 
-static void htcpLogHtcp(Ip::Address &, int, log_type, const char *);
+static void htcpLogHtcp(Ip::Address &, int, LogTags, const char *);
 static void htcpHandleMon(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
 static void htcpHandleNop(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
 static void htcpHandleSet(htcpDataHeader *, char *buf, int sz, Ip::Address &from);
 
@@ -745,13 +745,13 @@
 
     /*
      * Parse the request
      */
     method = HttpRequestMethod(s->method, NULL);
 
-    s->request = HttpRequest::CreateFromUrlAndMethod(s->uri, method == METHOD_NONE ? HttpRequestMethod(METHOD_GET) : method);
+    s->request = HttpRequest::CreateFromUrlAndMethod(s->uri, method == Http::METHOD_NONE ? HttpRequestMethod(Http::METHOD_GET) : method);
 
     if (s->request)
         HTTPMSGLOCK(s->request);
 
     return s;
 }
@@ -847,13 +847,13 @@
     /* default deny if no access list present */
     if (!acl)
         return false;
 
     ACLFilledChecklist checklist(acl, s->request, NULL);
     checklist.src_addr = from;
-    checklist.my_addr.SetNoAddr();
+    checklist.my_addr.setNoAddr();
     return (checklist.fastCheck() == ACCESS_ALLOWED);
 }
 
 static void
 htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Address &from)
 {
@@ -1118,13 +1118,13 @@
         debugs(31, 3, "htcpHandleTstResponse: No query key for response id '" << hdr->msg_id << "' from '" << from << "'");
         return;
     }
 
     peer = &queried_addr[hdr->msg_id % N_QUERIED_KEYS];
 
-    if ( *peer != from || peer->GetPort() != from.GetPort() ) {
+    if ( *peer != from || peer->port() != from.port() ) {
         debugs(31, 3, "htcpHandleTstResponse: Unexpected response source " << from );
         return;
     }
 
     if (hdr->F1 == 1) {
         debugs(31, 2, "htcpHandleTstResponse: error condition, F1/MO == 1");
@@ -1482,44 +1482,44 @@
         debugs(31, DBG_IMPORTANT, "HTCP Disabled.");
         return;
     }
 
     htcpIncomingConn = new Comm::Connection;
     htcpIncomingConn->local = Config.Addrs.udp_incoming;
-    htcpIncomingConn->local.SetPort(Config.Port.htcp);
+    htcpIncomingConn->local.port(Config.Port.htcp);
 
-    if (!Ip::EnableIpv6 && !htcpIncomingConn->local.SetIPv4()) {
+    if (!Ip::EnableIpv6 && !htcpIncomingConn->local.setIPv4()) {
         debugs(31, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << htcpIncomingConn->local << " is not an IPv4 address.");
         fatal("HTCP port cannot be opened.");
     }
     /* split-stack for now requires default IPv4-only HTCP */
-    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && htcpIncomingConn->local.IsAnyAddr()) {
-        htcpIncomingConn->local.SetIPv4();
+    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && htcpIncomingConn->local.isAnyAddr()) {
+        htcpIncomingConn->local.setIPv4();
     }
 
     AsyncCall::Pointer call = asyncCall(31, 2,
                                         "htcpIncomingConnectionOpened",
                                         Comm::UdpOpenDialer(&htcpIncomingConnectionOpened));
 
     Ipc::StartListening(SOCK_DGRAM,
                         IPPROTO_UDP,
                         htcpIncomingConn,
                         Ipc::fdnInHtcpSocket, call);
 
-    if (!Config.Addrs.udp_outgoing.IsNoAddr()) {
+    if (!Config.Addrs.udp_outgoing.isNoAddr()) {
         htcpOutgoingConn = new Comm::Connection;
         htcpOutgoingConn->local = Config.Addrs.udp_outgoing;
-        htcpOutgoingConn->local.SetPort(Config.Port.htcp);
+        htcpOutgoingConn->local.port(Config.Port.htcp);
 
-        if (!Ip::EnableIpv6 && !htcpOutgoingConn->local.SetIPv4()) {
+        if (!Ip::EnableIpv6 && !htcpOutgoingConn->local.setIPv4()) {
             debugs(31, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << htcpOutgoingConn->local << " is not an IPv4 address.");
             fatal("HTCP port cannot be opened.");
         }
         /* split-stack for now requires default IPv4-only HTCP */
-        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && htcpOutgoingConn->local.IsAnyAddr()) {
-            htcpOutgoingConn->local.SetIPv4();
+        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && htcpOutgoingConn->local.isAnyAddr()) {
+            htcpOutgoingConn->local.setIPv4();
         }
 
         enter_suid();
         comm_open_listener(SOCK_DGRAM, IPPROTO_UDP, htcpOutgoingConn, "Outgoing HTCP Socket");
         leave_suid();
 
@@ -1543,13 +1543,13 @@
         fatal("Cannot open HTCP Socket");
 
     Comm::SetSelect(conn->fd, COMM_SELECT_READ, htcpRecv, NULL, 0);
 
     debugs(31, DBG_CRITICAL, "Accepting HTCP messages on " << conn->local);
 
-    if (Config.Addrs.udp_outgoing.IsNoAddr()) {
+    if (Config.Addrs.udp_outgoing.isNoAddr()) {
         htcpOutgoingConn = conn;
         debugs(31, DBG_IMPORTANT, "Sending HTCP messages from " << htcpOutgoingConn->local);
     }
 }
 
 int
@@ -1718,13 +1718,13 @@
         debugs(12, DBG_IMPORTANT, "Stop sending HTCP from " << htcpOutgoingConn->local);
         htcpOutgoingConn = NULL;
     }
 }
 
 static void
-htcpLogHtcp(Ip::Address &caddr, int opcode, log_type logcode, const char *url)
+htcpLogHtcp(Ip::Address &caddr, int opcode, LogTags logcode, const char *url)
 {
     AccessLogEntry::Pointer al = new AccessLogEntry;
     if (LOG_TAG_NONE == logcode)
         return;
     if (!Config.onoff.log_udp)
         return;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: http
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/http.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/http.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/http.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/http.cc	2015-05-01 18:05:19.000000000 +0800
@@ -94,13 +94,13 @@
     }
 
 CBDATA_CLASS_INIT(HttpStateData);
 
 static const char *const crlf = "\r\n";
 
-static void httpMaybeRemovePublic(StoreEntry *, http_status);
+static void httpMaybeRemovePublic(StoreEntry *, Http::StatusCode);
 static void copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, const String strConnection, const HttpRequest * request,
         HttpHeader * hdr_out, const int we_do_ranges, const HttpStateFlags &);
 //Declared in HttpHeaderTools.cc
 void httpHdrAdd(HttpHeader *heads, HttpRequest *request, const AccessLogEntryPointer &al, HeaderWithAclList &headers_add);
 
 HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"), ServerStateData(theFwdState),
@@ -119,13 +119,13 @@
     request->hier.peer_http_request_sent.tv_usec = 0;
 
     if (fwd->serverConnection() != NULL)
         _peer = cbdataReference(fwd->serverConnection()->getPeer());         /* might be NULL */
 
     if (_peer) {
-        request->flags.proxying = 1;
+        request->flags.proxying = true;
         /*
          * This NEIGHBOR_PROXY_ONLY check probably shouldn't be here.
          * We might end up getting the object from somewhere else if,
          * for example, the request to this neighbor fails.
          */
         if (_peer->options.proxy_only)
@@ -173,76 +173,63 @@
 HttpStateData::httpStateConnClosed(const CommCloseCbParams &params)
 {
     debugs(11, 5, "httpStateFree: FD " << params.fd << ", httpState=" << params.data);
     mustStop("HttpStateData::httpStateConnClosed");
 }
 
-int
-httpCachable(const HttpRequestMethod& method)
-{
-    /* GET and HEAD are cachable. Others are not. */
-
-    // TODO: replase to HttpRequestMethod::isCachable() ?
-    if (method != METHOD_GET && method != METHOD_HEAD)
-        return 0;
-
-    /* else cachable */
-    return 1;
-}
-
 void
 HttpStateData::httpTimeout(const CommTimeoutCbParams &params)
 {
     debugs(11, 4, HERE << serverConnection << ": '" << entry->url() << "'" );
 
     if (entry->store_status == STORE_PENDING) {
-        fwd->fail(new ErrorState(ERR_READ_TIMEOUT, HTTP_GATEWAY_TIMEOUT, fwd->request));
+        fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, fwd->request));
     }
 
     serverConnection->close();
 }
 
 static void
-httpMaybeRemovePublic(StoreEntry * e, http_status status)
+httpMaybeRemovePublic(StoreEntry * e, Http::StatusCode status)
 {
     int remove = 0;
     int forbidden = 0;
     StoreEntry *pe;
 
     if (!EBIT_TEST(e->flags, KEY_PRIVATE))
         return;
 
     switch (status) {
 
-    case HTTP_OK:
+    case Http::scOkay:
 
-    case HTTP_NON_AUTHORITATIVE_INFORMATION:
+    case Http::scNonAuthoritativeInformation:
 
-    case HTTP_MULTIPLE_CHOICES:
+    case Http::scMultipleChoices:
 
-    case HTTP_MOVED_PERMANENTLY:
+    case Http::scMovedPermanently:
 
-    case HTTP_MOVED_TEMPORARILY:
+    case Http::scFound:
 
-    case HTTP_GONE:
+    case Http::scGone:
 
-    case HTTP_NOT_FOUND:
+    case Http::scNotFound:
         remove = 1;
 
         break;
 
-    case HTTP_FORBIDDEN:
+    case Http::scForbidden:
 
-    case HTTP_METHOD_NOT_ALLOWED:
+    case Http::scMethodNotAllowed:
         forbidden = 1;
 
         break;
 
 #if WORK_IN_PROGRESS
 
-    case HTTP_UNAUTHORIZED:
+    case Http::scUnauthorized:
         forbidden = 1;
 
         break;
 
 #endif
 
@@ -280,20 +267,20 @@
 
     /** \par
      * Also remove any cached HEAD response in case the object has
      * changed.
      */
     if (e->mem_obj->request)
-        pe = storeGetPublicByRequestMethod(e->mem_obj->request, METHOD_HEAD);
+        pe = storeGetPublicByRequestMethod(e->mem_obj->request, Http::METHOD_HEAD);
     else
-        pe = storeGetPublic(e->mem_obj->url, METHOD_HEAD);
+        pe = storeGetPublic(e->mem_obj->url, Http::METHOD_HEAD);
 
     if (pe != NULL) {
         assert(e != pe);
 #if USE_HTCP
-        neighborsHtcpClear(e, NULL, e->mem_obj->request, HttpRequestMethod(METHOD_HEAD), HTCP_CLR_INVALIDATION);
+        neighborsHtcpClear(e, NULL, e->mem_obj->request, HttpRequestMethod(Http::METHOD_HEAD), HTCP_CLR_INVALIDATION);
 #endif
         pe->release();
     }
 }
 
 void
@@ -467,126 +454,128 @@
     if ((v = hdr->getStr(HDR_CONTENT_TYPE)))
         if (!strncasecmp(v, "multipart/x-mixed-replace", 25)) {
             debugs(22, 3, HERE << "NO because Content-Type:multipart/x-mixed-replace");
             return 0;
         }
 
-    switch (rep->sline.status) {
+    switch (rep->sline.status()) {
         /* Responses that are cacheable */
 
-    case HTTP_OK:
+    case Http::scOkay:
 
-    case HTTP_NON_AUTHORITATIVE_INFORMATION:
+    case Http::scNonAuthoritativeInformation:
 
-    case HTTP_MULTIPLE_CHOICES:
+    case Http::scMultipleChoices:
 
-    case HTTP_MOVED_PERMANENTLY:
-    case HTTP_PERMANENT_REDIRECT:
+    case Http::scMovedPermanently:
+    case Http::scPermanentRedirect:
 
-    case HTTP_GONE:
+    case Http::scGone:
         /*
          * Don't cache objects that need to be refreshed on next request,
          * unless we know how to refresh it.
          */
 
         if (!refreshIsCachable(entry) && !REFRESH_OVERRIDE(store_stale)) {
             debugs(22, 3, "NO because refreshIsCachable() returned non-cacheable..");
             return 0;
         } else {
-            debugs(22, 3, HERE << "YES because HTTP status " << rep->sline.status);
+            debugs(22, 3, HERE << "YES because HTTP status " << rep->sline.status());
             return 1;
         }
         /* NOTREACHED */
         break;
 
         /* Responses that only are cacheable if the server says so */
 
-    case HTTP_MOVED_TEMPORARILY:
-    case HTTP_TEMPORARY_REDIRECT:
+    case Http::scFound:
+    case Http::scTemporaryRedirect:
         if (rep->date <= 0) {
-            debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status << " and Date missing/invalid");
+            debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status() << " and Date missing/invalid");
             return 0;
         }
         if (rep->expires > rep->date) {
-            debugs(22, 3, HERE << "YES because HTTP status " << rep->sline.status << " and Expires > Date");
+            debugs(22, 3, HERE << "YES because HTTP status " << rep->sline.status() << " and Expires > Date");
             return 1;
         } else {
-            debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status << " and Expires <= Date");
+            debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status() << " and Expires <= Date");
             return 0;
         }
         /* NOTREACHED */
         break;
 
         /* Errors can be negatively cached */
 
-    case HTTP_NO_CONTENT:
+    case Http::scNoContent:
 
-    case HTTP_USE_PROXY:
+    case Http::scUseProxy:
 
-    case HTTP_BAD_REQUEST:
+    case Http::scBadRequest:
 
-    case HTTP_FORBIDDEN:
+    case Http::scForbidden:
 
-    case HTTP_NOT_FOUND:
+    case Http::scNotFound:
 
-    case HTTP_METHOD_NOT_ALLOWED:
+    case Http::scMethodNotAllowed:
 
-    case HTTP_REQUEST_URI_TOO_LARGE:
+    case Http::scUriTooLong:
 
-    case HTTP_INTERNAL_SERVER_ERROR:
+    case Http::scInternalServerError:
 
-    case HTTP_NOT_IMPLEMENTED:
+    case Http::scNotImplemented:
 
-    case HTTP_BAD_GATEWAY:
+    case Http::scBadGateway:
 
-    case HTTP_SERVICE_UNAVAILABLE:
+    case Http::scServiceUnavailable:
 
-    case HTTP_GATEWAY_TIMEOUT:
-        debugs(22, 3, HERE << "MAYBE because HTTP status " << rep->sline.status);
+    case Http::scGatewayTimeout:
+    case Http::scMisdirectedRequest:
+
+        debugs(22, 3, "MAYBE because HTTP status " << rep->sline.status());
         return -1;
 
         /* NOTREACHED */
         break;
 
         /* Some responses can never be cached */
 
-    case HTTP_PARTIAL_CONTENT:	/* Not yet supported */
+    case Http::scPartialContent:	/* Not yet supported */
 
-    case HTTP_SEE_OTHER:
+    case Http::scSeeOther:
 
-    case HTTP_NOT_MODIFIED:
+    case Http::scNotModified:
 
-    case HTTP_UNAUTHORIZED:
+    case Http::scUnauthorized:
 
-    case HTTP_PROXY_AUTHENTICATION_REQUIRED:
+    case Http::scProxyAuthenticationRequired:
 
-    case HTTP_INVALID_HEADER:	/* Squid header parsing error */
+    case Http::scInvalidHeader:	/* Squid header parsing error */
 
-    case HTTP_HEADER_TOO_LARGE:
+    case Http::scHeaderTooLarge:
 
-    case HTTP_PAYMENT_REQUIRED:
-    case HTTP_NOT_ACCEPTABLE:
-    case HTTP_REQUEST_TIMEOUT:
-    case HTTP_CONFLICT:
-    case HTTP_LENGTH_REQUIRED:
-    case HTTP_PRECONDITION_FAILED:
-    case HTTP_REQUEST_ENTITY_TOO_LARGE:
-    case HTTP_UNSUPPORTED_MEDIA_TYPE:
-    case HTTP_UNPROCESSABLE_ENTITY:
-    case HTTP_LOCKED:
-    case HTTP_FAILED_DEPENDENCY:
-    case HTTP_INSUFFICIENT_STORAGE:
-    case HTTP_REQUESTED_RANGE_NOT_SATISFIABLE:
-    case HTTP_EXPECTATION_FAILED:
+    case Http::scPaymentRequired:
+    case Http::scNotAcceptable:
+    case Http::scRequestTimeout:
+    case Http::scConflict:
+    case Http::scLengthRequired:
+    case Http::scPreconditionFailed:
+    case Http::scPayloadTooLarge:
+    case Http::scUnsupportedMediaType:
+    case Http::scUnprocessableEntity:
+    case Http::scLocked:
+    case Http::scFailedDependency:
+    case Http::scInsufficientStorage:
+    case Http::scRequestedRangeNotSatisfied:
+    case Http::scExpectationFailed:
 
-        debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status);
+        debugs(22, 3, HERE << "NO because HTTP status " << rep->sline.status());
         return 0;
 
     default:
         /* RFC 2616 section 6.1.1: an unrecognized response MUST NOT be cached. */
-        debugs (11, 3, HERE << "NO because unknown HTTP status code " << rep->sline.status);
+        debugs (11, 3, HERE << "NO because unknown HTTP status code " << rep->sline.status());
         return 0;
 
         /* NOTREACHED */
         break;
     }
 
@@ -721,32 +710,33 @@
 
     if (!readBuf->hasContent()) {
         ctx_exit(ctx);
         return;
     }
 
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
 
     HttpReply *newrep = new HttpReply;
     const bool parsed = newrep->parse(readBuf, eof, &error);
 
     if (!parsed && readBuf->contentSize() > 5 && strncmp(readBuf->content(), "HTTP/", 5) != 0 && strncmp(readBuf->content(), "ICY", 3) != 0) {
         MemBuf *mb;
         HttpReply *tmprep = new HttpReply;
-        tmprep->setHeaders(HTTP_OK, "Gatewaying", NULL, -1, -1, -1);
+        tmprep->setHeaders(Http::scOkay, "Gatewaying", NULL, -1, -1, -1);
         tmprep->header.putExt("X-Transformed-From", "HTTP/0.9");
         mb = tmprep->pack();
         newrep->parse(mb, eof, &error);
         delete mb;
         delete tmprep;
     } else {
         if (!parsed && error > 0) { // unrecoverable parsing error
             debugs(11, 3, "processReplyHeader: Non-HTTP-compliant header: '" <<  readBuf->content() << "'");
             flags.headers_parsed = true;
-            newrep->sline.version = HttpVersion(1,1);
-            newrep->sline.status = error;
+            // XXX: when sanityCheck is gone and Http::StatusLine is used to parse,
+            //   the sline should be already set the appropriate values during that parser stage
+            newrep->sline.set(Http::ProtocolVersion(1,1), error);
             HttpReply *vrep = setVirginReply(newrep);
             entry->replaceHttpReply(vrep);
             ctx_exit(ctx);
             return;
         }
 
@@ -764,46 +754,46 @@
         header_bytes_read = headersEnd(readBuf->content(), readBuf->contentSize());
         readBuf->consume(header_bytes_read);
     }
 
     newrep->removeStaleWarnings();
 
-    if (newrep->sline.protocol == AnyP::PROTO_HTTP && newrep->sline.status >= 100 && newrep->sline.status < 200) {
+    if (newrep->sline.protocol == AnyP::PROTO_HTTP && newrep->sline.status() >= 100 && newrep->sline.status() < 200) {
         handle1xx(newrep);
         ctx_exit(ctx);
         return;
     }
 
     flags.chunked = false;
     if (newrep->sline.protocol == AnyP::PROTO_HTTP && newrep->header.chunked()) {
         flags.chunked = true;
         httpChunkDecoder = new ChunkedCodingParser;
     }
 
     if (!peerSupportsConnectionPinning())
-        request->flags.connectionAuthDisabled = 1;
+        request->flags.connectionAuthDisabled = true;
 
     HttpReply *vrep = setVirginReply(newrep);
     flags.headers_parsed = true;
 
     keepaliveAccounting(vrep);
 
     checkDateSkew(vrep);
 
     processSurrogateControl (vrep);
 
-    request->hier.peer_reply_status = newrep->sline.status;
+    request->hier.peer_reply_status = newrep->sline.status();
 
     ctx_exit(ctx);
 }
 
 /// ignore or start forwarding the 1xx response (a.k.a., control message)
 void
 HttpStateData::handle1xx(HttpReply *reply)
 {
-    HttpMsgPointerT<HttpReply> msg(reply); // will destroy reply if unused
+    HttpReply::Pointer msg(reply); // will destroy reply if unused
 
     // one 1xx at a time: we must not be called while waiting for previous 1xx
     Must(!flags.handling1xx);
     flags.handling1xx = true;
 
     if (!request->canHandle1xx()) {
@@ -813,13 +803,14 @@
     }
 
 #if USE_HTTP_VIOLATIONS
     // check whether the 1xx response forwarding is allowed by squid.conf
     if (Config.accessList.reply) {
         ACLFilledChecklist ch(Config.accessList.reply, originalRequest(), NULL);
-        ch.reply = HTTPMSGLOCK(reply);
+        ch.reply = reply;
+        HTTPMSGLOCK(ch.reply);
         if (ch.fastCheck() != ACCESS_ALLOWED) { // TODO: support slow lookups?
             debugs(11, 3, HERE << "ignoring denied 1xx");
             proceedAfter1xx();
             return;
         }
     }
@@ -872,16 +863,16 @@
     if (!_peer->connection_auth)
         return false;
 
     /*The peer supports connection pinning and the http reply status
       is not unauthorized, so the related connection can be pinned
      */
-    if (rep->sline.status != HTTP_UNAUTHORIZED)
+    if (rep->sline.status() != Http::scUnauthorized)
         return true;
 
-    /*The server respond with HTTP_UNAUTHORIZED and the peer configured
+    /*The server respond with Http::scUnauthorized and the peer configured
       with "connection-auth=on" we know that the peer supports pinned
       connections
     */
     if (_peer->connection_auth == 1)
         return true;
 
@@ -924,39 +915,39 @@
     Ctx ctx = ctx_enter(entry->mem_obj->url);
     HttpReply *rep = finalReply();
 
     entry->timestampsSet();
 
     /* Check if object is cacheable or not based on reply code */
-    debugs(11, 3, "haveParsedReplyHeaders: HTTP CODE: " << rep->sline.status);
+    debugs(11, 3, "HTTP CODE: " << rep->sline.status());
 
     if (neighbors_do_private_keys)
-        httpMaybeRemovePublic(entry, rep->sline.status);
+        httpMaybeRemovePublic(entry, rep->sline.status());
 
     if (rep->header.has(HDR_VARY)
 #if X_ACCELERATOR_VARY
             || rep->header.has(HDR_X_ACCELERATOR_VARY)
 #endif
        ) {
         const char *vary = httpMakeVaryMark(request, rep);
 
         if (!vary) {
             entry->makePrivate();
-            if (!fwd->reforwardableStatus(rep->sline.status))
+            if (!fwd->reforwardableStatus(rep->sline.status()))
                 EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
             goto no_cache;
         }
 
         entry->mem_obj->vary_headers = xstrdup(vary);
     }
 
     /*
      * If its not a reply that we will re-forward, then
      * allow the client to get it.
      */
-    if (!fwd->reforwardableStatus(rep->sline.status))
+    if (!fwd->reforwardableStatus(rep->sline.status()))
         EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
 
     switch (cacheableReply()) {
 
     case 1:
         entry->makePublic();
@@ -1167,13 +1158,13 @@
     if (io.flag != COMM_OK || len < 0) {
         debugs(11, 2, HERE << io.conn << ": read failure: " << xstrerror() << ".");
 
         if (ignoreErrno(io.xerrno)) {
             flags.do_next_read = true;
         } else {
-            ErrorState *err = new ErrorState(ERR_READ_ERROR, HTTP_BAD_GATEWAY, fwd->request);
+            ErrorState *err = new ErrorState(ERR_READ_ERROR, Http::scBadGateway, fwd->request);
             err->xerrno = io.xerrno;
             fwd->fail(err);
             flags.do_next_read = false;
             serverConnection->close();
         }
 
@@ -1292,18 +1283,18 @@
 
     err_type error = ERR_NONE;
 
     if (flags.headers_parsed) { // parsed headers, possibly with errors
         // check for header parsing errors
         if (HttpReply *vrep = virginReply()) {
-            const http_status s = vrep->sline.status;
-            const HttpVersion &v = vrep->sline.version;
-            if (s == HTTP_INVALID_HEADER && v != HttpVersion(0,9)) {
+            const Http::StatusCode s = vrep->sline.status();
+            const Http::ProtocolVersion &v = vrep->sline.version;
+            if (s == Http::scInvalidHeader && v != Http::ProtocolVersion(0,9)) {
                 debugs(11, DBG_IMPORTANT, "WARNING: HTTP: Invalid Response: Bad header encountered from " << entry->url() << " AKA " << request->GetHost() << request->urlpath.termedBuf() );
                 error = ERR_INVALID_RESP;
-            } else if (s == HTTP_HEADER_TOO_LARGE) {
+            } else if (s == Http::scHeaderTooLarge) {
                 fwd->dontRetry(true);
                 error = ERR_TOO_BIG;
             } else {
                 return true; // done parsing, got reply, and no error
             }
         } else {
@@ -1322,13 +1313,13 @@
                    entry->url() << " AKA " << request->GetHost() << request->urlpath.termedBuf() );
         }
     }
 
     assert(error != ERR_NONE);
     entry->reset();
-    fwd->fail(new ErrorState(error, HTTP_BAD_GATEWAY, fwd->request));
+    fwd->fail(new ErrorState(error, Http::scBadGateway, fwd->request));
     flags.do_next_read = false;
     serverConnection->close();
     return false; // quit on error
 }
 
 /** truncate what we read if we read too much so that writeReplyBody()
@@ -1475,13 +1466,13 @@
             } else if (request->flags.connectionAuth && request->flags.authSent) {
                 ispinned = true;
             }
 
             if (ispinned && request->clientConnectionManager.valid()) {
                 request->clientConnectionManager->pinConnection(serverConnection, request, _peer,
-                        (request->flags.connectionAuth != 0));
+                        (request->flags.connectionAuth));
             } else {
                 fwd->pconnPush(serverConnection, request->GetHost());
             }
 
             serverConnection = NULL;
             serverComplete();
@@ -1546,13 +1537,13 @@
     }
 
     if (io.flag == COMM_ERR_CLOSING)
         return;
 
     if (io.flag) {
-        ErrorState *err = new ErrorState(ERR_WRITE_ERROR, HTTP_BAD_GATEWAY, fwd->request);
+        ErrorState *err = new ErrorState(ERR_WRITE_ERROR, Http::scBadGateway, fwd->request);
         err->xerrno = io.xerrno;
         fwd->fail(err);
         serverConnection->close();
         return;
     }
 
@@ -1731,16 +1722,16 @@
 
     /* Abstraction break: We should interpret multipart/byterange responses
      * into offset-length data, and this works around our inability to do so.
      */
     if (!we_do_ranges && request->multipartRangeRequest()) {
         /* don't cache the result */
-        request->flags.cachable = 0;
+        request->flags.cachable = false;
         /* pretend it's not a range request */
         request->ignoreRange("want to request the whole object");
-        request->flags.isRanged=false;
+        request->flags.isRanged = false;
     }
 
     /* append Via */
     if (Config.onoff.via) {
         String strVia;
         strVia = hdr_in->getList(HDR_VIA);
@@ -1781,27 +1772,27 @@
                 debugs(11, DBG_IMPORTANT, "Warning: likely forwarding loop with " << url);
             }
         }
 
         if (strcmp(opt_forwarded_for, "on") == 0) {
             /** If set to ON - append client IP or 'unknown'. */
-            if ( request->client_addr.IsNoAddr() )
+            if ( request->client_addr.isNoAddr() )
                 strListAdd(&strFwd, "unknown", ',');
             else
-                strListAdd(&strFwd, request->client_addr.NtoA(ntoabuf, MAX_IPSTRLEN), ',');
+                strListAdd(&strFwd, request->client_addr.toStr(ntoabuf, MAX_IPSTRLEN), ',');
         } else if (strcmp(opt_forwarded_for, "off") == 0) {
             /** If set to OFF - append 'unknown'. */
             strListAdd(&strFwd, "unknown", ',');
         } else if (strcmp(opt_forwarded_for, "transparent") == 0) {
             /** If set to TRANSPARENT - pass through unchanged. */
         } else if (strcmp(opt_forwarded_for, "truncate") == 0) {
             /** If set to TRUNCATE - drop existing list and replace with client IP or 'unknown'. */
-            if ( request->client_addr.IsNoAddr() )
+            if ( request->client_addr.isNoAddr() )
                 strFwd = "unknown";
             else
-                strFwd = request->client_addr.NtoA(ntoabuf, MAX_IPSTRLEN);
+                strFwd = request->client_addr.toStr(ntoabuf, MAX_IPSTRLEN);
         }
         if (strFwd.size() > 0)
             hdr_out->putStr(HDR_X_FORWARDED_FOR, strFwd.termedBuf());
     }
     /** If set to DELETE - do not copy through. */
 
@@ -1818,13 +1809,13 @@
                               (int) request->port);
         }
     }
 
     /* append Authorization if known in URL, not in header and going direct */
     if (!hdr_out->has(HDR_AUTHORIZATION)) {
-        if (!request->flags.proxying && request->login && *request->login) {
+        if (!request->flags.proxying && request->login[0] != '\0') {
             httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s",
                               old_base64_encode(request->login));
         }
     }
 
     /* Fixup (Proxy-)Authorization special cases. Plain relaying dealt with above */
@@ -1999,13 +1990,13 @@
             hdr_out->addEntry(e->clone());
         break;
 
     case HDR_MAX_FORWARDS:
         /** \par Max-Forwards:
          * pass only on TRACE or OPTIONS requests */
-        if (request->method == METHOD_TRACE || request->method == METHOD_OPTIONS) {
+        if (request->method == Http::METHOD_TRACE || request->method == Http::METHOD_OPTIONS) {
             const int64_t hops = e->getInt64();
 
             if (hops > 0)
                 hdr_out->putInt64(HDR_MAX_FORWARDS, hops - 1);
         }
 
@@ -2104,16 +2095,22 @@
 /* build request prefix and append it to a given MemBuf;
  * return the length of the prefix */
 mb_size_t
 HttpStateData::buildRequestPrefix(MemBuf * mb)
 {
     const int offset = mb->size;
-    HttpVersion httpver(1,1);
+    /* Uses a local httpver variable to print the HTTP/1.1 label
+     * since the HttpRequest may have an older version label.
+     * XXX: This could create protocol bugs as the headers sent and
+     * flow control should all be based on the HttpRequest version
+     * not the one we are sending. Needs checking.
+     */
+    Http::ProtocolVersion httpver(1,1);
     const char * url;
     if (_peer && !_peer->options.originserver)
-        url = entry->url();
+        url = urlCanonical(request);
     else
         url = request->urlpath.termedBuf();
     mb->Printf("%s %s %s/%d.%d\r\n",
                RequestMethodStr(request->method),
                url && *url ? url : "/",
                AnyP::ProtocolType_str[httpver.protocol],
@@ -2122,15 +2119,15 @@
     {
         HttpHeader hdr(hoRequest);
         Packer p;
         httpBuildRequestHeader(request, entry, fwd->al, &hdr, flags);
 
         if (request->flags.pinned && request->flags.connectionAuth)
-            request->flags.authSent = 1;
+            request->flags.authSent = true;
         else if (hdr.has(HDR_AUTHORIZATION))
-            request->flags.authSent = 1;
+            request->flags.authSent = true;
 
         packerToMemInit(&p, mb);
         hdr.packInto(&p);
         hdr.clean();
         packerClean(&p);
     }
@@ -2372,13 +2369,13 @@
         // XXX: why does not this trigger a debug message on every request?
 
         if (flags.headers_parsed && !flags.abuse_detected) {
             flags.abuse_detected = true;
             debugs(11, DBG_IMPORTANT, "http handleMoreRequestBodyAvailable: Likely proxy abuse detected '" << request->client_addr << "' -> '" << entry->url() << "'" );
 
-            if (virginReply()->sline.status == HTTP_INVALID_HEADER) {
+            if (virginReply()->sline.status() == Http::scInvalidHeader) {
                 serverConnection->close();
                 return;
             }
         }
     }
 
@@ -2393,13 +2390,13 @@
     if (entry->isEmpty()) {
         debugs(11, 3, "request body aborted: " << serverConnection);
         // We usually get here when ICAP REQMOD aborts during body processing.
         // We might also get here if client-side aborts, but then our response
         // should not matter because either client-side will provide its own or
         // there will be no response at all (e.g., if the the client has left).
-        ErrorState *err = new ErrorState(ERR_ICAP_FAILURE, HTTP_INTERNAL_SERVER_ERROR, fwd->request);
+        ErrorState *err = new ErrorState(ERR_ICAP_FAILURE, Http::scInternalServerError, fwd->request);
         err->detailError(ERR_DETAIL_SRV_REQMOD_REQ_BODY);
         fwd->fail(err);
     }
 
     abortTransaction("request body producer aborted");
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpControlMsg.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpControlMsg.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpControlMsg.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpControlMsg.h	2015-05-01 18:05:19.000000000 +0800
@@ -26,20 +26,19 @@
 };
 
 /// bundles HTTP 1xx reply and the "successfully forwarded" callback
 class HttpControlMsg
 {
 public:
-    typedef HttpMsgPointerT<HttpReply> MsgPtr;
     typedef AsyncCall::Pointer Callback;
 
-    HttpControlMsg(const MsgPtr &aReply, const Callback &aCallback):
+    HttpControlMsg(const HttpReply::Pointer &aReply, const Callback &aCallback):
             reply(aReply), cbSuccess(aCallback) {}
 
 public:
-    MsgPtr reply; ///< the 1xx message being forwarded
+    HttpReply::Pointer reply; ///< the 1xx message being forwarded
     Callback cbSuccess; ///< called after successfully writing the 1xx message
 
     // We could add an API to notify of send failures as well, but the
     // current Source and Sink are tied via Store anyway, so the Source
     // will know, eventually, if the Sink is gone or otherwise failed.
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHdrRange.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHdrRange.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHdrRange.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHdrRange.cc	2015-05-01 18:05:19.000000000 +0800
@@ -221,13 +221,13 @@
 }
 
 /*
  * Range
  */
 
-HttpHdrRange::HttpHdrRange () : clen (HttpHdrRangeSpec::UnknownPosition)
+HttpHdrRange::HttpHdrRange() : clen(HttpHdrRangeSpec::UnknownPosition)
 {}
 
 HttpHdrRange *
 HttpHdrRange::ParseCreate(const String * range_spec)
 {
     HttpHdrRange *r = new HttpHdrRange;
@@ -282,13 +282,15 @@
 HttpHdrRange::~HttpHdrRange()
 {
     while (specs.size())
         delete specs.pop_back();
 }
 
-HttpHdrRange::HttpHdrRange(HttpHdrRange const &old) : specs()
+HttpHdrRange::HttpHdrRange(HttpHdrRange const &old) :
+        specs(),
+        clen(HttpHdrRangeSpec::UnknownPosition)
 {
     specs.reserve(old.specs.size());
 
     for (const_iterator i = old.begin(); i != old.end(); ++i)
         specs.push_back(new HttpHdrRangeSpec ( **i));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHdrSc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHdrSc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHdrSc.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHdrSc.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,13 +29,12 @@
  *
  */
 
 #ifndef SQUID_HTTPHDRSURROGATECONTROL_H
 #define SQUID_HTTPHDRSURROGATECONTROL_H
 
-#include "dlink.h"
 #include "HttpHdrScTarget.h"
 
 class StatHist;
 
 /* http surogate control header field */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeader.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeader.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeader.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeader.cc	2015-05-01 18:05:19.000000000 +0800
@@ -84,12 +84,13 @@
     {"Accept-Charset", HDR_ACCEPT_CHARSET, ftStr},
     {"Accept-Encoding", HDR_ACCEPT_ENCODING, ftStr},
     {"Accept-Language", HDR_ACCEPT_LANGUAGE, ftStr},
     {"Accept-Ranges", HDR_ACCEPT_RANGES, ftStr},
     {"Age", HDR_AGE, ftInt},
     {"Allow", HDR_ALLOW, ftStr},
+    {"Alternate-Protocol", HDR_ALTERNATE_PROTOCOL, ftStr},
     {"Authorization", HDR_AUTHORIZATION, ftStr},	/* for now */
     {"Cache-Control", HDR_CACHE_CONTROL, ftPCc},
     {"Connection", HDR_CONNECTION, ftStr},
     {"Content-Base", HDR_CONTENT_BASE, ftStr},
     {"Content-Disposition", HDR_CONTENT_DISPOSITION, ftStr},  /* for now */
     {"Content-Encoding", HDR_CONTENT_ENCODING, ftStr},
@@ -110,12 +111,13 @@
     {"HTTP2-Settings", HDR_HTTP2_SETTINGS, ftStr}, /* for now */
     {"If-Match", HDR_IF_MATCH, ftStr},	/* for now */
     {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123},
     {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
     {"If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag},
     {"Keep-Alive", HDR_KEEP_ALIVE, ftStr},
+    {"Key", HDR_KEY, ftStr},
     {"Last-Modified", HDR_LAST_MODIFIED, ftDate_1123},
     {"Link", HDR_LINK, ftStr},
     {"Location", HDR_LOCATION, ftStr},
     {"Max-Forwards", HDR_MAX_FORWARDS, ftInt64},
     {"Mime-Version", HDR_MIME_VERSION, ftStr},	/* for now */
     {"Negotiate", HDR_NEGOTIATE, ftStr},
@@ -185,12 +187,13 @@
     HDR_CACHE_CONTROL,
     HDR_CONTENT_ENCODING,
     HDR_CONTENT_LANGUAGE,
     HDR_CONNECTION,
     HDR_EXPECT,
     HDR_IF_MATCH, HDR_IF_NONE_MATCH,
+    HDR_KEY,
     HDR_LINK, HDR_PRAGMA,
     HDR_PROXY_CONNECTION,
     HDR_PROXY_SUPPORT,
     HDR_TRANSFER_ENCODING,
     HDR_UPGRADE,
     HDR_VARY,
@@ -229,12 +232,13 @@
 };
 
 static HttpHeaderMask ReplyHeadersMask;		/* set run-time using ReplyHeaders */
 static http_hdr_type ReplyHeadersArr[] = {
     HDR_ACCEPT, HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
     HDR_ACCEPT_RANGES, HDR_AGE,
+    HDR_KEY,
     HDR_LOCATION, HDR_MAX_FORWARDS,
     HDR_MIME_VERSION, HDR_PUBLIC, HDR_RETRY_AFTER, HDR_SERVER, HDR_SET_COOKIE, HDR_SET_COOKIE2,
     HDR_ORIGIN,
     HDR_VARY,
     HDR_WARNING, HDR_PROXY_CONNECTION, HDR_X_CACHE,
     HDR_X_CACHE_LOOKUP,
@@ -260,12 +264,13 @@
     HDR_PROXY_AUTHORIZATION, HDR_RANGE, HDR_REFERER, HDR_REQUEST_RANGE,
     HDR_USER_AGENT, HDR_X_FORWARDED_FOR, HDR_SURROGATE_CAPABILITY
 };
 
 static HttpHeaderMask HopByHopHeadersMask;
 static http_hdr_type HopByHopHeadersArr[] = {
+    HDR_ALTERNATE_PROTOCOL,
     HDR_CONNECTION, HDR_HTTP2_SETTINGS, HDR_KEEP_ALIVE, /*HDR_PROXY_AUTHENTICATE,*/ HDR_PROXY_AUTHORIZATION,
     HDR_TE, HDR_TRAILER, HDR_TRANSFER_ENCODING, HDR_UPGRADE, HDR_PROXY_CONNECTION
 };
 
 /* header accounting */
 static HttpHeaderStat HttpHeaderStats[] = {
@@ -543,13 +548,13 @@
 
 int
 HttpHeader::parse(const char *header_start, const char *header_end)
 {
     const char *field_ptr = header_start;
     HttpHeaderEntry *e, *e2;
-    bool warnOnError = (Config.onoff.relaxed_header_parser <= 0 ? DBG_IMPORTANT : 2);
+    int warnOnError = (Config.onoff.relaxed_header_parser <= 0 ? DBG_IMPORTANT : 2);
 
     PROF_start(HttpHeaderParse);
 
     assert(header_start && header_end);
     debugs(55, 7, "parsing hdr: (" << this << ")" << std::endl << getStringPrefix(header_start, header_end));
     ++ HttpHeaderStats[owner].parsedCount;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeader.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeader.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeader.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeader.h	2015-05-01 18:05:19.000000000 +0800
@@ -54,12 +54,13 @@
     HDR_ACCEPT_ENCODING,                /**< RFC 2608, 2616 */
     /*HDR_ACCEPT_FEATURES,*/            /* experimental RFC 2295 */
     HDR_ACCEPT_LANGUAGE,                /**< RFC 2608, 2616 */
     HDR_ACCEPT_RANGES,                  /**< RFC 2608, 2616 */
     HDR_AGE,                            /**< RFC 2608, 2616 */
     HDR_ALLOW,                          /**< RFC 2608, 2616 */
+    HDR_ALTERNATE_PROTOCOL,             /**< GFE custom header we may have to erase */
     /*HDR_ALTERNATES,*/                 /* deprecated RFC 2068, 2295 */
     HDR_AUTHORIZATION,                  /**< RFC 2608, 2616, 4559 */
     HDR_CACHE_CONTROL,                  /**< RFC 2608, 2616 */
     HDR_CONNECTION,                     /**< RFC 2608, 2616 */
     HDR_CONTENT_BASE,                   /**< RFC 2608 */
     HDR_CONTENT_DISPOSITION,            /**< RFC 2183, 2616 */
@@ -88,12 +89,13 @@
     HDR_IF_MATCH,                       /**< RFC 2608, 2616 */
     HDR_IF_MODIFIED_SINCE,              /**< RFC 2608, 2616 */
     HDR_IF_NONE_MATCH,                  /**< RFC 2608, 2616 */
     HDR_IF_RANGE,                       /**< RFC 2608, 2616 */
     /*HDR_IF_UNMODIFIED_SINCE,*/        /**< RFC 2608, 2616 */
     HDR_KEEP_ALIVE,                     /**< obsolete HTTP/1.0 header we may need to erase */
+    HDR_KEY,                            /**< experimental RFC Draft draft-fielding-http-key-02 */
     HDR_LAST_MODIFIED,                  /**< RFC 2608, 2616 */
     HDR_LINK,                           /**< RFC 2068 */
     HDR_LOCATION,                       /**< RFC 2608, 2616 */
     /*HDR_LOCK_TOKEN,*/                 /* RFC 2518 */
     HDR_MAX_FORWARDS,                   /**< RFC 2608, 2616 */
     HDR_MIME_VERSION,                   /**< RFC 2626 */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeaderRange.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeaderRange.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeaderRange.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeaderRange.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,13 +29,13 @@
  *
  */
 
 #ifndef SQUID_HTTPHEADERRANGE_H
 #define SQUID_HTTPHEADERRANGE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "MemPool.h"
 #include "Packer.h"
 #include "Range.h"
 #include "SquidString.h"
 
 class HttpReply;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeaderTools.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeaderTools.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeaderTools.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeaderTools.cc	2015-05-01 18:05:19.000000000 +0800
@@ -28,18 +28,20 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #include "squid.h"
+#include "globals.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "client_side_request.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "compat/strtoll.h"
+#include "ConfigParser.h"
 #include "fde.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderTools.h"
 #include "HttpRequest.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeaderTools.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeaderTools.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpHeaderTools.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpHeaderTools.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,9 +1,10 @@
 #ifndef SQUID_HTTPHEADERTOOLS_H
 #define SQUID_HTTPHEADERTOOLS_H
 
+#include "acl/forward.h"
 #include "format/Format.h"
 #include "HttpHeader.h"
 #include "typedefs.h"
 
 #if HAVE_FUNCTIONAL
 #include <functional>
@@ -18,14 +19,12 @@
 #include <string>
 #endif
 #if HAVE_STRINGS_H
 #include <strings.h>
 #endif
 
-class acl_access;
-class ACLList;
 class HeaderWithAcl;
 class HttpHeader;
 class HttpHeaderFieldInfo;
 class HttpRequest;
 class StoreEntry;
 class String;
@@ -90,13 +89,13 @@
     HeaderManglers &operator =(const HeaderManglers &);
 };
 
 class HeaderWithAcl
 {
 public:
-    HeaderWithAcl() :  aclList(NULL), fieldId (HDR_BAD_HDR), quoted(false) {}
+    HeaderWithAcl() : aclList(NULL), valueFormat(NULL), fieldId(HDR_BAD_HDR), quoted(false) {}
 
     /// HTTP header field name
     std::string fieldName;
 
     /// HTTP header field value, possibly with macros
     std::string fieldValue;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpMsg.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpMsg.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpMsg.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpMsg.cc	2015-05-01 18:05:19.000000000 +0800
@@ -39,18 +39,17 @@
 #include "mime_header.h"
 #include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
 HttpMsg::HttpMsg(http_hdr_owner_type owner): header(owner),
         cache_control(NULL), hdr_sz(0), content_length(0), protocol(AnyP::PROTO_NONE),
-        pstate(psReadyToParseStartLine), lock_count(0)
+        pstate(psReadyToParseStartLine)
 {}
 
 HttpMsg::~HttpMsg()
 {
-    assert(lock_count == 0);
     assert(!body_pipe);
 }
 
 HttpMsgParseState &operator++ (HttpMsgParseState &aState)
 {
     int tmp = (int)aState;
@@ -138,63 +137,64 @@
 
     *parse_start = *blk_end;
 
     return 1;
 }
 
-// negative return is the negated HTTP_ error code
+// negative return is the negated Http::StatusCode error code
 // zero return means need more data
 // positive return is the size of parsed headers
-bool HttpMsg::parse(MemBuf *buf, bool eof, http_status *error)
+bool
+HttpMsg::parse(MemBuf *buf, bool eof, Http::StatusCode *error)
 {
     assert(error);
-    *error = HTTP_STATUS_NONE;
+    *error = Http::scNone;
 
     // httpMsgParseStep() and debugging require 0-termination, unfortunately
     buf->terminate(); // does not affect content size
 
     // find the end of headers
     const size_t hdr_len = headersEnd(buf->content(), buf->contentSize());
 
     // sanity check the start line to see if this is in fact an HTTP message
     if (!sanityCheckStartLine(buf, hdr_len, error)) {
         // NP: sanityCheck sets *error and sends debug warnings on syntax errors.
         // if we have seen the connection close, this is an error too
-        if (eof && *error==HTTP_STATUS_NONE)
-            *error = HTTP_INVALID_HEADER;
+        if (eof && *error == Http::scNone)
+            *error = Http::scInvalidHeader;
 
         return false;
     }
 
     // TODO: move to httpReplyParseStep()
     if (hdr_len > Config.maxReplyHeaderSize || (hdr_len <= 0 && (size_t)buf->contentSize() > Config.maxReplyHeaderSize)) {
         debugs(58, DBG_IMPORTANT, "HttpMsg::parse: Too large reply header (" << hdr_len << " > " << Config.maxReplyHeaderSize);
-        *error = HTTP_HEADER_TOO_LARGE;
+        *error = Http::scHeaderTooLarge;
         return false;
     }
 
     if (hdr_len <= 0) {
         debugs(58, 3, "HttpMsg::parse: failed to find end of headers (eof: " << eof << ") in '" << buf->content() << "'");
 
         if (eof) // iff we have seen the end, this is an error
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
 
         return false;
     }
 
     const int res = httpMsgParseStep(buf->content(), buf->contentSize(), eof);
 
     if (res < 0) { // error
         debugs(58, 3, "HttpMsg::parse: cannot parse isolated headers in '" << buf->content() << "'");
-        *error = HTTP_INVALID_HEADER;
+        *error = Http::scInvalidHeader;
         return false;
     }
 
     if (res == 0) {
         debugs(58, 2, "HttpMsg::parse: strange, need more data near '" << buf->content() << "'");
-        *error = HTTP_INVALID_HEADER;
+        *error = Http::scInvalidHeader;
         return false; // but this should not happen due to headersEnd() above
     }
 
     assert(res > 0);
     debugs(58, 9, "HttpMsg::parse success (" << hdr_len << " bytes) near '" << buf->content() << "'");
 
@@ -319,13 +319,13 @@
     content_length = clen;
 }
 
 bool
 HttpMsg::persistent() const
 {
-    if (http_ver > HttpVersion(1, 0)) {
+    if (http_ver > Http::ProtocolVersion(1, 0)) {
         /*
          * for modern versions of HTTP: persistent unless there is
          * a "Connection: close" header.
          */
         return !httpHeaderHasConnDir(&header, "close");
     } else {
@@ -355,25 +355,6 @@
 {
     Packer p;
     packerToMemInit(&p, &mb);
     packFirstLineInto(&p, true);
     packerClean(&p);
 }
-
-// use HTTPMSGLOCK() instead of calling this directly
-HttpMsg *
-HttpMsg::_lock()
-{
-    ++lock_count;
-    return this;
-}
-
-// use HTTPMSGUNLOCK() instead of calling this directly
-void
-HttpMsg::_unlock()
-{
-    assert(lock_count > 0);
-    --lock_count;
-
-    if (0 == lock_count)
-        delete this;
-}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpMsg.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpMsg.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpMsg.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpMsg.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,40 +28,33 @@
  *
  */
 
 #ifndef SQUID_HTTPMSG_H
 #define SQUID_HTTPMSG_H
 
-#include "typedefs.h"
+#include "base/Lock.h"
+#include "BodyPipe.h"
 #include "HttpHeader.h"
 #include "HttpRequestMethod.h"
-#include "HttpStatusCode.h"
-#include "HttpVersion.h"
-#include "BodyPipe.h"
-
-// common parts of HttpRequest and HttpReply
+#include "http/StatusCode.h"
+#include "http/ProtocolVersion.h"
 
-template <class Msg>
-class HttpMsgPointerT;
-
-class HttpMsg
+/// common parts of HttpRequest and HttpReply
+class HttpMsg : public RefCountable
 {
 
 public:
-    typedef HttpMsgPointerT<HttpMsg> Pointer;
+    typedef RefCount<HttpMsg> Pointer;
 
     HttpMsg(http_hdr_owner_type owner);
     virtual ~HttpMsg();
 
     virtual void reset() = 0; // will have body when http*Clean()s are gone
 
     void packInto(Packer * p, bool full_uri) const;
 
-    virtual HttpMsg *_lock();	// please use HTTPMSGLOCK()
-    virtual void _unlock();	// please use HTTPMSGUNLOCK()
-
     ///< produce a message copy, except for a few connection-specific settings
     virtual HttpMsg *clone() const = 0; ///< \todo rename: not a true copy?
 
     /// [re]sets Content-Length header and cached value
     void setContentLength(int64_t clen);
 
@@ -71,13 +64,13 @@
      *
      * Factors other than the headers may result in connection closure.
      */
     bool persistent() const;
 
 public:
-    HttpVersion http_ver;
+    Http::ProtocolVersion http_ver;
 
     HttpHeader header;
 
     HttpHdrCc *cache_control;
 
     /* Unsupported, writable, may disappear/change in the future
@@ -92,14 +85,14 @@
     HttpMsgParseState pstate;   /* the current parsing state */
 
     BodyPipe::Pointer body_pipe; // optional pipeline to receive message body
 
     // returns true and sets hdr_sz on success
     // returns false and sets *error to zero when needs more data
-    // returns false and sets *error to a positive http_status code on error
-    bool parse(MemBuf *buf, bool eol, http_status *error);
+    // returns false and sets *error to a positive Http::StatusCode on error
+    bool parse(MemBuf *buf, bool eol, Http::StatusCode *error);
 
     bool parseCharBuf(const char *buf, ssize_t end);
 
     int httpMsgParseStep(const char *buf, int len, int atEnd);
 
     virtual int httpMsgParseError();
@@ -115,75 +108,21 @@
      * Validate the message start line is syntactically correct.
      * Set HTTP error status according to problems found.
      *
      * \retval true   Status line has no serious problems.
      * \retval false  Status line has a serious problem. Correct response is indicated by error.
      */
-    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error) = 0;
+    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error) = 0;
 
     virtual void packFirstLineInto(Packer * p, bool full_uri) const = 0;
 
     virtual bool parseFirstLine(const char *blk_start, const char *blk_end) = 0;
 
     virtual void hdrCacheInit();
-
-    int lock_count;
-
 };
 
 int httpMsgIsolateHeaders(const char **parse_start, int len, const char **blk_start, const char **blk_end);
 
-#define HTTPMSGUNLOCK(a) if(a){(a)->_unlock();(a)=NULL;}
-#define HTTPMSGLOCK(a) (a)->_lock()
-
-// TODO: replace HTTPMSGLOCK with general RefCounting and delete this class
-/// safe HttpMsg pointer wrapper that locks and unlocks the message
-template <class Msg>
-class HttpMsgPointerT
-{
-public:
-    HttpMsgPointerT(): msg(NULL) {}
-    explicit HttpMsgPointerT(Msg *m): msg(m) { lock(); }
-    virtual ~HttpMsgPointerT() { unlock(); }
-
-    HttpMsgPointerT(const HttpMsgPointerT &p): msg(p.msg) { lock(); }
-    HttpMsgPointerT &operator =(const HttpMsgPointerT &p)
-    { if (msg != p.msg) { unlock(); msg = p.msg; lock(); } return *this; }
-    HttpMsgPointerT &operator =(Msg *newM)
-    { if (msg != newM) { unlock(); msg = newM; lock(); } return *this; }
-
-    /// support converting a child msg pointer into a parent msg pointer
-    template <typename Other>
-    HttpMsgPointerT(const HttpMsgPointerT<Other> &o): msg(o.raw()) { lock(); }
-
-    /// support assigning a child msg pointer to a parent msg pointer
-    template <typename Other>
-    HttpMsgPointerT &operator =(const HttpMsgPointerT<Other> &o)
-    { if (msg != o.raw()) { unlock(); msg = o.raw(); lock(); } return *this; }
-
-    Msg &operator *() { return *msg; }
-    const Msg &operator *() const { return *msg; }
-    Msg *operator ->() { return msg; }
-    const Msg *operator ->() const { return msg; }
-    operator Msg *() const { return msg; }
-    // add more as needed
-
-    /// public access for HttpMsgPointerT copying and assignment; avoid
-    Msg *raw() const { return msg; }
-
-protected:
-    void lock() { if (msg) HTTPMSGLOCK(msg); } ///< prevent msg destruction
-    void unlock() { HTTPMSGUNLOCK(msg); } ///< allows/causes msg destruction
-
-private:
-    Msg *msg;
-};
-
-/// convenience wrapper to create HttpMsgPointerT<> object based on msg type
-template <class Msg>
-inline
-HttpMsgPointerT<Msg> HttpMsgPointer(Msg *msg)
-{
-    return HttpMsgPointerT<Msg>(msg);
-}
+#define HTTPMSGUNLOCK(a) if (a) { if ((a)->unlock() == 0) delete (a); (a)=NULL; }
+#define HTTPMSGLOCK(a) (a)->lock()
 
 #endif /* SQUID_HTTPMSG_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpParser.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpParser.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpParser.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpParser.cc	2015-05-01 18:05:19.000000000 +0800
@@ -5,13 +5,13 @@
 #include "SquidConfig.h"
 
 void
 HttpParser::clear()
 {
     state = HTTP_PARSE_NONE;
-    request_parse_status = HTTP_STATUS_NONE;
+    request_parse_status = Http::scNone;
     buf = NULL;
     bufsiz = 0;
     req.start = req.end = -1;
     hdr_start = hdr_end = -1;
     req.m_start = req.m_end = -1;
     req.u_start = req.u_end = -1;
@@ -93,13 +93,13 @@
                     break;
                 }
             }
 
             // RFC 2616 section 5.1
             // "No CR or LF is allowed except in the final CRLF sequence"
-            request_parse_status = HTTP_BAD_REQUEST;
+            request_parse_status = Http::scBadRequest;
             return -1;
         }
     }
     if (req.end == -1) {
         debugs(74, 5, "Parser: retval 0: from " << req.start <<
                "->" << req.end << ": needs more data to complete first line.");
@@ -113,57 +113,57 @@
 
     // Process what we now know about the line structure into field offsets
     // generating HTTP status for any aborts as we go.
 
     // First non-whitespace = beginning of method
     if (req.start > line_end) {
-        request_parse_status = HTTP_BAD_REQUEST;
+        request_parse_status = Http::scBadRequest;
         return -1;
     }
     req.m_start = req.start;
 
     // First whitespace = end of method
     if (first_whitespace > line_end || first_whitespace < req.start) {
-        request_parse_status = HTTP_BAD_REQUEST; // no method
+        request_parse_status = Http::scBadRequest; // no method
         return -1;
     }
     req.m_end = first_whitespace - 1;
     if (req.m_end < req.m_start) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing URI?
+        request_parse_status = Http::scBadRequest; // missing URI?
         return -1;
     }
 
     // First non-whitespace after first SP = beginning of URL+Version
     if (second_word > line_end || second_word < req.start) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing URI
+        request_parse_status = Http::scBadRequest; // missing URI
         return -1;
     }
     req.u_start = second_word;
 
     // RFC 1945: SP and version following URI are optional, marking version 0.9
     // we identify this by the last whitespace being earlier than URI start
     if (last_whitespace < second_word && last_whitespace >= req.start) {
         req.v_maj = 0;
         req.v_min = 9;
         req.u_end = line_end;
-        request_parse_status = HTTP_OK; // HTTP/0.9
+        request_parse_status = Http::scOkay; // HTTP/0.9
         return 1;
     } else {
         // otherwise last whitespace is somewhere after end of URI.
         req.u_end = last_whitespace;
         // crop any trailing whitespace in the area we think of as URI
         for (; req.u_end >= req.u_start && xisspace(buf[req.u_end]); --req.u_end);
     }
     if (req.u_end < req.u_start) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing URI
+        request_parse_status = Http::scBadRequest; // missing URI
         return -1;
     }
 
     // Last whitespace SP = before start of protocol/version
     if (last_whitespace >= line_end) {
-        request_parse_status = HTTP_BAD_REQUEST; // missing version
+        request_parse_status = Http::scBadRequest; // missing version
         return -1;
     }
     req.v_start = last_whitespace + 1;
     req.v_end = line_end;
 
     // We only accept HTTP protocol requests right now.
@@ -172,70 +172,71 @@
 #if USE_HTTP_VIOLATIONS
         // being lax; old parser accepted strange versions
         // there is a LOT of cases which are ambiguous, therefore we cannot use relaxed_header_parser here.
         req.v_maj = 0;
         req.v_min = 9;
         req.u_end = line_end;
-        request_parse_status = HTTP_OK; // treat as HTTP/0.9
+        request_parse_status = Http::scOkay; // treat as HTTP/0.9
         return 1;
 #else
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED; // protocol not supported / implemented.
+        // protocol not supported / implemented.
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
 #endif
     }
 
     int i = req.v_start + sizeof("HTTP/") -1;
 
     /* next should be 1 or more digits */
     if (!isdigit(buf[i])) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     int maj = 0;
     for (; i <= line_end && (isdigit(buf[i])) && maj < 65536; ++i) {
         maj = maj * 10;
         maj = maj + (buf[i]) - '0';
     }
     // catch too-big values or missing remainders
     if (maj >= 65536 || i > line_end) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     req.v_maj = maj;
 
     /* next should be .; we -have- to have this as we have a whole line.. */
     if (buf[i] != '.') {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     // catch missing minor part
     if (++i > line_end) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     /* next should be one or more digits */
     if (!isdigit(buf[i])) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     int min = 0;
     for (; i <= line_end && (isdigit(buf[i])) && min < 65536; ++i) {
         min = min * 10;
         min = min + (buf[i]) - '0';
     }
     // catch too-big values or trailing garbage
     if (min >= 65536 || i < line_end) {
-        request_parse_status = HTTP_HTTP_VERSION_NOT_SUPPORTED;
+        request_parse_status = Http::scHttpVersionNotSupported;
         return -1;
     }
     req.v_min = min;
 
     /*
      * Rightio - we have all the schtuff. Return true; we've got enough.
      */
-    request_parse_status = HTTP_OK;
+    request_parse_status = Http::scOkay;
     return 1;
 }
 
 int
 HttpParserParseReqLine(HttpParser *hmsg)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpParser.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpParser.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpParser.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpParser.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,10 +1,10 @@
 #ifndef _SQUID_SRC_HTTPPARSER_H
 #define _SQUID_SRC_HTTPPARSER_H
 
-#include "HttpStatusCode.h"
+#include "http/StatusCode.h"
 
 // Parser states
 #define HTTP_PARSE_NONE   0 // nothing. completely unset state.
 #define HTTP_PARSE_NEW    1 // initialized, but nothing usefully parsed yet.
 
 /** HTTP protocol parser.
@@ -69,15 +69,15 @@
     // Offsets for pieces of the MiME Header segment
     int hdr_start, hdr_end;
 
     // TODO: Offsets for pieces of the (HTTP reply) Status-Line as per RFC 2616
 
     /** HTTP status code to be used on the invalid-request error page
-     * HTTP_STATUS_NONE indicates incomplete parse, HTTP_OK indicates no error.
+     * Http::scNone indicates incomplete parse, Http::scOkay indicates no error.
      */
-    http_status request_parse_status;
+    Http::StatusCode request_parse_status;
 };
 
 // Legacy functions
 #define HttpParserInit(h,b,l) (h)->reset((b),(l))
 int HttpParserParseReqLine(HttpParser *hp);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpReply.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpReply.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpReply.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpReply.cc	2015-05-01 18:05:19.000000000 +0800
@@ -73,13 +73,13 @@
 };
 
 /* module initialization */
 void
 httpReplyInitModule(void)
 {
-    assert(HTTP_STATUS_NONE == 0); // HttpReply::parse() interface assumes that
+    assert(Http::scNone == 0); // HttpReply::parse() interface assumes that
     httpHeaderMaskInit(&Denied304HeadersMask, 0);
     httpHeaderCalcMask(&Denied304HeadersMask, Denied304HeadersArr, countof(Denied304HeadersArr));
 }
 
 HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
         expires (0), surrogate_control (NULL), content_range (NULL), keep_alive (0),
@@ -95,13 +95,13 @@
 }
 
 void
 HttpReply::init()
 {
     hdrCacheInit();
-    httpStatusLineInit(&sline);
+    sline.init();
     pstate = psReadyToParseStartLine;
     do_clean = true;
 }
 
 void HttpReply::reset()
 {
@@ -123,20 +123,20 @@
     // points to a pipe that is owned and initiated by another object.
     body_pipe = NULL;
 
     body.clear();
     hdrCacheClean();
     header.clean();
-    httpStatusLineClean(&sline);
+    sline.clean();
     bodySizeMax = -2; // hack: make calculatedBodySizeMax() false
 }
 
 void
 HttpReply::packHeadersInto(Packer * p) const
 {
-    httpStatusLinePackInto(&sline, p);
+    sline.packInto(p);
     header.packInto(p);
     packerAppend(p, "\r\n", 2);
 }
 
 void
 HttpReply::packInto(Packer * p)
@@ -156,24 +156,12 @@
     packerToMemInit(&p, mb);
     packInto(&p);
     packerClean(&p);
     return mb;
 }
 
-#if DEAD_CODE
-MemBuf *
-httpPackedReply(http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires)
-{
-    HttpReply *rep = new HttpReply;
-    rep->setHeaders(status, ctype, NULL, clen, lmt, expires);
-    MemBuf *mb = rep->pack();
-    delete rep;
-    return mb;
-}
-#endif
-
 HttpReply *
 HttpReply::make304() const
 {
     static const http_hdr_type ImsEntries[] = {HDR_DATE, HDR_CONTENT_TYPE, HDR_EXPIRES, HDR_LAST_MODIFIED, /* eof */ HDR_OTHER};
 
     HttpReply *rv = new HttpReply;
@@ -185,14 +173,13 @@
     rv->last_modified = last_modified;
     rv->expires = expires;
     rv->content_type = content_type;
     /* rv->cache_control */
     /* rv->content_range */
     /* rv->keep_alive */
-    HttpVersion ver(1,1);
-    httpStatusLineSet(&rv->sline, ver, HTTP_NOT_MODIFIED, NULL);
+    rv->sline.set(Http::ProtocolVersion(1,1), Http::scNotModified, NULL);
 
     for (t = 0; ImsEntries[t] != HDR_OTHER; ++t)
         if ((e = header.findEntry(ImsEntries[t])))
             rv->header.addEntry(e->clone());
 
     /* rv->body */
@@ -209,18 +196,17 @@
     MemBuf *rv = temp->pack();
     delete temp;
     return rv;
 }
 
 void
-HttpReply::setHeaders(http_status status, const char *reason,
+HttpReply::setHeaders(Http::StatusCode status, const char *reason,
                       const char *ctype, int64_t clen, time_t lmt, time_t expiresTime)
 {
     HttpHeader *hdr;
-    HttpVersion ver(1,1);
-    httpStatusLineSet(&sline, ver, status, reason);
+    sline.set(Http::ProtocolVersion(1,1), status, reason);
     hdr = &header;
     hdr->putStr(HDR_SERVER, visible_appname_string);
     hdr->putStr(HDR_MIME_VERSION, "1.0");
     hdr->putTime(HDR_DATE, squid_curtime);
 
     if (ctype) {
@@ -245,17 +231,16 @@
     expires = expiresTime;
 
     last_modified = lmt;
 }
 
 void
-HttpReply::redirect(http_status status, const char *loc)
+HttpReply::redirect(Http::StatusCode status, const char *loc)
 {
     HttpHeader *hdr;
-    HttpVersion ver(1,1);
-    httpStatusLineSet(&sline, ver, status, httpStatusString(status));
+    sline.set(Http::ProtocolVersion(1,1), status, NULL);
     hdr = &header;
     hdr->putStr(HDR_SERVER, APP_FULLNAME);
     hdr->putTime(HDR_DATE, squid_curtime);
     hdr->putInt64(HDR_CONTENT_LENGTH, 0);
     hdr->putStr(HDR_LOCATION, loc);
     date = squid_curtime;
@@ -425,43 +410,43 @@
  */
 int64_t
 HttpReply::bodySize(const HttpRequestMethod& method) const
 {
     if (sline.version.major < 1)
         return -1;
-    else if (method.id() == METHOD_HEAD)
+    else if (method.id() == Http::METHOD_HEAD)
         return 0;
-    else if (sline.status == HTTP_OK)
+    else if (sline.status() == Http::scOkay)
         (void) 0;		/* common case, continue */
-    else if (sline.status == HTTP_NO_CONTENT)
+    else if (sline.status() == Http::scNoContent)
         return 0;
-    else if (sline.status == HTTP_NOT_MODIFIED)
+    else if (sline.status() == Http::scNotModified)
         return 0;
-    else if (sline.status < HTTP_OK)
+    else if (sline.status() < Http::scOkay)
         return 0;
 
     return content_length;
 }
 
 /**
  * Checks the first line of an HTTP Reply is valid.
  * currently only checks "HTTP/" exists.
  *
  * NP: not all error cases are detected yet. Some are left for detection later in parse.
  */
 bool
-HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error)
+HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error)
 {
     // hack warning: using psize instead of size here due to type mismatches with MemBuf.
 
     // content is long enough to possibly hold a reply
     // 4 being magic size of a 3-digit number plus space delimiter
     if ( buf->contentSize() < (protoPrefix.psize() + 4) ) {
         if (hdr_len > 0) {
             debugs(58, 3, HERE << "Too small reply header (" << hdr_len << " bytes)");
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
         }
         return false;
     }
 
     int pos;
     // catch missing or mismatched protocol identifier
@@ -470,78 +455,74 @@
         protoPrefix = "ICY";
         pos = protoPrefix.psize();
     } else {
 
         if (protoPrefix.cmp(buf->content(), protoPrefix.size()) != 0) {
             debugs(58, 3, "HttpReply::sanityCheckStartLine: missing protocol prefix (" << protoPrefix << ") in '" << buf->content() << "'");
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
             return false;
         }
 
         // catch missing or negative status value (negative '-' is not a digit)
         pos = protoPrefix.psize();
 
         // skip arbitrary number of digits and a dot in the verion portion
         while ( pos <= buf->contentSize() && (*(buf->content()+pos) == '.' || xisdigit(*(buf->content()+pos)) ) ) ++pos;
 
         // catch missing version info
         if (pos == protoPrefix.psize()) {
             debugs(58, 3, "HttpReply::sanityCheckStartLine: missing protocol version numbers (ie. " << protoPrefix << "/1.0) in '" << buf->content() << "'");
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
             return false;
         }
     }
 
     // skip arbitrary number of spaces...
     while (pos <= buf->contentSize() && (char)*(buf->content()+pos) == ' ') ++pos;
 
     if (pos < buf->contentSize() && !xisdigit(*(buf->content()+pos))) {
         debugs(58, 3, "HttpReply::sanityCheckStartLine: missing or invalid status number in '" << buf->content() << "'");
-        *error = HTTP_INVALID_HEADER;
+        *error = Http::scInvalidHeader;
         return false;
     }
 
     return true;
 }
 
-void HttpReply::packFirstLineInto(Packer *p, bool unused) const
-{
-    httpStatusLinePackInto(&sline, p);
-}
-
-bool HttpReply::parseFirstLine(const char *blk_start, const char *blk_end)
+bool
+HttpReply::parseFirstLine(const char *blk_start, const char *blk_end)
 {
-    return httpStatusLineParse(&sline, protoPrefix, blk_start, blk_end);
+    return sline.parse(protoPrefix, blk_start, blk_end);
 }
 
 /* handy: resets and returns -1 */
 int
 HttpReply::httpMsgParseError()
 {
     int result(HttpMsg::httpMsgParseError());
     /* indicate an error in the status line */
-    sline.status = HTTP_INVALID_HEADER;
+    sline.set(Http::ProtocolVersion(1,1), Http::scInvalidHeader);
     return result;
 }
 
 /*
  * Indicate whether or not we would usually expect an entity-body
  * along with this response
  */
 bool
 HttpReply::expectingBody(const HttpRequestMethod& req_method, int64_t& theSize) const
 {
     bool expectBody = true;
 
-    if (req_method == METHOD_HEAD)
+    if (req_method == Http::METHOD_HEAD)
         expectBody = false;
-    else if (sline.status == HTTP_NO_CONTENT)
+    else if (sline.status() == Http::scNoContent)
         expectBody = false;
-    else if (sline.status == HTTP_NOT_MODIFIED)
+    else if (sline.status() == Http::scNotModified)
         expectBody = false;
-    else if (sline.status < HTTP_OK)
+    else if (sline.status() < Http::scOkay)
         expectBody = false;
     else
         expectBody = true;
 
     if (expectBody) {
         if (header.chunked())
@@ -582,25 +563,27 @@
         return false;
 
     return expectedSize > bodySizeMax;
 }
 
 void
-HttpReply::calcMaxBodySize(HttpRequest& request)
+HttpReply::calcMaxBodySize(HttpRequest& request) const
 {
     // hack: -2 is used as "we have not calculated max body size yet" state
     if (bodySizeMax != -2) // already tried
         return;
     bodySizeMax = -1;
 
     // short-circuit ACL testing if there are none configured
     if (!Config.ReplyBodySize)
         return;
 
     ACLFilledChecklist ch(NULL, &request, NULL);
-    ch.reply = HTTPMSGLOCK(this); // XXX: this lock makes method non-const
+    // XXX: cont-cast becomes irrelevant when checklist is HttpReply::Pointer
+    ch.reply = const_cast<HttpReply *>(this);
+    HTTPMSGLOCK(ch.reply);
     for (AclSizeLimit *l = Config.ReplyBodySize; l; l = l -> next) {
         /* if there is no ACL list or if the ACLs listed match use this size value */
         if (!l->aclList || ch.fastCheck(l->aclList) == ACCESS_ALLOWED) {
             debugs(58, 4, HERE << "bodySizeMax=" << bodySizeMax);
             bodySizeMax = l->size; // may be -1
             break;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpReply.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpReply.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpReply.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpReply.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,52 +30,40 @@
 #ifndef SQUID_HTTPREPLY_H
 #define SQUID_HTTPREPLY_H
 
 #include "HttpBody.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
-#include "HttpStatusLine.h"
+#include "http/StatusLine.h"
 
 void httpReplyInitModule(void);
 
-#if DEAD_CODE
-/** do everything in one call: init, set, pack, clean, return MemBuf */
-MemBuf *httpPackedReply(HttpVersion ver, http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires);
-#endif
-
 /* Sync changes here with HttpReply.cc */
 
 class HttpHdrContRange;
 
 class HttpHdrSc;
 
 class HttpReply: public HttpMsg
 {
 
 public:
-    typedef HttpMsgPointerT<HttpReply> Pointer;
+    typedef RefCount<HttpReply> Pointer;
 
     MEMPROXY_CLASS(HttpReply);
     HttpReply();
     ~HttpReply();
 
     virtual void reset();
 
-    /// \par use HTTPMSGLOCK() instead of calling this directly
-    virtual HttpReply *_lock() {
-        return static_cast<HttpReply*>(HttpMsg::_lock());
-    };
-
-    //virtual void unlock();  // only needed for debugging
-
     /**
      \retval true on success
      \retval false and sets *error to zero when needs more data
-     \retval false and sets *error to a positive http_status code on error
+     \retval false and sets *error to a positive Http::StatusCode on error
      */
-    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error);
+    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error);
 
     /** \par public, readable; never update these or their .hdr equivalents directly */
     time_t date;
 
     time_t last_modified;
 
@@ -87,13 +75,13 @@
 
     HttpHdrContRange *content_range;
 
     short int keep_alive;
 
     /** \par public, writable, but use httpReply* interfaces when possible */
-    HttpStatusLine sline;
+    Http::StatusLine sline;
 
     HttpBody body;		/**< for small constant memory-resident text bodies only */
 
     String protoPrefix;         /**< e.g., "HTTP/"  */
 
     bool do_clean;
@@ -105,22 +93,22 @@
 
     virtual bool inheritProperties(const HttpMsg *aMsg);
 
     void updateOnNotModified(HttpReply const *other);
 
     /** set commonly used info with one call */
-    void setHeaders(http_status status,
+    void setHeaders(Http::StatusCode status,
                     const char *reason, const char *ctype, int64_t clen, time_t lmt, time_t expires);
 
     /** \return a ready to use mem buffer with a packed reply */
     MemBuf *pack();
 
     /** construct a 304 reply and return it */
     HttpReply *make304() const;
 
-    void redirect(http_status, const char *);
+    void redirect(Http::StatusCode, const char *);
 
     int64_t bodySize(const HttpRequestMethod&) const;
 
     /** Checks whether received body exceeds known maximum size.
      * Requires a prior call to calcMaxBodySize().
      */
@@ -160,20 +148,20 @@
     /* header manipulation */
     time_t hdrExpirationTime();
 
     /** Calculates and stores maximum body size if needed.
      * Used by receivedBodyTooLarge() and expectedBodyTooLarge().
      */
-    void calcMaxBodySize(HttpRequest& request);
+    void calcMaxBodySize(HttpRequest& request) const;
 
     String removeStaleWarningValues(const String &value);
 
     mutable int64_t bodySizeMax; /**< cached result of calcMaxBodySize */
 
 protected:
-    virtual void packFirstLineInto(Packer * p, bool) const;
+    virtual void packFirstLineInto(Packer * p, bool) const { sline.packInto(p); }
 
     virtual bool parseFirstLine(const char *start, const char *end);
 
     virtual void hdrCacheInit();
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpRequest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpRequest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpRequest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpRequest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -54,18 +54,20 @@
 #include "auth/UserRequest.h"
 #endif
 #if ICAP_CLIENT
 #include "adaptation/icap/icap_log.h"
 #endif
 
-HttpRequest::HttpRequest() : HttpMsg(hoRequest)
+HttpRequest::HttpRequest() :
+        HttpMsg(hoRequest)
 {
     init();
 }
 
-HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) : HttpMsg(hoRequest)
+HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) :
+        HttpMsg(hoRequest)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE << "constructed, this=" << this << " id=" << ++id);
     init();
     initHTTP(aMethod, aProtocol, aUrlpath);
 }
@@ -84,13 +86,13 @@
     urlpath = aUrlpath;
 }
 
 void
 HttpRequest::init()
 {
-    method = METHOD_NONE;
+    method = Http::METHOD_NONE;
     protocol = AnyP::PROTO_NONE;
     urlpath = NULL;
     login[0] = '\0';
     host[0] = '\0';
     host_is_numeric = -1;
 #if USE_AUTH
@@ -100,33 +102,34 @@
     canonical = NULL;
     memset(&flags, '\0', sizeof(flags));
     range = NULL;
     ims = -1;
     imslen = 0;
     lastmod = -1;
-    client_addr.SetEmpty();
-    my_addr.SetEmpty();
+    client_addr.setEmpty();
+    my_addr.setEmpty();
     body_pipe = NULL;
     // hier
     dnsWait = -1;
     errType = ERR_NONE;
     errDetail = ERR_DETAIL_NONE;
     peer_login = NULL;		// not allocated/deallocated by this class
     peer_domain = NULL;		// not allocated/deallocated by this class
+    peer_host = NULL;
     vary_headers = NULL;
     myportname = null_string;
     tag = null_string;
 #if USE_AUTH
     extacl_user = null_string;
     extacl_passwd = null_string;
 #endif
     extacl_log = null_string;
     extacl_message = null_string;
     pstate = psReadyToParseStartLine;
 #if FOLLOW_X_FORWARDED_FOR
-    indirect_client_addr.SetEmpty();
+    indirect_client_addr.setEmpty();
 #endif /* FOLLOW_X_FORWARDED_FOR */
 #if USE_ADAPTATION
     adaptHistory_ = NULL;
 #endif
 #if ICAP_CLIENT
     icapHistory_ = NULL;
@@ -160,12 +163,14 @@
         delete range;
         range = NULL;
     }
 
     myportname.clean();
 
+    notes = NULL;
+
     tag.clean();
 #if USE_AUTH
     extacl_user.clean();
     extacl_passwd.clean();
 #endif
     extacl_log.clean();
@@ -269,52 +274,53 @@
 
     myportname = aReq->myportname;
 
     // main property is which connection the request was received on (if any)
     clientConnectionManager = aReq->clientConnectionManager;
 
+    notes = aReq->notes;
     return true;
 }
 
 /**
  * Checks the first line of an HTTP request is valid
  * currently just checks the request method is present.
  *
  * NP: Other errors are left for detection later in the parse.
  */
 bool
-HttpRequest::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error)
+HttpRequest::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error)
 {
     // content is long enough to possibly hold a reply
     // 2 being magic size of a 1-byte request method plus space delimiter
     if ( buf->contentSize() < 2 ) {
         // this is ony a real error if the headers apparently complete.
         if (hdr_len > 0) {
             debugs(58, 3, HERE << "Too large request header (" << hdr_len << " bytes)");
-            *error = HTTP_INVALID_HEADER;
+            *error = Http::scInvalidHeader;
         }
         return false;
     }
 
     /* See if the request buffer starts with a known HTTP request method. */
-    if (HttpRequestMethod(buf->content(),NULL) == METHOD_NONE) {
+    if (HttpRequestMethod(buf->content(),NULL) == Http::METHOD_NONE) {
         debugs(73, 3, "HttpRequest::sanityCheckStartLine: did not find HTTP request method");
-        *error = HTTP_INVALID_HEADER;
+        *error = Http::scInvalidHeader;
         return false;
     }
 
     return true;
 }
 
 bool
 HttpRequest::parseFirstLine(const char *start, const char *end)
 {
     const char *t = start + strcspn(start, w_space);
     method = HttpRequestMethod(start, t);
 
-    if (method == METHOD_NONE)
+    if (method == Http::METHOD_NONE)
         return false;
 
     start = t + strspn(t, w_space);
 
     const char *ver = findTrailingHTTPVersion(start, end);
 
@@ -568,50 +574,52 @@
  *
  * If the request cannot be created cleanly, NULL is returned
  */
 HttpRequest *
 HttpRequest::CreateFromUrl(char * url)
 {
-    return urlParse(METHOD_GET, url, NULL);
+    return urlParse(Http::METHOD_GET, url, NULL);
 }
 
-/*
+/**
  * Are responses to this request possible cacheable ?
  * If false then no matter what the response must not be cached.
  */
 bool
-HttpRequest::cacheable() const
+HttpRequest::maybeCacheable()
 {
     // Intercepted request with Host: header which cannot be trusted.
     // Because it failed verification, or someone bypassed the security tests
     // we cannot cache the reponse for sharing between clients.
     // TODO: update cache to store for particular clients only (going to same Host: and destination IP)
-    if (!flags.hostVerified && (flags.intercepted || flags.spoofClientIp))
+    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))
         return false;
 
-    if (protocol == AnyP::PROTO_HTTP)
-        return httpCachable(method);
-
-    /*
-     * The below looks questionable: what non HTTP protocols use connect,
-     * trace, put and post? RC
-     */
+    switch (protocol) {
+    case AnyP::PROTO_HTTP:
+    case AnyP::PROTO_HTTPS:
+        if (!method.respMaybeCacheable())
+            return false;
 
-    if (!method.isCacheble())
-        return false;
+        // XXX: this would seem the correct place to detect request cache-controls
+        //      no-store, private and related which block cacheability
+        break;
 
-    /*
-     * XXX POST may be cached sometimes.. ignored
-     * for now
-     */
-    if (protocol == AnyP::PROTO_GOPHER)
-        return gopherCachable(this);
+    case AnyP::PROTO_GOPHER:
+        if (!gopherCachable(this))
+            return false;
+        break;
 
-    if (protocol == AnyP::PROTO_CACHE_OBJECT)
+    case AnyP::PROTO_CACHE_OBJECT:
         return false;
 
+        //case AnyP::PROTO_FTP:
+    default:
+        break;
+    }
+
     return true;
 }
 
 bool
 HttpRequest::conditional() const
 {
@@ -674,13 +682,13 @@
 
 bool
 HttpRequest::canHandle1xx() const
 {
     // old clients do not support 1xx unless they sent Expect: 100-continue
     // (we reject all other HDR_EXPECT values so just check for HDR_EXPECT)
-    if (http_ver <= HttpVersion(1,0) && !header.has(HDR_EXPECT))
+    if (http_ver <= Http::ProtocolVersion(1,0) && !header.has(HDR_EXPECT))
         return false;
 
     // others must support 1xx control messages
     return true;
 }
 
@@ -688,6 +696,19 @@
 HttpRequest::pinnedConnection()
 {
     if (clientConnectionManager.valid() && clientConnectionManager->pinning.pinned)
         return clientConnectionManager.get();
     return NULL;
 }
+
+const char *
+HttpRequest::storeId()
+{
+    if (store_id.size() != 0) {
+        debugs(73, 3, "sent back store_id:" << store_id);
+
+        return store_id.termedBuf();
+    }
+    debugs(73, 3, "sent back canonicalUrl:" << urlCanonical(this) );
+
+    return urlCanonical(this);
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpRequest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpRequest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpRequest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpRequest.h	2015-05-01 18:05:19.000000000 +0800
@@ -34,12 +34,13 @@
 #include "base/CbcPointer.h"
 #include "Debug.h"
 #include "err_type.h"
 #include "HierarchyLogEntry.h"
 #include "HttpMsg.h"
 #include "HttpRequestMethod.h"
+#include "Notes.h"
 #include "RequestFlags.h"
 
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
 #if USE_ADAPTATION
@@ -62,49 +63,46 @@
 class DnsLookupDetails;
 
 class HttpRequest: public HttpMsg
 {
 
 public:
-    typedef HttpMsgPointerT<HttpRequest> Pointer;
+    typedef RefCount<HttpRequest> Pointer;
 
     MEMPROXY_CLASS(HttpRequest);
     HttpRequest();
     HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
     ~HttpRequest();
     virtual void reset();
 
-    // use HTTPMSGLOCK() instead of calling this directly
-    virtual HttpRequest *_lock() {
-        return static_cast<HttpRequest*>(HttpMsg::_lock());
-    };
-
     void initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
 
     virtual HttpRequest *clone() const;
 
-    /* are responses to this request potentially cachable */
-    bool cacheable() const;
+    /// Whether response to this request is potentially cachable
+    /// \retval false  Not cacheable.
+    /// \retval true   Possibly cacheable. Response factors will determine.
+    bool maybeCacheable();
 
     bool conditional() const; ///< has at least one recognized If-* header
 
     /// whether the client is likely to be able to handle a 1xx reply
     bool canHandle1xx() const;
 
     /* Now that we care what host contains it is better off being protected. */
     /* HACK: These two methods are only inline to get around Makefile dependancies */
     /*      caused by HttpRequest being used in places it really shouldn't.        */
     /*      ideally they would be methods of URL instead. */
     inline void SetHost(const char *src) {
-        host_addr.SetEmpty();
+        host_addr.setEmpty();
         host_addr = src;
-        if ( host_addr.IsAnyAddr() ) {
+        if (host_addr.isAnyAddr()) {
             xstrncpy(host, src, SQUIDHOSTNAMELEN);
             host_is_numeric = 0;
         } else {
-            host_addr.ToHostname(host, SQUIDHOSTNAMELEN);
+            host_addr.toHostStr(host, SQUIDHOSTNAMELEN);
             debugs(23, 3, "HttpRequest::SetHost() given IP: " << host_addr);
             host_is_numeric = 1;
         }
         safe_free(canonical); // force its re-build
     };
     inline const char* GetHost(void) const { return host; };
@@ -159,12 +157,20 @@
     unsigned short port;
 
     String urlpath;
 
     char *canonical;
 
+    /**
+     * If defined, store_id_program mapped the request URL to this ID.
+     * Store uses this ID (and not the URL) to find and store entries,
+     * avoiding caching duplicate entries when different URLs point to
+     * "essentially the same" cachable resource.
+     */
+    String store_id;
+
     RequestFlags flags;
 
     HttpHdrRange *range;
 
     time_t ims;
 
@@ -194,12 +200,14 @@
     const char *vary_headers;	/* Used when varying entities are detected. Changes how the store key is calculated */
 
     char *peer_domain;		/* Configured peer forceddomain */
 
     String myportname; // Internal tag name= value from port this requests arrived in.
 
+    NotePairs::Pointer notes; ///< annotations added by the note directive and helpers
+
     String tag;			/* Internal tag for this request */
 
     String extacl_user;		/* User name returned by extacl lookup */
 
     String extacl_passwd;	/* Password returned by extacl lookup */
 
@@ -237,12 +245,20 @@
 
     static HttpRequest * CreateFromUrl(char * url);
 
     ConnStateData *pinnedConnection();
 
     /**
+     * Returns the current StoreID for the request as a nul-terminated char*.
+     * Always returns the current id for the request
+     * (either the request canonical url or modified ID by the helper).
+     * Does not return NULL.
+     */
+    const char *storeId();
+
+    /**
      * The client connection manager, if known;
      * Used for any response actions needed directly to the client.
      * ie 1xx forwarding or connection pinning state changes
      */
     CbcPointer<ConnStateData> clientConnectionManager;
 
@@ -255,13 +271,13 @@
 
     mutable int64_t rangeOffsetLimit;  /* caches the result of getRangeOffsetLimit */
 
 protected:
     virtual void packFirstLineInto(Packer * p, bool full_uri) const;
 
-    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error);
+    virtual bool sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error);
 
     virtual void hdrCacheInit();
 
     virtual bool inheritProperties(const HttpMsg *aMsg);
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpRequestMethod.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpRequestMethod.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpRequestMethod.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpRequestMethod.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,92 +1,28 @@
-
 /*
  * DEBUG: section 73    HTTP Request
- * AUTHOR: Duane Wessels
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
 #include "HttpRequestMethod.h"
 #include "wordlist.h"
 
-const char* HttpRequestMethod::RequestMethodStr[] = {
-    "NONE",
-    "GET",
-    "POST",
-    "PUT",
-    "HEAD",
-    "CONNECT",
-    "TRACE",
-    "PURGE",
-    "OPTIONS",
-    "DELETE",
-    "PROPFIND",
-    "PROPPATCH",
-    "MKCOL",
-    "COPY",
-    "MOVE",
-    "LOCK",
-    "UNLOCK",
-    "BMOVE",
-    "BDELETE",
-    "BPROPFIND",
-    "BPROPPATCH",
-    "BCOPY",
-    "SEARCH",
-    "SUBSCRIBE",
-    "UNSUBSCRIBE",
-    "POLL",
-    "REPORT",
-    "MKACTIVITY",
-    "CHECKOUT",
-    "MERGE",
-    "ERROR"
-};
-
-static
-_method_t &operator++ (_method_t &aMethod)
+static Http::MethodType &
+operator++ (Http::MethodType &aMethod)
 {
     int tmp = (int)aMethod;
-    aMethod = (_method_t)(++tmp);
+    aMethod = (Http::MethodType)(++tmp);
     return aMethod;
 }
 
-/*
+/**
  * Construct a HttpRequestMethod from a NULL terminated string such as "GET"
  * or from a range of chars, * such as "GET" from "GETFOOBARBAZ"
  * (pass in pointer to G and pointer to F.)
  */
-HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMethod (METHOD_NONE)
+HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMethod (Http::METHOD_NONE)
 {
     if (begin == NULL)
         return;
 
     /*
      * This check for '%' makes sure that we don't
@@ -103,152 +39,232 @@
      * after b.
      */
     if (NULL == end)
         end = begin + strcspn(begin, w_space);
 
     if (end == begin) {
-        theMethod = METHOD_NONE;
+        theMethod = Http::METHOD_NONE;
         return;
     }
 
-    for (++theMethod; theMethod < METHOD_ENUM_END; ++theMethod) {
-        if (0 == strncasecmp(begin, RequestMethodStr[theMethod], end-begin)) {
+    for (++theMethod; theMethod < Http::METHOD_ENUM_END; ++theMethod) {
+        if (0 == strncasecmp(begin, Http::MethodType_str[theMethod], end-begin)) {
             return;
         }
     }
 
     // if method not found and method string is not null then it is other method
-    theMethod = METHOD_OTHER;
+    theMethod = Http::METHOD_OTHER;
     theImage.limitInit(begin,end-begin);
 }
 
-/** \todo AYJ: this _should_ be obsolete. Since all such methods fit nicely into METHOD_OTHER now. */
-void
-HttpRequestMethod::AddExtension(const char *mstr)
-{
-#if 0 /* obsolete now that we have METHOD_OTHER always enabled */
-    _method_t method = METHOD_NONE;
-
-    for (++method; method < METHOD_ENUM_END; ++method) {
-        if (0 == strcmp(mstr, RequestMethodStr[method])) {
-            debugs(23, 2, "Extension method '" << mstr << "' already exists");
-            return;
+char const*
+HttpRequestMethod::image() const
+{
+    if (Http::METHOD_OTHER != theMethod) {
+        return Http::MethodType_str[theMethod];
+    } else {
+        if (theImage.size()>0) {
+            return theImage.termedBuf();
+        } else {
+            return "METHOD_OTHER";
         }
+    }
+}
 
-        if (0 != strncmp("%EXT", RequestMethodStr[method], 4))
-            continue;
+bool
+HttpRequestMethod::isHttpSafe() const
+{
+    // Only a few methods are defined as safe. All others are "unsafe"
 
-        /* Don't free statically allocated "%EXTnn" string */
-        RequestMethodStr[method] = xstrdup(mstr);
+    // NOTE:
+    // All known RFCs which register methods are listed in comments.
+    // if there is one not listed which defines methods, it needs
+    // checking and adding. If only to say it is known to define none.
 
-        debugs(23, DBG_IMPORTANT, "Extension method '" << mstr << "' added, enum=" << method);
+    switch (theMethod) {
+        // RFC 2068 - none
 
-        return;
-    }
+        // RFC 2616 section 9.1.1
+    case Http::METHOD_GET:
+    case Http::METHOD_HEAD:
+    case Http::METHOD_OPTIONS:
 
-    debugs(23, DBG_IMPORTANT, "WARNING: Could not add new extension method '" << mstr << "' due to lack of array space");
-#endif
-}
+        // RFC 3253 section 3.6
+    case Http::METHOD_REPORT:
 
-void
-HttpRequestMethod::Configure(SquidConfig &cfg)
-{
-#if 0 /* extension methods obsolete now that we have METHOD_OTHER always enabled */
-    wordlist *w = cfg.ext_methods;
+        // RFC 3648 - none
+        // RFC 3744 - none
+        // RFC 4437 - none
+        // RFC 4791 - none
 
-    while (w) {
-        char *s;
+        // RFC 4918 section 9.1
+    case Http::METHOD_PROPFIND:
 
-        for (s = w->key; *s; ++s)
-            *s = xtoupper(*s);
+        // RFC 5323 section 2
+    case Http::METHOD_SEARCH:
 
-        AddExtension(w->key);
+        // RFC 5789 - none
+        // RFC 5842 - none
 
-        w = w->next;
-    }
-#endif
-}
+        return true;
 
-char const*
-HttpRequestMethod::image() const
-{
-    if (METHOD_OTHER != theMethod) {
-        return RequestMethodStr[theMethod];
-    } else {
-        if (theImage.size()>0) {
-            return theImage.termedBuf();
-        } else {
-            return "METHOD_OTHER";
-        }
+    default:
+        return false;
     }
 }
 
 bool
-HttpRequestMethod::isCacheble() const
+HttpRequestMethod::isIdempotent() const
 {
-    // TODO: optimize the lookup with a precomputed flags array
-    // XXX: the list seems wrong; e.g., Is METHOD_DELETE really cachable?
-    // see also http.cc::httpCachable()
+    // Only a few methods are defined as idempotent.
 
-    if (theMethod == METHOD_CONNECT)
-        return false;
+    // NOTE:
+    // All known RFCs which register methods are listed in comments.
+    // if there is one not listed which defines methods, it needs
+    // checking and adding. If only to say it is known to define none.
 
-    if (theMethod == METHOD_TRACE)
-        return false;
+    switch (theMethod) {
+        // RFC 2068 - TODO check LINK/UNLINK definition
 
-    if (theMethod == METHOD_PUT)
-        return false;
+        // RFC 2616 section 9.1.2
+    case Http::METHOD_GET:
+    case Http::METHOD_HEAD:
+    case Http::METHOD_PUT:
+    case Http::METHOD_DELETE:
+    case Http::METHOD_OPTIONS:
+    case Http::METHOD_TRACE:
+
+        // RFC 3253 - TODO check
+        // RFC 3648 - TODO check
+        // RFC 3744 - TODO check
+        // RFC 4437 - TODO check
+        // RFC 4791 - TODO check
+
+        // RFC 4918 section 9
+    case Http::METHOD_PROPFIND:
+    case Http::METHOD_PROPPATCH:
+    case Http::METHOD_MKCOL:
+    case Http::METHOD_COPY:
+    case Http::METHOD_MOVE:
+    case Http::METHOD_UNLOCK:
+
+        // RFC 5323 - TODO check
+        // RFC 5789 - TODO check
+        // RFC 5842 - TODO check
 
-    if (theMethod == METHOD_POST)
-        return false;
+        return true;
 
-    if (theMethod == METHOD_OTHER)
+    default:
         return false;
-
-    return true;
+    }
 }
 
 bool
-HttpRequestMethod::purgesOthers() const
+HttpRequestMethod::respMaybeCacheable() const
 {
-    // TODO: optimize the lookup with a precomputed flags array
-
+    // Only a few methods are defined as cacheable.
+    // All other methods from the below RFC are "MUST NOT cache"
     switch (theMethod) {
-        /* common sense suggests purging is not required? */
-    case METHOD_GET:     // XXX: but we do purge HEAD on successful GET
-    case METHOD_HEAD:
-    case METHOD_NONE:
-    case METHOD_CONNECT:
-    case METHOD_TRACE:
-    case METHOD_OPTIONS:
-    case METHOD_PROPFIND:
-    case METHOD_BPROPFIND:
-    case METHOD_COPY:
-    case METHOD_BCOPY:
-    case METHOD_LOCK:
-    case METHOD_UNLOCK:
-    case METHOD_SEARCH:
+        // RFC 2616 section 9
+    case Http::METHOD_GET:
+    case Http::METHOD_HEAD:
+        return true;
+#if WHEN_POST_CACHE_SUPPORTED
+    case Http::METHOD_POST: // Special case.
+        // RFC 2616 specifies POST as possibly cacheable
+        // However, Squid does not implement the required checks yet
+        return true;
+#endif
+
+        // RFC 4918 section 9
+#if WHEN_PROPFIND_CACHE_SUPPORTED
+    case Http::METHOD_PROPFIND: // Special case.
+        // RFC 4918 specifies PROPFIND as possibly cacheable
+        // However, Squid does not implement the required checks yet
+        return true;
+#endif
+
+        // RFC 5323 section 2 - defines no cacheable methods
+
+        // RFC 3253
+#if WHEN_CC_NOCACHE_DOES_REVALIDATES_IS_CONFIRMED
+    case Http::METHOD_CHECKOUT:
+    case Http::METHOD_CHECKIN:
+    case Http::METHOD_UNCHECKOUT:
+    case Http::METHOD_MKWORKSPACE:
+    case Http::METHOD_VERSION_CONTROL:
+    case Http::METHOD_UPDATE:
+    case Http::METHOD_LABEL:
+    case Http::METHOD_MERGE:
+    case Http::METHOD_BASELINE_CONTROL:
+    case Http::METHOD_MKACTIVITY:
+        // RFC 3253 defines these methods using "MUST include Cache-Control: no-cache".
+        //
+        // XXX: follow RFC 2616 definition of "no-cache" meaning "MAY cache, always revalidate"
+        // XXX: or treat as unregistered/undefined methods ??
+        // However, Squid may not implement the required revalidation checks yet
+        return ??;
+#endif
+
+        // Special Squid method tokens are not cacheable.
+        // RFC 2616 defines all unregistered or unspecified methods as non-cacheable
+        // until such time as an RFC defines them cacheable.
+    default:
         return false;
+    }
+}
 
-        /* purging mandated by RFC 2616 */
-    case METHOD_POST:
-    case METHOD_PUT:
-    case METHOD_DELETE:
+bool
+HttpRequestMethod::shouldInvalidate() const
+{
+    switch (theMethod) {
+        /* RFC 2616 section 13.10 - "MUST invalidate" */
+    case Http::METHOD_POST:
+    case Http::METHOD_PUT:
+    case Http::METHOD_DELETE:
         return true;
 
-        /* purging suggested by common sense */
-    case METHOD_PURGE:
+        /* Squid extension to force invalidation */
+    case Http::METHOD_PURGE:
         return true;
 
         /*
          * RFC 2616 sayeth, in section 13.10, final paragraph:
          * A cache that passes through requests for methods it does not
          * understand SHOULD invalidate any entities referred to by the
          * Request-URI.
          */
-    case METHOD_OTHER:
-    default:
+    case Http::METHOD_OTHER:
         return true;
+
+    default:
+        // Methods which are known but not required to invalidate.
+        return false;
     }
+}
+
+bool
+HttpRequestMethod::purgesOthers() const
+{
+    if (shouldInvalidate())
+        return true;
+
+    switch (theMethod) {
+        /* common sense suggests purging is not required? */
+    case Http::METHOD_GET:     // XXX: but we do purge HEAD on successful GET
+    case Http::METHOD_HEAD:
+    case Http::METHOD_NONE:
+    case Http::METHOD_CONNECT:
+    case Http::METHOD_TRACE:
+    case Http::METHOD_OPTIONS:
+    case Http::METHOD_PROPFIND:
+    case Http::METHOD_COPY:
+    case Http::METHOD_LOCK:
+    case Http::METHOD_UNLOCK:
+    case Http::METHOD_SEARCH:
+        return false;
 
-    return true; // not reached, but just in case
+    default:
+        return true;
+    }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpRequestMethod.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpRequestMethod.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/HttpRequestMethod.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/HttpRequestMethod.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,97 +1,32 @@
-/*
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
 #ifndef SQUID_HTTPREQUESTMETHOD_H
 #define SQUID_HTTPREQUESTMETHOD_H
 
+#include "http/MethodType.h"
+#include "SquidString.h"
 #include "SquidString.h"
 
 class SquidConfig;
 
 #include <iosfwd>
 
-enum _method_t {
-    METHOD_NONE,		/* 000 */
-    METHOD_GET,			/* 001 */
-    METHOD_POST,		/* 010 */
-    METHOD_PUT,			/* 011 */
-    METHOD_HEAD,		/* 100 */
-    METHOD_CONNECT,		/* 101 */
-    METHOD_TRACE,		/* 110 */
-    METHOD_PURGE,		/* 111 */
-    METHOD_OPTIONS,
-    METHOD_DELETE,		/* RFC2616 section 9.7 */
-    METHOD_PROPFIND,
-    METHOD_PROPPATCH,
-    METHOD_MKCOL,
-    METHOD_COPY,
-    METHOD_MOVE,
-    METHOD_LOCK,
-    METHOD_UNLOCK,
-    METHOD_BMOVE,
-    METHOD_BDELETE,
-    METHOD_BPROPFIND,
-    METHOD_BPROPPATCH,
-    METHOD_BCOPY,
-    METHOD_SEARCH,
-    METHOD_SUBSCRIBE,
-    METHOD_UNSUBSCRIBE,
-    METHOD_POLL,
-    METHOD_REPORT,
-    METHOD_MKACTIVITY,
-    METHOD_CHECKOUT,
-    METHOD_MERGE,
-    METHOD_OTHER,
-    METHOD_ENUM_END  // MUST be last, (yuck) this is used as an array-initialization index constant!
-};
-
 /**
  * This class represents an HTTP Request METHOD
  * - i.e. PUT, POST, GET etc.
  * It has a runtime extension facility to allow it to
  * efficiently support new methods
- \ingroup POD
  */
 class HttpRequestMethod
 {
 
 public:
-    static void AddExtension(const char *methodString);
-    static void Configure(SquidConfig &Config);
+//    static void Configure(SquidConfig &Config);
 
-    HttpRequestMethod() : theMethod(METHOD_NONE), theImage() {}
+    HttpRequestMethod() : theMethod(Http::METHOD_NONE), theImage() {}
 
-    HttpRequestMethod(_method_t const aMethod) : theMethod(aMethod), theImage() {}
+    HttpRequestMethod(Http::MethodType const aMethod) : theMethod(aMethod), theImage() {}
 
     /**
      \param begin    string to convert to request method.
      \param end      end of the method string (relative to begin). Use NULL if this is unknown.
      *
      \note DO NOT give end a default (ie NULL). That will cause silent char* conversion clashes.
@@ -101,68 +36,100 @@
     HttpRequestMethod & operator = (const HttpRequestMethod& aMethod) {
         theMethod = aMethod.theMethod;
         theImage = aMethod.theImage;
         return *this;
     }
 
-    HttpRequestMethod & operator = (_method_t const aMethod) {
+    HttpRequestMethod & operator = (Http::MethodType const aMethod) {
         theMethod = aMethod;
         theImage.clean();
         return *this;
     }
 
-    bool operator == (_method_t const & aMethod) const { return theMethod == aMethod; }
+    bool operator == (Http::MethodType const & aMethod) const { return theMethod == aMethod; }
     bool operator == (HttpRequestMethod const & aMethod) const {
         return theMethod == aMethod.theMethod &&
-               (theMethod != METHOD_OTHER || theImage == aMethod.theImage);
+               (theMethod != Http::METHOD_OTHER || theImage == aMethod.theImage);
     }
 
-    bool operator != (_method_t const & aMethod) const { return theMethod != aMethod; }
+    bool operator != (Http::MethodType const & aMethod) const { return theMethod != aMethod; }
     bool operator != (HttpRequestMethod const & aMethod) const {
         return !operator==(aMethod);
     }
 
     /** Iterate through all HTTP method IDs. */
     HttpRequestMethod& operator++() {
         // TODO: when this operator is used in more than one place,
         // replace it with HttpRequestMethods::Iterator API
-        // XXX: this interface can create METHOD_OTHER without an image
-        assert(theMethod < METHOD_ENUM_END);
-        theMethod = (_method_t)(1 + (int)theMethod);
+        // XXX: this interface can create Http::METHOD_OTHER without an image
+        assert(theMethod < Http::METHOD_ENUM_END);
+        theMethod = (Http::MethodType)(1 + (int)theMethod);
         return *this;
     }
 
     /** Get an ID representation of the method.
-     \retval METHOD_NONE   the method is unset
-     \retval METHOD_OTHER  the method is not recognized and has no unique ID
-     \retval *             the method is on of the recognized HTTP methods.
+     * \retval Http::METHOD_NONE   the method is unset
+     * \retval Http::METHOD_OTHER  the method is not recognized and has no unique ID
+     * \retval *                   the method is on of the recognized HTTP methods.
      */
-    _method_t id() const { return theMethod; }
+    Http::MethodType id() const { return theMethod; }
 
     /** Get a char string representation of the method. */
     char const * image() const;
 
-    bool isCacheble() const;
+    /// Whether this method is defined as a "safe" in HTTP/1.1
+    /// see RFC 2616 section 9.1.1
+    bool isHttpSafe() const;
+
+    /// Whether this method is defined as "idempotent" in HTTP/1.1
+    /// see RFC 2616 section 9.1.2
+    bool isIdempotent() const;
+
+    /** Whether responses to this method MAY be cached.
+     * \retval false  Not cacheable.
+     * \retval true   Possibly cacheable. Other details will determine.
+     */
+    bool respMaybeCacheable() const;
+
+    /** Whether this method SHOULD (or MUST) invalidate existing cached entries.
+     * Invalidation is always determined by the response
+     *
+     * RFC 2616 defines invalidate as either immediate purge
+     * or delayed explicit revalidate all stored copies on next use.
+     *
+     * \retval true   SHOULD invalidate. Response details can raise this to a MUST.
+     * \retval false  Other details will determine. Method is not a factor.
+     */
+    bool shouldInvalidate() const;
+
+    /* Whether this method invalidates existing cached entries.
+     * Kept for backward-compatibility. This is the old 2.x-3.2 invalidation behaviour.
+     *
+     * NOTE:
+     *    purgesOthers differs from shouldInvalidate() in that purgesOthers() returns
+     *    true on any methods the MAY invalidate (Squid opts to do so).
+     *    shouldInvalidate() only returns true on methods which SHOULD invalidate.
+     */
     bool purgesOthers() const;
 
 private:
     static const char *RequestMethodStr[];
 
-    _method_t theMethod; ///< Method type
-    String theImage;     ///< Used for store METHOD_OTHER only
+    Http::MethodType theMethod; ///< Method type
+    String theImage;     ///< Used for storing the Http::METHOD_OTHER only. A copy of the parsed method text.
 };
 
 inline std::ostream &
 operator << (std::ostream &os, HttpRequestMethod const &method)
 {
     os << method.image();
     return os;
 }
 
 inline const char*
-RequestMethodStr(const _method_t m)
+RequestMethodStr(const Http::MethodType m)
 {
     return HttpRequestMethod(m).image();
 }
 
 inline const char*
 RequestMethodStr(const HttpRequestMethod& m)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src: HttpStatusCode.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src: HttpStatusLine.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src: HttpStatusLine.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src: HttpVersion.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/Icmp4.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/Icmp4.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/Icmp4.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/Icmp4.cc	2015-05-01 18:05:19.000000000 +0800
@@ -146,13 +146,13 @@
 
         icmp_pktsize += len;
     }
 
     icmp->icmp_cksum = CheckSum((unsigned short *) icmp, icmp_pktsize);
 
-    to.GetAddrInfo(S);
+    to.getAddrInfo(S);
     ((sockaddr_in*)S->ai_addr)->sin_port = 0;
     assert(icmp_pktsize <= MAX_PKT4_SZ);
 
     debugs(42, 5, HERE << "Send ICMP packet to " << to << ".");
 
     x = sendto(icmp_sock,
@@ -164,13 +164,13 @@
 
     if (x < 0) {
         debugs(42, DBG_IMPORTANT, HERE << "Error sending to ICMP packet to " << to << ". ERR: " << xstrerror());
     }
 
     Log(to, ' ', NULL, 0, 0);
-    to.FreeAddrInfo(S);
+    Ip::Address::FreeAddrInfo(S);
 }
 
 void
 Icmp4::Recv(void)
 {
     int n;
@@ -188,13 +188,13 @@
         return;
     }
 
     if (pkt == NULL)
         pkt = (char *)xmalloc(MAX_PKT4_SZ);
 
-    preply.from.InitAddrInfo(from);
+    Ip::Address::InitAddrInfo(from);
     n = recvfrom(icmp_sock,
                  (void *)pkt,
                  MAX_PKT4_SZ,
                  0,
                  from->ai_addr,
                  &from->ai_addrlen);
@@ -237,18 +237,18 @@
 #endif
 #endif /* HAVE_STRUCT_IPHDR_IP_HL */
 
     icmp = (struct icmphdr *) (void *) (pkt + iphdrlen);
 
     if (icmp->icmp_type != ICMP_ECHOREPLY) {
-        preply.from.FreeAddrInfo(from);
+        Ip::Address::FreeAddrInfo(from);
         return;
     }
 
     if (icmp->icmp_id != icmp_ident) {
-        preply.from.FreeAddrInfo(from);
+        Ip::Address::FreeAddrInfo(from);
         return;
     }
 
     echo = (icmpEchoData *) (void *) (icmp + 1);
 
     preply.opcode = echo->opcode;
@@ -267,10 +267,10 @@
         return;
     }
 
     control.SendResult(preply, (sizeof(pingerReplyData) - MAX_PKT4_SZ + preply.psize) );
 
     Log(preply.from, icmp->icmp_type, IcmpPacketType(icmp->icmp_type), preply.rtt, preply.hops);
-    preply.from.FreeAddrInfo(from);
+    Ip::Address::FreeAddrInfo(from);
 }
 
 #endif /* USE_ICMP */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/Icmp6.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/Icmp6.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/Icmp6.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/Icmp6.cc	2015-05-01 18:05:19.000000000 +0800
@@ -181,13 +181,13 @@
 
         icmp6_pktsize += len;
     }
 
     icmp->icmp6_cksum = CheckSum((unsigned short *) icmp, icmp6_pktsize);
 
-    to.GetAddrInfo(S);
+    to.getAddrInfo(S);
     ((sockaddr_in6*)S->ai_addr)->sin6_port = 0;
 
     assert(icmp6_pktsize <= MAX_PKT6_SZ);
 
     debugs(42, 5, HERE << "Send Icmp6 packet to " << to << ".");
 
@@ -201,13 +201,13 @@
     if (x < 0) {
         debugs(42, DBG_IMPORTANT, HERE << "Error sending to ICMPv6 packet to " << to << ". ERR: " << xstrerror());
     }
     debugs(42,9, HERE << "x=" << x);
 
     Log(to, 0, NULL, 0, 0);
-    to.FreeAddrInfo(S);
+    Ip::Address::FreeAddrInfo(S);
 }
 
 /**
  * Reads an RFC 4443 Icmp6 ECHO-REPLY Packet from the network.
  */
 void
@@ -228,13 +228,13 @@
     }
 
     if (pkt == NULL) {
         pkt = (char *)xmalloc(MAX_PKT6_SZ);
     }
 
-    preply.from.InitAddrInfo(from);
+    Ip::Address::InitAddrInfo(from);
 
     n = recvfrom(icmp_sock,
                  (void *)pkt,
                  MAX_PKT6_SZ,
                  0,
                  from->ai_addr,
@@ -300,19 +300,19 @@
             break;
 
         default:
             debugs(42, 8, HERE << preply.from << " said: " << icmp6header->icmp6_type << "/" << (int)icmp6header->icmp6_code << " " <<
                    IcmpPacketType(icmp6header->icmp6_type));
         }
-        preply.from.FreeAddrInfo(from);
+        Ip::Address::FreeAddrInfo(from);
         return;
     }
 
     if (icmp6header->icmp6_id != icmp_ident) {
         debugs(42, 8, HERE << "dropping Icmp6 read. IDENT check failed. ident=='" << icmp_ident << "'=='" << icmp6header->icmp6_id << "'");
-        preply.from.FreeAddrInfo(from);
+        Ip::Address::FreeAddrInfo(from);
         return;
     }
 
     echo = (icmpEchoData *) pkt;
 
     preply.opcode = echo->opcode;
@@ -343,10 +343,10 @@
         IcmpPacketType(icmp6header->icmp6_type),
         preply.rtt,
         preply.hops);
 
     /* send results of the lookup back to squid.*/
     control.SendResult(preply, (sizeof(pingerReplyData) - PINGER_PAYLOAD_SZ + preply.psize) );
-    preply.from.FreeAddrInfo(from);
+    Ip::Address::FreeAddrInfo(from);
 }
 
 #endif /* USE_ICMP */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/IcmpPinger.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/IcmpPinger.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/IcmpPinger.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/IcmpPinger.cc	2015-05-01 18:05:19.000000000 +0800
@@ -206,22 +206,22 @@
         debugs(42, 2, HERE << "size mismatch, guess=" << guess_size << ", psize=" << pecho.psize);
         /* don't process this message, but keep running */
         return;
     }
 
     /* pass request for ICMPv6 handing */
-    if (pecho.to.IsIPv6()) {
+    if (pecho.to.isIPv6()) {
         debugs(42, 2, HERE << " Pass " << pecho.to << " off to ICMPv6 module.");
         icmp6.SendEcho(pecho.to,
                        pecho.opcode,
                        pecho.payload,
                        pecho.psize);
     }
 
     /* pass the packet for ICMP handling */
-    else if (pecho.to.IsIPv4()) {
+    else if (pecho.to.isIPv4()) {
         debugs(42, 2, HERE << " Pass " << pecho.to << " off to ICMPv4 module.");
         icmp4.SendEcho(pecho.to,
                        pecho.opcode,
                        pecho.payload,
                        pecho.psize);
     } else {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/IcmpSquid.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/IcmpSquid.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/IcmpSquid.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/IcmpSquid.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,12 +30,13 @@
  *
  */
 
 #include "squid.h"
 #include "comm.h"
 #include "comm/Loops.h"
+#include "defines.h"
 #include "fd.h"
 #include "icmp/IcmpSquid.h"
 #include "icmp/net_db.h"
 #include "ip/tools.h"
 #include "SquidConfig.h"
 #include "SquidIpc.h"
@@ -48,15 +49,12 @@
 // Instance global to be available in main() and elsewhere.
 IcmpSquid icmpEngine;
 
 #if USE_ICMP
 
 #define S_ICMP_ECHO     1
-#if DEAD_CODE
-#define S_ICMP_ICP      2
-#endif
 #define S_ICMP_DOM      3
 
 static void * hIpc;
 static pid_t pid;
 
 #endif /* USE_ICMP */
@@ -176,13 +174,13 @@
     if (n == 0) {
         return;
     }
 
     F = preply.from;
 
-    F.SetPort(0);
+    F.port(0);
 
     switch (preply.opcode) {
 
     case S_ICMP_ECHO:
         debugs(37,4, HERE << " ICMP_ECHO of " << preply.from << " gave: hops=" << preply.hops <<", rtt=" << preply.rtt);
         break;
@@ -223,13 +221,13 @@
         Close();
         return -1;
     }
 
     args[0] = "(pinger)";
     args[1] = NULL;
-    localhost.SetLocalhost();
+    localhost.setLocalhost();
 
     /*
      * Do NOT use IPC_DGRAM (=IPC_UNIX_DGRAM) here because you can't
      * send() more than 4096 bytes on a socketpair() socket (at
      * least on FreeBSD).
      */
@@ -257,13 +255,13 @@
 
     debugs(37, DBG_IMPORTANT, HERE << "Pinger socket opened on FD " << icmp_sock);
 
     /* Tests the pinger immediately using localhost */
     if (Ip::EnableIpv6)
         SendEcho(localhost, S_ICMP_ECHO, "ip6-localhost");
-    if (localhost.SetIPv4())
+    if (localhost.setIPv4())
         SendEcho(localhost, S_ICMP_ECHO, "localhost");
 
 #if _SQUID_WINDOWS_
 
     debugs(37, 4, HERE << "Pinger handle: 0x" << std::hex << hIpc << std::dec << ", PID: " << pid);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/Makefile.in	2015-05-01 16:51:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/Makefile.in	2015-05-01 18:06:56.000000000 +0800
@@ -94,14 +94,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -124,13 +170,14 @@
 	Icmp6.$(OBJEXT) pinger.$(OBJEXT)
 nodist_pinger_OBJECTS = debug.$(OBJEXT) globals.$(OBJEXT) \
 	time.$(OBJEXT) SquidConfig.$(OBJEXT) SquidNew.$(OBJEXT) \
 	stub_HelperChildConfig.$(OBJEXT)
 pinger_OBJECTS = $(am_pinger_OBJECTS) $(nodist_pinger_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 pinger_DEPENDENCIES = libicmp-core.la ../ip/libip.la \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3)
 pinger_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
 	$(CXXFLAGS) $(pinger_LDFLAGS) $(LDFLAGS) -o $@
@@ -488,12 +535,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -531,12 +579,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -563,27 +612,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -649,13 +701,13 @@
 CLEANFILES = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 @ENABLE_PINGER_FALSE@PINGER = 
 
 # ICMP Specific Configurations
 @ENABLE_PINGER_TRUE@PINGER = pinger
 noinst_LTLIBRARIES = libicmp-core.la libicmp.la
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/net_db.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/net_db.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icmp/net_db.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icmp/net_db.cc	2015-05-01 18:05:19.000000000 +0800
@@ -41,13 +41,13 @@
 #include "squid.h"
 #include "CachePeer.h"
 #include "cbdata.h"
 #include "disk.h"
 #include "event.h"
 #include "fde.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
 #include "internal.h"
 #include "ip/Address.h"
 #include "log/File.h"
@@ -123,13 +123,13 @@
  * linked list */
 static wordlist *peer_names = NULL;
 
 static void
 netdbHashInsert(netdbEntry * n, Ip::Address &addr)
 {
-    networkFromInaddr(addr).NtoA(n->network, MAX_IPSTRLEN);
+    networkFromInaddr(addr).toStr(n->network, MAX_IPSTRLEN);
     n->hash.key = n->network;
     assert(hash_lookup(addr_table, n->network) == NULL);
     hash_join(addr_table, &n->hash);
 }
 
 static void
@@ -261,13 +261,13 @@
 
 static netdbEntry *
 netdbLookupAddr(const Ip::Address &addr)
 {
     netdbEntry *n;
     char *key = new char[MAX_IPSTRLEN];
-    networkFromInaddr(addr).NtoA(key,MAX_IPSTRLEN);
+    networkFromInaddr(addr).toStr(key,MAX_IPSTRLEN);
     n = (netdbEntry *) hash_lookup(addr_table, key);
     delete[] key;
     return n;
 }
 
 static netdbEntry *
@@ -359,22 +359,22 @@
 {
     Ip::Address out;
 
     out = in;
 
     /* in IPv6 the 'network' should be the routing section. */
-    if ( in.IsIPv6() ) {
-        out.ApplyMask(64, AF_INET6);
+    if ( in.isIPv6() ) {
+        out.applyMask(64, AF_INET6);
         debugs(14, 5, "networkFromInaddr : Masked IPv6 Address to " << in << "/64 routing part.");
         return out;
     }
 
 #if USE_CLASSFUL
     struct in_addr b;
 
-    in.GetInAddr(b);
+    in.getInAddr(b);
 
     if (IN_CLASSC(b.s_addr))
         b.s_addr &= IN_CLASSC_NET;
     else if (IN_CLASSB(b.s_addr))
         b.s_addr &= IN_CLASSB_NET;
     else if (IN_CLASSA(b.s_addr))
@@ -384,13 +384,13 @@
 
 #endif
 
     debugs(14, 5, "networkFromInaddr : Masked IPv4 Address to " << out << "/24.");
 
     /* use /24 for everything under IPv4 */
-    out.ApplyMask(24, AF_INET);
+    out.applyMask(24, AF_INET);
     debugs(14, 5, "networkFromInaddr : Masked IPv4 Address to " << in << "/24.");
 
     return out;
 }
 
 static int
@@ -739,16 +739,16 @@
 
         /* skip reply headers */
 
         if ((hdr_sz = headersEnd(p, ex->buf_ofs))) {
             debugs(38, 5, "netdbExchangeHandleReply: hdr_sz = " << hdr_sz);
             rep = ex->e->getReply();
-            assert (0 != rep->sline.status);
-            debugs(38, 3, "netdbExchangeHandleReply: reply status " << rep->sline.status);
+            assert(rep->sline.status() != Http::scNone);
+            debugs(38, 3, "netdbExchangeHandleReply: reply status " << rep->sline.status());
 
-            if (HTTP_OK != rep->sline.status) {
+            if (rep->sline.status() != Http::scOkay) {
                 netdbExchangeDone(ex);
                 return;
             }
 
             assert((size_t)ex->buf_ofs >= hdr_sz);
 
@@ -779,13 +779,13 @@
 
     /* If we get here, we have some body to parse .. */
     debugs(38, 5, "netdbExchangeHandleReply: start parsing loop, size = " << size);
 
     while (size >= rec_sz) {
         debugs(38, 5, "netdbExchangeHandleReply: in parsing loop, size = " << size);
-        addr.SetAnyAddr();
+        addr.setAnyAddr();
         hops = rtt = 0.0;
 
         for (o = 0; o < rec_sz;) {
             switch ((int) *(p + o)) {
 
             case NETDB_EX_NETWORK:
@@ -814,13 +814,13 @@
                 debugs(38, DBG_IMPORTANT, "netdbExchangeHandleReply: corrupt data, aborting");
                 netdbExchangeDone(ex);
                 return;
             }
         }
 
-        if (!addr.IsAnyAddr() && rtt > 0)
+        if (!addr.isAnyAddr() && rtt > 0)
             netdbExchangeUpdatePeer(addr, ex->p, rtt, hops);
 
         assert(o == rec_sz);
 
         ex->used += rec_sz;
 
@@ -986,29 +986,12 @@
     host_table = NULL;
     wordlistDestroy(&peer_names);
     peer_names = NULL;
 #endif
 }
 
-#if 0 // AYJ: Looks to be unused code.
-int
-netdbHops(Ip::Address &addr)
-{
-#if USE_ICMP
-    netdbEntry *n = netdbLookupAddr(addr);
-
-    if (n && n->pings_recv) {
-        n->last_use_time = squid_curtime;
-        return (int) (n->hops + 0.5);
-    }
-
-#endif
-    return 256;
-}
-#endif
-
 void
 netdbDump(StoreEntry * sentry)
 {
 #if USE_ICMP
     netdbEntry *n;
     netdbEntry **list;
@@ -1166,13 +1149,13 @@
     netdbEntry *n;
     net_db_peer *p;
     debugs(38, 5, "netdbExchangeUpdatePeer: '" << addr << "', "<<
            std::setfill('0')<< std::setprecision(2) << hops << " hops, " <<
            rtt << " rtt");
 
-    if ( !addr.IsIPv4() ) {
+    if ( !addr.isIPv4() ) {
         debugs(38, 5, "netdbExchangeUpdatePeer: Aborting peer update for '" << addr << "', NetDB cannot handle IPv6.");
         return;
     }
 
     n = netdbLookupAddr(addr);
 
@@ -1229,13 +1212,13 @@
     int j;
     int rec_sz;
     char *buf;
 
     struct in_addr line_addr;
     s->buffer();
-    reply->setHeaders(HTTP_OK, "OK", NULL, -1, squid_curtime, -2);
+    reply->setHeaders(Http::scOkay, "OK", NULL, -1, squid_curtime, -2);
     s->replaceHttpReply(reply);
     rec_sz = 0;
     rec_sz += 1 + sizeof(struct in_addr);
     rec_sz += 1 + sizeof(int);
     rec_sz += 1 + sizeof(int);
     buf = (char *)memAllocate(MEM_4K_BUF);
@@ -1250,19 +1233,19 @@
             continue;
 
         if (! (addr = n->network) )
             continue;
 
         /* FIXME INET6 : NetDB cannot yet handle IPv6 addresses. Ensure only IPv4 get sent. */
-        if ( !addr.IsIPv4() )
+        if ( !addr.isIPv4() )
             continue;
 
         buf[i] = (char) NETDB_EX_NETWORK;
         ++i;
 
-        addr.GetInAddr(line_addr);
+        addr.getInAddr(line_addr);
         memcpy(&buf[i], &line_addr, sizeof(struct in_addr));
 
         i += sizeof(struct in_addr);
 
         buf[i] = (char) NETDB_EX_RTT;
         ++i;
@@ -1295,13 +1278,13 @@
 
     assert(0 == i);
     s->flush();
     memFree(buf, MEM_4K_BUF);
 #else
 
-    reply->setHeaders(HTTP_BAD_REQUEST, "Bad Request", NULL, -1, squid_curtime, -2);
+    reply->setHeaders(Http::scBadRequest, "Bad Request", NULL, -1, squid_curtime, -2);
     s->replaceHttpReply(reply);
     storeAppendPrintf(s, "NETDB support not compiled into this Squid cache.\n");
 #endif
 
     s->complete();
 }
@@ -1330,24 +1313,24 @@
         debugs(38, DBG_IMPORTANT, "netdbExchangeStart: Bad URI " << uri);
         return;
     }
 
     HTTPMSGLOCK(ex->r);
     assert(NULL != ex->r);
-    ex->r->http_ver = HttpVersion(1,1);
+    ex->r->http_ver = Http::ProtocolVersion(1,1);
     ex->connstate = STATE_HEADER;
-    ex->e = storeCreateEntry(uri, uri, RequestFlags(), METHOD_GET);
+    ex->e = storeCreateEntry(uri, uri, RequestFlags(), Http::METHOD_GET);
     ex->buf_sz = NETDB_REQBUF_SZ;
     assert(NULL != ex->e);
     ex->sc = storeClientListAdd(ex->e, ex);
     tempBuffer.offset = 0;
     tempBuffer.length = ex->buf_sz;
     tempBuffer.data = ex->buf;
     storeClientCopy(ex->sc, ex->e, tempBuffer,
                     netdbExchangeHandleReply, ex);
-    ex->r->flags.loopDetected = 1;	/* cheat! -- force direct */
+    ex->r->flags.loopDetected = true;	/* cheat! -- force direct */
 
     if (p->login)
         xstrncpy(ex->r->login, p->login, MAX_LOGIN_SZ);
 
     urlCanonical(ex->r);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ICP.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ICP.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ICP.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ICP.h	2015-05-01 18:05:19.000000000 +0800
@@ -37,12 +37,13 @@
  */
 
 #include "comm/forward.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
 #include "StoreClient.h"
+#include "LogTags.h"
 
 class HttpRequest;
 
 /**
  \ingroup ServerProtocolICPAPI
  *
@@ -119,13 +120,13 @@
     icpUdpData *next;
 #ifndef LESS_TIMING
 
     struct timeval start;
 #endif
 
-    log_type logcode;
+    LogTags logcode;
 
     struct timeval queue_time;
 };
 
 extern Comm::ConnectionPointer icpIncomingConn;
 extern Comm::ConnectionPointer icpOutgoingConn;
@@ -141,16 +142,16 @@
 void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
 icp_opcode icpGetCommonOpcode();
 
 /// \ingroup ServerProtocolICPAPI
-int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int);
+int icpUdpSend(int, const Ip::Address &, icp_common_t *, LogTags, int);
 
 /// \ingroup ServerProtocolICPAPI
-log_type icpLogFromICPCode(icp_opcode opcode);
+LogTags icpLogFromICPCode(icp_opcode opcode);
 
 /// \ingroup ServerProtocolICPAPI
 void icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd);
 
 /// \ingroup ServerProtocolICPAPI
 PF icpHandleUdp;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icp_v2.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icp_v2.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icp_v2.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icp_v2.cc	2015-05-01 18:05:19.000000000 +0800
@@ -69,13 +69,13 @@
 #include <errno.h>
 #endif
 
 static void icpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int errNo);
 
 /// \ingroup ServerProtocolICPInternal2
-static void icpLogIcp(const Ip::Address &, log_type, int, const char *, int);
+static void icpLogIcp(const Ip::Address &, LogTags, int, const char *, int);
 
 /// \ingroup ServerProtocolICPInternal2
 static void icpHandleIcpV2(int, Ip::Address &, char *, int);
 
 /// \ingroup ServerProtocolICPInternal2
 static void icpCount(void *, int, size_t, int);
@@ -129,16 +129,18 @@
 }
 
 /* ICPState */
 
 ICPState::ICPState(icp_common_t &aHeader, HttpRequest *aRequest):
         header(aHeader),
-        request(HTTPMSGLOCK(aRequest)),
+        request(aRequest),
         fd(-1),
         url(NULL)
-{}
+{
+    HTTPMSGLOCK(request);
+}
 
 ICPState::~ICPState()
 {
     safe_free(url);
     HTTPMSGUNLOCK(request);
 }
@@ -196,13 +198,13 @@
 }
 
 /* End ICP2State */
 
 /// \ingroup ServerProtocolICPInternal2
 static void
-icpLogIcp(const Ip::Address &caddr, log_type logcode, int len, const char *url, int delay)
+icpLogIcp(const Ip::Address &caddr, LogTags logcode, int len, const char *url, int delay)
 {
     AccessLogEntry::Pointer al = new AccessLogEntry();
 
     if (LOG_TAG_NONE == logcode)
         return;
 
@@ -293,13 +295,13 @@
 }
 
 int
 icpUdpSend(int fd,
            const Ip::Address &to,
            icp_common_t * msg,
-           log_type logcode,
+           LogTags logcode,
            int delay)
 {
     icpUdpData *queue;
     int x;
     int len;
     len = (int) ntohs(msg->length);
@@ -377,13 +379,13 @@
         return ICP_MISS_NOFETCH;
     }
 
     return ICP_ERR;
 }
 
-log_type
+LogTags
 icpLogFromICPCode(icp_opcode opcode)
 {
     if (opcode == ICP_ERR)
         return LOG_UDP_INVALID;
 
     if (opcode == ICP_DENIED)
@@ -432,13 +434,13 @@
     /* absent any explicit rules, we deny all */
     if (!Config.accessList.icp)
         return false;
 
     ACLFilledChecklist checklist(Config.accessList.icp, icp_request, NULL);
     checklist.src_addr = from;
-    checklist.my_addr.SetNoAddr();
+    checklist.my_addr.setNoAddr();
     return (checklist.fastCheck() == ACCESS_ALLOWED);
 }
 
 char const *
 icpGetUrlToSend(char *url)
 {
@@ -509,13 +511,13 @@
     state->flags = flags;
 
     state->rtt = rtt;
 
     state->src_rtt = src_rtt;
 
-    StoreEntry::getPublic (state, url, METHOD_GET);
+    StoreEntry::getPublic (state, url, Http::METHOD_GET);
 
     HTTPMSGUNLOCK(icp_request);
 }
 
 void
 _icp_common_t::handleReply(char *buf, Ip::Address &from)
@@ -679,44 +681,44 @@
 
     if ((port = Config.Port.icp) <= 0)
         return;
 
     icpIncomingConn = new Comm::Connection;
     icpIncomingConn->local = Config.Addrs.udp_incoming;
-    icpIncomingConn->local.SetPort(port);
+    icpIncomingConn->local.port(port);
 
-    if (!Ip::EnableIpv6 && !icpIncomingConn->local.SetIPv4()) {
+    if (!Ip::EnableIpv6 && !icpIncomingConn->local.setIPv4()) {
         debugs(12, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << icpIncomingConn->local << " is not an IPv4 address.");
         fatal("ICP port cannot be opened.");
     }
     /* split-stack for now requires default IPv4-only ICP */
-    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && icpIncomingConn->local.IsAnyAddr()) {
-        icpIncomingConn->local.SetIPv4();
+    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && icpIncomingConn->local.isAnyAddr()) {
+        icpIncomingConn->local.setIPv4();
     }
 
     AsyncCall::Pointer call = asyncCall(12, 2,
                                         "icpIncomingConnectionOpened",
                                         Comm::UdpOpenDialer(&icpIncomingConnectionOpened));
 
     Ipc::StartListening(SOCK_DGRAM,
                         IPPROTO_UDP,
                         icpIncomingConn,
                         Ipc::fdnInIcpSocket, call);
 
-    if ( !Config.Addrs.udp_outgoing.IsNoAddr() ) {
+    if ( !Config.Addrs.udp_outgoing.isNoAddr() ) {
         icpOutgoingConn = new Comm::Connection;
         icpOutgoingConn->local = Config.Addrs.udp_outgoing;
-        icpOutgoingConn->local.SetPort(port);
+        icpOutgoingConn->local.port(port);
 
-        if (!Ip::EnableIpv6 && !icpOutgoingConn->local.SetIPv4()) {
+        if (!Ip::EnableIpv6 && !icpOutgoingConn->local.setIPv4()) {
             debugs(49, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << icpOutgoingConn->local << " is not an IPv4 address.");
             fatal("ICP port cannot be opened.");
         }
         /* split-stack for now requires default IPv4-only ICP */
-        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && icpOutgoingConn->local.IsAnyAddr()) {
-            icpOutgoingConn->local.SetIPv4();
+        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && icpOutgoingConn->local.isAnyAddr()) {
+            icpOutgoingConn->local.setIPv4();
         }
 
         enter_suid();
         comm_open_listener(SOCK_DGRAM, IPPROTO_UDP, icpOutgoingConn, "Outgoing ICP Port");
         leave_suid();
 
@@ -742,13 +744,13 @@
         ipcache_nbgethostbyname(s->key, mcastJoinGroups, NULL); // XXX: pass the conn for mcastJoinGroups usage.
 
     debugs(12, DBG_IMPORTANT, "Accepting ICP messages on " << conn->local);
 
     fd_note(conn->fd, "Incoming ICP port");
 
-    if (Config.Addrs.udp_outgoing.IsNoAddr()) {
+    if (Config.Addrs.udp_outgoing.isNoAddr()) {
         icpOutgoingConn = conn;
         debugs(12, DBG_IMPORTANT, "Sending ICP messages from " << icpOutgoingConn->local);
     }
 }
 
 /**
@@ -853,8 +855,8 @@
 const cache_key *
 icpGetCacheKey(const char *url, int reqnum)
 {
     if (neighbors_do_private_keys && reqnum)
         return queried_keys[reqnum & N_QUERIED_KEYS_MASK];
 
-    return storeKeyPublic(url, METHOD_GET);
+    return storeKeyPublic(url, Http::METHOD_GET);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icp_v3.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icp_v3.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/icp_v3.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/icp_v3.cc	2015-05-01 18:05:19.000000000 +0800
@@ -75,13 +75,13 @@
     state->fd = fd;
 
     state->from = from;
 
     state->url = xstrdup (url);
 
-    StoreEntry::getPublic (state, url, METHOD_GET);
+    StoreEntry::getPublic (state, url, Http::METHOD_GET);
 }
 
 ICP3State::~ICP3State()
 {}
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ident/AclIdent.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ident/AclIdent.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ident/AclIdent.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ident/AclIdent.cc	2015-05-01 18:05:19.000000000 +0800
@@ -86,20 +86,24 @@
     ACLFilledChecklist *checklist = Filled(cl);
     if (checklist->rfc931[0]) {
         return data->match(checklist->rfc931);
     } else if (checklist->conn() != NULL && checklist->conn()->clientConnection != NULL && checklist->conn()->clientConnection->rfc931[0]) {
         return data->match(checklist->conn()->clientConnection->rfc931);
     } else if (checklist->conn() != NULL && Comm::IsConnOpen(checklist->conn()->clientConnection)) {
-        debugs(28, 3, HERE << "switching to ident lookup state");
-        checklist->changeState(IdentLookup::Instance());
-        return 0;
+        if (checklist->goAsync(IdentLookup::Instance())) {
+            debugs(28, 3, "switching to ident lookup state");
+            return -1;
+        }
+        // else fall through to ACCESS_DUNNO failure below
     } else {
         debugs(28, DBG_IMPORTANT, HERE << "Can't start ident lookup. No client connection" );
-        checklist->markFinished(ACCESS_DUNNO, "cannot start ident lookup");
-        return -1;
+        // fall through to ACCESS_DUNNO failure below
     }
+
+    checklist->markFinished(ACCESS_DUNNO, "cannot start ident lookup");
+    return -1;
 }
 
 wordlist *
 ACLIdent::dump() const
 {
     return data->dump();
@@ -130,21 +134,19 @@
 {
     ACLFilledChecklist *checklist = Filled(cl);
     const ConnStateData *conn = checklist->conn();
     // check that ACLIdent::match() tested this lookup precondition
     assert(conn && Comm::IsConnOpen(conn->clientConnection));
     debugs(28, 3, HERE << "Doing ident lookup" );
-    checklist->asyncInProgress(true);
     Ident::Start(checklist->conn()->clientConnection, LookupDone, checklist);
 }
 
 void
 IdentLookup::LookupDone(const char *ident, void *data)
 {
     ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
-    assert(checklist->asyncState() == IdentLookup::Instance());
 
     if (ident) {
         xstrncpy(checklist->rfc931, ident, USER_IDENT_SZ);
     } else {
         xstrncpy(checklist->rfc931, dash_str, USER_IDENT_SZ);
     }
@@ -153,12 +155,10 @@
      * Cache the ident result in the connection, to avoid redoing ident lookup
      * over and over on persistent connections
      */
     if (checklist->conn() != NULL && checklist->conn()->clientConnection != NULL && !checklist->conn()->clientConnection->rfc931[0])
         xstrncpy(checklist->conn()->clientConnection->rfc931, checklist->rfc931, USER_IDENT_SZ);
 
-    checklist->asyncInProgress(false);
-    checklist->changeState(ACLChecklist::NullState::Instance());
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(IdentLookup::Instance());
 }
 
 #endif /* USE_IDENT */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ident/Ident.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ident/Ident.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ident/Ident.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ident/Ident.cc	2015-05-01 18:05:19.000000000 +0800
@@ -53,102 +53,125 @@
     IDCB *callback;
     void *callback_data;
 
     struct _IdentClient *next;
 } IdentClient;
 
-typedef struct _IdentStateData {
+class IdentStateData
+{
+public:
+    /* AsyncJob API emulated */
+    void deleteThis(const char *aReason);
+    void swanSong();
+
+    /// notify all waiting IdentClient callbacks
+    void notify(const char *result);
+
     hash_link hash;		/* must be first */
     Comm::ConnectionPointer conn;
     MemBuf queryMsg;  ///< the lookup message sent to IDENT server
     IdentClient *clients;
     char buf[IDENT_BUFSIZE];
-} IdentStateData;
+
+private:
+    CBDATA_CLASS2(IdentStateData);
+};
+
+CBDATA_CLASS_INIT(IdentStateData);
 
 // TODO: make these all a series of Async job calls. They are self-contained callbacks now.
 static IOCB ReadReply;
 static IOCB WriteFeedback;
 static CLCB Close;
 static CTCB Timeout;
 static CNCB ConnectDone;
 static hash_table *ident_hash = NULL;
 static void ClientAdd(IdentStateData * state, IDCB * callback, void *callback_data);
-static void identCallback(IdentStateData * state, char *result);
 
 } // namespace Ident
 
 Ident::IdentConfig Ident::TheConfig;
 
-/**** PRIVATE FUNCTIONS ****/
+void
+Ident::IdentStateData::deleteThis(const char *aReason)
+{
+    swanSong();
+    delete this;
+}
 
 void
-Ident::identCallback(IdentStateData * state, char *result)
+Ident::IdentStateData::swanSong()
 {
-    IdentClient *client;
+    if (clients != NULL)
+        notify(NULL);
+
+    if (Comm::IsConnOpen(conn)) {
+        comm_remove_close_handler(conn->fd, Ident::Close, this);
+        conn->close();
+    }
 
-    if (result && *result == '\0')
-        result = NULL;
+    hash_remove_link(ident_hash, (hash_link *) this);
+    xfree(hash.key);
+}
 
-    while ((client = state->clients)) {
+void
+Ident::IdentStateData::notify(const char *result)
+{
+    while (IdentClient *client = clients) {
         void *cbdata;
-        state->clients = client->next;
+        clients = client->next;
 
         if (cbdataReferenceValidDone(client->callback_data, &cbdata))
             client->callback(result, cbdata);
 
         xfree(client);
     }
 }
 
 void
 Ident::Close(const CommCloseCbParams &params)
 {
     IdentStateData *state = (IdentStateData *)params.data;
-    identCallback(state, NULL);
-    state->conn->close();
-    hash_remove_link(ident_hash, (hash_link *) state);
-    xfree(state->hash.key);
-    cbdataFree(state);
+    state->deleteThis("connection closed");
 }
 
 void
 Ident::Timeout(const CommTimeoutCbParams &io)
 {
     debugs(30, 3, HERE << io.conn);
-    io.conn->close();
+    IdentStateData *state = (IdentStateData *)io.data;
+    state->deleteThis("timeout");
 }
 
 void
 Ident::ConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xerrno, void *data)
 {
     IdentStateData *state = (IdentStateData *)data;
 
     if (status != COMM_OK) {
-        if (status == COMM_TIMEOUT) {
+        if (status == COMM_TIMEOUT)
             debugs(30, 3, "IDENT connection timeout to " << state->conn->remote);
-        }
+        state->deleteThis(status == COMM_TIMEOUT ? "connect timeout" : "connect error");
         return;
     }
 
-    assert(conn != NULL && conn == state->conn);
-
     /*
      * see if any of our clients still care
      */
     IdentClient *c;
     for (c = state->clients; c; c = c->next) {
         if (cbdataReferenceValid(c->callback_data))
             break;
     }
 
     if (c == NULL) {
-        /* no clients care */
-        conn->close();
+        state->deleteThis("client(s) aborted");
         return;
     }
 
+    assert(conn != NULL && conn == state->conn);
     comm_add_close_handler(conn->fd, Ident::Close, state);
 
     AsyncCall::Pointer writeCall = commCbCall(5,4, "Ident::WriteFeedback",
                                    CommIoCbPtrFun(Ident::WriteFeedback, state));
     Comm::Write(conn, &state->queryMsg, writeCall);
     AsyncCall::Pointer readCall = commCbCall(5,4, "Ident::ReadReply",
@@ -164,13 +187,14 @@
 {
     debugs(30, 5, HERE << conn << ": Wrote IDENT request " << len << " bytes.");
 
     // TODO handle write errors better. retry or abort?
     if (flag != COMM_OK) {
         debugs(30, 2, HERE << conn << " err-flags=" << flag << " IDENT write error: " << xstrerr(xerrno));
-        conn->close();
+        IdentStateData *state = (IdentStateData *)data;
+        state->deleteThis("write error");
     }
 }
 
 void
 Ident::ReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, comm_err_t flag, int xerrno, void *data)
 {
@@ -179,13 +203,13 @@
     char *t = NULL;
 
     assert(buf == state->buf);
     assert(conn->fd == state->conn->fd);
 
     if (flag != COMM_OK || len <= 0) {
-        state->conn->close();
+        state->deleteThis("read error");
         return;
     }
 
     /*
      * XXX This isn't really very tolerant. It should read until EOL
      * or EOF and then decode the answer... If the reply is fragmented
@@ -201,17 +225,19 @@
 
     debugs(30, 5, HERE << conn << ": Read '" << buf << "'");
 
     if (strstr(buf, "USERID")) {
         if ((ident = strrchr(buf, ':'))) {
             while (xisspace(*++ident));
-            Ident::identCallback(state, ident);
+            if (ident && *ident == '\0')
+                ident = NULL;
+            state->notify(ident);
         }
     }
 
-    state->conn->close();
+    state->deleteThis("completed");
 }
 
 void
 Ident::ClientAdd(IdentStateData * state, IDCB * callback, void *callback_data)
 {
     IdentClient *c = (IdentClient *)xcalloc(1, sizeof(*c));
@@ -220,52 +246,47 @@
     c->callback_data = cbdataReference(callback_data);
 
     for (C = &state->clients; *C; C = &(*C)->next);
     *C = c;
 }
 
-CBDATA_TYPE(IdentStateData);
-
-/**** PUBLIC FUNCTIONS ****/
-
 /*
  * start a TCP connection to the peer host on port 113
  */
 void
 Ident::Start(const Comm::ConnectionPointer &conn, IDCB * callback, void *data)
 {
     IdentStateData *state;
     char key1[IDENT_KEY_SZ];
     char key2[IDENT_KEY_SZ];
     char key[IDENT_KEY_SZ];
 
-    conn->local.ToURL(key1, IDENT_KEY_SZ);
-    conn->remote.ToURL(key2, IDENT_KEY_SZ);
+    conn->local.toUrl(key1, IDENT_KEY_SZ);
+    conn->remote.toUrl(key2, IDENT_KEY_SZ);
     snprintf(key, IDENT_KEY_SZ, "%s,%s", key1, key2);
 
     if (!ident_hash) {
         Init();
     }
     if ((state = (IdentStateData *)hash_lookup(ident_hash, key)) != NULL) {
         ClientAdd(state, callback, data);
         return;
     }
 
-    CBDATA_INIT_TYPE(IdentStateData);
-    state = cbdataAlloc(IdentStateData);
+    state = new IdentStateData;
     state->hash.key = xstrdup(key);
 
     // copy the conn details. We dont want the original FD to be re-used by IDENT.
     state->conn = conn->copyDetails();
     // NP: use random port for secure outbound to IDENT_PORT
-    state->conn->local.SetPort(0);
-    state->conn->remote.SetPort(IDENT_PORT);
+    state->conn->local.port(0);
+    state->conn->remote.port(IDENT_PORT);
 
     // build our query from the original connection details
     state->queryMsg.init();
-    state->queryMsg.Printf("%d, %d\r\n", conn->remote.GetPort(), conn->local.GetPort());
+    state->queryMsg.Printf("%d, %d\r\n", conn->remote.port(), conn->local.port());
 
     ClientAdd(state, callback, data);
     hash_join(ident_hash, &state->hash);
 
     AsyncCall::Pointer call = commCbCall(30,3, "Ident::ConnectDone", CommConnectCbPtrFun(Ident::ConnectDone, state));
     AsyncJob::Start(new Comm::ConnOpener(state->conn, call, Ident::TheConfig.timeout));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ident/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ident/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ident/Makefile.in	2015-05-01 16:51:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ident/Makefile.in	2015-05-01 18:06:57.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -451,12 +497,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -494,12 +541,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -526,27 +574,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -613,13 +664,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libident.la
 libident_la_SOURCES = \
 	AclIdent.h \
 	AclIdent.cc \
 	Config.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/internal.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/internal.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/internal.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/internal.cc	2015-05-01 18:05:19.000000000 +0800
@@ -45,13 +45,13 @@
 #include "tools.h"
 #include "URL.h"
 #include "wordlist.h"
 
 /* called when we "miss" on an internal object;
  * generate known dynamic objects,
- * return HTTP_NOT_FOUND for others
+ * return Http::scNotFound for others
  */
 void
 internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest * request, StoreEntry * entry)
 {
     ErrorState *err;
     const char *upath = request->urlpath.termedBuf();
@@ -65,22 +65,22 @@
 #else
 
         const char *msgbuf = "This cache does not support Cache Digests.\n";
 #endif
 
         HttpReply *reply = new HttpReply;
-        reply->setHeaders(HTTP_NOT_FOUND, "Not Found", "text/plain", strlen(msgbuf), squid_curtime, -2);
+        reply->setHeaders(Http::scNotFound, "Not Found", "text/plain", strlen(msgbuf), squid_curtime, -2);
         entry->replaceHttpReply(reply);
         entry->append(msgbuf, strlen(msgbuf));
         entry->complete();
     } else if (0 == strncmp(upath, "/squid-internal-mgr/", 20)) {
         CacheManager::GetInstance()->Start(clientConn, request, entry);
     } else {
         debugObj(76, 1, "internalStart: unknown request:\n",
                  request, (ObjPackMethod) & httpRequestPack);
-        err = new ErrorState(ERR_INVALID_REQ, HTTP_NOT_FOUND, request);
+        err = new ErrorState(ERR_INVALID_REQ, Http::scNotFound, request);
         errorAppendEntry(entry, err);
     }
 }
 
 int
 internalCheck(const char *urlpath)
@@ -105,14 +105,14 @@
     /* convert host name to lower case */
     xstrncpy(lc_host, host, SQUIDHOSTNAMELEN);
     Tolower(lc_host);
 
     /* check for an IP address and format appropriately if found */
     Ip::Address test = lc_host;
-    if ( !test.IsAnyAddr() ) {
-        test.ToHostname(lc_host,SQUIDHOSTNAMELEN);
+    if ( !test.isAnyAddr() ) {
+        test.toHostStr(lc_host,SQUIDHOSTNAMELEN);
     }
 
     /*
      * append the domain in order to mirror the requests with appended
      * domains
      */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Address.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Address.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Address.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Address.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,42 +1,11 @@
 /*
  * DEBUG: section 14    IP Storage and Handling
  * AUTHOR: Amos Jeffries
- *
- * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from the
- *  Internet community.  Development is led by Duane Wessels of the
- *  National Laboratory for Applied Network Research and funded by the
- *  National Science Foundation.  Squid is Copyrighted (C) 1998 by
- *  the Regents of the University of California.  Please see the
- *  COPYRIGHT file for full details.  Squid incorporates software
- *  developed and/or copyrighted by other sources.  Please see the
- *  CREDITS file for full details.
- *
- *  This Ip::Address code is copyright (C) 2007 by Treehouse Networks Ltd
- *  of New Zealand. It is published and Lisenced as an extension of
- *  squid under the same conditions as the main squid application.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
+ * COPYRIGHT: GPL version 2, (C)2007-2013 Treehouse Networks Ltd.
  */
-
 #include "squid.h"
 #include "compat/inet_ntop.h"
 #include "compat/getaddrinfo.h"
 #include "Debug.h"
 #include "ip/Address.h"
 #include "ip/tools.h"
@@ -49,72 +18,81 @@
 #include <string.h>
 #endif
 #if HAVE_ARPA_INET_H
 /* for inet_ntoa() */
 #include <arpa/inet.h>
 #endif
+#if HAVE_WS2TCPIP_H
+// Windows IPv6 definitions
+#include <ws2tcpip.h>
+#endif
+
+// some OS (ie WIndows) define IN6_ADDR_EQUAL instead
+#if !defined(IN6_ARE_ADDR_EQUAL) && _SQUID_WINDOWS_
+#define IN6_ARE_ADDR_EQUAL IN6_ADDR_EQUAL
+#endif
 
 /* Debugging only. Dump the address content when a fatal assert is encountered. */
 #define IASSERT(a,b)  \
 	if(!(b)){	printf("assert \"%s\" at line %d\n", a, __LINE__); \
-		printf("Ip::Address invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
+		printf("Ip::Address invalid? with isIPv4()=%c, isIPv6()=%c\n",(isIPv4()?'T':'F'),(isIPv6()?'T':'F')); \
 		printf("ADDRESS:"); \
-		for(unsigned int i = 0; i < sizeof(m_SocketAddr.sin6_addr); ++i) { \
-			printf(" %x", m_SocketAddr.sin6_addr.s6_addr[i]); \
+		for(unsigned int i = 0; i < sizeof(mSocketAddr_.sin6_addr); ++i) { \
+			printf(" %x", mSocketAddr_.sin6_addr.s6_addr[i]); \
 		} printf("\n"); assert(b); \
 	}
 
 int
-Ip::Address::GetCIDR() const
+Ip::Address::cidr() const
 {
-    uint8_t shift,byte;
+    uint8_t shift,ipbyte;
     uint8_t bit,caught;
     int len = 0;
-    const uint8_t *ptr= m_SocketAddr.sin6_addr.s6_addr;
+    const uint8_t *ptr= mSocketAddr_.sin6_addr.s6_addr;
 
     /* Let's scan all the bits from Most Significant to Least */
     /* Until we find an "0" bit. Then, we return */
     shift=0;
 
     /* return IPv4 CIDR for any Mapped address */
     /* Thus only check the mapped bit */
 
-    if ( !IsIPv6() ) {
+    if ( !isIPv6() ) {
         shift = 12;
     }
 
-    for (; shift<sizeof(m_SocketAddr.sin6_addr) ; ++shift) {
-        byte= *(ptr+shift);
+    for (; shift<sizeof(mSocketAddr_.sin6_addr) ; ++shift) {
+        ipbyte= *(ptr+shift);
 
-        if (byte == 0xFF) {
+        if (ipbyte == 0xFF) {
             len += 8;
             continue ;  /* A short-cut */
         }
 
         for (caught = 0 , bit= 7 ; !caught && (bit <= 7); --bit) {
-            caught = ((byte & 0x80) == 0x00);  /* Found a '0' at 'bit' ? */
+            caught = ((ipbyte & 0x80) == 0x00);  /* Found a '0' at 'bit' ? */
 
             if (!caught)
                 ++len;
 
-            byte <<= 1;
+            ipbyte <<= 1;
         }
 
         if (caught)
             break; /* We have found the most significant "0" bit.  */
     }
 
     return len;
 }
 
 int
-Ip::Address::ApplyMask(Ip::Address const &mask_addr)
+Ip::Address::applyMask(Ip::Address const &mask_addr)
 {
-    uint32_t *p1 = (uint32_t*)(&m_SocketAddr.sin6_addr);
-    uint32_t const *p2 = (uint32_t const *)(&mask_addr.m_SocketAddr.sin6_addr);
-    unsigned int blen = sizeof(m_SocketAddr.sin6_addr)/sizeof(uint32_t);
+    uint32_t *p1 = (uint32_t*)(&mSocketAddr_.sin6_addr);
+    uint32_t const *p2 = (uint32_t const *)(&mask_addr.mSocketAddr_.sin6_addr);
+    unsigned int blen = sizeof(mSocketAddr_.sin6_addr)/sizeof(uint32_t);
     unsigned int changes = 0;
 
     for (unsigned int i = 0; i < blen; ++i) {
         if ((p1[i] & p2[i]) != p1[i])
             ++changes;
 
@@ -122,39 +100,39 @@
     }
 
     return changes;
 }
 
 bool
-Ip::Address::ApplyMask(const unsigned int cidr, int mtype)
+Ip::Address::applyMask(const unsigned int cidrMask, int mtype)
 {
     uint8_t clearbits = 0;
     uint8_t* p = NULL;
 
     // validation and short-cuts.
-    if (cidr > 128)
+    if (cidrMask > 128)
         return false;
 
-    if (cidr > 32 && mtype == AF_INET)
+    if (cidrMask > 32 && mtype == AF_INET)
         return false;
 
-    if (cidr == 0) {
+    if (cidrMask == 0) {
         /* CIDR /0 is NoAddr regardless of the IPv4/IPv6 protocol */
-        SetNoAddr();
+        setNoAddr();
         return true;
     }
 
-    clearbits = (uint8_t)( (mtype==AF_INET6?128:32) -cidr);
+    clearbits = (uint8_t)( (mtype==AF_INET6?128:32) - cidrMask);
 
     // short-cut
     if (clearbits == 0)
         return true;
 
-    p = (uint8_t*)(&m_SocketAddr.sin6_addr) + 15;
+    p = (uint8_t*)(&mSocketAddr_.sin6_addr) + 15;
 
-    for (; clearbits>0 && p >= (uint8_t*)&m_SocketAddr.sin6_addr ; --p ) {
+    for (; clearbits>0 && p >= (uint8_t*)&mSocketAddr_.sin6_addr ; --p ) {
         if (clearbits < 8) {
             *p &= ((0xFF << clearbits) & 0xFF);
             clearbits = 0;
         } else {
             *p &= 0x00;
             clearbits -= 8;
@@ -162,47 +140,47 @@
     }
 
     return true;
 }
 
 bool
-Ip::Address::IsSockAddr() const
+Ip::Address::isSockAddr() const
 {
-    return (m_SocketAddr.sin6_port != 0);
+    return (mSocketAddr_.sin6_port != 0);
 }
 
 bool
-Ip::Address::IsIPv4() const
+Ip::Address::isIPv4() const
 {
-    return IN6_IS_ADDR_V4MAPPED( &m_SocketAddr.sin6_addr );
+    return IN6_IS_ADDR_V4MAPPED( &mSocketAddr_.sin6_addr );
 }
 
 bool
-Ip::Address::IsIPv6() const
+Ip::Address::isIPv6() const
 {
-    return !IsIPv4();
+    return !isIPv4();
 }
 
 bool
-Ip::Address::IsAnyAddr() const
+Ip::Address::isAnyAddr() const
 {
-    return IN6_IS_ADDR_UNSPECIFIED(&m_SocketAddr.sin6_addr) || IN6_ARE_ADDR_EQUAL(&m_SocketAddr.sin6_addr, &v4_anyaddr);
+    return IN6_IS_ADDR_UNSPECIFIED(&mSocketAddr_.sin6_addr) || IN6_ARE_ADDR_EQUAL(&mSocketAddr_.sin6_addr, &v4_anyaddr);
 }
 
 /// NOTE: Does NOT clear the Port stored. Ony the Address and Type.
 void
-Ip::Address::SetAnyAddr()
+Ip::Address::setAnyAddr()
 {
-    memset(&m_SocketAddr.sin6_addr, 0, sizeof(struct in6_addr) );
+    memset(&mSocketAddr_.sin6_addr, 0, sizeof(struct in6_addr) );
 }
 
 /// NOTE: completely empties the Ip::Address structure. Address, Port, Type, everything.
 void
-Ip::Address::SetEmpty()
+Ip::Address::setEmpty()
 {
-    memset(&m_SocketAddr, 0, sizeof(m_SocketAddr) );
+    memset(&mSocketAddr_, 0, sizeof(mSocketAddr_) );
 }
 
 #if _SQUID_AIX_
 // Bug 2885 comment 78 explains.
 // In short AIX has a different netinet/in.h union definition
 const struct in6_addr Ip::Address::v4_localhost = {{{ 0x00000000, 0x00000000, 0x0000ffff, 0x7f000001 }}};
@@ -222,88 +200,88 @@
 const struct in6_addr Ip::Address::v6_noaddr = {{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}
 };
 #endif
 
 bool
-Ip::Address::SetIPv4()
+Ip::Address::setIPv4()
 {
-    if ( IsLocalhost() ) {
-        m_SocketAddr.sin6_addr = v4_localhost;
+    if ( isLocalhost() ) {
+        mSocketAddr_.sin6_addr = v4_localhost;
         return true;
     }
 
-    if ( IsAnyAddr() ) {
-        m_SocketAddr.sin6_addr = v4_anyaddr;
+    if ( isAnyAddr() ) {
+        mSocketAddr_.sin6_addr = v4_anyaddr;
         return true;
     }
 
-    if ( IsNoAddr() ) {
-        m_SocketAddr.sin6_addr = v4_noaddr;
+    if ( isNoAddr() ) {
+        mSocketAddr_.sin6_addr = v4_noaddr;
         return true;
     }
 
-    if ( IsIPv4())
+    if ( isIPv4())
         return true;
 
     // anything non-IPv4 and non-convertable is BAD.
     return false;
 }
 
 bool
-Ip::Address::IsLocalhost() const
+Ip::Address::isLocalhost() const
 {
-    return IN6_IS_ADDR_LOOPBACK( &m_SocketAddr.sin6_addr ) || IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v4_localhost );
+    return IN6_IS_ADDR_LOOPBACK( &mSocketAddr_.sin6_addr ) || IN6_ARE_ADDR_EQUAL( &mSocketAddr_.sin6_addr, &v4_localhost );
 }
 
 void
-Ip::Address::SetLocalhost()
+Ip::Address::setLocalhost()
 {
     if (Ip::EnableIpv6) {
-        m_SocketAddr.sin6_addr = in6addr_loopback;
-        m_SocketAddr.sin6_family = AF_INET6;
+        mSocketAddr_.sin6_addr = in6addr_loopback;
+        mSocketAddr_.sin6_family = AF_INET6;
     } else {
-        m_SocketAddr.sin6_addr = v4_localhost;
-        m_SocketAddr.sin6_family = AF_INET;
+        mSocketAddr_.sin6_addr = v4_localhost;
+        mSocketAddr_.sin6_family = AF_INET;
     }
 }
 
 bool
-Ip::Address::IsSiteLocal6() const
+Ip::Address::isSiteLocal6() const
 {
     // RFC 4193 the site-local allocated range is fc00::/7
     // with fd00::/8 as the only currently allocated range (so we test it first).
     // BUG: as of 2010-02 Linux and BSD define IN6_IS_ADDR_SITELOCAL() to check for fec::/10
-    return m_SocketAddr.sin6_addr.s6_addr[0] == static_cast<uint8_t>(0xfd) ||
-           m_SocketAddr.sin6_addr.s6_addr[0] == static_cast<uint8_t>(0xfc);
+    return mSocketAddr_.sin6_addr.s6_addr[0] == static_cast<uint8_t>(0xfd) ||
+           mSocketAddr_.sin6_addr.s6_addr[0] == static_cast<uint8_t>(0xfc);
 }
 
 bool
-Ip::Address::IsSlaac() const
+Ip::Address::isSiteLocalAuto() const
 {
-    return m_SocketAddr.sin6_addr.s6_addr[10] == static_cast<uint8_t>(0xff) &&
-           m_SocketAddr.sin6_addr.s6_addr[11] == static_cast<uint8_t>(0xfe);
+    return mSocketAddr_.sin6_addr.s6_addr[11] == static_cast<uint8_t>(0xff) &&
+           mSocketAddr_.sin6_addr.s6_addr[12] == static_cast<uint8_t>(0xfe);
 }
 
 bool
-Ip::Address::IsNoAddr() const
+Ip::Address::isNoAddr() const
 {
     // IFF the address == 0xff..ff (all ones)
-    return IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v6_noaddr )
-           || IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v4_noaddr );
+    return IN6_ARE_ADDR_EQUAL( &mSocketAddr_.sin6_addr, &v6_noaddr )
+           || IN6_ARE_ADDR_EQUAL( &mSocketAddr_.sin6_addr, &v4_noaddr );
 }
 
 void
-Ip::Address::SetNoAddr()
+Ip::Address::setNoAddr()
 {
-    memset(&m_SocketAddr.sin6_addr, 0xFF, sizeof(struct in6_addr) );
-    m_SocketAddr.sin6_family = AF_INET6;
+    memset(&mSocketAddr_.sin6_addr, 0xFF, sizeof(struct in6_addr) );
+    mSocketAddr_.sin6_family = AF_INET6;
 }
 
 bool
-Ip::Address::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const
+Ip::Address::getReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const
 {
     char *p = buf;
     unsigned char const *r = dat.s6_addr;
 
     /* RFC1886 says: */
     /*     4321:0:1:2:3:4:567:89ab */
@@ -324,39 +302,39 @@
     snprintf(p,10,"ip6.arpa.");
 
     return true;
 }
 
 bool
-Ip::Address::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const
+Ip::Address::getReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const
 {
     unsigned int i = (unsigned int) ntohl(dat.s_addr);
     snprintf(buf, 32, "%u.%u.%u.%u.in-addr.arpa.",
              i & 255,
              (i >> 8) & 255,
              (i >> 16) & 255,
              (i >> 24) & 255);
     return true;
 }
 
 bool
-Ip::Address::GetReverseString(char buf[MAX_IPSTRLEN], int show_type) const
+Ip::Address::getReverseString(char buf[MAX_IPSTRLEN], int show_type) const
 {
 
     if (show_type == AF_UNSPEC) {
-        show_type = IsIPv6() ? AF_INET6 : AF_INET ;
+        show_type = isIPv6() ? AF_INET6 : AF_INET ;
     }
 
-    if (show_type == AF_INET && IsIPv4()) {
-        struct in_addr* tmp = (struct in_addr*)&m_SocketAddr.sin6_addr.s6_addr[12];
-        return GetReverseString4(buf, *tmp);
-    } else if ( show_type == AF_INET6 && IsIPv6() ) {
-        return GetReverseString6(buf, m_SocketAddr.sin6_addr);
+    if (show_type == AF_INET && isIPv4()) {
+        struct in_addr* tmp = (struct in_addr*)&mSocketAddr_.sin6_addr.s6_addr[12];
+        return getReverseString4(buf, *tmp);
+    } else if ( show_type == AF_INET6 && isIPv6() ) {
+        return getReverseString6(buf, mSocketAddr_.sin6_addr);
     }
 
-    debugs(14, DBG_CRITICAL, "Unable to convert '" << NtoA(buf,MAX_IPSTRLEN) << "' to the rDNS type requested.");
+    debugs(14, DBG_CRITICAL, "Unable to convert '" << toStr(buf,MAX_IPSTRLEN) << "' to the rDNS type requested.");
 
     buf[0] = '\0';
 
     return false;
 }
 
@@ -366,163 +344,156 @@
     memcpy(this, &s, sizeof(Ip::Address));
     return *this;
 };
 
 Ip::Address::Address(const char*s)
 {
-    SetEmpty();
-    LookupHostIP(s, true);
+    setEmpty();
+    lookupHostIP(s, true);
 }
 
 bool
 Ip::Address::operator =(const char* s)
 {
-    return LookupHostIP(s, true);
+    return lookupHostIP(s, true);
 }
 
 bool
 Ip::Address::GetHostByName(const char* s)
 {
-    return LookupHostIP(s, false);
+    return lookupHostIP(s, false);
 }
 
 bool
-Ip::Address::LookupHostIP(const char *s, bool nodns)
+Ip::Address::lookupHostIP(const char *s, bool nodns)
 {
-    int err = 0;
-
-    short port = 0;
-
-    struct addrinfo *res = NULL;
-
     struct addrinfo want;
-
     memset(&want, 0, sizeof(struct addrinfo));
     if (nodns) {
         want.ai_flags = AI_NUMERICHOST; // prevent actual DNS lookups!
     }
-#if 0
-    else if (!Ip::EnableIpv6)
-        want.ai_family = AF_INET;  // maybe prevent IPv6 DNS lookups.
-#endif
 
+    int err = 0;
+    struct addrinfo *res = NULL;
     if ( (err = getaddrinfo(s, NULL, &want, &res)) != 0) {
         debugs(14,3, HERE << "Given Non-IP '" << s << "': " << gai_strerror(err) );
         /* free the memory getaddrinfo() dynamically allocated. */
-        if (res) {
+        if (res)
             freeaddrinfo(res);
-            res = NULL;
-        }
         return false;
     }
 
+    struct addrinfo *resHead = res; // we need to free the whole list later
+    if (!Ip::EnableIpv6) {
+        // if we are IPv6-disabled, use first-IPv4 instead of first-IP.
+        struct addrinfo *maybeIpv4 = res;
+        while (maybeIpv4) {
+            if (maybeIpv4->ai_family == AF_INET)
+                break;
+            maybeIpv4 = maybeIpv4->ai_next;
+        }
+        if (maybeIpv4 != NULL)
+            res = maybeIpv4;
+        // else IPv6-only host, let the caller deal with first-IP anyway.
+    }
+
     /*
      *  NP: =(sockaddr_*) may alter the port. we don't want that.
      *      all we have been given as input was an IPA.
      */
-    port = GetPort();
+    short portSaved = port();
     operator=(*res);
-    SetPort(port);
+    port(portSaved);
 
     /* free the memory getaddrinfo() dynamically allocated. */
-    freeaddrinfo(res);
-
-    res = NULL;
-
+    freeaddrinfo(resHead);
     return true;
 }
 
 Ip::Address::Address(struct sockaddr_in const &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 };
 
 Ip::Address &
 Ip::Address::operator =(struct sockaddr_in const &s)
 {
-    Map4to6((const in_addr)s.sin_addr, m_SocketAddr.sin6_addr);
-    m_SocketAddr.sin6_port = s.sin_port;
-    m_SocketAddr.sin6_family = AF_INET6;
+    map4to6((const in_addr)s.sin_addr, mSocketAddr_.sin6_addr);
+    mSocketAddr_.sin6_port = s.sin_port;
+    mSocketAddr_.sin6_family = AF_INET6;
     return *this;
 };
 
 Ip::Address &
 Ip::Address::operator =(const struct sockaddr_storage &s)
 {
     /* some AF_* magic to tell socket types apart and what we need to do */
     if (s.ss_family == AF_INET6) {
-        memcpy(&m_SocketAddr, &s, sizeof(struct sockaddr_in6));
+        memcpy(&mSocketAddr_, &s, sizeof(struct sockaddr_in6));
     } else { // convert it to our storage mapping.
         struct sockaddr_in *sin = (struct sockaddr_in*)&s;
-        m_SocketAddr.sin6_port = sin->sin_port;
-        Map4to6( sin->sin_addr, m_SocketAddr.sin6_addr);
+        mSocketAddr_.sin6_port = sin->sin_port;
+        map4to6( sin->sin_addr, mSocketAddr_.sin6_addr);
     }
     return *this;
 };
 
 Ip::Address::Address(struct sockaddr_in6 const &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 };
 
 Ip::Address &
 Ip::Address::operator =(struct sockaddr_in6 const &s)
 {
-    memcpy(&m_SocketAddr, &s, sizeof(struct sockaddr_in6));
+    memcpy(&mSocketAddr_, &s, sizeof(struct sockaddr_in6));
 
     return *this;
 };
 
 Ip::Address::Address(struct in_addr const &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 };
 
 Ip::Address &
 Ip::Address::operator =(struct in_addr const &s)
 {
-    Map4to6((const in_addr)s, m_SocketAddr.sin6_addr);
-    m_SocketAddr.sin6_family = AF_INET6;
+    map4to6((const in_addr)s, mSocketAddr_.sin6_addr);
+    mSocketAddr_.sin6_family = AF_INET6;
     return *this;
 };
 
 Ip::Address::Address(struct in6_addr const &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 };
 
 Ip::Address &
 Ip::Address::operator =(struct in6_addr const &s)
 {
 
-    memcpy(&m_SocketAddr.sin6_addr, &s, sizeof(struct in6_addr));
-    m_SocketAddr.sin6_family = AF_INET6;
+    memcpy(&mSocketAddr_.sin6_addr, &s, sizeof(struct in6_addr));
+    mSocketAddr_.sin6_family = AF_INET6;
 
     return *this;
 };
 
 Ip::Address::Address(const Ip::Address &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 }
 
-Ip::Address::Address(Ip::Address *s)
-{
-    SetEmpty();
-    if (s)
-        memcpy(this, s, sizeof(Ip::Address));
-}
-
 Ip::Address::Address(const struct hostent &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 }
 
 bool
 Ip::Address::operator =(const struct hostent &s)
 {
@@ -560,13 +531,13 @@
 
     return true;
 }
 
 Ip::Address::Address(const struct addrinfo &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 }
 
 bool
 Ip::Address::operator =(const struct addrinfo &s)
 {
@@ -619,13 +590,13 @@
     }
 
     return true;
 }
 
 void
-Ip::Address::GetAddrInfo(struct addrinfo *&dst, int force) const
+Ip::Address::getAddrInfo(struct addrinfo *&dst, int force) const
 {
     if (dst == NULL) {
         dst = new addrinfo;
     }
 
     memset(dst, 0, sizeof(struct addrinfo));
@@ -646,18 +617,18 @@
         dst->ai_protocol = IPPROTO_TCP;
 
     if (dst->ai_socktype == SOCK_DGRAM // implies UDP
             && dst->ai_protocol == 0)
         dst->ai_protocol = IPPROTO_UDP;
 
-    if (force == AF_INET6 || (force == AF_UNSPEC && Ip::EnableIpv6 && IsIPv6()) ) {
+    if (force == AF_INET6 || (force == AF_UNSPEC && Ip::EnableIpv6 && isIPv6()) ) {
         dst->ai_addr = (struct sockaddr*)new sockaddr_in6;
 
         memset(dst->ai_addr,0,sizeof(struct sockaddr_in6));
 
-        GetSockAddr(*((struct sockaddr_in6*)dst->ai_addr));
+        getSockAddr(*((struct sockaddr_in6*)dst->ai_addr));
 
         dst->ai_addrlen = sizeof(struct sockaddr_in6);
 
         dst->ai_family = ((struct sockaddr_in6*)dst->ai_addr)->sin6_family;
 
 #if 0
@@ -671,19 +642,19 @@
          * FreeBSD dies horribly when using dual-stack with it set.
          *         (43) Protocol not supported
          */
         dst->ai_protocol = IPPROTO_IPV6;
 #endif
 
-    } else if ( force == AF_INET || (force == AF_UNSPEC && IsIPv4()) ) {
+    } else if ( force == AF_INET || (force == AF_UNSPEC && isIPv4()) ) {
 
         dst->ai_addr = (struct sockaddr*)new sockaddr_in;
 
         memset(dst->ai_addr,0,sizeof(struct sockaddr_in));
 
-        GetSockAddr(*((struct sockaddr_in*)dst->ai_addr));
+        getSockAddr(*((struct sockaddr_in*)dst->ai_addr));
 
         dst->ai_addrlen = sizeof(struct sockaddr_in);
 
         dst->ai_family = ((struct sockaddr_in*)dst->ai_addr)->sin_family;
     } else {
         IASSERT("false",false);
@@ -725,19 +696,19 @@
     ai = NULL;
 }
 
 int
 Ip::Address::matchIPAddr(const Ip::Address &rhs) const
 {
-    uint8_t *l = (uint8_t*)m_SocketAddr.sin6_addr.s6_addr;
-    uint8_t *r = (uint8_t*)rhs.m_SocketAddr.sin6_addr.s6_addr;
+    uint8_t *l = (uint8_t*)mSocketAddr_.sin6_addr.s6_addr;
+    uint8_t *r = (uint8_t*)rhs.mSocketAddr_.sin6_addr.s6_addr;
 
     // loop a byte-wise compare
     // NP: match MUST be R-to-L : L-to-R produces inconsistent gt/lt results at varying CIDR
     //     expected difference on CIDR is gt/eq or lt/eq ONLY.
-    for (unsigned int i = 0 ; i < sizeof(m_SocketAddr.sin6_addr) ; ++i) {
+    for (unsigned int i = 0 ; i < sizeof(mSocketAddr_.sin6_addr) ; ++i) {
 
         if (l[i] < r[i])
             return -1;
 
         if (l[i] > r[i])
             return 1;
@@ -764,106 +735,106 @@
     return ! ( operator==(s) );
 }
 
 bool
 Ip::Address::operator <=(const Ip::Address &rhs) const
 {
-    if (IsAnyAddr() && !rhs.IsAnyAddr())
+    if (isAnyAddr() && !rhs.isAnyAddr())
         return true;
 
     return (matchIPAddr(rhs) <= 0);
 }
 
 bool
 Ip::Address::operator >=(const Ip::Address &rhs) const
 {
-    if (IsNoAddr() && !rhs.IsNoAddr())
+    if (isNoAddr() && !rhs.isNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) >= 0);
 }
 
 bool
 Ip::Address::operator >(const Ip::Address &rhs) const
 {
-    if (IsNoAddr() && !rhs.IsNoAddr())
+    if (isNoAddr() && !rhs.isNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) > 0);
 }
 
 bool
 Ip::Address::operator <(const Ip::Address &rhs) const
 {
-    if (IsAnyAddr() && !rhs.IsAnyAddr())
+    if (isAnyAddr() && !rhs.isAnyAddr())
         return true;
 
     return ( matchIPAddr(rhs) < 0);
 }
 
 unsigned short
-Ip::Address::GetPort() const
+Ip::Address::port() const
 {
-    return ntohs( m_SocketAddr.sin6_port );
+    return ntohs( mSocketAddr_.sin6_port );
 }
 
 unsigned short
-Ip::Address::SetPort(unsigned short prt)
+Ip::Address::port(unsigned short prt)
 {
-    m_SocketAddr.sin6_port = htons(prt);
+    mSocketAddr_.sin6_port = htons(prt);
 
     return prt;
 }
 
 /**
- * NtoA Given a buffer writes a readable ascii version of the IPA and/or port stored
+ * toStr Given a buffer writes a readable ascii version of the IPA and/or port stored
  *
  * Buffer must be of a size large enough to hold the converted address.
  * This size is provided in the form of a global defined variable MAX_IPSTRLEN
  * Should a buffer shorter be provided the string result will be truncated
  * at the length of the available buffer.
  *
  * A copy of the buffer is also returned for simple immediate display.
  */
 char *
-Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
+Ip::Address::toStr(char* buf, const unsigned int blen, int force) const
 {
     // Ensure we have a buffer.
     if (buf == NULL) {
         return NULL;
     }
 
     /* some external code may have blindly memset a parent. */
     /* thats okay, our default is known */
-    if ( IsAnyAddr() ) {
-        if (IsIPv6())
+    if ( isAnyAddr() ) {
+        if (isIPv6())
             memcpy(buf,"::\0", min(static_cast<unsigned int>(3),blen));
-        else if (IsIPv4())
+        else if (isIPv4())
             memcpy(buf,"0.0.0.0\0", min(static_cast<unsigned int>(8),blen));
         return buf;
     }
 
     memset(buf,0,blen); // clear buffer before write
 
     /* Pure-IPv6 CANNOT be displayed in IPv4 format. */
     /* However IPv4 CAN. */
-    if ( force == AF_INET && !IsIPv4() ) {
-        if ( IsIPv6() ) {
+    if ( force == AF_INET && !isIPv4() ) {
+        if ( isIPv6() ) {
             memcpy(buf, "{!IPv4}\0", min(static_cast<unsigned int>(8),blen));
         }
         return buf;
     }
 
-    if ( force == AF_INET6 || (force == AF_UNSPEC && IsIPv6()) ) {
+    if ( force == AF_INET6 || (force == AF_UNSPEC && isIPv6()) ) {
 
-        inet_ntop(AF_INET6, &m_SocketAddr.sin6_addr, buf, blen);
+        inet_ntop(AF_INET6, &mSocketAddr_.sin6_addr, buf, blen);
 
-    } else  if ( force == AF_INET || (force == AF_UNSPEC && IsIPv4()) ) {
+    } else  if ( force == AF_INET || (force == AF_UNSPEC && isIPv4()) ) {
 
         struct in_addr tmp;
-        GetInAddr(tmp);
+        getInAddr(tmp);
         inet_ntop(AF_INET, &tmp, buf, blen);
     } else {
         debugs(14, DBG_CRITICAL, "WARNING: Corrupt IP Address details OR required to display in unknown format (" <<
                force << "). accepted={" << AF_UNSPEC << "," << AF_INET << "," << AF_INET6 << "}");
         fprintf(stderr,"WARNING: Corrupt IP Address details OR required to display in unknown format (%d). accepted={%d,%d,%d} ",
                 force, AF_UNSPEC, AF_INET, AF_INET6);
@@ -872,124 +843,124 @@
     }
 
     return buf;
 }
 
 unsigned int
-Ip::Address::ToHostname(char *buf, const unsigned int blen) const
+Ip::Address::toHostStr(char *buf, const unsigned int blen) const
 {
     char *p = buf;
 
-    if (IsIPv6() && blen > 0) {
+    if (isIPv6() && blen > 0) {
         *p = '[';
         ++p;
     }
 
     /* 8 being space for [ ] : and port digits */
-    if ( IsIPv6() )
-        NtoA(p, blen-8, AF_INET6);
+    if ( isIPv6() )
+        toStr(p, blen-8, AF_INET6);
     else
-        NtoA(p, blen-8, AF_INET);
+        toStr(p, blen-8, AF_INET);
 
     // find the end of the new string
     while (*p != '\0' && p < buf+blen)
         ++p;
 
-    if (IsIPv6() && p < (buf+blen-1) ) {
+    if (isIPv6() && p < (buf+blen-1) ) {
         *p = ']';
         ++p;
     }
 
     /* terminate just in case. */
     *p = '\0';
 
     /* return size of buffer now used */
     return (p - buf);
 }
 
 char *
-Ip::Address::ToURL(char* buf, unsigned int blen) const
+Ip::Address::toUrl(char* buf, unsigned int blen) const
 {
     char *p = buf;
 
     // Ensure we have a buffer.
 
     if (buf == NULL) {
         return NULL;
     }
 
-    p += ToHostname(p, blen);
+    p += toHostStr(p, blen);
 
-    if (m_SocketAddr.sin6_port > 0 && p <= (buf+blen-7) ) {
+    if (mSocketAddr_.sin6_port > 0 && p <= (buf+blen-7) ) {
         // ':port' (short int) needs at most 6 bytes plus 1 for 0-terminator
-        snprintf(p, 7, ":%d", GetPort() );
+        snprintf(p, 7, ":%d", port() );
     }
 
     // force a null-terminated string
     buf[blen-1] = '\0';
 
     return buf;
 }
 
 void
-Ip::Address::GetSockAddr(struct sockaddr_storage &addr, const int family) const
+Ip::Address::getSockAddr(struct sockaddr_storage &addr, const int family) const
 {
     struct sockaddr_in *sin = NULL;
 
-    if ( family == AF_INET && !IsIPv4()) {
+    if ( family == AF_INET && !isIPv4()) {
         // FIXME INET6: caller using the wrong socket type!
-        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this);
+        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::getSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this);
         assert(false);
     }
 
-    if ( family == AF_INET6 || (family == AF_UNSPEC && IsIPv6()) ) {
+    if ( family == AF_INET6 || (family == AF_UNSPEC && isIPv6()) ) {
         struct sockaddr_in6 *ss6 = (struct sockaddr_in6*)&addr;
-        GetSockAddr(*ss6);
-    } else if ( family == AF_INET || (family == AF_UNSPEC && IsIPv4()) ) {
+        getSockAddr(*ss6);
+    } else if ( family == AF_INET || (family == AF_UNSPEC && isIPv4()) ) {
         sin = (struct sockaddr_in*)&addr;
-        GetSockAddr(*sin);
+        getSockAddr(*sin);
     } else {
         IASSERT("false",false);
     }
 }
 
 void
-Ip::Address::GetSockAddr(struct sockaddr_in &buf) const
+Ip::Address::getSockAddr(struct sockaddr_in &buf) const
 {
-    if ( IsIPv4() ) {
+    if ( isIPv4() ) {
         buf.sin_family = AF_INET;
-        buf.sin_port = m_SocketAddr.sin6_port;
-        Map6to4( m_SocketAddr.sin6_addr, buf.sin_addr);
+        buf.sin_port = mSocketAddr_.sin6_port;
+        map6to4( mSocketAddr_.sin6_addr, buf.sin_addr);
     } else {
-        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this );
+        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::getSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this );
 
         memset(&buf,0xFFFFFFFF,sizeof(struct sockaddr_in));
         assert(false);
     }
 
 #if HAVE_SIN_LEN_IN_SAI
     /* not all OS have this field, BUT when they do it can be a problem if set wrong */
     buf.sin_len = sizeof(struct sockaddr_in);
 #endif
 }
 
 void
-Ip::Address::GetSockAddr(struct sockaddr_in6 &buf) const
+Ip::Address::getSockAddr(struct sockaddr_in6 &buf) const
 {
-    memcpy(&buf, &m_SocketAddr, sizeof(struct sockaddr_in6));
+    memcpy(&buf, &mSocketAddr_, sizeof(struct sockaddr_in6));
     /* maintain address family. It may have changed inside us. */
     buf.sin6_family = AF_INET6;
 
 #if HAVE_SIN6_LEN_IN_SAI
     /* not all OS have this field, BUT when they do it can be a problem if set wrong */
     buf.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 }
 
 void
-Ip::Address::Map4to6(const struct in_addr &in, struct in6_addr &out) const
+Ip::Address::map4to6(const struct in_addr &in, struct in6_addr &out) const
 {
     /* check for special cases */
 
     if ( in.s_addr == 0x00000000) {
         /* ANYADDR */
         out = v4_anyaddr;
@@ -1004,13 +975,13 @@
         out.s6_addr[14] = ((uint8_t *)&in.s_addr)[2];
         out.s6_addr[15] = ((uint8_t *)&in.s_addr)[3];
     }
 }
 
 void
-Ip::Address::Map6to4(const struct in6_addr &in, struct in_addr &out) const
+Ip::Address::map6to4(const struct in6_addr &in, struct in_addr &out) const
 {
     /* ANYADDR */
     /* NOADDR */
     /* general */
 
     memset(&out, 0, sizeof(struct in_addr));
@@ -1018,27 +989,27 @@
     ((uint8_t *)&out.s_addr)[1] = in.s6_addr[13];
     ((uint8_t *)&out.s_addr)[2] = in.s6_addr[14];
     ((uint8_t *)&out.s_addr)[3] = in.s6_addr[15];
 }
 
 void
-Ip::Address::GetInAddr(struct in6_addr &buf) const
+Ip::Address::getInAddr(struct in6_addr &buf) const
 {
-    memcpy(&buf, &m_SocketAddr.sin6_addr, sizeof(struct in6_addr));
+    memcpy(&buf, &mSocketAddr_.sin6_addr, sizeof(struct in6_addr));
 }
 
 bool
-Ip::Address::GetInAddr(struct in_addr &buf) const
+Ip::Address::getInAddr(struct in_addr &buf) const
 {
-    if ( IsIPv4() ) {
-        Map6to4(m_SocketAddr.sin6_addr, buf);
+    if ( isIPv4() ) {
+        map6to4(mSocketAddr_.sin6_addr, buf);
         return true;
     }
 
     // default:
     // non-compatible IPv6 Pure Address
 
-    debugs(14, DBG_IMPORTANT, HERE << "Ip::Address::GetInAddr : Cannot convert non-IPv4 to IPv4. IPA=" << *this);
+    debugs(14, DBG_IMPORTANT, HERE << "Ip::Address::getInAddr : Cannot convert non-IPv4 to IPv4. IPA=" << *this);
     memset(&buf,0xFFFFFFFF,sizeof(struct in_addr));
     assert(false);
     return false;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Address.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Address.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Address.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Address.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,43 +1,13 @@
 /*
  * DEBUG: section 14    IP Storage and Handling
  * AUTHOR: Amos Jeffries
- *
- * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from the
- *  Internet community.  Development is led by Duane Wessels of the
- *  National Laboratory for Applied Network Research and funded by the
- *  National Science Foundation.  Squid is Copyrighted (C) 1998 by
- *  the Regents of the University of California.  Please see the
- *  COPYRIGHT file for full details.  Squid incorporates software
- *  developed and/or copyrighted by other sources.  Please see the
- *  CREDITS file for full details.
- *
- *  This Ip::Address code is copyright (C) 2007 by Treehouse Networks Ltd
- *  of New Zealand. It is published and Lisenced as an extension of
- *  squid under the same conditions as the main squid application.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
+ * COPYRIGHT: GPL version 2, (C)2007-2013 Treehouse Networks Ltd.
  */
-#ifndef _SQUID_IP_IPADDRESS_H
-#define _SQUID_IP_IPADDRESS_H
+#ifndef _SQUID_SRC_IP_ADDRESS_H
+#define _SQUID_SRC_IP_ADDRESS_H
 
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 #if HAVE_NETINET_IN_H
 #include <netinet/in.h>
@@ -72,24 +42,14 @@
 class Address
 {
 
 public:
     /** @name Constructors and Destructor */
     /*@{*/
-    Address() { SetEmpty(); }
-    Address(const Address &);
-
-    /**
-     * This constructor takes its own copy of the object pointed to for memory-safe usage later.
-     * The caller must itself perform and ptr memory-management needed.
-     *
-     \deprecated Use of pointers can be nasty. Consider this a last-resort.
-     *           Prefer the by-reference (&) version instead.
-     */
-    Address(Address *);
-
+    Address() { setEmpty(); }
+    Address(const Ip::Address &);
     Address(const struct in_addr &);
     Address(const struct sockaddr_in &);
     Address(const struct in6_addr &);
     Address(const struct sockaddr_in6 &);
     Address(const struct hostent &);
     Address(const struct addrinfo &);
@@ -123,163 +83,163 @@
     /* methods */
 
     /** Test whether content can be used as an IPv4 address
      \retval true  if content was received as an IPv4-Mapped address
      \retval false if content was received as a non-mapped IPv6 native address.
      */
-    bool IsIPv4() const;
+    bool isIPv4() const;
 
     /** Test whether content can be used as an IPv6 address.
      \retval true  if content is a non IPv4-mapped address.
      \retval false if content is IPv4-mapped.
      */
-    bool IsIPv6() const;
+    bool isIPv6() const;
 
     /** Test whether content can be used as a Socket address.
      \retval true  if address AND port are both set
      \retval true  if content was received as a Socket address with port
      \retval false if port in unset (zero)
      */
-    bool IsSockAddr() const;
+    bool isSockAddr() const;
 
     /** Content-neutral test for whether the specific IP case ANY_ADDR is stored.
      *  This is the default content of a new undefined Ip::Address object.
      \retval true IPv4 0.0.0.0
      \retval true IPv6 ::
      \retval false anything else.
      */
-    bool IsAnyAddr() const;
+    bool isAnyAddr() const;
 
     /** Content-neutral test for whether the specific IP case NO_ADDR is stored.
      \retval true IPv4 255.255.255.255
      \retval true IPv6 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
      \retval false anything else.
      */
-    bool IsNoAddr() const;
+    bool isNoAddr() const;
 
     /** Content-neutral test for whether the specific IP case LOCALHOST is stored.
      *  This is the default content of a new undefined Ip::Address object.
      \retval true IPv4 127.0.0.1
      \retval true IPv6 ::1
      \retval false anything else.
      */
-    bool IsLocalhost() const;
+    bool isLocalhost() const;
 
     /** Test whether content is an IPv6 Site-Local address.
      \retval true  if address begins with fd00::/8.
      \retval false if --disable-ipv6 has been compiled.
      \retval false if address does not match fd00::/8
      */
-    bool IsSiteLocal6() const;
+    bool isSiteLocal6() const;
 
     /** Test whether content is an IPv6 address with SLAAC EUI-64 embeded.
      \retval true  if address matches ::ff:fe00:0
      \retval false if --disable-ipv6 has been compiled.
      \retval false if address does not match ::ff:fe00:0
      */
-    bool IsSlaac() const;
+    bool isSiteLocalAuto() const;
 
     /*@}*/
 
     /** Retrieve the Port if stored.
      \retval 0 Port is unset or an error occured.
      \retval n Port associated with this address in host native -endian.
      */
-    unsigned short GetPort() const;
+    unsigned short port() const;
 
     /** Set the Port value for an address.
      *  Replaces any previously existing Port value.
      \param port Port being assigned in host native -endian.
      \retval 0 Port is unset or an error occured.
      \retval n Port associated with this address in host native -endian.
      */
-    unsigned short SetPort(unsigned short port);
+    unsigned short port(unsigned short port);
 
     /// Set object to contain the specific IP case ANY_ADDR (format-neutral).
-    /// see IsAnyAddr() for more detail.
-    void SetAnyAddr();
+    /// see isAnyAddr() for more detail.
+    void setAnyAddr();
 
     /// Set object to contain the specific IP case NO_ADDR (format-neutral).
-    /// see IsNoAddr() for more detail.
-    void SetNoAddr();
+    /// see isNoAddr() for more detail.
+    void setNoAddr();
 
     /// Set object to contain the specific IP case LOCALHOST (format-neutral).
-    /// see IsLocalhost() for more detail.
-    void SetLocalhost();
+    /// see isLocalhost() for more detail.
+    void setLocalhost();
 
     /// Fast reset of the stored content to what would be after default constructor.
-    void SetEmpty();
+    void setEmpty();
 
     /** Require an IPv4-only address for this usage.
      *  Converts the object to prefer only IPv4 output.
      \retval true	Content can be IPv4
      \retval false	Content CANNOT be IPv4
      */
-    bool SetIPv4();
+    bool setIPv4();
 
     /**
      *  Valid results IF and only IF the stored IP address is actually a network bitmask
      \retval N number of bits which are set in the bitmask stored.
      */
-    int GetCIDR() const;
+    int cidr() const;
 
     /** Apply a mask to the stored address.
      \param mask Netmask format to be bit-mask-AND'd over the stored address.
      */
-    int ApplyMask(const Address &mask);
+    int applyMask(const Address &mask);
 
     /** Apply a mask to the stored address.
      *  CIDR will be converted appropriate to map the stored content.
      \param cidr   CIDR Mask being applied. As an integer in host format.
      \param mtype  Type of CIDR mask being applied (AF_INET or AF_INET6)
      */
-    bool ApplyMask(const unsigned int cidr, int mtype);
+    bool applyMask(const unsigned int cidr, int mtype);
 
     /** Return the ASCII equivalent of the address
      *  Semantically equivalent to the IPv4 inet_ntoa()
      *  eg. 127.0.0.1 (IPv4) or ::1 (IPv6)
      *  But for memory safety it requires a buffer as input
      *  instead of producing one magically.
      *  If buffer is not large enough the data is truncated silently.
      \param buf Allocated buffer to write address to
      \param len byte length of buffer available for writing.
      \param force (optional) require the IPA in a specific format.
      \return pointer to buffer received.
      */
-    char* NtoA(char *buf, const unsigned int blen, int force = AF_UNSPEC) const;
+    char* toStr(char *buf, const unsigned int blen, int force = AF_UNSPEC) const;
 
     /** Return the ASCII equivalent of the address:port combination
      *  Provides a URL formatted version of the content.
      *  If buffer is not large enough the data is truncated silently.
      *  eg. 127.0.0.1:80 (IPv4) or [::1]:80 (IPv6)
      \param buf Allocated buffer to write address:port to
      \param len byte length of buffer available for writing.
      \return pointer to buffer received.
      */
-    char* ToURL(char *buf, unsigned int len) const;
+    char* toUrl(char *buf, unsigned int len) const;
 
     /** Return a properly hostname formatted copy of the address
      *  Provides a URL formatted version of the content.
      *  If buffer is not large enough the data is truncated silently.
      *  eg. 127.0.0.1 (IPv4) or [::1] (IPv6)
      \param buf Allocated buffer to write address to
      \param len byte length of buffer available for writing.
      \return amount of buffer filled.
      */
-    unsigned int ToHostname(char *buf, const unsigned int len) const;
+    unsigned int toHostStr(char *buf, const unsigned int len) const;
 
     /**
      *  Convert the content into a Reverse-DNS string.
      *  The buffer sent MUST be allocated large enough to hold the resulting string.
      *  Name truncation will occur if buf does not have enough space.
      *  The constant MAX_IPSTRLEN is defined to provide for sizing arrays correctly.
      \param show_type  may be one of: AF_INET, AF_INET6 for the format of rDNS string wanted.
      *                 AF_UNSPEC the default displays the IP in its most advanced native form.
      \param buf        buffer to receive the text string output.
      */
-    bool GetReverseString(char buf[MAX_IPSTRLEN], int show_type = AF_UNSPEC) const;
+    bool getReverseString(char buf[MAX_IPSTRLEN], int show_type = AF_UNSPEC) const;
 
     /** Test how two IP relate to each other.
      \retval  0  IP are equal
      \retval  1  IP rhs is greater (numerically) than that stored.
      \retval -1  IP rhs is less (numerically) than that stored.
      */
@@ -305,13 +265,13 @@
      *  Ip::Address allocated objects MUST be destructed by Ip::Address::FreeAddrInfo
      *  System getaddrinfo() allocated objects MUST be freed with system freeaddrinfo()
      *
      \param ai structure to be filled out.
      \param force a specific sockaddr type is needed. default: don't care.
      */
-    void GetAddrInfo(struct addrinfo *&ai, int force = AF_UNSPEC) const;
+    void getAddrInfo(struct addrinfo *&ai, int force = AF_UNSPEC) const;
 
     /**
      *  Equivalent to the sysem call freeaddrinfo() but for Ip::Address allocated data
      */
     static void FreeAddrInfo(struct addrinfo *&ai);
 
@@ -335,38 +295,38 @@
     /* FIXME: When C => C++ conversion is done will be fully private.
      * Legacy Transition Methods.
      * These are here solely to simplify the transition
      * when moving from converted code to unconverted
      * these functions can be used to convert this object
      * and pull out the data needed by the unconverted code
-     * they are intentionaly hard to use, use GetAddrInfo() instead.
+     * they are intentionaly hard to use, use getAddrInfo() instead.
      * these functiosn WILL NOT be in the final public API after transition.
      */
 
-    void GetSockAddr(struct sockaddr_storage &addr, const int family) const;
-    void GetSockAddr(struct sockaddr_in &) const;
-    bool GetInAddr(struct in_addr &) const; /* false if could not convert IPv6 down to IPv4 */
-    void GetSockAddr(struct sockaddr_in6 &) const;
-    void GetInAddr(struct in6_addr &) const;
+    void getSockAddr(struct sockaddr_storage &addr, const int family) const;
+    void getSockAddr(struct sockaddr_in &) const;
+    bool getInAddr(struct in_addr &) const; /* false if could not convert IPv6 down to IPv4 */
+    void getSockAddr(struct sockaddr_in6 &) const;
+    void getInAddr(struct in6_addr &) const;
 
 private:
     /* Conversion for dual-type internals */
 
-    bool GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const;
+    bool getReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const;
 
-    bool GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const;
+    bool getReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const;
 
-    void Map4to6(const struct in_addr &src, struct in6_addr &dest) const;
+    void map4to6(const struct in_addr &src, struct in6_addr &dest) const;
 
-    void Map6to4(const struct in6_addr &src, struct in_addr &dest) const;
+    void map6to4(const struct in6_addr &src, struct in_addr &dest) const;
 
     // Worker behind GetHostName and char* converters
-    bool LookupHostIP(const char *s, bool nodns);
+    bool lookupHostIP(const char *s, bool nodns);
 
     /* variables */
-    struct sockaddr_in6 m_SocketAddr;
+    struct sockaddr_in6 mSocketAddr_;
 
 private:
     /* Internally used constants */
     static const unsigned int STRLEN_IP4A = 16;              // aaa.bbb.ccc.ddd\0
     static const unsigned int STRLEN_IP4R = 28;              // ddd.ccc.bbb.aaa.in-addr.arpa.\0
     static const unsigned int STRLEN_IP4S = 21;              // ddd.ccc.bbb.aaa:ppppp\0
@@ -382,13 +342,13 @@
 };
 
 inline std::ostream &
 operator << (std::ostream &os, const Address &ipa)
 {
     char buf[MAX_IPSTRLEN];
-    os << ipa.ToURL(buf,MAX_IPSTRLEN);
+    os << ipa.toUrl(buf,MAX_IPSTRLEN);
     return os;
 }
 
 // WAS _sockaddr_in_list in an earlier incarnation
 class Address_list
 {
@@ -401,7 +361,7 @@
 };
 
 } // namespace Ip
 
 void parse_IpAddress_list_token(Ip::Address_list **, char *);
 
-#endif /* _SQUID_IP_IPADDRESS_H */
+#endif /* _SQUID_SRC_IP_ADDRESS_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Intercept.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Intercept.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Intercept.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Intercept.cc	2015-05-01 18:05:19.000000000 +0800
@@ -27,34 +27,51 @@
  *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
+
+// Enable hack to workaround Solaris 10 IPFilter breakage
+#define BUILDING_SQUID_IP_INTERCEPT_CC 1
+
 #include "squid.h"
 #include "comm/Connection.h"
 #include "ip/Intercept.h"
 #include "fde.h"
 #include "src/tools.h"
 
 #if IPF_TRANSPARENT
 
+#if !defined(IPFILTER_VERSION)
+#define IPFILTER_VERSION        5000004
+#endif
+
+#if HAVE_SYS_IOCCOM_H
+#include <sys/ioccom.h>
+#endif
 #if HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
+#if HAVE_NETINET_IP6_H
+#include <netinet/ip6.h>
+#endif
 #if HAVE_NETINET_TCP_H
 #include <netinet/tcp.h>
 #endif
 #if HAVE_NET_IF_H
 #include <net/if.h>
 #endif
 #if HAVE_IPL_H
 #include <ipl.h>
 #elif HAVE_NETINET_IPL_H
 #include <netinet/ipl.h>
 #endif
+#if USE_SOLARIS_IPFILTER_MINOR_T_HACK
+#undef minor_t
+#endif
 #if HAVE_IP_FIL_COMPAT_H
 #include <ip_fil_compat.h>
 #elif HAVE_NETINET_IP_FIL_COMPAT_H
 #include <netinet/ip_fil_compat.h>
 #elif HAVE_IP_COMPAT_H
 #include <ip_compat.h>
@@ -93,13 +110,27 @@
 
 #if LINUX_NETFILTER
 #if HAVE_LIMITS_H
 /* must be before including netfilter_ipv4.h */
 #include <limits.h>
 #endif
+#include <linux/if.h>
 #include <linux/netfilter_ipv4.h>
+#if HAVE_LINUX_NETFILTER_IPV6_IP6_TABLES_H
+/* 2013-07-01: Pablo the Netfilter maintainer is rejecting patches
+ * which will enable C++ compilers to build the Netfilter public headers.
+ * We can auto-detect its presence and attempt to use in case he ever
+ * changes his mind or things get cleaned up some other way.
+ * But until then are usually forced to hard-code the getsockopt() code
+ * for IPv6 NAT lookups.
+ */
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#endif
+#if !defined(IP6T_SO_ORIGINAL_DST)
+#define IP6T_SO_ORIGINAL_DST	80	// stolen with prejudice from the above file.
+#endif
 #endif /* LINUX_NETFILTER required headers */
 
 // single global instance for access by other components.
 Ip::Intercept Ip::Interceptor;
 
 void
@@ -121,73 +152,69 @@
 }
 
 bool
 Ip::Intercept::NetfilterInterception(const Comm::ConnectionPointer &newConn, int silent)
 {
 #if LINUX_NETFILTER
-    struct sockaddr_in lookup;
-    socklen_t len = sizeof(struct sockaddr_in);
-    newConn->local.GetSockAddr(lookup);
+    struct sockaddr_storage lookup;
+    socklen_t len = newConn->local.isIPv6() ? sizeof(sockaddr_in6) : sizeof(sockaddr_in);
+    newConn->local.getSockAddr(lookup, AF_UNSPEC);
 
     /** \par
      * Try NAT lookup for REDIRECT or DNAT targets. */
-    if ( getsockopt(newConn->fd, IPPROTO_IP, SO_ORIGINAL_DST, &lookup, &len) != 0) {
+    if ( getsockopt(newConn->fd,
+                    newConn->local.isIPv6() ? IPPROTO_IPV6 : IPPROTO_IP,
+                    newConn->local.isIPv6() ? IP6T_SO_ORIGINAL_DST : SO_ORIGINAL_DST,
+                    &lookup,
+                    &len) != 0) {
         if (!silent) {
-            debugs(89, DBG_IMPORTANT, HERE << " NF getsockopt(SO_ORIGINAL_DST) failed on " << newConn << ": " << xstrerror());
+            debugs(89, DBG_IMPORTANT, "ERROR: NF getsockopt(ORIGINAL_DST) failed on " << newConn << ": " << xstrerror());
             lastReported_ = squid_curtime;
         }
-        debugs(89, 9, HERE << "address: " << newConn);
+        debugs(89, 9, "address: " << newConn);
         return false;
     } else {
         newConn->local = lookup;
-        debugs(89, 5, HERE << "address NAT: " << newConn);
+        debugs(89, 5, "address NAT: " << newConn);
         return true;
     }
 #endif
     return false;
 }
 
 bool
-Ip::Intercept::NetfilterTransparent(const Comm::ConnectionPointer &newConn, int silent)
+Ip::Intercept::TproxyTransparent(const Comm::ConnectionPointer &newConn, int silent)
 {
-#if LINUX_NETFILTER
+#if (LINUX_NETFILTER && defined(IP_TRANSPARENT)) || \
+    (PF_TRANSPARENT && defined(SO_BINDANY)) || \
+    (IPFW_TRANSPARENT && defined(IP_BINDANY))
+
     /* Trust the user configured properly. If not no harm done.
      * We will simply attempt a bind outgoing on our own IP.
      */
-    newConn->remote.SetPort(0); // allow random outgoing port to prevent address clashes
+    newConn->remote.port(0); // allow random outgoing port to prevent address clashes
     debugs(89, 5, HERE << "address TPROXY: " << newConn);
     return true;
 #else
     return false;
 #endif
 }
 
 bool
 Ip::Intercept::IpfwInterception(const Comm::ConnectionPointer &newConn, int silent)
 {
 #if IPFW_TRANSPARENT
-    struct sockaddr_storage lookup;
-    socklen_t len = sizeof(struct sockaddr_storage);
-    newConn->local.GetSockAddr(lookup, AF_INET);
-
-    /** \par
-     * Try lookup for IPFW interception. */
-    if ( getsockname(newConn->fd, (struct sockaddr*)&lookup, &len) != 0 ) {
-        if ( !silent ) {
-            debugs(89, DBG_IMPORTANT, HERE << " IPFW getsockname(...) failed: " << xstrerror());
-            lastReported_ = squid_curtime;
-        }
-        debugs(89, 9, HERE << "address: " << newConn);
-        return false;
-    } else {
-        newConn->local = lookup;
-        debugs(89, 5, HERE << "address NAT: " << newConn);
-        return true;
-    }
-#endif
+    /* The getsockname() call performed already provided the TCP packet details.
+     * There is no way to identify whether they came from NAT or not.
+     * Trust the user configured properly.
+     */
+    debugs(89, 5, HERE << "address NAT: " << newConn);
+    return true;
+#else
     return false;
+#endif
 }
 
 bool
 Ip::Intercept::IpfInterception(const Comm::ConnectionPointer &newConn, int silent)
 {
 #if IPF_TRANSPARENT  /* --enable-ipf-transparent */
@@ -196,16 +223,16 @@
     static int natfd = -1;
     int x;
 
     // all fields must be set to 0
     memset(&natLookup, 0, sizeof(natLookup));
     // for NAT lookup set local and remote IP:port's
-    natLookup.nl_inport = htons(newConn->local.GetPort());
-    newConn->local.GetInAddr(natLookup.nl_inip);
-    natLookup.nl_outport = htons(newConn->remote.GetPort());
-    newConn->remote.GetInAddr(natLookup.nl_outip);
+    natLookup.nl_inport = htons(newConn->local.port());
+    newConn->local.getInAddr(natLookup.nl_inip);
+    natLookup.nl_outport = htons(newConn->remote.port());
+    newConn->remote.getInAddr(natLookup.nl_outip);
     // ... and the TCP flag
     natLookup.nl_flags = IPN_TCP;
 
     if (natfd < 0) {
         int save_errno;
         enter_suid();
@@ -265,40 +292,37 @@
         }
 
         debugs(89, 9, HERE << "address: " << newConn);
         return false;
     } else {
         newConn->local = natLookup.nl_realip;
-        newConn->local.SetPort(ntohs(natLookup.nl_realport));
+        newConn->local.port(ntohs(natLookup.nl_realport));
         debugs(89, 5, HERE << "address NAT: " << newConn);
         return true;
     }
 
 #endif /* --enable-ipf-transparent */
     return false;
 }
 
 bool
-Ip::Intercept::PfTransparent(const Comm::ConnectionPointer &newConn, int silent)
+Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent)
 {
-#if PF_TRANSPARENT && defined(SO_BINDANY)
-    /* Trust the user configured properly. If not no harm done.
-     * We will simply attempt a bind outgoing on our own IP.
+#if PF_TRANSPARENT  /* --enable-pf-transparent */
+
+#if !USE_NAT_DEVPF
+    /* On recent PF versions the getsockname() call performed already provided
+     * the required TCP packet details.
+     * There is no way to identify whether they came from NAT or not.
+     *
+     * Trust the user configured properly.
      */
-    newConn->remote.SetPort(0); // allow random outgoing port to prevent address clashes
-    debugs(89, 5, HERE << "address DIVERT: " << newConn);
+    debugs(89, 5, HERE << "address NAT divert-to: " << newConn);
     return true;
-#else
-    return false;
-#endif
-}
 
-bool
-Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent)
-{
-#if PF_TRANSPARENT  /* --enable-pf-transparent */
+#else /* USE_NAT_DEVPF / --with-nat-devpf */
 
     struct pfioc_natlook nl;
     static int pffd = -1;
 
     if (pffd < 0)
         pffd = open("/dev/pf", O_RDONLY);
@@ -309,17 +333,17 @@
             lastReported_ = squid_curtime;
         }
         return false;
     }
 
     memset(&nl, 0, sizeof(struct pfioc_natlook));
-    newConn->remote.GetInAddr(nl.saddr.v4);
-    nl.sport = htons(newConn->remote.GetPort());
+    newConn->remote.getInAddr(nl.saddr.v4);
+    nl.sport = htons(newConn->remote.port());
 
-    newConn->local.GetInAddr(nl.daddr.v4);
-    nl.dport = htons(newConn->local.GetPort());
+    newConn->local.getInAddr(nl.daddr.v4);
+    nl.dport = htons(newConn->local.port());
 
     nl.af = AF_INET;
     nl.proto = IPPROTO_TCP;
     nl.direction = PF_OUT;
 
     if (ioctl(pffd, DIOCNATLOOK, &nl)) {
@@ -332,17 +356,17 @@
             pffd = -1;
         }
         debugs(89, 9, HERE << "address: " << newConn);
         return false;
     } else {
         newConn->local = nl.rdaddr.v4;
-        newConn->local.SetPort(ntohs(nl.rdport));
+        newConn->local.port(ntohs(nl.rdport));
         debugs(89, 5, HERE << "address NAT: " << newConn);
         return true;
     }
-
+#endif /* --with-nat-devpf */
 #endif /* --enable-pf-transparent */
     return false;
 }
 
 bool
 Ip::Intercept::Lookup(const Comm::ConnectionPointer &newConn, const Comm::ConnectionPointer &listenConn)
@@ -364,20 +388,15 @@
     debugs(89, 5, HERE << "address BEGIN: me/client= " << newConn->local << ", destination/me= " << newConn->remote);
 
     newConn->flags |= (listenConn->flags & (COMM_TRANSPARENT|COMM_INTERCEPTION));
 
     /* NP: try TPROXY first, its much quieter than NAT when non-matching */
     if (transparentActive_ && listenConn->flags&COMM_TRANSPARENT) {
-        if (NetfilterTransparent(newConn, silent)) return true;
-        if (PfTransparent(newConn, silent)) return true;
+        if (TproxyTransparent(newConn, silent)) return true;
     }
 
-    /* NAT is only available in IPv4 */
-    if ( !newConn->local.IsIPv4()  ) return false;
-    if ( !newConn->remote.IsIPv4() ) return false;
-
     if (interceptActive_ && listenConn->flags&COMM_INTERCEPTION) {
         /* NAT methods that use sock-opts to return client address */
         if (NetfilterInterception(newConn, silent)) return true;
         if (IpfwInterception(newConn, silent)) return true;
 
         /* NAT methods that use ioctl to return client address AND destination address */
@@ -392,110 +411,97 @@
     return false;
 }
 
 bool
 Ip::Intercept::ProbeForTproxy(Ip::Address &test)
 {
-#if defined(IP_TRANSPARENT)
+    bool doneSuid = false;
+
+#if _SQUID_LINUX_ && defined(IP_TRANSPARENT) // Linux
+# define soLevel SOL_IP
+# define soFlag  IP_TRANSPARENT
+
+#elif defined(SO_BINDANY) // OpenBSD 4.7+ and NetBSD with PF
+# define soLevel SOL_SOCKET
+# define soFlag  SO_BINDANY
+    enter_suid();
+    doneSuid = true;
+
+#elif defined(IP_BINDANY) // FreeBSD with IPFW
+# define soLevel IPPROTO_IP
+# define soFlag  IP_BINDANY
+    enter_suid();
+    doneSuid = true;
+
+#endif
+
+#if defined(soLevel) && defined(soFlag)
+
     debugs(3, 3, "Detect TPROXY support on port " << test);
 
     int tos = 1;
     int tmp_sock = -1;
 
     /* Probe to see if the Kernel TPROXY support is IPv6-enabled */
-    if (test.IsIPv6()) {
+    if (test.isIPv6()) {
         debugs(3, 3, "...Probing for IPv6 TPROXY support.");
 
         struct sockaddr_in6 tmp_ip6;
         Ip::Address tmp = "::2";
-        tmp.SetPort(0);
-        tmp.GetSockAddr(tmp_ip6);
+        tmp.port(0);
+        tmp.getSockAddr(tmp_ip6);
 
         if ( (tmp_sock = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP)) >= 0 &&
-                setsockopt(tmp_sock, SOL_IP, IP_TRANSPARENT, (char *)&tos, sizeof(int)) == 0 &&
+                setsockopt(tmp_sock, soLevel, soFlag, (char *)&tos, sizeof(int)) == 0 &&
                 bind(tmp_sock, (struct sockaddr*)&tmp_ip6, sizeof(struct sockaddr_in6)) == 0 ) {
 
             debugs(3, 3, "IPv6 TPROXY support detected. Using.");
             close(tmp_sock);
+            if (doneSuid)
+                leave_suid();
             return true;
         }
         if (tmp_sock >= 0) {
             close(tmp_sock);
             tmp_sock = -1;
         }
     }
 
-    if ( test.IsIPv6() && !test.SetIPv4() ) {
+    if ( test.isIPv6() && !test.setIPv4() ) {
         debugs(3, DBG_CRITICAL, "TPROXY lacks IPv6 support for " << test );
+        if (doneSuid)
+            leave_suid();
         return false;
     }
 
     /* Probe to see if the Kernel TPROXY support is IPv4-enabled (aka present) */
-    if (test.IsIPv4()) {
+    if (test.isIPv4()) {
         debugs(3, 3, "...Probing for IPv4 TPROXY support.");
 
         struct sockaddr_in tmp_ip4;
         Ip::Address tmp = "127.0.0.2";
-        tmp.SetPort(0);
-        tmp.GetSockAddr(tmp_ip4);
+        tmp.port(0);
+        tmp.getSockAddr(tmp_ip4);
 
         if ( (tmp_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) >= 0 &&
-                setsockopt(tmp_sock, SOL_IP, IP_TRANSPARENT, (char *)&tos, sizeof(int)) == 0 &&
+                setsockopt(tmp_sock, soLevel, soFlag, (char *)&tos, sizeof(int)) == 0 &&
                 bind(tmp_sock, (struct sockaddr*)&tmp_ip4, sizeof(struct sockaddr_in)) == 0 ) {
 
             debugs(3, 3, "IPv4 TPROXY support detected. Using.");
             close(tmp_sock);
+            if (doneSuid)
+                leave_suid();
             return true;
         }
         if (tmp_sock >= 0) {
             close(tmp_sock);
         }
     }
 
-#elif defined(SO_BINDANY)
-    debugs(3, 3, "Detect BINDANY support on port " << test);
-
-    int tos = 1;
-    int tmp_sock = -1;
-
-    if (test.IsIPv6()) {
-        debugs(3, 3, "...Probing for IPv6 SO_BINDANY support.");
-
-        struct sockaddr_in6 tmp_ip6;
-        Ip::Address tmp = "::2";
-        tmp.SetPort(0);
-        tmp.GetSockAddr(tmp_ip6);
-
-        if ((tmp_sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP)) >=0 &&
-                (setsockopt(tmp_sock, SOL_SOCKET, SO_BINDANY, (char *)&tos,
-                            sizeof(tos)) == 0) &&
-                (bind(tmp_sock, (struct sockaddr*)&tmp_ip6, sizeof(struct sockaddr_in6)) == 0)) {
-            debugs(3, 3, "IPv6 BINDANY support detected. Using.");
-            close(tmp_sock);
-            return true;
-        }
-    }
-
-    if (test.IsIPv4()) {
-        debugs(3, 3, "...Probing for IPv4 SO_BINDANY support.");
-
-        struct sockaddr_in tmp_ip4;
-        Ip::Address tmp = "127.0.0.2";
-        tmp.SetPort(0);
-        tmp.GetSockAddr(tmp_ip4);
-
-        if ((tmp_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) >=0 &&
-                (setsockopt(tmp_sock, SOL_SOCKET, SO_BINDANY, (char *)&tos,
-                            sizeof(tos)) == 0) &&
-                (bind(tmp_sock, (struct sockaddr*)&tmp_ip4, sizeof(struct sockaddr_in)) == 0)) {
-            debugs(3, 3, "IPv4 BINDANY support detected. Using.");
-            close(tmp_sock);
-            return true;
-        }
-    }
-
 #else
     debugs(3, 3, "TPROXY setsockopt() not supported on this platform. Disabling TPROXY.");
 
 #endif
+    if (doneSuid)
+        leave_suid();
     return false;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Intercept.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Intercept.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Intercept.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Intercept.h	2015-05-01 18:05:19.000000000 +0800
@@ -85,28 +85,29 @@
      */
     inline void StopInterception(const char *str);
 
 private:
 
     /**
-     * perform Lookups on Netfilter interception targets (REDIRECT, DNAT).
+     * perform Lookups on fully-transparent interception targets (TPROXY).
+     * Supports Netfilter, PF and IPFW.
      *
      * \param silent   0 if errors are to be displayed. 1 if errors are to be hidden.
      * \param newConn  Details known, to be updated where relevant.
      * \return         Whether successfuly located the new address.
      */
-    bool NetfilterInterception(const Comm::ConnectionPointer &newConn, int silent);
+    bool TproxyTransparent(const Comm::ConnectionPointer &newConn, int silent);
 
     /**
-     * perform Lookups on Netfilter fully-transparent interception targets (TPROXY).
+     * perform Lookups on Netfilter interception targets (REDIRECT, DNAT).
      *
      * \param silent   0 if errors are to be displayed. 1 if errors are to be hidden.
      * \param newConn  Details known, to be updated where relevant.
      * \return         Whether successfuly located the new address.
      */
-    bool NetfilterTransparent(const Comm::ConnectionPointer &newConn, int silent);
+    bool NetfilterInterception(const Comm::ConnectionPointer &newConn, int silent);
 
     /**
      * perform Lookups on IPFW interception.
      *
      * \param silent   0 if errors are to be displayed. 1 if errors are to be hidden.
      * \param newConn  Details known, to be updated where relevant.
@@ -129,21 +130,12 @@
      * \param silent   0 if errors are to be displayed. 1 if errors are to be hidden.
      * \param newConn  Details known, to be updated where relevant.
      * \return         Whether successfuly located the new address.
      */
     bool PfInterception(const Comm::ConnectionPointer &newConn, int silent);
 
-    /**
-     * perform Lookups on PF fully-transparent interception target (DIVERT).
-     *
-     * \param silent   0 if errors are to be displayed. 1 if errors are to be hidden.
-     * \param newConn  Details known, to be updated where relevant.
-     * \return         Whether successfuly located the new address.
-     */
-    bool PfTransparent(const Comm::ConnectionPointer &newConn, int silent);
-
     int transparentActive_;
     int interceptActive_;
     time_t lastReported_; /**< Time of last error report. Throttles NAT error display to 1 per minute */
 };
 
 #if LINUX_NETFILTER && !defined(IP_TRANSPARENT)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Makefile.in	2015-05-01 16:51:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Makefile.in	2015-05-01 18:06:58.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -115,13 +161,14 @@
 nodist_testIpAddress_OBJECTS = stub_debug.$(OBJEXT) \
 	stub_tools.$(OBJEXT) testMain.$(OBJEXT)
 testIpAddress_OBJECTS = $(am_testIpAddress_OBJECTS) \
 	$(nodist_testIpAddress_OBJECTS)
 am__DEPENDENCIES_1 =
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_2 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_3 = $(am__DEPENDENCIES_2)
+am__DEPENDENCIES_3 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_2)
 testIpAddress_DEPENDENCIES = libip.la $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1)
 testIpAddress_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
 	$(AM_CXXFLAGS) $(CXXFLAGS) $(testIpAddress_LDFLAGS) $(LDFLAGS) \
@@ -468,12 +515,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -511,12 +559,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -543,27 +592,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -629,13 +681,13 @@
 CLEANFILES = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libip.la
 libip_la_SOURCES = \
 	forward.h \
 	Address.h \
 	Address.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Qos.cci /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Qos.cci
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/Qos.cci	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/Qos.cci	2015-05-01 18:05:19.000000000 +0800
@@ -8,26 +8,26 @@
     // Bug 3731: FreeBSD produces 'invalid option'
     // unless we pass it a 32-bit variable storing 8-bits of data.
     // NP: it is documented as 'int' for all systems, even those like Linux which accept 8-bit char
     //     so we convert to a int before setting.
     int bTos = tos;
 
-    if (conn->remote.IsIPv4()) {
+    if (conn->remote.isIPv4()) {
 #if defined(IP_TOS)
         int x = setsockopt(conn->fd, IPPROTO_IP, IP_TOS, &bTos, sizeof(bTos));
         if (x < 0)
             debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IP_TOS) on " << conn << ": " << xstrerror());
         else
             conn->tos = tos;
         return x;
 #else
         debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(IP_TOS) not supported on this platform");
         return -1;
 #endif
 
-    } else { // if (conn->remote.IsIPv6()) {
+    } else { // if (conn->remote.isIPv6()) {
 #if defined(IPV6_TCLASS)
         int x = setsockopt(conn->fd, IPPROTO_IPV6, IPV6_TCLASS, &bTos, sizeof(bTos));
         if (x < 0)
             debugs(50, 2, "Ip::Qos::setSockTos: setsockopt(IPV6_TCLASS) on " << conn << ": " << xstrerror());
         else
             conn->tos = tos;
@@ -45,12 +45,14 @@
 Ip::Qos::setSockNfmark(const Comm::ConnectionPointer &conn, nfmark_t mark)
 {
 #if SO_MARK && USE_LIBCAP
     int x = setsockopt(conn->fd, SOL_SOCKET, SO_MARK, &mark, sizeof(nfmark_t));
     if (x < 0)
         debugs(50, 2, "setSockNfmark: setsockopt(SO_MARK) on " << conn << ": " << xstrerror());
+    else
+        conn->nfmark = mark;
     return x;
 #elif USE_LIBCAP
     debugs(50, DBG_IMPORTANT, "WARNING: setsockopt(SO_MARK) not supported on this platform");
     return -1;
 #else
     debugs(50, DBG_IMPORTANT, "WARNING: Netfilter marking disabled (netfilter marking requires build with LIBCAP)");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/QosConfig.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/QosConfig.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/QosConfig.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/QosConfig.cc	2015-05-01 18:05:19.000000000 +0800
@@ -63,33 +63,33 @@
 
         /* Prepare data needed to find the connection in the conntrack table.
          * We need the local and remote IP address, and the local and remote
          * port numbers.
          */
 
-        if (Ip::EnableIpv6 && server->local.IsIPv6()) {
+        if (Ip::EnableIpv6 && server->local.isIPv6()) {
             nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET6);
             struct in6_addr serv_fde_remote_ip6;
-            server->remote.GetInAddr(serv_fde_remote_ip6);
+            server->remote.getInAddr(serv_fde_remote_ip6);
             nfct_set_attr(ct, ATTR_IPV6_DST, serv_fde_remote_ip6.s6_addr);
             struct in6_addr serv_fde_local_ip6;
-            server->local.GetInAddr(serv_fde_local_ip6);
+            server->local.getInAddr(serv_fde_local_ip6);
             nfct_set_attr(ct, ATTR_IPV6_SRC, serv_fde_local_ip6.s6_addr);
         } else {
             nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET);
             struct in_addr serv_fde_remote_ip;
-            server->remote.GetInAddr(serv_fde_remote_ip);
+            server->remote.getInAddr(serv_fde_remote_ip);
             nfct_set_attr_u32(ct, ATTR_IPV4_DST, serv_fde_remote_ip.s_addr);
             struct in_addr serv_fde_local_ip;
-            server->local.GetInAddr(serv_fde_local_ip);
+            server->local.getInAddr(serv_fde_local_ip);
             nfct_set_attr_u32(ct, ATTR_IPV4_SRC, serv_fde_local_ip.s_addr);
         }
 
         nfct_set_attr_u8(ct, ATTR_L4PROTO, IPPROTO_TCP);
-        nfct_set_attr_u16(ct, ATTR_PORT_DST, htons(server->remote.GetPort()));
-        nfct_set_attr_u16(ct, ATTR_PORT_SRC, htons(server->local.GetPort()));
+        nfct_set_attr_u16(ct, ATTR_PORT_DST, htons(server->remote.port()));
+        nfct_set_attr_u16(ct, ATTR_PORT_SRC, htons(server->local.port()));
 
         /* Open a handle to the conntrack */
         if (struct nfct_handle *h = nfct_open(CONNTRACK, 0)) {
             /* Register the callback. The callback function will record the mark value. */
             nfct_callback_register(h, NFCT_T_ALL, getNfMarkCallback, (void *)clientFde);
             /* Query the conntrack table using the data previously set */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/QosConfig.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/QosConfig.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/QosConfig.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/QosConfig.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,9 +1,10 @@
 #ifndef SQUID_QOSCONFIG_H
 #define SQUID_QOSCONFIG_H
 
+#include "acl/forward.h"
 #include "hier_code.h"
 #include "ip/forward.h"
 
 #if HAVE_LIBNETFILTER_CONNTRACK_LIBNETFILTER_CONNTRACK_H
 #include <libnetfilter_conntrack/libnetfilter_conntrack.h>
 #endif
@@ -13,13 +14,12 @@
 #endif
 
 #if HAVE_LIMITS
 #include <limits>
 #endif
 
-class ACLList;
 class fde;
 
 // TODO: move to new ACL framework
 // not integrated in namespace, as this class uses a strange CBDATA definition
 // POD
 class acl_tos
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/testAddress.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/testAddress.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/testAddress.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/testAddress.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,18 +35,18 @@
 void
 testIpAddress::testDefaults()
 {
     Ip::Address anIPA;
 
     /* test stored values */
-    CPPUNIT_ASSERT( anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( anIPA.IsIPv6() );
+    CPPUNIT_ASSERT( anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( anIPA.isIPv6() );
 }
 
 void
 testIpAddress::testInAddrConstructor()
 {
     struct in_addr inval;
@@ -55,19 +55,19 @@
     inval.s_addr = htonl(0xC0A8640C);
     outval.s_addr = htonl(0x00000000);
 
     Ip::Address anIPA(inval);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp(&inval, &outval, sizeof(struct in_addr)) == 0 );
 }
 
 void
 testIpAddress::testInAddr6Constructor()
 {
@@ -79,19 +79,19 @@
     inval.s6_addr32[2] = htonl(0xFFFFFFFF);
     inval.s6_addr32[3] = htonl(0xFFFFFFFF);
 
     Ip::Address anIPA(inval);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !anIPA.isIPv4() );
+    CPPUNIT_ASSERT( anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &inval, &outval, sizeof(struct in6_addr)) == 0 );
 }
 
 void
 testIpAddress::testSockAddrConstructor()
 {
@@ -108,19 +108,19 @@
     insock.sin_len = sizeof(struct sockaddr_in);
 #endif
 
     Ip::Address anIPA(insock);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.GetPort() );
-    anIPA.GetSockAddr(outsock);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT( anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.port() );
+    anIPA.getSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in)) == 0 );
 }
 
 void
 testIpAddress::testSockAddr6Constructor()
 {
@@ -140,19 +140,19 @@
     insock.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 
     Ip::Address anIPA((const struct sockaddr_in6)insock);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.GetPort() );
-    anIPA.GetSockAddr(outsock);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !anIPA.isIPv4() );
+    CPPUNIT_ASSERT( anIPA.isIPv6() );
+    CPPUNIT_ASSERT( anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.port() );
+    anIPA.getSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in6)) == 0 );
 }
 
 void
 testIpAddress::testCopyConstructor()
 {
@@ -170,19 +170,19 @@
 #endif
 
     Ip::Address inIPA(insock);
     Ip::Address outIPA(inIPA);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !outIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !outIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( outIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !outIPA.IsIPv6() );
-    CPPUNIT_ASSERT( outIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , outIPA.GetPort() );
-    outIPA.GetSockAddr(outsock);
+    CPPUNIT_ASSERT( !outIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !outIPA.isNoAddr() );
+    CPPUNIT_ASSERT( outIPA.isIPv4() );
+    CPPUNIT_ASSERT( !outIPA.isIPv6() );
+    CPPUNIT_ASSERT( outIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , outIPA.port() );
+    outIPA.getSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in)) == 0 );
 }
 
 void
 testIpAddress::testHostentConstructor()
 {
@@ -195,19 +195,19 @@
     hp = gethostbyname("192.168.100.12");
     CPPUNIT_ASSERT( hp != NULL /* gethostbyname failure.*/ );
 
     Ip::Address anIPA(*hp);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 }
 
 void
 testIpAddress::testStringConstructor()
 {
@@ -216,19 +216,19 @@
 
     expectval.s_addr = htonl(0xC0A8640C);
 
     Ip::Address anIPA = "192.168.100.12";
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
     struct in6_addr expectv6;
     struct in6_addr outval6;
 
     expectv6.s6_addr32[0] = htonl(0x20000800);
@@ -236,71 +236,71 @@
     expectv6.s6_addr32[2] = htonl(0x00000000);
     expectv6.s6_addr32[3] = htonl(0x00000045);
 
     Ip::Address bnIPA = "2000:800::45";
 
 //char test[256];
-//bnIPA.NtoA(test, 256);
+//bnIPA.toStr(test, 256);
 //printf("bnIPA: %s\n", test);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !bnIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !bnIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !bnIPA.IsIPv4() );
-    CPPUNIT_ASSERT(  bnIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !bnIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , bnIPA.GetPort() );
-    bnIPA.GetInAddr(outval6);
+    CPPUNIT_ASSERT( !bnIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !bnIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !bnIPA.isIPv4() );
+    CPPUNIT_ASSERT(  bnIPA.isIPv6() );
+    CPPUNIT_ASSERT( !bnIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , bnIPA.port() );
+    bnIPA.getInAddr(outval6);
     CPPUNIT_ASSERT( memcmp( &expectv6, &outval6, sizeof(struct in6_addr)) == 0 );
 
     /* test IPv6 as an old netmask format. This is invalid but sometimes use. */
     Ip::Address cnIPA = "ffff:ffff:fff0::";
 
     expectv6.s6_addr32[0] = htonl(0xFFFFFFFF);
     expectv6.s6_addr32[1] = htonl(0xFFF00000);
     expectv6.s6_addr32[2] = htonl(0x00000000);
     expectv6.s6_addr32[3] = htonl(0x00000000);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !cnIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !cnIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !cnIPA.IsIPv4() );
-    CPPUNIT_ASSERT( cnIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !cnIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , cnIPA.GetPort() );
-    cnIPA.GetInAddr(outval6);
+    CPPUNIT_ASSERT( !cnIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !cnIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !cnIPA.isIPv4() );
+    CPPUNIT_ASSERT( cnIPA.isIPv6() );
+    CPPUNIT_ASSERT( !cnIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , cnIPA.port() );
+    cnIPA.getInAddr(outval6);
     CPPUNIT_ASSERT( memcmp( &expectv6, &outval6, sizeof(struct in6_addr)) == 0 );
 }
 
 void
-testIpAddress::testSetEmpty()
+testIpAddress::testsetEmpty()
 {
     Ip::Address anIPA;
     struct in_addr inval;
 
     inval.s_addr = htonl(0xC0A8640C);
 
     anIPA = inval;
 
     /* test stored values before empty */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
 
-    anIPA.SetEmpty();
+    anIPA.setEmpty();
 
     /* test stored values after empty */
-    CPPUNIT_ASSERT( anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT( anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !anIPA.isIPv4() );
+    CPPUNIT_ASSERT( anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
 }
 
 void
 testIpAddress::testBooleans()
 {
     Ip::Address lhsIPA;
@@ -320,25 +320,25 @@
     CPPUNIT_ASSERT(  ( lhsIPA >= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA >  rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA <= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA <  rhsIPA ) );
 
     /* test equality versus ANYADDR */
-    lhsIPA.SetAnyAddr();
-    rhsIPA.SetAnyAddr();
+    lhsIPA.setAnyAddr();
+    rhsIPA.setAnyAddr();
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) == 0 );
     CPPUNIT_ASSERT(  ( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA != rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA >= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA >  rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA <= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA <  rhsIPA ) );
 
     /* test equality versus NOADDR */
-    lhsIPA.SetNoAddr();
-    rhsIPA.SetNoAddr();
+    lhsIPA.setNoAddr();
+    rhsIPA.setNoAddr();
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) == 0 );
     CPPUNIT_ASSERT(  ( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA != rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA >= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA >  rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA <= rhsIPA ) );
@@ -353,25 +353,25 @@
     CPPUNIT_ASSERT( !( lhsIPA >= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA >  rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA <= rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA <  rhsIPA ) );
 
     /* test inequality versus ANYADDR (less than) */
-    lhsIPA.SetAnyAddr();
+    lhsIPA.setAnyAddr();
     rhsIPA = valHigh;
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) < 0 );
     CPPUNIT_ASSERT( !( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA != rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA >= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA >  rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA <= rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA <  rhsIPA ) );
 
     /* test inequality versus NOADDR (less than) */
     lhsIPA = valLow;
-    rhsIPA.SetNoAddr();
+    rhsIPA.setNoAddr();
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) < 0 );
     CPPUNIT_ASSERT( !( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA != rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA >= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA >  rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA <= rhsIPA ) );
@@ -387,89 +387,89 @@
     CPPUNIT_ASSERT(  ( lhsIPA >  rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA <= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA <  rhsIPA ) );
 
     /* test inequality (greater than) */
     lhsIPA = valHigh;
-    rhsIPA.SetAnyAddr();
+    rhsIPA.setAnyAddr();
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) > 0 );
     CPPUNIT_ASSERT( !( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA != rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA >= rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA >  rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA <= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA <  rhsIPA ) );
 
     /* test inequality versus NOADDR (greater than) */
-    lhsIPA.SetNoAddr();
+    lhsIPA.setNoAddr();
     rhsIPA = valLow;
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) > 0 );
     CPPUNIT_ASSERT( !( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA != rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA >= rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA >  rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA <= rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA <  rhsIPA ) );
 
 }
 
 void
-testIpAddress::testNtoA()
+testIpAddress::testtoStr()
 {
     struct in_addr inval;
     char buf[MAX_IPSTRLEN];
     Ip::Address anIPA;
 
-    anIPA.SetAnyAddr();
+    anIPA.setAnyAddr();
 
     /* test AnyAddr display values */
-    CPPUNIT_ASSERT( memcmp("::", anIPA.NtoA(buf,MAX_IPSTRLEN), 2) == 0 );
+    CPPUNIT_ASSERT( memcmp("::", anIPA.toStr(buf,MAX_IPSTRLEN), 2) == 0 );
 
     inval.s_addr = htonl(0xC0A8640C);
     anIPA = inval;
 
     /* test IP display */
-    CPPUNIT_ASSERT( memcmp("192.168.100.12",anIPA.NtoA(buf,MAX_IPSTRLEN), 14) == 0 );
+    CPPUNIT_ASSERT( memcmp("192.168.100.12",anIPA.toStr(buf,MAX_IPSTRLEN), 14) == 0 );
 
-    anIPA.SetNoAddr();
+    anIPA.setNoAddr();
 
     /* test NoAddr display values */
-    CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",anIPA.NtoA(buf,MAX_IPSTRLEN), 39) == 0 );
+    CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",anIPA.toStr(buf,MAX_IPSTRLEN), 39) == 0 );
 }
 
 void
-testIpAddress::testToURL_fromInAddr()
+testIpAddress::testtoUrl_fromInAddr()
 {
     char buf[MAX_IPSTRLEN];
     buf[0] = '\0';
     struct in_addr inval;
 
     inval.s_addr = htonl(0xC0A8640C);
 
     Ip::Address anIPA(inval);
 
     /* test values */
-    anIPA.ToURL(buf,MAX_IPSTRLEN);
+    anIPA.toUrl(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("192.168.100.12", buf, 14) == 0 );
 
     /* test output when constructed from in6_addr with IPv6 */
     struct in6_addr ip6val;
 
     ip6val.s6_addr32[0] = htonl(0xC0A8640C);
     ip6val.s6_addr32[1] = htonl(0xFFFFFFFF);
     ip6val.s6_addr32[2] = htonl(0xFFFFFFFF);
     ip6val.s6_addr32[3] = htonl(0xFFFFFFFF);
 
     Ip::Address bnIPA(ip6val);
 
-    bnIPA.ToURL(buf,MAX_IPSTRLEN);
+    bnIPA.toUrl(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]", buf, 41) == 0 );
 }
 
 void
-testIpAddress::testToURL_fromSockAddr()
+testIpAddress::testtoUrl_fromSockAddr()
 {
     struct sockaddr_in sock;
     sock.sin_addr.s_addr = htonl(0xC0A8640C);
     sock.sin_port = htons(80);
     sock.sin_family = AF_INET;
 #if HAVE_SIN_LEN_IN_SAI
@@ -477,13 +477,13 @@
 #endif
 
     Ip::Address anIPA(sock);
     char buf[MAX_IPSTRLEN];
 
     /* test values */
-    anIPA.ToURL(buf,MAX_IPSTRLEN);
+    anIPA.toUrl(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("192.168.100.12:80", buf, 17) == 0 );
 
     /* test output when constructed from in6_addr with IPv6 */
     struct sockaddr_in6 ip6val;
 
     ip6val.sin6_addr.s6_addr32[0] = htonl(0xC0A8640C);
@@ -495,129 +495,129 @@
 #if HAVE_SIN6_LEN_IN_SAI
     ip6val.sin6_len = sizeof(struct sockaddr_in6);
 #endif
 
     Ip::Address bnIPA(ip6val);
 
-    bnIPA.ToURL(buf,MAX_IPSTRLEN);
+    bnIPA.toUrl(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]:80", buf, 44) == 0 );
 }
 
 void
-testIpAddress::testGetReverseString()
+testIpAddress::testgetReverseString()
 {
     char buf[MAX_IPSTRLEN];
 
     struct in_addr ipv4val;
     ipv4val.s_addr = htonl(0xC0A8640C);
 
     Ip::Address v4IPA(ipv4val);
 
     /* test IPv4 output */
-    v4IPA.GetReverseString(buf);
+    v4IPA.getReverseString(buf);
     CPPUNIT_ASSERT( memcmp("12.100.168.192.in-addr.arpa.",buf, 28) == 0 );
 
-    v4IPA.GetReverseString(buf,AF_INET);
+    v4IPA.getReverseString(buf,AF_INET);
     CPPUNIT_ASSERT( memcmp("12.100.168.192.in-addr.arpa.",buf, 28) == 0 );
 
-    v4IPA.GetReverseString(buf,AF_INET6);
+    v4IPA.getReverseString(buf,AF_INET6);
     CPPUNIT_ASSERT( memcmp("",buf, 1) == 0 );
 
     struct in6_addr ip6val;
 
     ip6val.s6_addr32[0] = htonl(0xC0A8640C);
     ip6val.s6_addr32[1] = htonl(0xFFFFFFFF);
     ip6val.s6_addr32[2] = htonl(0xFFFFFFFF);
     ip6val.s6_addr32[3] = htonl(0xFFFFFFFF);
 
     Ip::Address v6IPA(ip6val);
 
     /* test IPv6 output */
-    v6IPA.GetReverseString(buf);
+    v6IPA.getReverseString(buf);
     CPPUNIT_ASSERT( memcmp("f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.c.0.4.6.8.a.0.c.ip6.arpa.",buf,73) == 0 );
 }
 
 void
 testIpAddress::testMasking()
 {
     char buf[MAX_IPSTRLEN];
     Ip::Address anIPA;
     Ip::Address maskIPA;
 
     /* Test Basic CIDR Routine */
-    anIPA.SetAnyAddr();
-    CPPUNIT_ASSERT_EQUAL( 0 ,anIPA.GetCIDR() );
+    anIPA.setAnyAddr();
+    CPPUNIT_ASSERT_EQUAL( 0 ,anIPA.cidr() );
 
-    anIPA.SetNoAddr();
-    CPPUNIT_ASSERT_EQUAL( 128 , anIPA.GetCIDR() );
+    anIPA.setNoAddr();
+    CPPUNIT_ASSERT_EQUAL( 128 , anIPA.cidr() );
 
     /* Test Numeric ApplyCIDR */
-    anIPA.SetNoAddr();
-    CPPUNIT_ASSERT( !anIPA.ApplyMask(129,AF_INET6) );
-    CPPUNIT_ASSERT( !anIPA.ApplyMask(33,AF_INET) );
-
-    anIPA.SetNoAddr();
-    CPPUNIT_ASSERT( anIPA.ApplyMask(31,AF_INET) );
-    CPPUNIT_ASSERT_EQUAL( 127 , anIPA.GetCIDR() );
-
-    anIPA.SetNoAddr();
-    CPPUNIT_ASSERT( anIPA.ApplyMask(127,AF_INET6) );
-    CPPUNIT_ASSERT_EQUAL( 127 , anIPA.GetCIDR() );
-
-    anIPA.SetNoAddr();
-    anIPA.ApplyMask(80,AF_INET6);
-    CPPUNIT_ASSERT_EQUAL( 80 , anIPA.GetCIDR() );
+    anIPA.setNoAddr();
+    CPPUNIT_ASSERT( !anIPA.applyMask(129,AF_INET6) );
+    CPPUNIT_ASSERT( !anIPA.applyMask(33,AF_INET) );
+
+    anIPA.setNoAddr();
+    CPPUNIT_ASSERT( anIPA.applyMask(31,AF_INET) );
+    CPPUNIT_ASSERT_EQUAL( 127 , anIPA.cidr() );
+
+    anIPA.setNoAddr();
+    CPPUNIT_ASSERT( anIPA.applyMask(127,AF_INET6) );
+    CPPUNIT_ASSERT_EQUAL( 127 , anIPA.cidr() );
+
+    anIPA.setNoAddr();
+    anIPA.applyMask(80,AF_INET6);
+    CPPUNIT_ASSERT_EQUAL( 80 , anIPA.cidr() );
 
     /* BUG Check: test values by display. */
-    CPPUNIT_ASSERT( anIPA.NtoA(buf,MAX_IPSTRLEN) != NULL );
+    CPPUNIT_ASSERT( anIPA.toStr(buf,MAX_IPSTRLEN) != NULL );
     CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff::", buf, 26) == 0 );
 
     /* Test Network Bitmask from Ip::Address */
-    anIPA.SetNoAddr();
+    anIPA.setNoAddr();
     maskIPA = "255.255.240.0";
-    CPPUNIT_ASSERT_EQUAL( 20 , maskIPA.GetCIDR() );
-    anIPA.ApplyMask(maskIPA);
-    CPPUNIT_ASSERT_EQUAL( 20 , anIPA.GetCIDR() );
+    CPPUNIT_ASSERT_EQUAL( 20 , maskIPA.cidr() );
+    anIPA.applyMask(maskIPA);
+    CPPUNIT_ASSERT_EQUAL( 20 , anIPA.cidr() );
 
     /* BUG Check: test values memory after masking. */
     struct in_addr btest;
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    anIPA.GetInAddr(btest);
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    anIPA.getInAddr(btest);
     CPPUNIT_ASSERT_EQUAL( (uint32_t)htonl(0xFFFFF000) , btest.s_addr );
 
     /* BUG Check failing test. Masked values for display. */
-    CPPUNIT_ASSERT( memcmp("255.255.240.0",anIPA.NtoA(buf,MAX_IPSTRLEN), 13) == 0 );
+    CPPUNIT_ASSERT( memcmp("255.255.240.0",anIPA.toStr(buf,MAX_IPSTRLEN), 13) == 0 );
 
-    anIPA.SetNoAddr();
-    maskIPA.SetNoAddr();
+    anIPA.setNoAddr();
+    maskIPA.setNoAddr();
 
     /* IPv6 masks MUST be CIDR representations. */
     /* however as with IPv4 they can technically be represented as a bitmask */
     maskIPA = "ffff:ffff:fff0::";
-    CPPUNIT_ASSERT( !maskIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !maskIPA.IsNoAddr() );
-    anIPA.ApplyMask(maskIPA);
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT_EQUAL( 44 , anIPA.GetCIDR() );
+    CPPUNIT_ASSERT( !maskIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !maskIPA.isNoAddr() );
+    anIPA.applyMask(maskIPA);
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT_EQUAL( 44 , anIPA.cidr() );
 
-    anIPA.SetNoAddr();
-    maskIPA.SetNoAddr();
+    anIPA.setNoAddr();
+    maskIPA.setNoAddr();
 
     /* IPv4 masks represented in IPv6 as IPv4 bitmasks. */
     maskIPA = "::ffff:ffff:f000";
-    CPPUNIT_ASSERT( !maskIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !maskIPA.IsNoAddr() );
-    CPPUNIT_ASSERT(  maskIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !maskIPA.IsIPv6() );
-    anIPA.ApplyMask(maskIPA);
-    CPPUNIT_ASSERT( !maskIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !maskIPA.IsNoAddr() );
-    CPPUNIT_ASSERT(  maskIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !maskIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( 20 , anIPA.GetCIDR() );
+    CPPUNIT_ASSERT( !maskIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !maskIPA.isNoAddr() );
+    CPPUNIT_ASSERT(  maskIPA.isIPv4() );
+    CPPUNIT_ASSERT( !maskIPA.isIPv6() );
+    anIPA.applyMask(maskIPA);
+    CPPUNIT_ASSERT( !maskIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !maskIPA.isNoAddr() );
+    CPPUNIT_ASSERT(  maskIPA.isIPv4() );
+    CPPUNIT_ASSERT( !maskIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( 20 , anIPA.cidr() );
 }
 
 void
 testIpAddress::testAddrInfo()
 {
     struct addrinfo *expect;
@@ -630,13 +630,13 @@
 
     Ip::Address anIP = "127.0.0.1";
 
     /* assert this just to check that getaddrinfo is working properly */
     CPPUNIT_ASSERT( getaddrinfo("127.0.0.1", NULL, &hints, &expect ) == 0 );
 
-    anIP.GetAddrInfo(ipval);
+    anIP.getAddrInfo(ipval);
 
 #if 0
     /* display a byte-by-byte hex comparison of the addr cores */
     unsigned int *p;
     p = (unsigned int*)expect;
     printf("\nSYS-ADDRINFO: %2x %2x %2x %2x %2x %2x",
@@ -708,13 +708,13 @@
                               ((struct sockaddr_in6*)ipval->ai_addr)->sin6_port );
     }
 
     CPPUNIT_ASSERT( memcmp( expect->ai_addr, ipval->ai_addr, expect->ai_addrlen ) == 0 );
 
     freeaddrinfo(expect);
-    anIP.FreeAddrInfo(ipval);
+    Ip::Address::FreeAddrInfo(ipval);
 }
 
 void
 testIpAddress::testBugNullingDisplay()
 {
     // Weird Bug: address set to empty during string conversion somewhere.
@@ -730,55 +730,55 @@
 
     expectval.s_addr = htonl(0xC0A8640C);
 
     Ip::Address anIPA = "192.168.100.12";
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
-    /* POKE NtoA display function to see what it is doing */
-    anIPA.NtoA(ntoabuf,MAX_IPSTRLEN);
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    /* POKE toStr display function to see what it is doing */
+    anIPA.toStr(ntoabuf,MAX_IPSTRLEN);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    /* test stored values */
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
-    /* POKE ToHostname display function to see what it is doing */
-    anIPA.ToHostname(hostbuf,MAX_IPSTRLEN);
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    /* POKE toHostStr display function to see what it is doing */
+    anIPA.toHostStr(hostbuf,MAX_IPSTRLEN);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    /* test stored values */
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
-    /* POKE ToURL display function to see what it is doing */
-    anIPA.ToURL(urlbuf,MAX_IPSTRLEN);
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    /* POKE toUrl display function to see what it is doing */
+    anIPA.toUrl(urlbuf,MAX_IPSTRLEN);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    /* test stored values */
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/testAddress.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/testAddress.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ip/testAddress.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ip/testAddress.h	2015-05-01 18:05:19.000000000 +0800
@@ -15,19 +15,19 @@
     CPPUNIT_TEST( testInAddr6Constructor );
     CPPUNIT_TEST( testSockAddrConstructor );
     CPPUNIT_TEST( testSockAddr6Constructor );
     CPPUNIT_TEST( testHostentConstructor );
     CPPUNIT_TEST( testStringConstructor );
     CPPUNIT_TEST( testCopyConstructor );
-    CPPUNIT_TEST( testSetEmpty );
+    CPPUNIT_TEST( testsetEmpty );
     CPPUNIT_TEST( testBooleans );
     CPPUNIT_TEST( testAddrInfo );
-    CPPUNIT_TEST( testNtoA );
-    CPPUNIT_TEST( testToURL_fromInAddr );
-    CPPUNIT_TEST( testToURL_fromSockAddr );
-    CPPUNIT_TEST( testGetReverseString );
+    CPPUNIT_TEST( testtoStr );
+    CPPUNIT_TEST( testtoUrl_fromInAddr );
+    CPPUNIT_TEST( testtoUrl_fromSockAddr );
+    CPPUNIT_TEST( testgetReverseString );
     CPPUNIT_TEST( testMasking );
 
     CPPUNIT_TEST( testBugNullingDisplay );
     CPPUNIT_TEST_SUITE_END();
 
 public:
@@ -40,21 +40,21 @@
     void testSockAddrConstructor();
     void testSockAddr6Constructor();
     void testHostentConstructor();
     void testStringConstructor();
     void testCopyConstructor();
 
-    void testSetEmpty();
+    void testsetEmpty();
     void testBooleans();
 
     void testAddrInfo();
 
-    void testNtoA();
-    void testToURL_fromInAddr();
-    void testToURL_fromSockAddr();
-    void testGetReverseString();
+    void testtoStr();
+    void testtoUrl_fromInAddr();
+    void testtoUrl_fromSockAddr();
+    void testgetReverseString();
     void testMasking();
 
     // bugs.
     void testBugNullingDisplay();
 
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Coordinator.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Coordinator.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Coordinator.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Coordinator.cc	2015-05-01 18:05:19.000000000 +0800
@@ -252,29 +252,29 @@
 {
     const OpenListenerParams &p = request.params;
 
     debugs(54, 6, HERE << "opening listen FD at " << p.addr << " for kid" <<
            request.requestorId);
 
-    Comm::ConnectionPointer conn = new Comm::Connection;
-    conn->local = p.addr; // comm_open_listener may modify it
-    conn->flags = p.flags;
+    Comm::ConnectionPointer newConn = new Comm::Connection;
+    newConn->local = p.addr; // comm_open_listener may modify it
+    newConn->flags = p.flags;
 
     enter_suid();
-    comm_open_listener(p.sock_type, p.proto, conn, FdNote(p.fdNote));
-    errNo = Comm::IsConnOpen(conn) ? 0 : errno;
+    comm_open_listener(p.sock_type, p.proto, newConn, FdNote(p.fdNote));
+    errNo = Comm::IsConnOpen(newConn) ? 0 : errno;
     leave_suid();
 
-    debugs(54, 6, HERE << "tried listening on " << conn << " for kid" <<
+    debugs(54, 6, HERE << "tried listening on " << newConn << " for kid" <<
            request.requestorId);
 
     // cache positive results
-    if (Comm::IsConnOpen(conn))
-        listeners[request.params] = conn;
+    if (Comm::IsConnOpen(newConn))
+        listeners[request.params] = newConn;
 
-    return conn;
+    return newConn;
 }
 
 void Ipc::Coordinator::broadcastSignal(int sig) const
 {
     typedef StrandCoords::const_iterator SCI;
     for (SCI iter = strands_.begin(); iter != strands_.end(); ++iter) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Coordinator.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Coordinator.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Coordinator.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Coordinator.h	2015-05-01 18:05:19.000000000 +0800
@@ -3,13 +3,13 @@
  *
  */
 
 #ifndef SQUID_IPC_COORDINATOR_H
 #define SQUID_IPC_COORDINATOR_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "ipc/Messages.h"
 #include "ipc/Port.h"
 #include "ipc/SharedListen.h"
 #include "ipc/StrandCoords.h"
 #include "ipc/StrandSearch.h"
 #include "mgr/forward.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Kid.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Kid.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Kid.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Kid.cc	2015-05-01 18:05:19.000000000 +0800
@@ -45,13 +45,13 @@
     isRunning = true;
     pid = cpid;
     time(&startTime);
 }
 
 /// called when kid terminates, sets exiting status
-void Kid::stop(status_type exitStatus)
+void Kid::stop(status_type theExitStatus)
 {
     assert(running());
     assert(startTime != 0);
 
     isRunning = false;
 
@@ -59,13 +59,13 @@
     time(&stop_time);
     if ((stop_time - startTime) < fastFailureTimeLimit)
         ++badFailures;
     else
         badFailures = 0; // the failures are not "frequent" [any more]
 
-    status = exitStatus;
+    status = theExitStatus;
 }
 
 /// returns true if tracking of kid is stopped
 bool Kid::running() const
 {
     return isRunning;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Kid.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Kid.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Kid.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Kid.h	2015-05-01 18:05:19.000000000 +0800
@@ -87,12 +87,13 @@
 /// process kinds
 typedef enum {
     pkOther  = 0, ///< we do not know or do not care
     pkCoordinator = 1, ///< manages all other kids
     pkWorker = 2, ///< general-purpose worker bee
     pkDisker = 4, ///< cache_dir manager
+    pkHelper = 8  ///< general-purpose helper child
 } ProcessKind;
 
 /// ProcessKind for the current process
 extern int TheProcessKind;
 
 #endif /* SQUID_IPC_KID_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Kids.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Kids.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Kids.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Kids.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  */
 
 #ifndef SQUID_IPC_KIDS_H
 #define SQUID_IPC_KIDS_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "ipc/Kid.h"
 
 /// a collection of kids
 class Kids
 {
 public:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Makefile.in	2015-05-01 16:51:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Makefile.in	2015-05-01 18:06:58.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -456,12 +502,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -499,12 +546,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -531,27 +579,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -618,13 +669,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libipc.la
 libipc_la_SOURCES = \
 	AtomicWord.cc \
 	AtomicWord.h \
 	FdNotes.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/mem/Pointer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/mem/Pointer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/mem/Pointer.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/mem/Pointer.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,15 +1,15 @@
 /*
  */
 
 #ifndef SQUID_IPC_MEM_POINTER_H
 #define SQUID_IPC_MEM_POINTER_H
 
+#include "base/RefCount.h"
 #include "base/TextException.h"
 #include "ipc/mem/Segment.h"
-#include "RefCount.h"
 
 namespace Ipc
 {
 
 namespace Mem
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Queue.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Queue.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Queue.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Queue.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  */
 
 #ifndef SQUID_IPC_QUEUE_H
 #define SQUID_IPC_QUEUE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "Debug.h"
 #include "base/InstanceId.h"
 #include "ipc/AtomicWord.h"
 #include "ipc/mem/FlexibleArray.h"
 #include "ipc/mem/Pointer.h"
 #include "util.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Request.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Request.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Request.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Request.h	2015-05-01 18:05:19.000000000 +0800
@@ -3,14 +3,14 @@
  *
  */
 
 #ifndef SQUID_IPC_REQUEST_H
 #define SQUID_IPC_REQUEST_H
 
+#include "base/RefCount.h"
 #include "ipc/forward.h"
-#include "RefCount.h"
 
 namespace Ipc
 {
 
 /// IPC request
 class Request: public RefCountable
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Response.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Response.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/Response.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/Response.h	2015-05-01 18:05:19.000000000 +0800
@@ -3,14 +3,14 @@
  *
  */
 
 #ifndef SQUID_IPC_RESPONSE_H
 #define SQUID_IPC_RESPONSE_H
 
+#include "base/RefCount.h"
 #include "ipc/forward.h"
-#include "RefCount.h"
 
 namespace Ipc
 {
 
 /// A response to Ipc::Request.
 class Response: public RefCountable
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/SharedListen.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/SharedListen.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/SharedListen.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/SharedListen.cc	2015-05-01 18:05:19.000000000 +0800
@@ -139,17 +139,17 @@
     if (Comm::IsConnOpen(cbd->conn)) {
         OpenListenerParams &p = por.params;
         cbd->conn->local = p.addr;
         cbd->conn->flags = p.flags;
         // XXX: leave the comm AI stuff to comm_import_opened()?
         struct addrinfo *AI = NULL;
-        p.addr.GetAddrInfo(AI);
+        p.addr.getAddrInfo(AI);
         AI->ai_socktype = p.sock_type;
         AI->ai_protocol = p.proto;
         comm_import_opened(cbd->conn, FdNote(p.fdNote), AI);
-        p.addr.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
     }
 
     cbd->errNo = response.errNo;
     cbd->handlerSubscription = por.params.handlerSubscription;
     ScheduleCallHere(por.callback);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/StoreMap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/StoreMap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/StoreMap.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/StoreMap.h	2015-05-01 18:05:19.000000000 +0800
@@ -166,14 +166,14 @@
 StoreMapWithExtras<ExtrasT>::Init(const char *const path, const int limit)
 {
     return StoreMap::Init(path, limit, sizeof(Extras));
 }
 
 template <class ExtrasT>
-StoreMapWithExtras<ExtrasT>::StoreMapWithExtras(const char *const path):
-        StoreMap(path)
+StoreMapWithExtras<ExtrasT>::StoreMapWithExtras(const char *const aPath):
+        StoreMap(aPath)
 {
     const size_t sharedSizeWithoutExtras =
         Shared::SharedMemorySize(entryLimit(), 0);
     sharedExtras = reinterpret_cast<Extras *>(reinterpret_cast<char *>(shared.getRaw()) + sharedSizeWithoutExtras);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/TypedMsgHdr.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/TypedMsgHdr.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/TypedMsgHdr.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/TypedMsgHdr.cc	2015-05-01 18:05:19.000000000 +0800
@@ -129,44 +129,44 @@
     Must(s.psize() <= maxSize);
     putInt(s.psize());
     putRaw(s.rawBuf(), s.psize());
 }
 
 void
-Ipc::TypedMsgHdr::getFixed(void *raw, size_t size) const
+Ipc::TypedMsgHdr::getFixed(void *rawBuf, size_t rawSize) const
 {
     // no need to load size because it is constant
-    getRaw(raw, size);
+    getRaw(rawBuf, rawSize);
 }
 
 void
-Ipc::TypedMsgHdr::putFixed(const void *raw, size_t size)
+Ipc::TypedMsgHdr::putFixed(const void *rawBuf, size_t rawSize)
 {
     // no need to store size because it is constant
-    putRaw(raw, size);
+    putRaw(rawBuf, rawSize);
 }
 
 /// low-level loading of exactly size bytes of raw data
 void
-Ipc::TypedMsgHdr::getRaw(void *raw, size_t size) const
+Ipc::TypedMsgHdr::getRaw(void *rawBuf, size_t rawSize) const
 {
-    if (size > 0) {
-        Must(size <= data.size - offset);
-        memcpy(raw, data.raw + offset, size);
-        offset += size;
+    if (rawSize > 0) {
+        Must(rawSize <= data.size - offset);
+        memcpy(rawBuf, data.raw + offset, rawSize);
+        offset += rawSize;
     }
 }
 
 /// low-level storage of exactly size bytes of raw data
 void
-Ipc::TypedMsgHdr::putRaw(const void *raw, size_t size)
+Ipc::TypedMsgHdr::putRaw(const void *rawBuf, size_t rawSize)
 {
-    if (size > 0) {
-        Must(size <= sizeof(data.raw) - data.size);
-        memcpy(data.raw + data.size, raw, size);
-        data.size += size;
+    if (rawSize > 0) {
+        Must(rawSize <= sizeof(data.raw) - data.size);
+        memcpy(data.raw + data.size, rawBuf, rawSize);
+        data.size += rawSize;
     }
 }
 
 bool
 Ipc::TypedMsgHdr::hasFd() const
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/UdsOp.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/UdsOp.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/UdsOp.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/UdsOp.cc	2015-05-01 18:05:19.000000000 +0800
@@ -123,18 +123,18 @@
 {
     debugs(54, 5, HERE << params.conn << " flag " << params.flag << " retries " << retries << " [" << this << ']');
     writing = false;
     if (params.flag != COMM_OK && retries-- > 0) {
         // perhaps a fresh connection and more time will help?
         conn()->close();
-        sleep();
+        startSleep();
     }
 }
 
 /// pause for a while before resending the message
-void Ipc::UdsSender::sleep()
+void Ipc::UdsSender::startSleep()
 {
     Must(!sleeping);
     sleeping = true;
     eventAdd("Ipc::UdsSender::DelayedRetry",
              Ipc::UdsSender::DelayedRetry,
              new Pointer(this), 1, 0, false); // TODO: Use Fibonacci increments
@@ -190,17 +190,17 @@
 {
     struct sockaddr_in addr;
     socklen_t len = sizeof(addr);
     if (getsockname(conn->fd, reinterpret_cast<sockaddr*>(&addr), &len) == 0) {
         conn->remote = addr;
         struct addrinfo* addr_info = NULL;
-        conn->remote.GetAddrInfo(addr_info);
+        conn->remote.getAddrInfo(addr_info);
         addr_info->ai_socktype = socktype;
         addr_info->ai_protocol = protocol;
         comm_import_opened(conn, Ipc::FdNote(noteId), addr_info);
-        conn->remote.FreeAddrInfo(addr_info);
+        Ip::Address::FreeAddrInfo(addr_info);
     } else {
         debugs(54, DBG_CRITICAL, "ERROR: Ipc::ImportFdIntoComm: " << conn << ' ' << xstrerror());
         conn->close();
     }
     return conn;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/UdsOp.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/UdsOp.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc/UdsOp.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc/UdsOp.h	2015-05-01 18:05:19.000000000 +0800
@@ -68,13 +68,13 @@
     virtual void swanSong(); // UdsOp (AsyncJob) API
     virtual void start(); // UdsOp (AsyncJob) API
     virtual bool doneAll() const; // UdsOp (AsyncJob) API
     virtual void timedout(); // UdsOp API
 
 private:
-    void sleep();
+    void startSleep();
     void cancelSleep();
     static void DelayedRetry(void *data);
     void delayedRetry();
 
     void write(); ///< schedule writing
     void wrote(const CommIoCbParams& params); ///< done writing or error
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipcache.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipcache.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipcache.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipcache.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,12 +30,13 @@
  *
  */
 
 #include "squid.h"
 #include "cbdata.h"
 #include "CacheManager.h"
+#include "dlink.h"
 #include "DnsLookupDetails.h"
 #include "event.h"
 #include "ip/Address.h"
 #include "ip/tools.h"
 #include "ipcache.h"
 #include "Mem.h"
@@ -110,14 +111,14 @@
     char *error_message;
 
     struct timeval request_time;
     dlink_node lru;
     unsigned short locks;
     struct {
-        unsigned int negcached:1;
-        unsigned int fromhosts:1;
+        bool negcached;
+        bool fromhosts;
     } flags;
 
     int age() const; ///< time passed since request_time or -1 if unknown
 };
 
 /// \ingroup IPCacheInternal
@@ -426,13 +427,13 @@
 
     if (ipcount > 0) {
         int j, k;
 
         i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(ipcount, sizeof(Ip::Address)));
         for (int l = 0; l < ipcount; ++l)
-            i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
+            i->addrs.in_addrs[l].setEmpty(); // perform same init actions as constructor would.
         i->addrs.bad_mask = (unsigned char *)xcalloc(ipcount, sizeof(unsigned char));
         memset(i->addrs.bad_mask, 0, sizeof(unsigned char) * ipcount);
 
         for (j = 0, k = 0; k < ipcount; ++k) {
             if ((i->addrs.in_addrs[j] = A[k]))
                 ++j;
@@ -470,13 +471,13 @@
     int na = 0;
     int ttl = 0;
     const char *name = (const char *)i->hash.key;
     int cname_found = 0;
 
     i->expires = squid_curtime + Config.negativeDnsTtl;
-    i->flags.negcached = 1;
+    i->flags.negcached = true;
     safe_free(i->addrs.in_addrs);
     assert(i->addrs.in_addrs == NULL);
     safe_free(i->addrs.bad_mask);
     assert(i->addrs.bad_mask == NULL);
     safe_free(i->error_message);
     assert(i->error_message == NULL);
@@ -536,13 +537,13 @@
             ++IpcacheStats.cname_only;
         return 0;
     }
 
     i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(na, sizeof(Ip::Address)));
     for (int l = 0; l < na; ++l)
-        i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
+        i->addrs.in_addrs[l].setEmpty(); // perform same init actions as constructor would.
     i->addrs.bad_mask = (unsigned char *)xcalloc(na, sizeof(unsigned char));
 
     for (j = 0, k = 0; k < nr; ++k) {
 
         if (answers[k].type == RFC1035_TYPE_A) {
             if (answers[k].rdlength != sizeof(struct in_addr))
@@ -582,35 +583,35 @@
 
     if (ttl < Config.negativeDnsTtl)
         ttl = Config.negativeDnsTtl;
 
     i->expires = squid_curtime + ttl;
 
-    i->flags.negcached = 0;
+    i->flags.negcached = false;
 
     return i->addrs.count;
 }
 
 #endif
 
 /// \ingroup IPCacheInternal
 static void
 #if USE_DNSHELPER
-ipcacheHandleReply(void *data, char *reply)
+ipcacheHandleReply(void *data, const HelperReply &reply)
 #else
 ipcacheHandleReply(void *data, const rfc1035_rr * answers, int na, const char *error_message)
 #endif
 {
     ipcache_entry *i;
     static_cast<generic_cbdata *>(data)->unwrap(&i);
     ++IpcacheStats.replies;
     const int age = i->age();
     statCounter.dns.svcTime.count(age);
 
 #if USE_DNSHELPER
-    ipcacheParse(i, reply);
+    ipcacheParse(i, reply.other().content());
 #else
 
     int done = ipcacheParse(i, answers, na, error_message);
 
     /* If we have not produced either IPs or Error immediately, wait for recursion to finish. */
     if (done != 0 || error_message != NULL)
@@ -729,13 +730,13 @@
     debugs(14, DBG_IMPORTANT, "Initializing IP Cache...");
     memset(&IpcacheStats, '\0', sizeof(IpcacheStats));
     memset(&lru_list, '\0', sizeof(lru_list));
     memset(&static_addrs, '\0', sizeof(ipcache_addrs));
 
     static_addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(1, sizeof(Ip::Address)));
-    static_addrs.in_addrs->SetEmpty(); // properly setup the Ip::Address!
+    static_addrs.in_addrs->setEmpty(); // properly setup the Ip::Address!
     static_addrs.bad_mask = (unsigned char *)xcalloc(1, sizeof(unsigned char));
     ipcache_high = (long) (((float) Config.ipcache.size *
                             (float) Config.ipcache.high) / (float) 100);
     ipcache_low = (long) (((float) Config.ipcache.size *
                            (float) Config.ipcache.low) / (float) 100);
     n = hashPrime(ipcache_high / 4);
@@ -840,18 +841,18 @@
     /** \par
      * Cached entries have IPs listed with a BNF of:   ip-address '-' ('OK'|'BAD') */
     for (k = 0; k < count; ++k) {
         /* Display tidy-up: IPv6 are so big make the list vertical */
         if (k == 0)
             storeAppendPrintf(sentry, " %45.45s-%3s\n",
-                              i->addrs.in_addrs[k].NtoA(buf,MAX_IPSTRLEN),
+                              i->addrs.in_addrs[k].toStr(buf,MAX_IPSTRLEN),
                               i->addrs.bad_mask[k] ? "BAD" : "OK ");
         else
             storeAppendPrintf(sentry, "%s %45.45s-%3s\n",
                               "                                                         ", /* blank-space indenting IP list */
-                              i->addrs.in_addrs[k].NtoA(buf,MAX_IPSTRLEN),
+                              i->addrs.in_addrs[k].toStr(buf,MAX_IPSTRLEN),
                               i->addrs.bad_mask[k] ? "BAD" : "OK ");
     }
 }
 
 /**
  \ingroup IPCacheInternal
@@ -1068,13 +1069,12 @@
         return;
 
     /** Marks the given address as BAD */
     if (!ia->bad_mask[k]) {
         ia->bad_mask[k] = TRUE;
         ++ia->badcount;
-        i->expires = min(squid_curtime + max((time_t)60, Config.negativeDnsTtl), i->expires);
         debugs(14, 2, "ipcacheMarkBadAddr: " << name << " " << addr );
     }
 
     /** then calls ipcacheCycleAddr() to advance the current pointer to the next OK address. */
     ipcacheCycleAddr(name, ia);
 }
@@ -1215,13 +1215,13 @@
     i->addrs.badcount = 0;
 
     i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(1, sizeof(Ip::Address)));
     i->addrs.bad_mask = (unsigned char *)xcalloc(1, sizeof(unsigned char));
     i->addrs.in_addrs[0] = ip;
     i->addrs.bad_mask[0] = FALSE;
-    i->flags.fromhosts = 1;
+    i->flags.fromhosts = true;
     ipcacheAddEntry(i);
     ipcacheLockEntry(i);
     return 0;
 }
 
 #if SQUID_SNMP
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc.cc	2015-05-01 18:05:19.000000000 +0800
@@ -33,12 +33,13 @@
 #include "squid.h"
 #include "comm/Connection.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
 #include "ip/Address.h"
+#include "ipc/Kid.h"
 #include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "tools.h"
 #include "rfc1738.h"
 
 static const char *hello_string = "hi there\n";
@@ -201,37 +202,37 @@
     debugs(54, 3, "ipcCreate: prfd FD " << prfd);
     debugs(54, 3, "ipcCreate: pwfd FD " << pwfd);
     debugs(54, 3, "ipcCreate: crfd FD " << crfd);
     debugs(54, 3, "ipcCreate: cwfd FD " << cwfd);
 
     if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {
-        PaS.InitAddrInfo(AI);
+        Ip::Address::InitAddrInfo(AI);
 
         if (getsockname(pwfd, AI->ai_addr, &AI->ai_addrlen) < 0) {
-            PaS.FreeAddrInfo(AI);
+            Ip::Address::FreeAddrInfo(AI);
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
         PaS = *AI;
 
         debugs(54, 3, "ipcCreate: FD " << pwfd << " sockaddr " << PaS);
 
-        PaS.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
 
-        ChS.InitAddrInfo(AI);
+        Ip::Address::InitAddrInfo(AI);
 
         if (getsockname(crfd, AI->ai_addr, &AI->ai_addrlen) < 0) {
-            ChS.FreeAddrInfo(AI);
+            Ip::Address::FreeAddrInfo(AI);
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
         ChS = *AI;
 
-        ChS.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
 
         debugs(54, 3, "ipcCreate: FD " << crfd << " sockaddr " << ChS );
 
     }
 
     if (type == IPC_TCP_SOCKET) {
@@ -307,12 +308,13 @@
         }
 
         return pid;
     }
 
     /* child */
+    TheProcessKind = pkHelper;
     no_suid();			/* give up extra priviliges */
 
     /* close shared socket with parent */
     close(prfd);
 
     if (pwfd != prfd)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc_win32.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc_win32.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ipc_win32.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ipc_win32.cc	2015-05-01 18:05:19.000000000 +0800
@@ -200,32 +200,36 @@
         return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
     }
 
 // AYJ: these flags should be neutral, but if not IPv6 version needs adding
     if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {
 
-        tmp_addr.InitAddrInfo(aiPS);
+        Ip::Address::InitAddrInfo(aiPS);
 
         if (getsockname(pwfd, aiPS->ai_addr, &(aiPS->ai_addrlen) ) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            Ip::Address::FreeAddrInfo(aiPS);
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
         tmp_addr = *aiPS;
+        Ip::Address::FreeAddrInfo(aiPS);
 
         debugs(54, 3, "ipcCreate: FD " << pwfd << " sockaddr " << tmp_addr );
 
-        tmp_addr.InitAddrInfo(aiCS);
+        Ip::Address::InitAddrInfo(aiCS);
 
         if (getsockname(crfd, aiCS->ai_addr, &(aiCS->ai_addrlen) ) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            Ip::Address::FreeAddrInfo(aiCS);
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
-        tmp_addr.SetEmpty();
+        tmp_addr.setEmpty();
         tmp_addr = *aiCS;
+        Ip::Address::FreeAddrInfo(aiCS);
 
         debugs(54, 3, "ipcCreate: FD " << crfd << " sockaddr " << tmp_addr );
     }
 
     if (type == IPC_TCP_SOCKET) {
         if (listen(crfd, 1) < 0) {
@@ -318,19 +322,16 @@
     if (rfd)
         *rfd = prfd;
 
     if (wfd)
         *wfd = pwfd;
 
-    fd_table[prfd].flags.ipc = 1;
-
-    fd_table[pwfd].flags.ipc = 1;
-
-    fd_table[crfd].flags.ipc = 1;
-
-    fd_table[cwfd].flags.ipc = 1;
+    fd_table[prfd].flags.ipc = true;
+    fd_table[pwfd].flags.ipc = true;
+    fd_table[crfd].flags.ipc = true;
+    fd_table[cwfd].flags.ipc = true;
 
     if (Config.sleep_after_fork) {
         /* XXX emulation of usleep() */
         DWORD sl;
         sl = Config.sleep_after_fork / 1000;
 
@@ -482,33 +483,37 @@
         if (pwfd_ipc < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: CHILD: Failed to create server FD for " << prog << ".");
             ipcSend(cwfd, err_string, strlen(err_string));
             goto cleanup;
         }
 
-        PS_ipc.InitAddrInfo(aiPS_ipc);
+        Ip::Address::InitAddrInfo(aiPS_ipc);
 
         if (getsockname(pwfd_ipc, aiPS_ipc->ai_addr, &(aiPS_ipc->ai_addrlen)) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             ipcSend(cwfd, err_string, strlen(err_string));
+            Ip::Address::FreeAddrInfo(aiPS_ipc);
             goto cleanup;
         }
 
         PS_ipc = *aiPS_ipc;
+        Ip::Address::FreeAddrInfo(aiPS_ipc);
 
         debugs(54, 3, "ipcCreate: FD " << pwfd_ipc << " sockaddr " << PS_ipc);
 
-        CS_ipc.InitAddrInfo(aiCS_ipc);
+        Ip::Address::InitAddrInfo(aiCS_ipc);
 
         if (getsockname(crfd_ipc, aiCS_ipc->ai_addr, &(aiCS_ipc->ai_addrlen)) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             ipcSend(cwfd, err_string, strlen(err_string));
+            Ip::Address::FreeAddrInfo(aiCS_ipc);
             goto cleanup;
         }
 
         CS_ipc = *aiCS_ipc;
+        Ip::Address::FreeAddrInfo(aiCS_ipc);
 
         debugs(54, 3, "ipcCreate: FD " << crfd_ipc << " sockaddr " << CS_ipc);
 
         if (comm_connect_addr(pwfd_ipc, CS_ipc) == COMM_ERROR) {
             ipcSend(cwfd, err_string, strlen(err_string));
             goto cleanup;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/LeakFinder.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/LeakFinder.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/LeakFinder.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/LeakFinder.cc	2015-05-01 18:05:19.000000000 +0800
@@ -42,21 +42,26 @@
 #include "Store.h"
 #include "SquidTime.h"
 
 /* ========================================================================= */
 
 LeakFinderPtr::LeakFinderPtr(void *p , const char *f, const int l) :
-        file(f), line(l), when(squid_curtime)
+        file(f),
+        line(l),
+        when(squid_curtime)
 {
+    // XXX: these bits should be done by hash_link()
     key = p;
     next = NULL;
 }
 
 /* ========================================================================= */
 
-LeakFinder::LeakFinder()
+LeakFinder::LeakFinder() :
+        count(0),
+        last_dump(0)
 {
     debugs(45, 3, "LeakFinder constructed");
     table = hash_create(cmp, 1 << 8, hash);
 #if 0
     /* if this is desired to reinstate, add a
      * RegisterWithCacheManager method
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/access_log.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/access_log.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/access_log.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/access_log.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,13 +30,17 @@
  *
  */
 
 #include "squid.h"
 #include "AccessLogEntry.h"
 #include "acl/Checklist.h"
+#if USE_ADAPTATION
+#include "adaptation/Config.h"
+#endif
 #include "CachePeer.h"
+#include "errorpage.h"
 #include "err_detail_type.h"
 #include "errorpage.h"
 #include "errorpage.h"
 #include "format/Token.h"
 #include "globals.h"
 #include "hier_code.h"
@@ -247,13 +251,13 @@
 
 HierarchyLogEntry::HierarchyLogEntry() :
         code(HIER_NONE),
         cd_lookup(LOOKUP_NONE),
         n_choices(0),
         n_ichoices(0),
-        peer_reply_status(HTTP_STATUS_NONE),
+        peer_reply_status(Http::scNone),
         peer_response_time(-1),
         total_response_time(-1),
         tcpServer(NULL),
         bodyBytesRead(-1)
 {
     memset(host, '\0', SQUIDHOSTNAMELEN);
@@ -314,23 +318,24 @@
 #endif
 
     for (log = Config.Log.accesslogs; log; log = log->next) {
         if (log->type == Log::Format::CLF_NONE)
             continue;
 
-        log->logfile = logfileOpen(log->filename, MAX_URL << 2, 1);
+        log->logfile = logfileOpen(log->filename, log->bufferSize, log->fatal);
 
         LogfileStatus = LOG_ENABLE;
 
 #if USE_ADAPTATION
         for (Format::Token * curr_token = (log->logFormat?log->logFormat->format:NULL); curr_token; curr_token = curr_token->next) {
             if (curr_token->type == Format::LFT_ADAPTATION_SUM_XACT_TIMES ||
                     curr_token->type == Format::LFT_ADAPTATION_ALL_XACT_TIMES ||
                     curr_token->type == Format::LFT_ADAPTATION_LAST_HEADER ||
                     curr_token->type == Format::LFT_ADAPTATION_LAST_HEADER_ELEM ||
-                    curr_token->type == Format::LFT_ADAPTATION_LAST_ALL_HEADERS) {
+                    curr_token->type == Format::LFT_ADAPTATION_LAST_ALL_HEADERS||
+                    (curr_token->type == Format::LFT_NOTE && !Adaptation::Config::metaHeaders.empty())) {
                 Log::TheConfig.hasAdaptToken = true;
             }
 #if ICAP_CLIENT
             if (curr_token->type == Format::LFT_ICAP_TOTAL_TIME) {
                 Log::TheConfig.hasIcapToken = true;
             }
@@ -524,13 +529,12 @@
 headersLog(int cs, int pq, const HttpRequestMethod& method, void *data)
 {
     HttpReply *rep;
     HttpRequest *req;
     unsigned short magic = 0;
     unsigned char M = (unsigned char) m;
-    unsigned short S;
     char *hmask;
     int ccmask = 0;
 
     if (0 == pq) {
         /* reply */
         rep = data;
@@ -559,48 +563,18 @@
         magic |= 0x5300;
     }
 
     magic = htons(magic);
     ccmask = htonl(ccmask);
 
+    unsigned short S = 0;
     if (0 == pq)
-        S = (unsigned short) rep->sline.status;
-    else
-        S = (unsigned short) HTTP_STATUS_NONE;
+        S = static_cast<unsigned short>(rep->sline.status());
 
     logfileWrite(headerslog, &magic, sizeof(magic));
     logfileWrite(headerslog, &M, sizeof(M));
     logfileWrite(headerslog, &S, sizeof(S));
     logfileWrite(headerslog, hmask, sizeof(HttpHeaderMask));
     logfileWrite(headerslog, &ccmask, sizeof(int));
 }
 
 #endif
-
-int
-logTypeIsATcpHit(log_type code)
-{
-    /* this should be a bitmap for better optimization */
-
-    if (code == LOG_TCP_HIT)
-        return 1;
-
-    if (code == LOG_TCP_IMS_HIT)
-        return 1;
-
-    if (code == LOG_TCP_REFRESH_FAIL_OLD)
-        return 1;
-
-    if (code == LOG_TCP_REFRESH_UNMODIFIED)
-        return 1;
-
-    if (code == LOG_TCP_NEGATIVE_HIT)
-        return 1;
-
-    if (code == LOG_TCP_MEM_HIT)
-        return 1;
-
-    if (code == LOG_TCP_OFFLINE_HIT)
-        return 1;
-
-    return 0;
-}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/access_log.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/access_log.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/access_log.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/access_log.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,13 +30,14 @@
  *
  */
 
 #ifndef SQUID_LOG_ACCESS_LOG_H_
 #define SQUID_LOG_ACCESS_LOG_H_
 
-int logTypeIsATcpHit(log_type);
+#include "LogTags.h"
+
 void fvdbCountVia(const char *key);
 void fvdbCountForw(const char *key);
 
 #if HEADERS_LOG
 class HttpRequestMethod;
 void headersLog(int cs, int pq, const HttpRequestMethod& m, void *data);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/CustomLog.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/CustomLog.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/CustomLog.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/CustomLog.h	2015-05-01 18:05:19.000000000 +0800
@@ -26,15 +26,15 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 //#include "format/Format.h"
+#include "acl/forward.h"
 #include "log/Formats.h"
 
-class ACLList;
 class Logfile;
 namespace Format
 {
 class Format;
 }
 
@@ -45,9 +45,13 @@
     char *filename;
     ACLList *aclList;
     Format::Format *logFormat;
     Logfile *logfile;
     CustomLog *next;
     Log::Format::log_type type;
+    /// how much to buffer before dropping or dying (access_log buffer-size)
+    size_t bufferSize;
+    /// whether unrecoverable errors (e.g., dropping a log record) kill worker
+    bool fatal;
 };
 
 #endif /* SQUID_CUSTOMLOG_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/File.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/File.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/File.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/File.cc	2015-05-01 18:05:19.000000000 +0800
@@ -34,13 +34,13 @@
 #include "fde.h"
 #include "log/File.h"
 #include "log/ModDaemon.h"
 #include "log/ModStdio.h"
 #include "log/ModSyslog.h"
 #include "log/ModUdp.h"
-#include "log/ModTcp.h"
+#include "log/TcpLogger.h"
 
 CBDATA_TYPE(Logfile);
 
 Logfile *
 logfileOpen(const char *path, size_t bufsz, int fatal_flag)
 {
@@ -59,23 +59,23 @@
         ret = logfile_mod_stdio_open(lf, patharg, bufsz, fatal_flag);
     } else if (strncmp(path, "daemon:", 7) == 0) {
         patharg = path + 7;
         ret = logfile_mod_daemon_open(lf, patharg, bufsz, fatal_flag);
     } else if (strncmp(path, "tcp:", 4) == 0) {
         patharg = path + 4;
-        ret = logfile_mod_tcp_open(lf, patharg, bufsz, fatal_flag);
+        ret = Log::TcpLogger::Open(lf, patharg, bufsz, fatal_flag);
     } else if (strncmp(path, "udp:", 4) == 0) {
         patharg = path + 4;
         ret = logfile_mod_udp_open(lf, patharg, bufsz, fatal_flag);
 #if HAVE_SYSLOG
     } else if (strncmp(path, "syslog:", 7) == 0) {
         patharg = path + 7;
         ret = logfile_mod_syslog_open(lf, patharg, bufsz, fatal_flag);
 #endif
     } else {
-        debugs(50, DBG_IMPORTANT, "WARNING: log parameters now start with a module name. Use 'stdio:" << patharg << "'");
+        debugs(50, DBG_IMPORTANT, "WARNING: log name now starts with a module name. Use 'stdio:" << patharg << "'");
         snprintf(lf->path, MAXPATHLEN, "stdio:%s", patharg);
         ret = logfile_mod_stdio_open(lf, patharg, bufsz, fatal_flag);
     }
     if (!ret) {
         if (fatal_flag)
             fatalf("logfileOpen: %s: couldn't open!\n", path);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/FormatHttpdCombined.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/FormatHttpdCombined.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/FormatHttpdCombined.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/FormatHttpdCombined.cc	2015-05-01 18:05:19.000000000 +0800
@@ -77,13 +77,13 @@
                   AnyP::ProtocolType_str[al->http.version.protocol],
                   al->http.version.major, al->http.version.minor,
                   al->http.code,
                   al->cache.replySize,
                   referer,
                   agent,
-                  ::Format::log_tags[al->cache.code],
+                  LogTags_str[al->cache.code],
                   al->http.statusSfx(),
                   hier_code_str[al->hier.code],
                   (Config.onoff.log_mime_hdrs?"":"\n"));
 
     safe_free(user_ident);
     safe_free(user_auth);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/FormatHttpdCommon.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/FormatHttpdCommon.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/FormatHttpdCommon.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/FormatHttpdCommon.cc	2015-05-01 18:05:19.000000000 +0800
@@ -62,13 +62,13 @@
                   al->_private.method_str,
                   al->url,
                   AnyP::ProtocolType_str[al->http.version.protocol],
                   al->http.version.major, al->http.version.minor,
                   al->http.code,
                   al->cache.replySize,
-                  ::Format::log_tags[al->cache.code],
+                  LogTags_str[al->cache.code],
                   al->http.statusSfx(),
                   hier_code_str[al->hier.code],
                   (Config.onoff.log_mime_hdrs?"":"\n"));
 
     safe_free(user_auth);
     safe_free(user_ident);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/Formats.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/Formats.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/Formats.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/Formats.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,11 +1,11 @@
 #ifndef _SQUID_LOG_FORMATS_H
 #define _SQUID_LOG_FORMATS_H
 
 #include "AccessLogEntry.h"
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class AccessLogEntry;
 class CustomLog;
 class Logfile;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/FormatSquidIcap.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/FormatSquidIcap.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/FormatSquidIcap.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/FormatSquidIcap.cc	2015-05-01 18:05:19.000000000 +0800
@@ -47,19 +47,19 @@
 Log::Format::SquidIcap(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
     const char *client = NULL;
     const char *user = NULL;
     char tmp[MAX_IPSTRLEN], clientbuf[MAX_IPSTRLEN];
 
-    if (al->cache.caddr.IsAnyAddr()) { // ICAP OPTIONS xactions lack client
+    if (al->cache.caddr.isAnyAddr()) { // ICAP OPTIONS xactions lack client
         client = "-";
     } else {
         if (Config.onoff.log_fqdn)
             client = fqdncache_gethostbyaddr(al->cache.caddr, FQDN_LOOKUP_IF_MISS);
         if (!client)
-            client = al->cache.caddr.NtoA(clientbuf, MAX_IPSTRLEN);
+            client = al->cache.caddr.toStr(clientbuf, MAX_IPSTRLEN);
     }
 
 #if USE_AUTH
     if (al->request != NULL && al->request->auth_user_request != NULL)
         user = ::Format::QuoteUrlEncodeUsername(al->request->auth_user_request->username());
 #endif
@@ -86,10 +86,10 @@
                   al->icap.outcome,
                   al->icap.resStatus,
                   al->icap.bytesRead,
                   Adaptation::Icap::ICAP::methodStr(al->icap.reqMethod),
                   al->icap.reqUri.termedBuf(),
                   user ? user : "-",
-                  al->icap.hostAddr.NtoA(tmp, MAX_IPSTRLEN));
+                  al->icap.hostAddr.toStr(tmp, MAX_IPSTRLEN));
     safe_free(user);
 }
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/FormatSquidNative.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/FormatSquidNative.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/FormatSquidNative.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/FormatSquidNative.cc	2015-05-01 18:05:19.000000000 +0800
@@ -72,22 +72,22 @@
 
     logfilePrintf(logfile, "%9ld.%03d %6d %s %s%s/%03d %" PRId64 " %s %s %s %s%s/%s %s%s",
                   (long int) current_time.tv_sec,
                   (int) current_time.tv_usec / 1000,
                   al->cache.msec,
                   clientip,
-                  ::Format::log_tags[al->cache.code],
+                  LogTags_str[al->cache.code],
                   al->http.statusSfx(),
                   al->http.code,
                   al->cache.replySize,
                   al->_private.method_str,
                   al->url,
                   user ? user : dash_str,
                   al->hier.ping.timedout ? "TIMEOUT_" : "",
                   hier_code_str[al->hier.code],
-                  al->hier.tcpServer != NULL ? al->hier.tcpServer->remote.NtoA(hierHost, sizeof(hierHost)) : "-",
+                  al->hier.tcpServer != NULL ? al->hier.tcpServer->remote.toStr(hierHost, sizeof(hierHost)) : "-",
                   al->http.content_type,
                   (Config.onoff.log_mime_hdrs?"":"\n"));
 
     safe_free(user);
 
     if (Config.onoff.log_mime_hdrs) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -21,13 +21,13 @@
 	ModDaemon.cc \
 	ModDaemon.h \
 	ModStdio.cc \
 	ModStdio.h \
 	ModSyslog.cc \
 	ModSyslog.h \
-	ModTcp.cc \
-	ModTcp.h \
 	ModUdp.cc \
 	ModUdp.h \
 	CustomLog.h \
-	CustomLog.cc
+	CustomLog.cc \
+	TcpLogger.cc \
+	TcpLogger.h
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/Makefile.in	2015-05-01 16:51:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/Makefile.in	2015-05-01 18:06:59.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -105,13 +151,13 @@
 LTLIBRARIES = $(noinst_LTLIBRARIES)
 liblog_la_LIBADD =
 am_liblog_la_OBJECTS = access_log.lo Config.lo File.lo \
 	FormatHttpdCombined.lo FormatHttpdCommon.lo \
 	FormatSquidCustom.lo FormatSquidIcap.lo FormatSquidNative.lo \
 	FormatSquidReferer.lo FormatSquidUseragent.lo ModDaemon.lo \
-	ModStdio.lo ModSyslog.lo ModTcp.lo ModUdp.lo CustomLog.lo
+	ModStdio.lo ModSyslog.lo ModUdp.lo CustomLog.lo TcpLogger.lo
 liblog_la_OBJECTS = $(am_liblog_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 AM_V_P = $(am__v_P_@AM_V@)
@@ -455,12 +501,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -498,12 +545,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -530,27 +578,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -617,13 +668,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = liblog.la
 liblog_la_SOURCES = \
 	access_log.h \
 	access_log.cc \
 	Config.cc \
@@ -641,18 +692,18 @@
 	ModDaemon.cc \
 	ModDaemon.h \
 	ModStdio.cc \
 	ModStdio.h \
 	ModSyslog.cc \
 	ModSyslog.h \
-	ModTcp.cc \
-	ModTcp.h \
 	ModUdp.cc \
 	ModUdp.h \
 	CustomLog.h \
-	CustomLog.cc
+	CustomLog.cc \
+	TcpLogger.cc \
+	TcpLogger.h
 
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(top_srcdir)/src/TestHeaders.am $(am__configure_deps)
@@ -726,14 +777,14 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/FormatSquidNative.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/FormatSquidReferer.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/FormatSquidUseragent.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ModDaemon.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ModStdio.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ModSyslog.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ModTcp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ModUdp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TcpLogger.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/access_log.Plo@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
 @am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/ModDaemon.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/ModDaemon.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/ModDaemon.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/ModDaemon.cc	2015-05-01 18:05:19.000000000 +0800
@@ -110,32 +110,35 @@
     xfree(b);
 }
 
 static void
 logfileHandleWrite(int fd, void *data)
 {
-    Logfile *lf = (Logfile *) data;
-    l_daemon_t *ll = (l_daemon_t *) lf->data;
-    int ret;
-    logfile_buffer_t *b;
+    Logfile *lf = static_cast<Logfile *>(data);
+    l_daemon_t *ll = static_cast<l_daemon_t *>(lf->data);
 
     /*
      * We'll try writing the first entry until its done - if we
      * get a partial write then we'll re-schedule until its completed.
      * Its naive but it'll do for now.
      */
-    b = static_cast<logfile_buffer_t*>(ll->bufs.head->data);
+    if (!ll->bufs.head) // abort if there is nothing pending right now.
+        return;
+
+    logfile_buffer_t *b = static_cast<logfile_buffer_t*>(ll->bufs.head->data);
     assert(b != NULL);
     ll->flush_pending = 0;
 
-    ret = FD_WRITE_METHOD(ll->wfd, b->buf + b->written_len, b->len - b->written_len);
-    debugs(50, 3, "logfileHandleWrite: " << lf->path << ": write returned " << ret);
+    int ret = FD_WRITE_METHOD(ll->wfd, b->buf + b->written_len, b->len - b->written_len);
+    debugs(50, 3, lf->path << ": write returned " << ret);
     if (ret < 0) {
         if (ignoreErrno(errno)) {
             /* something temporary */
-            goto reschedule;
+            Comm::SetSelect(ll->wfd, COMM_SELECT_WRITE, logfileHandleWrite, lf, 0);
+            ll->flush_pending = 1;
+            return;
         }
         debugs(50, DBG_IMPORTANT,"logfileHandleWrite: " << lf->path << ": error writing (" << xstrerror() << ")");
         /* XXX should handle this better */
         fatal("I don't handle this error well!");
     }
     if (ret == 0) {
@@ -150,21 +153,18 @@
     if (b->written_len == b->len) {
         /* written the whole buffer! */
         logfileFreeBuffer(lf, b);
         b = NULL;
     }
     /* Is there more to write? */
-    if (ll->bufs.head == NULL) {
-        goto finish;
-    }
+    if (!ll->bufs.head)
+        return;
     /* there is, so schedule more */
 
-reschedule:
     Comm::SetSelect(ll->wfd, COMM_SELECT_WRITE, logfileHandleWrite, lf, 0);
     ll->flush_pending = 1;
-finish:
     return;
 }
 
 static void
 logfileQueueWrite(Logfile * lf)
 {
@@ -250,13 +250,13 @@
     ll->eol = 1;
     {
         Ip::Address localhost;
         args[0] = "(logfile-daemon)";
         args[1] = path;
         args[2] = NULL;
-        localhost.SetLocalhost();
+        localhost.setLocalhost();
         ll->pid = ipcCreate(IPC_STREAM, Log::TheConfig.logfile_daemon, args, "logfile-daemon", localhost, &ll->rfd, &ll->wfd, NULL);
         if (ll->pid < 0)
             fatal("Couldn't start logfile helper");
     }
     ll->nbufs = 0;
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log: ModTcp.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log: ModTcp.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/ModUdp.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/ModUdp.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/log/ModUdp.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log/ModUdp.cc	2015-05-01 18:05:19.000000000 +0800
@@ -180,27 +180,27 @@
             return FALSE;
         }
     }
     safe_free(strAddr);
 
     Ip::Address any_addr;
-    any_addr.SetAnyAddr();
+    any_addr.setAnyAddr();
 
     // require the sending UDP port to be of the right family for the destination address.
-    if (addr.IsIPv4())
-        any_addr.SetIPv4();
+    if (addr.isIPv4())
+        any_addr.setIPv4();
 
     ll->fd = comm_open(SOCK_DGRAM, IPPROTO_UDP, any_addr, COMM_NONBLOCKING, "UDP log socket");
     if (ll->fd < 0) {
         if (lf->flags.fatal) {
             fatalf("Unable to open UDP socket for logging\n");
         } else {
             debugs(50, DBG_IMPORTANT, "Unable to open UDP socket for logging");
             return FALSE;
         }
-    } else if (!comm_connect_addr(ll->fd, &addr)) {
+    } else if (!comm_connect_addr(ll->fd, addr)) {
         if (lf->flags.fatal) {
             fatalf("Unable to connect to %s for UDP log: %s\n", lf->path, xstrerror());
         } else {
             debugs(50, DBG_IMPORTANT, "Unable to connect to " << lf->path << " for UDP log: " << xstrerror());
             return FALSE;
         }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log: TcpLogger.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/log: TcpLogger.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: LogTags.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/main.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/main.cc	2015-05-01 18:05:19.000000000 +0800
@@ -50,15 +50,15 @@
 #include "errorpage.h"
 #include "event.h"
 #include "EventLoop.h"
 #include "ExternalACL.h"
 #include "fd.h"
 #include "format/Token.h"
-#include "forward.h"
 #include "fs/Module.h"
 #include "fqdncache.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "htcp.h"
 #include "HttpHeader.h"
 #include "HttpReply.h"
 #include "icmp/IcmpSquid.h"
 #include "icmp/net_db.h"
@@ -117,16 +117,16 @@
 #include "DelayPools.h"
 #endif
 #if USE_LOADABLE_MODULES
 #include "LoadableModules.h"
 #endif
 #if USE_SSL_CRTD
-#include "ssl/helper.h"
 #include "ssl/certificate_db.h"
 #endif
 #if USE_SSL
+#include "ssl/helper.h"
 #include "ssl/context_storage.h"
 #endif
 #if ICAP_CLIENT
 #include "adaptation/icap/Config.h"
 #endif
 #if USE_ECAP
@@ -150,26 +150,20 @@
 #endif
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
 
 #if USE_WIN32_SERVICE
-#include "squid_windows.h"
 #include <process.h>
 
 static int opt_install_service = FALSE;
 static int opt_remove_service = FALSE;
 static int opt_signal_service = FALSE;
 static int opt_command_line = FALSE;
 void WIN32_svcstatusupdate(DWORD, DWORD);
 void WINAPI WIN32_svcHandler(DWORD);
-
-#endif
-
-#if !defined(SQUID_BUILD_INFO)
-#define SQUID_BUILD_INFO ""
 #endif
 
 static char *opt_syslog_facility = NULL;
 static int icpPortNumOverride = 1;	/* Want to detect "-u 0" */
 static int configured_once = 0;
 #if MALLOC_DBG
@@ -299,13 +293,17 @@
             "       -f file   Use given config-file instead of\n"
             "                 %s\n"
             "       -h        Print help message.\n"
 #if USE_WIN32_SERVICE
             "       -i        Installs as a Windows Service (see -n option).\n"
 #endif
-            "       -k reconfigure|rotate|shutdown|interrupt|kill|debug|check|parse\n"
+            "       -k reconfigure|rotate|shutdown|"
+#ifdef SIGTTIN
+            "restart|"
+#endif
+            "interrupt|kill|debug|check|parse\n"
             "                 Parse configuration file, then send signal to \n"
             "                 running copy (except -k parse) and exit.\n"
 #if USE_WIN32_SERVICE
             "       -n name   Specify Windows Service name to use for service operations\n"
             "                 default is: " _WIN_SQUID_DEFAULT_SERVICE_NAME ".\n"
             "       -r        Removes a Windows Service (see -n option).\n"
@@ -504,18 +502,12 @@
 #if MALLOC_DBG
                 malloc_debug_level = atoi(optarg);
 #else
                 fatal("Need to add -DMALLOC_DBG when compiling to use -mX option");
 #endif
 
-            } else {
-#if XMALLOC_TRACE
-                xmalloc_trace = !xmalloc_trace;
-#else
-                fatal("Need to configure --enable-xmalloc-debug-trace to use -m option");
-#endif
             }
             break;
 
 #if USE_WIN32_SERVICE
 
         case 'n':
@@ -703,13 +695,12 @@
         htcpOpenPorts();
 #endif
 #if SQUID_SNMP
         snmpOpenPorts();
 #endif
 
-        clientdbInit();
         icmpEngine.Open();
         netdbInit();
         asnInit();
         ACL::Initialize();
         peerSelectInit();
 
@@ -766,12 +757,14 @@
 #endif
     dnsShutdown();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Shutdown();
 #endif
 #if USE_SSL
+    if (Ssl::CertValidationHelper::GetInstance())
+        Ssl::CertValidationHelper::GetInstance()->Shutdown();
     Ssl::TheGlobalContextStorage.reconfigureStart();
 #endif
     redirectShutdown();
 #if USE_AUTH
     authenticateReset();
 #endif
@@ -848,12 +841,16 @@
 #endif
     storeLogOpen();
     dnsInit();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Init();
 #endif
+#if USE_SSL
+    if (Ssl::CertValidationHelper::GetInstance())
+        Ssl::CertValidationHelper::GetInstance()->Init();
+#endif
 
     redirectInit();
 #if USE_AUTH
     authenticateInit(&Auth::TheConfig);
 #endif
     externalAclInit();
@@ -944,44 +941,60 @@
         debugs(0, DBG_CRITICAL, "it to run as a non-priveledged user with the");
         debugs(0, DBG_CRITICAL, "'cache_effective_user' option in the config file.");
         fatal("Don't run Squid as root, set 'cache_effective_user'!");
     }
 }
 
+/// changes working directory, providing error reporting
+static bool
+mainChangeDir(const char *dir)
+{
+    if (chdir(dir) == 0)
+        return true;
+
+    debugs(50, DBG_CRITICAL, "cannot change current directory to " << dir <<
+           ": " << xstrerror());
+    return false;
+}
+
+/// set the working directory.
 static void
 mainSetCwd(void)
 {
-    char pathbuf[MAXPATHLEN];
+    static bool chrooted = false;
+    if (Config.chroot_dir && !chrooted) {
+        chrooted = true;
+
+        if (chroot(Config.chroot_dir) != 0)
+            fatalf("chroot to %s failed: %s", Config.chroot_dir, xstrerror());
 
-    if (Config.coredump_dir) {
-        if (0 == strcmp("none", Config.coredump_dir)) {
-            (void) 0;
-        } else if (chdir(Config.coredump_dir) == 0) {
+        if (!mainChangeDir("/"))
+            fatalf("chdir to / after chroot to %s failed", Config.chroot_dir);
+    }
+
+    if (Config.coredump_dir && strcmp("none", Config.coredump_dir) != 0) {
+        if (mainChangeDir(Config.coredump_dir)) {
             debugs(0, DBG_IMPORTANT, "Set Current Directory to " << Config.coredump_dir);
             return;
-        } else {
-            debugs(50, DBG_CRITICAL, "chdir: " << Config.coredump_dir << ": " << xstrerror());
         }
     }
 
     /* If we don't have coredump_dir or couldn't cd there, report current dir */
+    char pathbuf[MAXPATHLEN];
     if (getcwd(pathbuf, MAXPATHLEN)) {
         debugs(0, DBG_IMPORTANT, "Current Directory is " << pathbuf);
     } else {
         debugs(50, DBG_CRITICAL, "WARNING: Can't find current directory, getcwd: " << xstrerror());
     }
 }
 
 static void
 mainInitialize(void)
 {
     /* chroot if configured to run inside chroot */
-
-    if (Config.chroot_dir && (chroot(Config.chroot_dir) != 0 || chdir("/") != 0)) {
-        fatal("failed to chroot");
-    }
+    mainSetCwd();
 
     if (opt_catch_signals) {
         squid_signal(SIGSEGV, death, SA_NODEFER | SA_RESETHAND);
         squid_signal(SIGBUS, death, SA_NODEFER | SA_RESETHAND);
     }
 
@@ -1045,12 +1058,17 @@
     dnsInit();
 
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Init();
 #endif
 
+#if USE_SSL
+    if (Ssl::CertValidationHelper::GetInstance())
+        Ssl::CertValidationHelper::GetInstance()->Init();
+#endif
+
     redirectInit();
 #if USE_AUTH
     authenticateInit(&Auth::TheConfig);
 #endif
     externalAclInit();
 
@@ -1279,16 +1297,12 @@
 
 int
 SquidMain(int argc, char **argv)
 {
     ConfigureCurrentKid(argv[0]);
 
-#if HAVE_SBRK
-    sbrk_start = sbrk(0);
-#endif
-
     Debug::parseOptions(NULL);
     debug_log = stderr;
 
 #if defined(SQUID_MAXFD_LIMIT)
 
     if (SQUID_MAXFD_LIMIT < Squid_MaxFD)
@@ -1413,17 +1427,14 @@
 
 #endif
 
     /* send signal to running copy and exit */
     if (opt_send_signal != -1) {
         /* chroot if configured to run inside chroot */
-
+        mainSetCwd();
         if (Config.chroot_dir) {
-            if (chroot(Config.chroot_dir))
-                fatal("failed to chroot");
-
             no_suid();
         } else {
             leave_suid();
         }
 
         sendSignal();
@@ -1439,16 +1450,13 @@
 
     if (!opt_no_daemon && Config.workers > 0)
         watch_child(argv);
 
     if (opt_create_swap_dirs) {
         /* chroot if configured to run inside chroot */
-
-        if (Config.chroot_dir && chroot(Config.chroot_dir)) {
-            fatal("failed to chroot");
-        }
+        mainSetCwd();
 
         setEffectiveUser();
         debugs(0, DBG_CRITICAL, "Creating missing swap directories");
         Store::Root().create();
 
         return 0;
@@ -1838,12 +1846,16 @@
 
     debugs(1, DBG_IMPORTANT, "Shutting down...");
     dnsShutdown();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Shutdown();
 #endif
+#if USE_SSL
+    if (Ssl::CertValidationHelper::GetInstance())
+        Ssl::CertValidationHelper::GetInstance()->Shutdown();
+#endif
     redirectShutdown();
     externalAclShutdown();
     icpClosePorts();
 #if USE_HTCP
     htcpClosePorts();
 #endif
@@ -1906,37 +1918,21 @@
     httpHeaderCleanModule();
     statFreeMemory();
     eventFreeMemory();
     mimeFreeMemory();
     errorClean();
 #endif
-#if !XMALLOC_TRACE
-
-    if (opt_no_daemon) {
-        file_close(0);
-        file_close(1);
-        file_close(2);
-    }
-
-#endif
     // clear StoreController
     Store::Root(NULL);
 
     fdDumpOpen();
 
     comm_exit();
 
     memClean();
 
-#if XMALLOC_TRACE
-
-    xmalloc_find_leaks();
-
-    debugs(1, DBG_CRITICAL, "Memory used after shutdown: " << xmalloc_total);
-
-#endif
 #if MEM_GEN_TRACE
 
     log_trace_done();
 
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -40,14 +40,14 @@
 AUTH_LIBS= auth/libauth.la
 AUTH_ACL_LIBS= auth/libacls.la
 check_PROGRAMS+= tests/testACLMaxUserIP
 endif
 DIST_SUBDIRS += auth
 
-SUBDIRS	+= ip icmp ident log ipc mgr
-DIST_SUBDIRS += ip icmp ident log ipc mgr
+SUBDIRS	+= http ip icmp ident log ipc mgr
+DIST_SUBDIRS += http ip icmp ident log ipc mgr
 
 if ENABLE_SSL
 SUBDIRS += ssl
 SSL_LIBS = \
 	ssl/libsslsquid.la \
 	ssl/libsslutil.la
@@ -77,13 +77,13 @@
 DIST_SUBDIRS += adaptation
 
 if USE_ESI
 SUBDIRS += esi
 ESI_LOCAL_LIBS = \
 	esi/libesi.la \
-	$(top_builddir)/lib/libTrie/src/libTrie.a
+	$(top_builddir)/lib/libTrie/libTrie.a
 ESI_LIBS = $(ESI_LOCAL_LIBS) \
 	$(XMLLIB) \
 	$(EXPATLIB)
 else
 ESI_LIBS = 
 endif
@@ -194,13 +194,12 @@
 	unlinkd \
 	dnsserver \
 	recv-announce \
 	tests/testUfs \
 	tests/testCoss \
 	tests/testRock \
-	tests/testNull \
 	ufsdump
 
 ## cfgen is used when building squid
 ## ufsdump is a debug utility, it is possibly useful for end users with cache
 ## corruption, but at this point we do not install it.
 noinst_PROGRAMS = \
@@ -347,35 +346,34 @@
 	fd.h \
 	fd.cc \
 	fde.cc \
 	fde.h \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
-	forward.h \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	Generic.h \
 	globals.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	helper.h \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	HierarchyLogEntry.h \
 	$(HTCPSOURCE) \
 	HttpStateFlags.h \
 	http.cc \
 	http.h \
-	HttpStatusCode.h \
-	HttpStatusLine.cc \
-	HttpStatusLine.h \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
@@ -404,13 +402,12 @@
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequest.h \
 	HttpRequestMethod.cc \
 	HttpRequestMethod.h \
-	HttpVersion.h \
 	ICP.h \
 	icp_opcode.h \
 	icp_v2.cc \
 	icp_v3.cc \
 	int.h \
 	int.cc \
@@ -419,14 +416,17 @@
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	ipcache.h \
 	$(LEAKFINDERSOURCE) \
 	SquidList.h \
 	SquidList.cc \
+	LogTags.h \
 	lookup_t.h \
 	main.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
 	mem_node.h \
 	Mem.h \
 	MemBuf.cc \
@@ -437,12 +437,14 @@
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Packer.h \
 	Parsing.cc \
 	Parsing.h \
 	$(XPROF_STATS_SOURCE) \
 	pconn.cc \
@@ -597,12 +599,13 @@
 	cf_parser.cci \
 	err_type.cc \
 	err_detail_type.cc \
 	globals.cc \
 	hier_code.cc \
 	icp_opcode.cc \
+	LogTags.cc \
 	lookup_t.cc \
 	repl_modules.cc \
 	swap_log_op.cc
 
 CLEANFILES += $(BUILT_SOURCES)
 
@@ -611,13 +614,12 @@
 	$(BUILT_SOURCES)
 
 squid_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	$(DISK_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
@@ -625,19 +627,21 @@
 	fs/libfs.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
 	comm/libcomm.la \
 	eui/libeui.la \
+	http/libsquid-http.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(XTRA_OBJS) \
 	$(DISK_LINKOBJS) \
 	$(REPL_OBJS) \
 	$(DISK_OS_LIBS) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(REGEXLIB) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	$(SNMP_LIBS) \
@@ -767,12 +771,13 @@
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(XTRA_OBJS) \
 	$(REPL_OBJS) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(EPOLL_LIBS) \
 	$(MINGW_LIBS) \
@@ -934,13 +939,13 @@
 DEFAULT_ICON_DIR	= $(datadir)/icons
 DEFAULT_ERROR_DIR	= $(datadir)/errors
 
 # Make location configure settings available to the code
 DEFS += -DDEFAULT_CONFIG_FILE=\"$(DEFAULT_CONFIG_FILE)\" -DDEFAULT_SQUID_DATA_DIR=\"$(datadir)\" -DDEFAULT_SQUID_CONFIG_DIR=\"$(sysconfdir)\"
 
-snmp_core.o snmp_agent.o: ../snmplib/libsnmplib.a $(top_srcdir)/include/cache_snmp.h
+snmp_core.o snmp_agent.o: ../snmplib/libsnmplib.la $(top_srcdir)/include/cache_snmp.h
 
 globals.cc: globals.h mk-globals-c.awk
 	$(AWK) -f $(srcdir)/mk-globals-c.awk < $(srcdir)/globals.h > $@ || ($(RM) -f $@ && exit 1)
 
 ## Generate files containing string arrays for various enums....
 hier_code.cc: hier_code.h mk-string-arrays.awk
@@ -949,12 +954,15 @@
 err_type.cc: err_type.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/err_type.h > $@ || ($(RM) -f $@ && exit 1)
 
 err_detail_type.cc: err_detail_type.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/err_detail_type.h | sed 's/ERR_DETAIL_//' > $@ || ($(RM) -f $@ && exit 1)
 
+LogTags.cc: LogTags.h mk-string-arrays.awk
+	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/LogTags.h | sed 's/LOG_//' > $@ || ($(RM) -f $@ && exit 1)
+
 lookup_t.cc: lookup_t.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/lookup_t.h > $@ || ($(RM) -f $@ && exit 1)
 
 icp_opcode.cc: icp_opcode.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/icp_opcode.h > $@ || ($(RM) -f $@ && exit 1)
 
@@ -1084,13 +1092,13 @@
 	tests/testHttpRequest \
 	tests/testStore \
 	tests/testString \
 	tests/testURL \
 	tests/testConfigParser \
 	tests/testStatHist \
-	$(STORE_TESTS)
+	tests/testVector
 
 if HAVE_FS_ROCK
 check_PROGRAMS += tests/testRock
 endif
 if HAVE_FS_UFS
 check_PROGRAMS += tests/testUfs
@@ -1123,12 +1131,13 @@
 
 
 # - add other component .(h|cc) files needed to link and run tests
 tests_testHttpReply_SOURCES=\
 	cbdata.cc \
 	cbdata.h \
+	ConfigParser.cc \
 	ETag.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
@@ -1150,15 +1159,12 @@
 	HttpHeaderTools.cc \
 	HttpControlMsg.h \
 	HttpMsg.cc \
 	HttpMsg.h \
 	HttpReply.cc \
 	HttpReply.h \
-	HttpStatusCode.h \
-	HttpStatusLine.cc \
-	HttpStatusLine.h \
 	Mem.h \
 	mem.cc \
 	RegexList.h \
 	RegexList.cc \
 	MemBuf.cc \
 	MemBuf.h \
@@ -1200,12 +1206,13 @@
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testHttpReply_SOURCES=\
 	$(TESTSOURCES)
 tests_testHttpReply_LDFLAGS = $(LIBADD_DL)
 tests_testHttpReply_LDADD=\
+	http/libsquid-http.la \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	anyp/libanyp.la \
 	ip/libip.la \
@@ -1213,12 +1220,13 @@
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
+	$(NETTLELIB) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttpReply_DEPENDENCIES= $(SQUID_CPPUNIT_LA)
 
 tests_testACLMaxUserIP_SOURCES= \
@@ -1251,12 +1259,16 @@
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpRequestMethod.cc \
 	int.h \
 	int.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
+	Notes.cc \
+	Notes.h \
 	SquidList.h \
 	SquidList.cc \
 	mem_node.cc \
 	Packer.cc \
 	Parsing.cc \
 	SquidMath.cc \
@@ -1286,12 +1298,13 @@
 	SwapDir.h \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
+	tests/stub_client_side.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_errorpage.cc \
 	fd.h \
 	tests/stub_fd.cc \
@@ -1330,12 +1343,13 @@
 	MemBuf.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testACLMaxUserIP_SOURCES= \
 	$(TESTSOURCES)
 tests_testACLMaxUserIP_LDADD= \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
@@ -1347,12 +1361,13 @@
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_OS_LIBS) \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testACLMaxUserIP_LDFLAGS = $(LIBADD_DL)
@@ -1442,23 +1457,26 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	hier_code.h \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	$(HTCPSOURCE) \
 	HttpStateFlags.h \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
@@ -1473,34 +1491,38 @@
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -1575,24 +1597,25 @@
 	wordlist.cc
 nodist_tests_testCacheManager_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 # comm.cc only requires comm/libcomm.la until fdc_table is dead.
 tests_testCacheManager_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	comm/libcomm.la \
+	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
@@ -1603,12 +1626,13 @@
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -1656,17 +1680,18 @@
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
 	Mem.h \
 	mem.cc \
 	Packer.cc \
@@ -1721,12 +1746,13 @@
 	tests/stub_http.cc \
 	tests/stub_icp.cc \
 	internal.h \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
 	tests/stub_pconn.cc \
@@ -1754,19 +1780,19 @@
 	$(TESTSOURCES) \
 	$(DISKIO_GEN_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testDiskIO_LDADD = \
+	http/libsquid-http.la \
 	SquidConfig.o \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	libsquid.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
 	ip/libip.la \
@@ -1780,12 +1806,13 @@
 	ipc/libipc.la \
 	base/libbase.la \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
@@ -1847,22 +1874,25 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
@@ -1883,36 +1913,40 @@
 	HttpParser.h \
 	HttpReply.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -1972,12 +2006,13 @@
 	tests/CapturingStoreEntry.h \
 	tests/testEvent.cc \
 	tests/testEvent.h \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
 	tools.cc \
 	tunnel.cc \
 	MemStore.cc \
@@ -1994,16 +2029,16 @@
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testEvent_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEvent_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -2022,12 +2057,13 @@
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -2089,22 +2125,25 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
@@ -2125,23 +2164,25 @@
 	HttpParser.h \
 	HttpReply.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
 	mime.h \
@@ -2149,12 +2190,14 @@
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -2214,12 +2257,13 @@
 	SwapDir.cc \
 	tests/testEventLoop.cc \
 	tests/testEventLoop.h \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
 	tools.cc \
 	tunnel.cc \
 	MemStore.cc \
@@ -2236,16 +2280,16 @@
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testEventLoop_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEventLoop_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -2264,12 +2308,13 @@
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -2328,22 +2373,25 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
@@ -2364,23 +2412,25 @@
 	HttpParser.h \
 	HttpReply.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
 	mime.h \
@@ -2388,12 +2438,14 @@
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
@@ -2449,12 +2501,13 @@
 	String.cc \
 	StrList.h \
 	StrList.cc \
 	SwapDir.cc \
 	tests/test_http_range.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
 	tools.cc \
@@ -2472,16 +2525,16 @@
 	wordlist.h \
 	wordlist.cc
 nodist_tests_test_http_range_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_test_http_range_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -2500,12 +2553,13 @@
 	base/libbase.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -2538,12 +2592,13 @@
 	time.cc \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testHttpParser_SOURCES = \
 	$(TESTSOURCES)
 tests_testHttpParser_LDADD= \
+	http/libsquid-http.la \
 	SquidConfig.o \
 	base/libbase.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -2570,12 +2625,13 @@
 	tests/testHttpRequestMethod.h \
 	tests/testHttpRequestMethod.cc \
 	tests/testMain.cc \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
@@ -2616,22 +2672,25 @@
 	ExternalACLEntry.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
@@ -2646,34 +2705,38 @@
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -2749,13 +2812,12 @@
 nodist_tests_testHttpRequest_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testHttpRequest_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -2765,20 +2827,22 @@
 	anyp/libanyp.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
+	http/libsquid-http.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_OS_LIBS) \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -2827,12 +2891,14 @@
 	RequestFlags.cc \
 	RequestFlags.h \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Packer.cc \
@@ -2881,12 +2947,13 @@
 	fd.h \
 	fde.h \
 	tests/stub_fd.cc \
 	tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	tests/stub_HttpReply.cc \
 	tests/stub_HttpRequest.cc \
 	tests/stub_libcomm.cc \
@@ -2925,16 +2992,16 @@
 	$(TESTSOURCES) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 
 tests_testStore_LDADD= \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -2943,12 +3010,13 @@
 	ipc/libipc.la \
 	anyp/libanyp.la \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	$(COMPAT_LIB) \
@@ -2999,13 +3067,12 @@
 SWAP_TEST_DS =\
 	repl_modules.o \
 	$(DISK_LIBS) \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -3021,12 +3088,13 @@
 	tests/testUfs.h \
 	tests/stub_cache_manager.cc \
 	tests/stub_client_db.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	tests/stub_UdsOp.cc \
 	internal.h \
 	tests/stub_internal.cc \
@@ -3045,19 +3113,20 @@
 	disk.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemObject.cc \
 	StoreSwapLogData.cc \
 	StoreIOState.cc \
 	StoreMeta.cc \
 	StoreMetaMD5.cc \
 	StoreMetaSTD.cc \
@@ -3149,18 +3218,18 @@
 	$(TESTSOURCES) \
 	$(DISKIO_GEN_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testUfs_LDADD = \
+	http/libsquid-http.la \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -3176,34 +3245,49 @@
 	anyp/libanyp.la \
 	base/libbase.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testUfs_LDFLAGS = $(LIBADD_DL)
 tests_testUfs_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
+check_PROGRAMS += testRefCount
+testRefCount_SOURCES= \
+	base/Lock.h \
+	base/RefCount.h \
+	tests/stub_cbdata.cc \
+	tests/stub_debug.cc \
+	tests/stub_MemBuf.cc \
+	tests/testRefCount.cc
+testRefCount_LDADD = \
+	base/libbase.la \
+	$(top_builddir)/lib/libmiscutil.la \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+
 tests_testRock_SOURCES = \
 	cbdata.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	disk.h \
 	disk.cc \
 	ETag.cc \
 	EventLoop.cc \
 	event.cc \
 	fatal.h \
-	tests/stub_fatal.cc \
+	fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.h \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
@@ -3220,17 +3304,18 @@
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
 	Packer.cc \
@@ -3284,12 +3369,13 @@
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
 	tests/stub_HttpRequest.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_libmgr.cc \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
@@ -3313,12 +3399,13 @@
 	$(DISKIO_GEN_SOURCE) \
 	swap_log_op.cc \
 	SquidMath.cc \
 	SquidMath.h \
 	$(TESTSOURCES)
 tests_testRock_LDADD = \
+	http/libsquid-http.la \
 	libsquid.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(AUTH_LIBS) \
@@ -3326,19 +3413,19 @@
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
-	eui/libeui.la \
 	ipc/libipc.la \
 	base/libbase.la \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testRock_LDFLAGS = $(INCLUDES) $(LIBADD_DL)
@@ -3354,12 +3441,13 @@
 	tests/stub_client_db.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
 	internal.h \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_pconn.cc \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_stats.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
@@ -3371,13 +3459,12 @@
 	disk.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
 	MemObject.cc \
 	StoreSwapLogData.cc \
@@ -3478,13 +3565,12 @@
 	anyp/libanyp.la \
 	libsquid.la \
 	$(REGEXLIB) \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	comm/libcomm.la \
 	ip/libip.la \
@@ -3507,156 +3593,12 @@
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testCoss_LDFLAGS = $(LIBADD_DL)
 tests_testCoss_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
-tests_testNull_SOURCES = \
-	tests/testNull.cc \
-	tests/testMain.cc \
-	tests/testNull.h \
-	internal.h \
-	tests/stub_internal.cc \
-	store_rebuild.h \
-	tests/stub_store_rebuild.cc \
-	tests/stub_store_stats.cc \
-	fd.h \
-	fd.cc \
-	disk.h \
-	disk.cc \
-	FileMap.h \
-	filemap.cc \
-	HttpBody.h \
-	HttpBody.cc \
-	HttpReply.cc \
-	HttpStatusLine.cc \
-	int.h \
-	int.cc \
-	SquidList.h \
-	SquidList.cc \
-	MemObject.cc \
-	StoreSwapLogData.cc \
-	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
-	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
-	StoreFileSystem.cc \
-	store_io.cc \
-	store_swapout.cc \
-	store_swapmeta.cc \
-	$(UNLINKDSOURCE) \
-	$(WIN32_SOURCE) \
-	event.cc \
-	$(DELAY_POOL_SOURCE) \
-	CacheDigest.h \
-	CacheDigest.cc \
-	ConfigParser.cc \
-	EventLoop.cc \
-	HttpMsg.cc \
-	RemovalPolicy.cc \
-	store_dir.cc \
-	repl_modules.h \
-	store.cc \
-	HttpRequestMethod.cc \
-	store_key_md5.h \
-	store_key_md5.cc \
-	Parsing.cc \
-	ConfigOption.cc \
-	SwapDir.cc \
-	tests/stub_acl.cc \
-	cache_cf.h \
-	YesNoNone.h \
-	tests/stub_cache_cf.cc \
-	tests/stub_helper.cc \
-	cbdata.cc \
-	String.cc \
-	tests/stub_comm.cc \
-	tests/stub_debug.cc \
-	tests/stub_client_side_request.cc \
-	tests/stub_http.cc \
-	mem_node.cc \
-	stmem.cc \
-	mime.h \
-	tests/stub_mime.cc \
-	HttpHeaderFieldInfo.h \
-	HttpHeaderTools.h \
-	HttpHeaderTools.cc \
-	HttpHeader.h \
-	HttpHeader.cc \
-	Mem.h \
-	mem.cc \
-	ClientInfo.h \
-	MemBuf.cc \
-	HttpHdrContRange.cc \
-	Packer.cc \
-	HttpHeaderFieldStat.h \
-	HttpHdrCc.h \
-	HttpHdrCc.cc \
-	HttpHdrCc.cci \
-	HttpHdrSc.cc \
-	HttpHdrScTarget.cc \
-	url.cc \
-	StatCounters.h \
-	StatCounters.cc \
-	StatHist.h \
-	tests/stub_StatHist.cc \
-	tests/stub_errorpage.cc \
-	tests/stub_HttpRequest.cc \
-	log/access_log.h \
-	tests/stub_access_log.cc \
-	refresh.h \
-	refresh.cc \
-	tests/stub_store_client.cc \
-	tests/stub_store_stats.cc \
-	tools.h \
-	tests/stub_tools.cc \
-	tests/testStoreSupport.cc \
-	tests/testStoreSupport.h \
-	time.cc \
-	URLScheme.cc \
-	wordlist.h \
-	wordlist.cc \
-	$(DISKIO_SOURCE)
-
-nodist_tests_testNull_SOURCES = \
-	$(TESTSOURCES) \
-	$(DISKIO_GEN_SOURCE)
-tests_testNull_LDADD = \
-	$(REGEXLIB) \
-	$(AUTH_ACL_LIBS) \
-	ident/libident.la \
-	acl/libacls.la \
-	eui/libeui.la \
-	acl/libstate.la \
-	$(AUTH_LIBS) \
-	acl/libapi.la \
-	base/libbase.la \
-	libsquid.la \
-	ip/libip.la \
-	fs/libfs.la \
-	ipc/libipc.la \
-	mgr/libmgr.la \
-	$(REPL_OBJS) \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
-	acl/libapi.la \
-	$(top_builddir)/lib/libmisccontainers.la \
-	$(top_builddir)/lib/libmiscencoding.la \
-	$(top_builddir)/lib/libmiscutil.la \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SSLLIB) \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-tests_testNull_LDFLAGS = $(LIBADD_DL)
-tests_testNull_DEPENDENCIES = \
-	$(SWAP_TEST_DS)
-
 ## Tests of the URL module.
 ## TODO: Trim this down once the insanity is over.
 tests_testURL_SOURCES = \
 	AccessLogEntry.cc \
 	$(ACL_REGISTRATION_SOURCES) \
 	BodyPipe.cc \
@@ -3704,22 +3646,25 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
@@ -3740,36 +3685,40 @@
 	HttpParser.h \
 	HttpReply.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -3853,12 +3802,13 @@
 	$(WIN32_SOURCE) \
 	wordlist.h \
 	wordlist.cc
 nodist_tests_testURL_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testURL_LDADD = \
+	http/libsquid-http.la \
 	anyp/libanyp.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
@@ -3881,12 +3831,13 @@
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(COMPAT_LIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -3973,12 +3924,27 @@
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(COMPAT_LIB)
 tests_testStatHist_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 
+tests_testVector_SOURCES = \
+	tests/testVector.cc \
+	tests/testMain.cc \
+	tests/testVector.h \
+	time.cc
+nodist_tests_testVector_SOURCES = \
+	$(TESTSOURCES)
+tests_testVector_LDADD= \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+tests_testVector_LDFLAGS = $(LIBADD_DL)
+tests_testVector_DEPENDENCIES = \
+	$(SQUID_CPPUNIT_LA)
+
 
 TESTS += testHeaders
 
 ## Special Universal .h dependency test script
 ## aborts if error encountered
 testHeaders: $(srcdir)/*.h $(srcdir)/DiskIO/*.h $(srcdir)/DiskIO/*/*.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Makefile.in	2015-05-01 16:51:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Makefile.in	2015-05-01 18:06:46.000000000 +0800
@@ -96,26 +96,25 @@
 	tests/testCacheManager$(EXEEXT) tests/testDiskIO$(EXEEXT) \
 	tests/testEvent$(EXEEXT) tests/testEventLoop$(EXEEXT) \
 	tests/test_http_range$(EXEEXT) tests/testHttpParser$(EXEEXT) \
 	tests/testHttpReply$(EXEEXT) tests/testHttpRequest$(EXEEXT) \
 	tests/testStore$(EXEEXT) tests/testString$(EXEEXT) \
 	tests/testURL$(EXEEXT) tests/testConfigParser$(EXEEXT) \
-	tests/testStatHist$(EXEEXT) $(STORE_TESTS) $(am__EXEEXT_2) \
-	$(am__EXEEXT_3)
+	tests/testStatHist$(EXEEXT) tests/testVector$(EXEEXT) \
+	$(am__EXEEXT_2) $(am__EXEEXT_3) testRefCount$(EXEEXT)
 @USE_LOADABLE_MODULES_TRUE@am__append_1 = $(INCLTDL)
 @ENABLE_AUTH_TRUE@am__append_2 = auth
 @ENABLE_AUTH_TRUE@am__append_3 = tests/testACLMaxUserIP
 @ENABLE_SSL_TRUE@am__append_4 = ssl
 @ENABLE_SNMP_TRUE@am__append_5 = snmp
 @USE_ADAPTATION_TRUE@am__append_6 = adaptation
 @USE_ESI_TRUE@am__append_7 = esi
 EXTRA_PROGRAMS = DiskIO/DiskDaemon/diskd$(EXEEXT) unlinkd$(EXEEXT) \
 	dnsserver$(EXEEXT) recv-announce$(EXEEXT) \
 	tests/testUfs$(EXEEXT) tests/testCoss$(EXEEXT) \
-	tests/testRock$(EXEEXT) tests/testNull$(EXEEXT) \
-	ufsdump$(EXEEXT)
+	tests/testRock$(EXEEXT) ufsdump$(EXEEXT)
 noinst_PROGRAMS = cf_gen$(EXEEXT)
 sbin_PROGRAMS = squid$(EXEEXT)
 bin_PROGRAMS =
 libexec_PROGRAMS = $(am__EXEEXT_4) $(DISK_PROGRAMS) $(am__EXEEXT_5)
 @USE_LOADABLE_MODULES_TRUE@am__append_8 = $(LOADABLE_MODULES_SOURCES)
 @USE_LOADABLE_MODULES_TRUE@am__append_9 = -L$(top_builddir) $(LIBLTDL)
@@ -128,14 +127,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -233,13 +278,14 @@
 	DiskIO/DiskDaemon/diskd.$(OBJEXT)
 nodist_DiskIO_DiskDaemon_diskd_OBJECTS = time.$(OBJEXT)
 DiskIO_DiskDaemon_diskd_OBJECTS =  \
 	$(am_DiskIO_DiskDaemon_diskd_OBJECTS) \
 	$(nodist_DiskIO_DiskDaemon_diskd_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 DiskIO_DiskDaemon_diskd_DEPENDENCIES =  \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
@@ -288,41 +334,42 @@
 	SquidDns.h DnsLookupDetails.h DnsLookupDetails.cc dns.cc \
 	enums.h err_type.h err_detail_type.h errorpage.cc errorpage.h \
 	ETag.cc ETag.h event.cc event.h EventLoop.h EventLoop.cc \
 	external_acl.cc ExternalACL.h ExternalACLEntry.cc \
 	ExternalACLEntry.h FadingCounter.h FadingCounter.cc fatal.h \
 	fatal.cc fd.h fd.cc fde.cc fde.h FileMap.h filemap.cc \
-	forward.cc forward.h fqdncache.h fqdncache.cc ftp.h ftp.cc \
+	fqdncache.h fqdncache.cc ftp.h ftp.cc FwdState.cc FwdState.h \
 	Generic.h globals.h gopher.h gopher.cc helper.cc helper.h \
-	HelperChildConfig.h HelperChildConfig.cc hier_code.h \
-	HierarchyLogEntry.h htcp.cc htcp.h HttpStateFlags.h http.cc \
-	http.h HttpStatusCode.h HttpStatusLine.cc HttpStatusLine.h \
-	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
-	HttpHdrRange.cc HttpHdrSc.cc HttpHdrSc.h HttpHdrScTarget.cc \
-	HttpHdrScTarget.h HttpHdrContRange.cc HttpHdrContRange.h \
-	HttpHeaderStat.h HttpHeader.h HttpHeader.cc HttpHeaderMask.h \
-	HttpHeaderRange.h HttpHeaderFieldInfo.h HttpHeaderTools.h \
-	HttpHeaderTools.cc HttpBody.h HttpBody.cc HttpControlMsg.h \
-	HttpMsg.cc HttpMsg.h HttpParser.cc HttpParser.h HttpReply.cc \
-	HttpReply.h RequestFlags.h RequestFlags.cc HttpRequest.cc \
-	HttpRequest.h HttpRequestMethod.cc HttpRequestMethod.h \
-	HttpVersion.h ICP.h icp_opcode.h icp_v2.cc icp_v3.cc int.h \
-	int.cc internal.h internal.cc SquidIpc.h ipc.cc ipc_win32.cc \
-	ipcache.cc ipcache.h LeakFinder.cc SquidList.h SquidList.cc \
-	lookup_t.h main.cc Mem.h mem.cc mem_node.cc mem_node.h \
-	MemBuf.cc MemObject.cc MemObject.h mime.h mime.cc \
-	mime_header.h mime_header.cc multicast.h multicast.cc \
-	neighbors.h neighbors.cc Packer.cc Packer.h Parsing.cc \
-	Parsing.h ProfStats.cc pconn.cc pconn.h PeerDigest.h \
-	peer_digest.cc peer_proxy_negotiate_auth.h \
-	peer_proxy_negotiate_auth.cc peer_select.cc peer_sourcehash.h \
-	peer_sourcehash.cc peer_userhash.h peer_userhash.cc \
-	PeerSelectState.h PingData.h protos.h redirect.h redirect.cc \
-	refresh.h refresh.cc RemovalPolicy.cc RemovalPolicy.h \
-	send-announce.h send-announce.cc base/InstanceId.h MemBlob.h \
-	MemBlob.cc SnmpRequest.h snmp_core.h snmp_core.cc snmp_agent.h \
+	HelperChildConfig.h HelperChildConfig.cc HelperReply.cc \
+	HelperReply.h hier_code.h HierarchyLogEntry.h htcp.cc htcp.h \
+	HttpStateFlags.h http.cc http.h HttpHeaderFieldStat.h \
+	HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci HttpHdrRange.cc \
+	HttpHdrSc.cc HttpHdrSc.h HttpHdrScTarget.cc HttpHdrScTarget.h \
+	HttpHdrContRange.cc HttpHdrContRange.h HttpHeaderStat.h \
+	HttpHeader.h HttpHeader.cc HttpHeaderMask.h HttpHeaderRange.h \
+	HttpHeaderFieldInfo.h HttpHeaderTools.h HttpHeaderTools.cc \
+	HttpBody.h HttpBody.cc HttpControlMsg.h HttpMsg.cc HttpMsg.h \
+	HttpParser.cc HttpParser.h HttpReply.cc HttpReply.h \
+	RequestFlags.h RequestFlags.cc HttpRequest.cc HttpRequest.h \
+	HttpRequestMethod.cc HttpRequestMethod.h ICP.h icp_opcode.h \
+	icp_v2.cc icp_v3.cc int.h int.cc internal.h internal.cc \
+	SquidIpc.h ipc.cc ipc_win32.cc ipcache.cc ipcache.h \
+	LeakFinder.cc SquidList.h SquidList.cc LogTags.h lookup_t.h \
+	main.cc MasterXaction.cc MasterXaction.h Mem.h mem.cc \
+	mem_node.cc mem_node.h MemBuf.cc MemObject.cc MemObject.h \
+	mime.h mime.cc mime_header.h mime_header.cc multicast.h \
+	multicast.cc neighbors.h neighbors.cc Notes.cc Notes.h \
+	Packer.cc Packer.h Parsing.cc Parsing.h ProfStats.cc pconn.cc \
+	pconn.h PeerDigest.h peer_digest.cc \
+	peer_proxy_negotiate_auth.h peer_proxy_negotiate_auth.cc \
+	peer_select.cc peer_sourcehash.h peer_sourcehash.cc \
+	peer_userhash.h peer_userhash.cc PeerSelectState.h PingData.h \
+	protos.h redirect.h redirect.cc refresh.h refresh.cc \
+	RemovalPolicy.cc RemovalPolicy.h send-announce.h \
+	send-announce.cc base/InstanceId.h MemBlob.h MemBlob.cc \
+	SnmpRequest.h snmp_core.h snmp_core.cc snmp_agent.h \
 	snmp_agent.cc SquidMath.h SquidMath.cc SquidNew.cc IoStats.h \
 	stat.h stat.cc StatCounters.h StatCounters.cc StatHist.h \
 	StatHist.cc String.cc StrList.h StrList.cc stmem.cc stmem.h \
 	repl_modules.h store.cc Store.h StoreFileSystem.cc \
 	StoreFileSystem.h StoreHashIndex.h store_io.cc StoreIOBuffer.h \
 	StoreIOState.cc StoreIOState.h store_client.cc StoreClient.h \
@@ -381,52 +428,52 @@
 	debug.$(OBJEXT) $(am__objects_6) disk.$(OBJEXT) \
 	$(am__objects_7) dlink.$(OBJEXT) $(am__objects_8) \
 	errorpage.$(OBJEXT) ETag.$(OBJEXT) event.$(OBJEXT) \
 	EventLoop.$(OBJEXT) external_acl.$(OBJEXT) \
 	ExternalACLEntry.$(OBJEXT) FadingCounter.$(OBJEXT) \
 	fatal.$(OBJEXT) fd.$(OBJEXT) fde.$(OBJEXT) filemap.$(OBJEXT) \
-	forward.$(OBJEXT) fqdncache.$(OBJEXT) ftp.$(OBJEXT) \
+	fqdncache.$(OBJEXT) ftp.$(OBJEXT) FwdState.$(OBJEXT) \
 	gopher.$(OBJEXT) helper.$(OBJEXT) HelperChildConfig.$(OBJEXT) \
-	$(am__objects_9) http.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
+	HelperReply.$(OBJEXT) $(am__objects_9) http.$(OBJEXT) \
 	HttpHdrCc.$(OBJEXT) HttpHdrRange.$(OBJEXT) HttpHdrSc.$(OBJEXT) \
 	HttpHdrScTarget.$(OBJEXT) HttpHdrContRange.$(OBJEXT) \
 	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
 	HttpBody.$(OBJEXT) HttpMsg.$(OBJEXT) HttpParser.$(OBJEXT) \
 	HttpReply.$(OBJEXT) RequestFlags.$(OBJEXT) \
 	HttpRequest.$(OBJEXT) HttpRequestMethod.$(OBJEXT) \
 	icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) int.$(OBJEXT) \
 	internal.$(OBJEXT) $(am__objects_10) ipcache.$(OBJEXT) \
 	$(am__objects_11) SquidList.$(OBJEXT) main.$(OBJEXT) \
-	mem.$(OBJEXT) mem_node.$(OBJEXT) MemBuf.$(OBJEXT) \
-	MemObject.$(OBJEXT) mime.$(OBJEXT) mime_header.$(OBJEXT) \
-	multicast.$(OBJEXT) neighbors.$(OBJEXT) Packer.$(OBJEXT) \
-	Parsing.$(OBJEXT) $(am__objects_12) pconn.$(OBJEXT) \
-	peer_digest.$(OBJEXT) peer_proxy_negotiate_auth.$(OBJEXT) \
-	peer_select.$(OBJEXT) peer_sourcehash.$(OBJEXT) \
-	peer_userhash.$(OBJEXT) redirect.$(OBJEXT) refresh.$(OBJEXT) \
-	RemovalPolicy.$(OBJEXT) send-announce.$(OBJEXT) \
-	$(am__objects_13) $(am__objects_15) SquidMath.$(OBJEXT) \
-	SquidNew.$(OBJEXT) stat.$(OBJEXT) StatCounters.$(OBJEXT) \
-	StatHist.$(OBJEXT) String.$(OBJEXT) StrList.$(OBJEXT) \
-	stmem.$(OBJEXT) store.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
-	store_io.$(OBJEXT) StoreIOState.$(OBJEXT) \
-	store_client.$(OBJEXT) store_digest.$(OBJEXT) \
-	store_dir.$(OBJEXT) store_key_md5.$(OBJEXT) \
-	store_log.$(OBJEXT) store_rebuild.$(OBJEXT) \
-	store_swapin.$(OBJEXT) store_swapmeta.$(OBJEXT) \
-	store_swapout.$(OBJEXT) StoreMeta.$(OBJEXT) \
-	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
-	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
-	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
-	StoreStats.$(OBJEXT) StoreSwapLogData.$(OBJEXT) \
-	Server.$(OBJEXT) SwapDir.$(OBJEXT) MemStore.$(OBJEXT) \
-	time.$(OBJEXT) tools.$(OBJEXT) tunnel.$(OBJEXT) \
-	$(am__objects_16) url.$(OBJEXT) URLScheme.$(OBJEXT) \
-	urn.$(OBJEXT) wccp.$(OBJEXT) wccp2.$(OBJEXT) whois.$(OBJEXT) \
-	wordlist.$(OBJEXT) $(am__objects_17) $(am__objects_18) \
-	$(am__objects_20)
+	MasterXaction.$(OBJEXT) mem.$(OBJEXT) mem_node.$(OBJEXT) \
+	MemBuf.$(OBJEXT) MemObject.$(OBJEXT) mime.$(OBJEXT) \
+	mime_header.$(OBJEXT) multicast.$(OBJEXT) neighbors.$(OBJEXT) \
+	Notes.$(OBJEXT) Packer.$(OBJEXT) Parsing.$(OBJEXT) \
+	$(am__objects_12) pconn.$(OBJEXT) peer_digest.$(OBJEXT) \
+	peer_proxy_negotiate_auth.$(OBJEXT) peer_select.$(OBJEXT) \
+	peer_sourcehash.$(OBJEXT) peer_userhash.$(OBJEXT) \
+	redirect.$(OBJEXT) refresh.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
+	send-announce.$(OBJEXT) $(am__objects_13) $(am__objects_15) \
+	SquidMath.$(OBJEXT) SquidNew.$(OBJEXT) stat.$(OBJEXT) \
+	StatCounters.$(OBJEXT) StatHist.$(OBJEXT) String.$(OBJEXT) \
+	StrList.$(OBJEXT) stmem.$(OBJEXT) store.$(OBJEXT) \
+	StoreFileSystem.$(OBJEXT) store_io.$(OBJEXT) \
+	StoreIOState.$(OBJEXT) store_client.$(OBJEXT) \
+	store_digest.$(OBJEXT) store_dir.$(OBJEXT) \
+	store_key_md5.$(OBJEXT) store_log.$(OBJEXT) \
+	store_rebuild.$(OBJEXT) store_swapin.$(OBJEXT) \
+	store_swapmeta.$(OBJEXT) store_swapout.$(OBJEXT) \
+	StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
+	StoreMetaSTD.$(OBJEXT) StoreMetaSTDLFS.$(OBJEXT) \
+	StoreMetaUnpacker.$(OBJEXT) StoreMetaURL.$(OBJEXT) \
+	StoreMetaVary.$(OBJEXT) StoreStats.$(OBJEXT) \
+	StoreSwapLogData.$(OBJEXT) Server.$(OBJEXT) SwapDir.$(OBJEXT) \
+	MemStore.$(OBJEXT) time.$(OBJEXT) tools.$(OBJEXT) \
+	tunnel.$(OBJEXT) $(am__objects_16) url.$(OBJEXT) \
+	URLScheme.$(OBJEXT) urn.$(OBJEXT) wccp.$(OBJEXT) \
+	wccp2.$(OBJEXT) whois.$(OBJEXT) wordlist.$(OBJEXT) \
+	$(am__objects_17) $(am__objects_18) $(am__objects_20)
 am__EXTRA_squid_SOURCES_DIST = DiskIO/AIO/aio_win32.cc \
 	DiskIO/AIO/aio_win32.h ConfigOption.h CommonPool.h \
 	CompositePoolNode.h delay_pools.cc DelayId.cc DelayId.h \
 	DelayIdComposite.h DelayBucket.cc DelayBucket.h DelayConfig.cc \
 	DelayConfig.h DelayPool.cc DelayPool.h DelayPools.h \
 	DelaySpec.cc DelaySpec.h DelayTagged.cc DelayTagged.h \
@@ -439,46 +486,54 @@
 	snmp_agent.cc unlinkd.h unlinkd.cc win32.h win32.cc WinSvc.h \
 	WinSvc.cc LoadableModule.h LoadableModule.cc LoadableModules.h \
 	LoadableModules.cc
 am__objects_21 = DiskIO/DiskIOModules_gen.$(OBJEXT)
 am__objects_22 = err_type.$(OBJEXT) err_detail_type.$(OBJEXT) \
 	globals.$(OBJEXT) hier_code.$(OBJEXT) icp_opcode.$(OBJEXT) \
-	lookup_t.$(OBJEXT) repl_modules.$(OBJEXT) \
+	LogTags.$(OBJEXT) lookup_t.$(OBJEXT) repl_modules.$(OBJEXT) \
 	swap_log_op.$(OBJEXT)
 nodist_squid_OBJECTS = $(am__objects_21) $(am__objects_22)
 squid_OBJECTS = $(am_squid_OBJECTS) $(nodist_squid_OBJECTS)
 @USE_ESI_TRUE@am__DEPENDENCIES_4 = $(ESI_LOCAL_LIBS) \
 @USE_ESI_TRUE@	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
 @ENABLE_SNMP_TRUE@am__DEPENDENCIES_5 = snmp/libsnmp.la \
 @ENABLE_SNMP_TRUE@	$(am__DEPENDENCIES_3)
 @USE_LOADABLE_MODULES_TRUE@am__DEPENDENCIES_6 = $(am__DEPENDENCIES_3)
 squid_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
 	$(CXXFLAGS) $(squid_LDFLAGS) $(LDFLAGS) -o $@
+am_testRefCount_OBJECTS = tests/stub_cbdata.$(OBJEXT) \
+	tests/stub_debug.$(OBJEXT) tests/stub_MemBuf.$(OBJEXT) \
+	tests/testRefCount.$(OBJEXT)
+testRefCount_OBJECTS = $(am_testRefCount_OBJECTS)
+testRefCount_DEPENDENCIES = base/libbase.la \
+	$(top_builddir)/lib/libmiscutil.la $(am__DEPENDENCIES_2) \
+	$(am__DEPENDENCIES_3)
 am_tests_testACLMaxUserIP_OBJECTS = cbdata.$(OBJEXT) \
 	ConfigOption.$(OBJEXT) ConfigParser.$(OBJEXT) \
 	DiskIO/ReadRequest.$(OBJEXT) DiskIO/WriteRequest.$(OBJEXT) \
 	ETag.$(OBJEXT) event.$(OBJEXT) tests/stub_fatal.$(OBJEXT) \
 	filemap.$(OBJEXT) HelperChildConfig.$(OBJEXT) \
 	HttpBody.$(OBJEXT) HttpHeader.$(OBJEXT) \
 	HttpHeaderTools.$(OBJEXT) HttpHdrContRange.$(OBJEXT) \
 	HttpHdrRange.$(OBJEXT) HttpHdrCc.$(OBJEXT) HttpHdrSc.$(OBJEXT) \
 	HttpHdrScTarget.$(OBJEXT) HttpMsg.$(OBJEXT) \
-	HttpRequestMethod.$(OBJEXT) int.$(OBJEXT) SquidList.$(OBJEXT) \
+	HttpRequestMethod.$(OBJEXT) int.$(OBJEXT) \
+	MasterXaction.$(OBJEXT) Notes.$(OBJEXT) SquidList.$(OBJEXT) \
 	mem_node.$(OBJEXT) Packer.$(OBJEXT) Parsing.$(OBJEXT) \
 	SquidMath.$(OBJEXT) StatCounters.$(OBJEXT) StrList.$(OBJEXT) \
 	tests/stub_StatHist.$(OBJEXT) stmem.$(OBJEXT) String.$(OBJEXT) \
 	store_dir.$(OBJEXT) StoreIOState.$(OBJEXT) StoreMeta.$(OBJEXT) \
 	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
 	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
 	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
 	StoreSwapLogData.$(OBJEXT) store_key_md5.$(OBJEXT) \
 	swap_log_op.$(OBJEXT) SwapDir.$(OBJEXT) \
 	tests/stub_access_log.$(OBJEXT) tests/stub_cache_cf.$(OBJEXT) \
-	tests/stub_debug.$(OBJEXT) tests/stub_DelayId.$(OBJEXT) \
-	tests/stub_DiskIOModule.$(OBJEXT) \
+	tests/stub_client_side.$(OBJEXT) tests/stub_debug.$(OBJEXT) \
+	tests/stub_DelayId.$(OBJEXT) tests/stub_DiskIOModule.$(OBJEXT) \
 	tests/stub_errorpage.$(OBJEXT) tests/stub_fd.$(OBJEXT) \
 	tests/stub_HttpRequest.$(OBJEXT) \
 	tests/stub_HttpReply.$(OBJEXT) \
 	tests/stub_ipc_TypedMsgHdr.$(OBJEXT) \
 	tests/stub_libcomm.$(OBJEXT) tests/stub_libformat.$(OBJEXT) \
 	tests/stub_libsslsquid.$(OBJEXT) \
@@ -493,22 +548,23 @@
 	time.$(OBJEXT) url.$(OBJEXT) URLScheme.$(OBJEXT) mem.$(OBJEXT) \
 	MemBuf.$(OBJEXT) wordlist.$(OBJEXT)
 am__objects_23 = test_tools.$(OBJEXT) globals.$(OBJEXT)
 nodist_tests_testACLMaxUserIP_OBJECTS = $(am__objects_23)
 tests_testACLMaxUserIP_OBJECTS = $(am_tests_testACLMaxUserIP_OBJECTS) \
 	$(nodist_tests_testACLMaxUserIP_OBJECTS)
-tests_testACLMaxUserIP_DEPENDENCIES = $(AUTH_ACL_LIBS) \
-	ident/libident.la acl/libacls.la eui/libeui.la acl/libstate.la \
-	$(AUTH_LIBS) acl/libapi.la anyp/libanyp.la base/libbase.la \
-	libsquid.la ip/libip.la ipc/libipc.la mgr/libmgr.la \
+tests_testACLMaxUserIP_DEPENDENCIES = http/libsquid-http.la \
+	$(AUTH_ACL_LIBS) ident/libident.la acl/libacls.la \
+	eui/libeui.la acl/libstate.la $(AUTH_LIBS) acl/libapi.la \
+	anyp/libanyp.la base/libbase.la libsquid.la ip/libip.la \
+	ipc/libipc.la mgr/libmgr.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la $(am__DEPENDENCIES_3) \
 	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
-	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_2) \
-	$(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
+	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3)
 tests_testACLMaxUserIP_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
 	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testACLMaxUserIP_LDFLAGS) \
 	$(LDFLAGS) -o $@
 am_tests_testBoilerplate_OBJECTS = tests/testBoilerplate.$(OBJEXT) \
 	tests/testMain.$(OBJEXT) time.$(OBJEXT)
@@ -546,44 +602,45 @@
 	DiskIO/DiskIOStrategy.h DiskIO/IORequestor.h \
 	DiskIO/DiskIOModule.h disk.h disk.cc dlink.h dlink.cc \
 	dns_internal.cc SquidDns.h DnsLookupDetails.h \
 	DnsLookupDetails.cc dns.cc errorpage.cc ETag.cc event.cc \
 	external_acl.cc ExternalACLEntry.cc fatal.h \
 	tests/stub_fatal.cc fd.h fd.cc fde.cc FileMap.h filemap.cc \
-	forward.cc fqdncache.h fqdncache.cc ftp.h ftp.cc gopher.h \
-	gopher.cc hier_code.h helper.cc HelperChildConfig.h \
-	HelperChildConfig.cc htcp.cc htcp.h HttpStateFlags.h http.cc \
-	HttpBody.h HttpBody.cc HttpHeader.h HttpHeader.cc \
-	HttpHeaderFieldInfo.h HttpHeaderTools.h HttpHeaderTools.cc \
-	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
-	HttpHdrContRange.cc HttpHdrRange.cc HttpHdrSc.cc \
-	HttpHdrScTarget.cc HttpMsg.cc HttpReply.cc HttpStatusLine.cc \
-	icp_v2.cc icp_v3.cc SquidIpc.h ipc.cc ipc_win32.cc ipcache.cc \
-	int.h int.cc internal.h internal.cc SquidList.h SquidList.cc \
-	multicast.h multicast.cc mem_node.cc MemBuf.cc MemObject.cc \
-	mime.h mime.cc mime_header.h mime_header.cc neighbors.h \
-	neighbors.cc Packer.cc Parsing.cc pconn.cc peer_digest.cc \
-	peer_proxy_negotiate_auth.h peer_proxy_negotiate_auth.cc \
-	peer_select.cc peer_sourcehash.h peer_sourcehash.cc \
-	peer_userhash.h peer_userhash.cc redirect.h redirect.cc \
-	refresh.h refresh.cc RemovalPolicy.cc Server.cc SnmpRequest.h \
-	snmp_core.h snmp_core.cc snmp_agent.h snmp_agent.cc \
-	SquidMath.h SquidMath.cc IoStats.h stat.h stat.cc \
-	StatCounters.h StatCounters.cc StatHist.h StrList.h StrList.cc \
-	tests/stub_StatHist.cc stmem.cc repl_modules.h store.cc \
-	store_client.cc store_digest.h store_digest.cc store_dir.cc \
-	store_io.cc store_key_md5.h store_key_md5.cc store_log.h \
-	store_log.cc store_rebuild.h store_rebuild.cc store_swapin.h \
-	store_swapin.cc store_swapmeta.cc store_swapout.cc \
-	StoreFileSystem.cc StoreIOState.cc StoreMeta.cc \
-	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
-	StoreMetaUnpacker.cc StoreMetaURL.cc StoreMetaVary.cc \
-	StoreSwapLogData.cc tools.h tools.cc tunnel.cc SwapDir.cc \
-	MemStore.cc unlinkd.h unlinkd.cc url.cc URLScheme.cc urn.h \
-	urn.cc wccp2.h wccp2.cc whois.h whois.cc FadingCounter.cc \
-	win32.cc wordlist.h wordlist.cc
+	fqdncache.h fqdncache.cc ftp.h ftp.cc FwdState.cc FwdState.h \
+	gopher.h gopher.cc hier_code.h helper.cc HelperChildConfig.h \
+	HelperChildConfig.cc HelperReply.cc HelperReply.h htcp.cc \
+	htcp.h HttpStateFlags.h http.cc HttpBody.h HttpBody.cc \
+	HttpHeader.h HttpHeader.cc HttpHeaderFieldInfo.h \
+	HttpHeaderTools.h HttpHeaderTools.cc HttpHeaderFieldStat.h \
+	HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci HttpHdrContRange.cc \
+	HttpHdrRange.cc HttpHdrSc.cc HttpHdrScTarget.cc HttpMsg.cc \
+	HttpReply.cc icp_v2.cc icp_v3.cc SquidIpc.h ipc.cc \
+	ipc_win32.cc ipcache.cc int.h int.cc internal.h internal.cc \
+	SquidList.h SquidList.cc MasterXaction.cc MasterXaction.h \
+	multicast.h multicast.cc mem_node.cc MemBlob.cc MemBuf.cc \
+	MemObject.cc mime.h mime.cc mime_header.h mime_header.cc \
+	neighbors.h neighbors.cc Notes.cc Notes.h Packer.cc Parsing.cc \
+	pconn.cc peer_digest.cc peer_proxy_negotiate_auth.h \
+	peer_proxy_negotiate_auth.cc peer_select.cc peer_sourcehash.h \
+	peer_sourcehash.cc peer_userhash.h peer_userhash.cc redirect.h \
+	redirect.cc refresh.h refresh.cc RemovalPolicy.cc Server.cc \
+	SnmpRequest.h snmp_core.h snmp_core.cc snmp_agent.h \
+	snmp_agent.cc SquidMath.h SquidMath.cc IoStats.h stat.h \
+	stat.cc StatCounters.h StatCounters.cc StatHist.h StrList.h \
+	StrList.cc tests/stub_StatHist.cc stmem.cc repl_modules.h \
+	store.cc store_client.cc store_digest.h store_digest.cc \
+	store_dir.cc store_io.cc store_key_md5.h store_key_md5.cc \
+	store_log.h store_log.cc store_rebuild.h store_rebuild.cc \
+	store_swapin.h store_swapin.cc store_swapmeta.cc \
+	store_swapout.cc StoreFileSystem.cc StoreIOState.cc \
+	StoreMeta.cc StoreMetaMD5.cc StoreMetaSTD.cc \
+	StoreMetaSTDLFS.cc StoreMetaUnpacker.cc StoreMetaURL.cc \
+	StoreMetaVary.cc StoreSwapLogData.cc tools.h tools.cc \
+	tunnel.cc SwapDir.cc MemStore.cc unlinkd.h unlinkd.cc url.cc \
+	URLScheme.cc urn.h urn.cc wccp2.h wccp2.cc whois.h whois.cc \
+	FadingCounter.cc win32.cc wordlist.h wordlist.cc
 am_tests_testCacheManager_OBJECTS = AccessLogEntry.$(OBJEXT) \
 	$(am__objects_4) debug.$(OBJEXT) HttpParser.$(OBJEXT) \
 	RequestFlags.$(OBJEXT) HttpRequest.$(OBJEXT) \
 	HttpRequestMethod.$(OBJEXT) mem.$(OBJEXT) String.$(OBJEXT) \
 	tests/testCacheManager.$(OBJEXT) tests/testMain.$(OBJEXT) \
 	tests/stub_main_cc.$(OBJEXT) \
@@ -598,46 +655,48 @@
 	ConfigParser.$(OBJEXT) CpuAffinityMap.$(OBJEXT) \
 	CpuAffinitySet.$(OBJEXT) $(am__objects_6) $(am__objects_7) \
 	disk.$(OBJEXT) dlink.$(OBJEXT) $(am__objects_8) \
 	errorpage.$(OBJEXT) ETag.$(OBJEXT) event.$(OBJEXT) \
 	external_acl.$(OBJEXT) ExternalACLEntry.$(OBJEXT) \
 	tests/stub_fatal.$(OBJEXT) fd.$(OBJEXT) fde.$(OBJEXT) \
-	filemap.$(OBJEXT) forward.$(OBJEXT) fqdncache.$(OBJEXT) \
-	ftp.$(OBJEXT) gopher.$(OBJEXT) helper.$(OBJEXT) \
-	HelperChildConfig.$(OBJEXT) $(am__objects_9) http.$(OBJEXT) \
-	HttpBody.$(OBJEXT) HttpHeader.$(OBJEXT) \
-	HttpHeaderTools.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
-	HttpHdrContRange.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
-	HttpHdrSc.$(OBJEXT) HttpHdrScTarget.$(OBJEXT) \
-	HttpMsg.$(OBJEXT) HttpReply.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
-	icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) $(am__objects_10) \
-	ipcache.$(OBJEXT) int.$(OBJEXT) internal.$(OBJEXT) \
-	SquidList.$(OBJEXT) multicast.$(OBJEXT) mem_node.$(OBJEXT) \
+	filemap.$(OBJEXT) fqdncache.$(OBJEXT) ftp.$(OBJEXT) \
+	FwdState.$(OBJEXT) gopher.$(OBJEXT) helper.$(OBJEXT) \
+	HelperChildConfig.$(OBJEXT) HelperReply.$(OBJEXT) \
+	$(am__objects_9) http.$(OBJEXT) HttpBody.$(OBJEXT) \
+	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
+	HttpHdrCc.$(OBJEXT) HttpHdrContRange.$(OBJEXT) \
+	HttpHdrRange.$(OBJEXT) HttpHdrSc.$(OBJEXT) \
+	HttpHdrScTarget.$(OBJEXT) HttpMsg.$(OBJEXT) \
+	HttpReply.$(OBJEXT) icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) \
+	$(am__objects_10) ipcache.$(OBJEXT) int.$(OBJEXT) \
+	internal.$(OBJEXT) SquidList.$(OBJEXT) MasterXaction.$(OBJEXT) \
+	multicast.$(OBJEXT) mem_node.$(OBJEXT) MemBlob.$(OBJEXT) \
 	MemBuf.$(OBJEXT) MemObject.$(OBJEXT) mime.$(OBJEXT) \
-	mime_header.$(OBJEXT) neighbors.$(OBJEXT) Packer.$(OBJEXT) \
-	Parsing.$(OBJEXT) pconn.$(OBJEXT) peer_digest.$(OBJEXT) \
-	peer_proxy_negotiate_auth.$(OBJEXT) peer_select.$(OBJEXT) \
-	peer_sourcehash.$(OBJEXT) peer_userhash.$(OBJEXT) \
-	redirect.$(OBJEXT) refresh.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
-	Server.$(OBJEXT) $(am__objects_15) SquidMath.$(OBJEXT) \
-	stat.$(OBJEXT) StatCounters.$(OBJEXT) StrList.$(OBJEXT) \
-	tests/stub_StatHist.$(OBJEXT) stmem.$(OBJEXT) store.$(OBJEXT) \
-	store_client.$(OBJEXT) store_digest.$(OBJEXT) \
-	store_dir.$(OBJEXT) store_io.$(OBJEXT) store_key_md5.$(OBJEXT) \
-	store_log.$(OBJEXT) store_rebuild.$(OBJEXT) \
-	store_swapin.$(OBJEXT) store_swapmeta.$(OBJEXT) \
-	store_swapout.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
-	StoreIOState.$(OBJEXT) StoreMeta.$(OBJEXT) \
-	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
-	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
-	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
-	StoreSwapLogData.$(OBJEXT) tools.$(OBJEXT) tunnel.$(OBJEXT) \
-	SwapDir.$(OBJEXT) MemStore.$(OBJEXT) $(am__objects_16) \
-	url.$(OBJEXT) URLScheme.$(OBJEXT) urn.$(OBJEXT) \
-	wccp2.$(OBJEXT) whois.$(OBJEXT) FadingCounter.$(OBJEXT) \
-	$(am__objects_17) wordlist.$(OBJEXT)
+	mime_header.$(OBJEXT) neighbors.$(OBJEXT) Notes.$(OBJEXT) \
+	Packer.$(OBJEXT) Parsing.$(OBJEXT) pconn.$(OBJEXT) \
+	peer_digest.$(OBJEXT) peer_proxy_negotiate_auth.$(OBJEXT) \
+	peer_select.$(OBJEXT) peer_sourcehash.$(OBJEXT) \
+	peer_userhash.$(OBJEXT) redirect.$(OBJEXT) refresh.$(OBJEXT) \
+	RemovalPolicy.$(OBJEXT) Server.$(OBJEXT) $(am__objects_15) \
+	SquidMath.$(OBJEXT) stat.$(OBJEXT) StatCounters.$(OBJEXT) \
+	StrList.$(OBJEXT) tests/stub_StatHist.$(OBJEXT) \
+	stmem.$(OBJEXT) store.$(OBJEXT) store_client.$(OBJEXT) \
+	store_digest.$(OBJEXT) store_dir.$(OBJEXT) store_io.$(OBJEXT) \
+	store_key_md5.$(OBJEXT) store_log.$(OBJEXT) \
+	store_rebuild.$(OBJEXT) store_swapin.$(OBJEXT) \
+	store_swapmeta.$(OBJEXT) store_swapout.$(OBJEXT) \
+	StoreFileSystem.$(OBJEXT) StoreIOState.$(OBJEXT) \
+	StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
+	StoreMetaSTD.$(OBJEXT) StoreMetaSTDLFS.$(OBJEXT) \
+	StoreMetaUnpacker.$(OBJEXT) StoreMetaURL.$(OBJEXT) \
+	StoreMetaVary.$(OBJEXT) StoreSwapLogData.$(OBJEXT) \
+	tools.$(OBJEXT) tunnel.$(OBJEXT) SwapDir.$(OBJEXT) \
+	MemStore.$(OBJEXT) $(am__objects_16) url.$(OBJEXT) \
+	URLScheme.$(OBJEXT) urn.$(OBJEXT) wccp2.$(OBJEXT) \
+	whois.$(OBJEXT) FadingCounter.$(OBJEXT) $(am__objects_17) \
+	wordlist.$(OBJEXT)
 nodist_tests_testCacheManager_OBJECTS = $(am__objects_22) \
 	$(am__objects_21)
 tests_testCacheManager_OBJECTS = $(am_tests_testCacheManager_OBJECTS) \
 	$(nodist_tests_testCacheManager_OBJECTS)
 tests_testCacheManager_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
@@ -658,17 +717,17 @@
 	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testConfigParser_LDFLAGS) \
 	$(LDFLAGS) -o $@
 am__tests_testCoss_SOURCES_DIST = tests/testCoss.cc tests/testMain.cc \
 	tests/testCoss.h tests/stub_cache_manager.cc client_db.h \
 	tests/stub_client_db.cc tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc internal.h \
-	tests/stub_internal.cc tests/stub_ipc.cc tests/stub_pconn.cc \
-	store_rebuild.h tests/stub_store_rebuild.cc \
-	tests/stub_store_stats.cc fatal.h tests/stub_fatal.cc fd.h \
-	fd.cc fde.h fde.cc disk.h disk.cc FileMap.h filemap.cc \
-	HttpBody.h HttpBody.cc HttpReply.cc HttpStatusLine.cc int.h \
+	tests/stub_internal.cc tests/stub_ipc.cc tests/stub_libeui.cc \
+	tests/stub_pconn.cc store_rebuild.h \
+	tests/stub_store_rebuild.cc tests/stub_store_stats.cc fatal.h \
+	tests/stub_fatal.cc fd.h fd.cc fde.h fde.cc disk.h disk.cc \
+	FileMap.h filemap.cc HttpBody.h HttpBody.cc HttpReply.cc int.h \
 	int.cc SquidList.h SquidList.cc MemObject.cc \
 	StoreSwapLogData.cc StoreIOState.cc StoreMeta.cc \
 	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
 	StoreMetaUnpacker.cc StoreMetaURL.cc StoreMetaVary.cc \
 	StoreFileSystem.cc store_io.cc store_swapout.cc \
 	store_swapmeta.cc unlinkd.h unlinkd.cc win32.cc event.cc \
@@ -706,28 +765,28 @@
 	DiskIO/DiskIOModule.h
 am_tests_testCoss_OBJECTS = tests/testCoss.$(OBJEXT) \
 	tests/testMain.$(OBJEXT) tests/stub_cache_manager.$(OBJEXT) \
 	tests/stub_client_db.$(OBJEXT) tests/stub_debug.$(OBJEXT) \
 	tests/stub_HelperChildConfig.$(OBJEXT) \
 	tests/stub_internal.$(OBJEXT) tests/stub_ipc.$(OBJEXT) \
-	tests/stub_pconn.$(OBJEXT) tests/stub_store_rebuild.$(OBJEXT) \
+	tests/stub_libeui.$(OBJEXT) tests/stub_pconn.$(OBJEXT) \
+	tests/stub_store_rebuild.$(OBJEXT) \
 	tests/stub_store_stats.$(OBJEXT) tests/stub_fatal.$(OBJEXT) \
 	fd.$(OBJEXT) fde.$(OBJEXT) disk.$(OBJEXT) filemap.$(OBJEXT) \
-	HttpBody.$(OBJEXT) HttpReply.$(OBJEXT) \
-	HttpStatusLine.$(OBJEXT) int.$(OBJEXT) SquidList.$(OBJEXT) \
-	MemObject.$(OBJEXT) StoreSwapLogData.$(OBJEXT) \
-	StoreIOState.$(OBJEXT) StoreMeta.$(OBJEXT) \
-	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
-	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
-	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
-	StoreFileSystem.$(OBJEXT) store_io.$(OBJEXT) \
-	store_swapout.$(OBJEXT) store_swapmeta.$(OBJEXT) \
-	$(am__objects_16) $(am__objects_17) event.$(OBJEXT) \
-	$(am__objects_6) CacheDigest.$(OBJEXT) ConfigParser.$(OBJEXT) \
-	EventLoop.$(OBJEXT) HttpMsg.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
-	store_dir.$(OBJEXT) store.$(OBJEXT) \
+	HttpBody.$(OBJEXT) HttpReply.$(OBJEXT) int.$(OBJEXT) \
+	SquidList.$(OBJEXT) MemObject.$(OBJEXT) \
+	StoreSwapLogData.$(OBJEXT) StoreIOState.$(OBJEXT) \
+	StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
+	StoreMetaSTD.$(OBJEXT) StoreMetaSTDLFS.$(OBJEXT) \
+	StoreMetaUnpacker.$(OBJEXT) StoreMetaURL.$(OBJEXT) \
+	StoreMetaVary.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
+	store_io.$(OBJEXT) store_swapout.$(OBJEXT) \
+	store_swapmeta.$(OBJEXT) $(am__objects_16) $(am__objects_17) \
+	event.$(OBJEXT) $(am__objects_6) CacheDigest.$(OBJEXT) \
+	ConfigParser.$(OBJEXT) EventLoop.$(OBJEXT) HttpMsg.$(OBJEXT) \
+	RemovalPolicy.$(OBJEXT) store_dir.$(OBJEXT) store.$(OBJEXT) \
 	HttpRequestMethod.$(OBJEXT) store_key_md5.$(OBJEXT) \
 	Parsing.$(OBJEXT) ConfigOption.$(OBJEXT) SwapDir.$(OBJEXT) \
 	tests/stub_acl.$(OBJEXT) tests/stub_cache_cf.$(OBJEXT) \
 	tests/stub_helper.$(OBJEXT) cbdata.$(OBJEXT) String.$(OBJEXT) \
 	tests/stub_client_side_request.$(OBJEXT) \
 	tests/stub_http.$(OBJEXT) mem_node.$(OBJEXT) stmem.$(OBJEXT) \
@@ -770,17 +829,17 @@
 	event.cc fatal.h tests/stub_fatal.cc fd.h fd.cc fde.h fde.cc \
 	FileMap.h filemap.cc HttpBody.h HttpBody.cc \
 	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
 	HttpHdrContRange.cc HttpHdrSc.cc HttpHdrScTarget.cc \
 	HttpHdrRange.cc HttpHeaderFieldInfo.h HttpHeaderTools.h \
 	HttpHeaderTools.cc HttpHeader.h HttpHeader.cc HttpMsg.cc \
-	HttpReply.cc HttpRequestMethod.cc HttpStatusLine.cc int.h \
-	int.cc SquidList.h SquidList.cc MemBuf.cc MemObject.cc \
-	mem_node.cc Mem.h mem.cc Packer.cc Parsing.cc refresh.h \
-	refresh.cc RemovalPolicy.cc RequestFlags.h RequestFlags.cc \
-	StatCounters.h StatCounters.cc StatHist.h \
+	HttpReply.cc HttpRequestMethod.cc int.h int.cc SquidList.h \
+	SquidList.cc MasterXaction.cc MasterXaction.h MemBuf.cc \
+	MemObject.cc mem_node.cc Mem.h mem.cc Packer.cc Parsing.cc \
+	refresh.h refresh.cc RemovalPolicy.cc RequestFlags.h \
+	RequestFlags.cc StatCounters.h StatCounters.cc StatHist.h \
 	tests/stub_StatHist.cc stmem.cc StoreFileSystem.cc \
 	StoreIOState.cc StoreMeta.cc StoreMetaMD5.cc StoreMetaSTD.cc \
 	StoreMetaSTDLFS.cc StoreMetaUnpacker.cc StoreMetaURL.cc \
 	StoreMetaVary.cc StoreSwapLogData.cc store_dir.cc store_io.cc \
 	store_key_md5.h store_key_md5.cc store_swapout.cc \
 	store_swapmeta.cc repl_modules.h store.cc String.cc StrList.h \
@@ -790,15 +849,15 @@
 	tests/stub_client_db.cc client_side_request.h \
 	tests/stub_client_side_request.cc tests/stub_debug.cc \
 	tests/stub_errorpage.cc tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc tests/stub_HttpRequest.cc \
 	tests/stub_http.cc tests/stub_icp.cc internal.h \
 	tests/stub_internal.cc tests/stub_ipc.cc tests/stub_ipcache.cc \
-	tests/stub_libformat.cc tests/stub_libicmp.cc \
-	tests/stub_MemStore.cc mime.h tests/stub_mime.cc \
-	tests/stub_pconn.cc tests/stub_Port.cc \
+	tests/stub_libeui.cc tests/stub_libformat.cc \
+	tests/stub_libicmp.cc tests/stub_MemStore.cc mime.h \
+	tests/stub_mime.cc tests/stub_pconn.cc tests/stub_Port.cc \
 	tests/stub_store_client.cc tests/stub_store_stats.cc \
 	store_rebuild.h tests/stub_store_rebuild.cc \
 	tests/stub_UdsOp.cc tests/testDiskIO.cc tests/testDiskIO.h \
 	tests/testMain.cc tests/testStoreSupport.cc \
 	tests/testStoreSupport.h time.cc unlinkd.h unlinkd.cc url.cc \
 	URLScheme.cc win32.cc wordlist.h wordlist.cc tools.h \
@@ -810,25 +869,24 @@
 	fd.$(OBJEXT) fde.$(OBJEXT) filemap.$(OBJEXT) \
 	HttpBody.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
 	HttpHdrContRange.$(OBJEXT) HttpHdrSc.$(OBJEXT) \
 	HttpHdrScTarget.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
 	HttpHeaderTools.$(OBJEXT) HttpHeader.$(OBJEXT) \
 	HttpMsg.$(OBJEXT) HttpReply.$(OBJEXT) \
-	HttpRequestMethod.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
-	int.$(OBJEXT) SquidList.$(OBJEXT) MemBuf.$(OBJEXT) \
-	MemObject.$(OBJEXT) mem_node.$(OBJEXT) mem.$(OBJEXT) \
-	Packer.$(OBJEXT) Parsing.$(OBJEXT) refresh.$(OBJEXT) \
-	RemovalPolicy.$(OBJEXT) RequestFlags.$(OBJEXT) \
-	StatCounters.$(OBJEXT) tests/stub_StatHist.$(OBJEXT) \
-	stmem.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
-	StoreIOState.$(OBJEXT) StoreMeta.$(OBJEXT) \
-	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
-	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
-	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
-	StoreSwapLogData.$(OBJEXT) store_dir.$(OBJEXT) \
-	store_io.$(OBJEXT) store_key_md5.$(OBJEXT) \
+	HttpRequestMethod.$(OBJEXT) int.$(OBJEXT) SquidList.$(OBJEXT) \
+	MasterXaction.$(OBJEXT) MemBuf.$(OBJEXT) MemObject.$(OBJEXT) \
+	mem_node.$(OBJEXT) mem.$(OBJEXT) Packer.$(OBJEXT) \
+	Parsing.$(OBJEXT) refresh.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
+	RequestFlags.$(OBJEXT) StatCounters.$(OBJEXT) \
+	tests/stub_StatHist.$(OBJEXT) stmem.$(OBJEXT) \
+	StoreFileSystem.$(OBJEXT) StoreIOState.$(OBJEXT) \
+	StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
+	StoreMetaSTD.$(OBJEXT) StoreMetaSTDLFS.$(OBJEXT) \
+	StoreMetaUnpacker.$(OBJEXT) StoreMetaURL.$(OBJEXT) \
+	StoreMetaVary.$(OBJEXT) StoreSwapLogData.$(OBJEXT) \
+	store_dir.$(OBJEXT) store_io.$(OBJEXT) store_key_md5.$(OBJEXT) \
 	store_swapout.$(OBJEXT) store_swapmeta.$(OBJEXT) \
 	store.$(OBJEXT) String.$(OBJEXT) StrList.$(OBJEXT) \
 	SwapDir.$(OBJEXT) tests/stub_access_log.$(OBJEXT) \
 	tests/stub_acl.$(OBJEXT) tests/stub_cache_cf.$(OBJEXT) \
 	tests/stub_cache_manager.$(OBJEXT) \
 	tests/stub_client_db.$(OBJEXT) \
@@ -836,16 +894,16 @@
 	tests/stub_debug.$(OBJEXT) tests/stub_errorpage.$(OBJEXT) \
 	tests/stub_helper.$(OBJEXT) \
 	tests/stub_HelperChildConfig.$(OBJEXT) \
 	tests/stub_HttpRequest.$(OBJEXT) tests/stub_http.$(OBJEXT) \
 	tests/stub_icp.$(OBJEXT) tests/stub_internal.$(OBJEXT) \
 	tests/stub_ipc.$(OBJEXT) tests/stub_ipcache.$(OBJEXT) \
-	tests/stub_libformat.$(OBJEXT) tests/stub_libicmp.$(OBJEXT) \
-	tests/stub_MemStore.$(OBJEXT) tests/stub_mime.$(OBJEXT) \
-	tests/stub_pconn.$(OBJEXT) tests/stub_Port.$(OBJEXT) \
-	tests/stub_store_client.$(OBJEXT) \
+	tests/stub_libeui.$(OBJEXT) tests/stub_libformat.$(OBJEXT) \
+	tests/stub_libicmp.$(OBJEXT) tests/stub_MemStore.$(OBJEXT) \
+	tests/stub_mime.$(OBJEXT) tests/stub_pconn.$(OBJEXT) \
+	tests/stub_Port.$(OBJEXT) tests/stub_store_client.$(OBJEXT) \
 	tests/stub_store_stats.$(OBJEXT) \
 	tests/stub_store_rebuild.$(OBJEXT) tests/stub_UdsOp.$(OBJEXT) \
 	tests/testDiskIO.$(OBJEXT) tests/testMain.$(OBJEXT) \
 	tests/testStoreSupport.$(OBJEXT) time.$(OBJEXT) \
 	$(am__objects_16) url.$(OBJEXT) URLScheme.$(OBJEXT) \
 	$(am__objects_17) wordlist.$(OBJEXT) \
@@ -879,27 +937,28 @@
 	DiskIO/DiskIOStrategy.h DiskIO/IORequestor.h \
 	DiskIO/DiskIOModule.h disk.h disk.cc dlink.h dlink.cc \
 	dns_internal.cc SquidDns.h DnsLookupDetails.h \
 	DnsLookupDetails.cc dns.cc errorpage.cc ETag.cc event.cc \
 	EventLoop.h EventLoop.cc external_acl.cc ExternalACLEntry.cc \
 	FadingCounter.cc fatal.h tests/stub_fatal.cc fd.h fd.cc fde.cc \
-	FileMap.h filemap.cc forward.cc fqdncache.h fqdncache.cc ftp.h \
-	ftp.cc gopher.h gopher.cc helper.cc HelperChildConfig.h \
-	HelperChildConfig.cc hier_code.h htcp.cc htcp.h http.cc \
-	HttpBody.h HttpBody.cc HttpHeader.h HttpHeader.cc \
-	HttpHeaderFieldInfo.h HttpHeaderTools.h HttpHeaderTools.cc \
-	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
-	HttpHdrContRange.cc HttpHdrRange.cc HttpHdrSc.cc \
-	HttpHdrScTarget.cc HttpMsg.cc HttpParser.cc HttpParser.h \
-	HttpReply.cc RequestFlags.h RequestFlags.cc HttpRequest.cc \
-	HttpRequestMethod.cc HttpStatusLine.cc icp_v2.cc icp_v3.cc \
-	SquidIpc.h ipc.cc ipc_win32.cc ipcache.cc int.h int.cc \
-	internal.h internal.cc SquidList.h SquidList.cc Mem.h mem.cc \
-	mem_node.cc MemBuf.cc MemObject.cc mime.h mime.cc \
-	mime_header.h mime_header.cc multicast.h multicast.cc \
-	neighbors.h neighbors.cc Packer.cc Parsing.cc pconn.cc \
+	FileMap.h filemap.cc fqdncache.h fqdncache.cc ftp.h ftp.cc \
+	FwdState.cc FwdState.h gopher.h gopher.cc helper.cc \
+	HelperChildConfig.h HelperChildConfig.cc HelperReply.cc \
+	HelperReply.h hier_code.h htcp.cc htcp.h http.cc HttpBody.h \
+	HttpBody.cc HttpHeader.h HttpHeader.cc HttpHeaderFieldInfo.h \
+	HttpHeaderTools.h HttpHeaderTools.cc HttpHeaderFieldStat.h \
+	HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci HttpHdrContRange.cc \
+	HttpHdrRange.cc HttpHdrSc.cc HttpHdrScTarget.cc HttpMsg.cc \
+	HttpParser.cc HttpParser.h HttpReply.cc RequestFlags.h \
+	RequestFlags.cc HttpRequest.cc HttpRequestMethod.cc icp_v2.cc \
+	icp_v3.cc SquidIpc.h ipc.cc ipc_win32.cc ipcache.cc int.h \
+	int.cc internal.h internal.cc SquidList.h SquidList.cc \
+	MasterXaction.cc MasterXaction.h Mem.h mem.cc mem_node.cc \
+	MemBlob.cc MemBuf.cc MemObject.cc mime.h mime.cc mime_header.h \
+	mime_header.cc multicast.h multicast.cc neighbors.h \
+	neighbors.cc Notes.cc Notes.h Packer.cc Parsing.cc pconn.cc \
 	peer_digest.cc peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc peer_select.cc peer_sourcehash.h \
 	peer_sourcehash.cc peer_userhash.h peer_userhash.cc redirect.h \
 	redirect.cc refresh.h refresh.cc RemovalPolicy.cc Server.cc \
 	StrList.h StrList.cc SnmpRequest.h snmp_core.h snmp_core.cc \
 	snmp_agent.h snmp_agent.cc SquidMath.cc SquidMath.h IoStats.h \
@@ -912,16 +971,17 @@
 	StoreFileSystem.cc StoreIOState.cc StoreMeta.cc \
 	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
 	StoreMetaUnpacker.cc StoreMetaURL.cc StoreMetaVary.cc \
 	StoreSwapLogData.cc String.cc SwapDir.cc \
 	tests/CapturingStoreEntry.h tests/testEvent.cc \
 	tests/testEvent.h tests/testMain.cc tests/stub_main_cc.cc \
-	tests/stub_ipc_Forwarder.cc tests/stub_store_stats.cc time.cc \
-	tools.h tools.cc tunnel.cc MemStore.cc unlinkd.h unlinkd.cc \
-	url.cc URLScheme.cc urn.h urn.cc wccp2.h wccp2.cc whois.h \
-	whois.cc win32.cc wordlist.h wordlist.cc
+	tests/stub_ipc_Forwarder.cc tests/stub_libeui.cc \
+	tests/stub_store_stats.cc time.cc tools.h tools.cc tunnel.cc \
+	MemStore.cc unlinkd.h unlinkd.cc url.cc URLScheme.cc urn.h \
+	urn.cc wccp2.h wccp2.cc whois.h whois.cc win32.cc wordlist.h \
+	wordlist.cc
 am_tests_testEvent_OBJECTS = AccessLogEntry.$(OBJEXT) $(am__objects_4) \
 	BodyPipe.$(OBJEXT) CacheDigest.$(OBJEXT) YesNoNone.$(OBJEXT) \
 	cache_cf.$(OBJEXT) cache_manager.$(OBJEXT) carp.$(OBJEXT) \
 	cbdata.$(OBJEXT) ChunkedCodingParser.$(OBJEXT) \
 	client_db.$(OBJEXT) client_side.$(OBJEXT) \
 	client_side_reply.$(OBJEXT) client_side_request.$(OBJEXT) \
@@ -930,47 +990,49 @@
 	CpuAffinitySet.$(OBJEXT) debug.$(OBJEXT) $(am__objects_6) \
 	$(am__objects_7) disk.$(OBJEXT) dlink.$(OBJEXT) \
 	$(am__objects_8) errorpage.$(OBJEXT) ETag.$(OBJEXT) \
 	event.$(OBJEXT) EventLoop.$(OBJEXT) external_acl.$(OBJEXT) \
 	ExternalACLEntry.$(OBJEXT) FadingCounter.$(OBJEXT) \
 	tests/stub_fatal.$(OBJEXT) fd.$(OBJEXT) fde.$(OBJEXT) \
-	filemap.$(OBJEXT) forward.$(OBJEXT) fqdncache.$(OBJEXT) \
-	ftp.$(OBJEXT) gopher.$(OBJEXT) helper.$(OBJEXT) \
-	HelperChildConfig.$(OBJEXT) $(am__objects_9) http.$(OBJEXT) \
-	HttpBody.$(OBJEXT) HttpHeader.$(OBJEXT) \
-	HttpHeaderTools.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
-	HttpHdrContRange.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
-	HttpHdrSc.$(OBJEXT) HttpHdrScTarget.$(OBJEXT) \
-	HttpMsg.$(OBJEXT) HttpParser.$(OBJEXT) HttpReply.$(OBJEXT) \
+	filemap.$(OBJEXT) fqdncache.$(OBJEXT) ftp.$(OBJEXT) \
+	FwdState.$(OBJEXT) gopher.$(OBJEXT) helper.$(OBJEXT) \
+	HelperChildConfig.$(OBJEXT) HelperReply.$(OBJEXT) \
+	$(am__objects_9) http.$(OBJEXT) HttpBody.$(OBJEXT) \
+	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
+	HttpHdrCc.$(OBJEXT) HttpHdrContRange.$(OBJEXT) \
+	HttpHdrRange.$(OBJEXT) HttpHdrSc.$(OBJEXT) \
+	HttpHdrScTarget.$(OBJEXT) HttpMsg.$(OBJEXT) \
+	HttpParser.$(OBJEXT) HttpReply.$(OBJEXT) \
 	RequestFlags.$(OBJEXT) HttpRequest.$(OBJEXT) \
-	HttpRequestMethod.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
-	icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) $(am__objects_10) \
-	ipcache.$(OBJEXT) int.$(OBJEXT) internal.$(OBJEXT) \
-	SquidList.$(OBJEXT) mem.$(OBJEXT) mem_node.$(OBJEXT) \
+	HttpRequestMethod.$(OBJEXT) icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) \
+	$(am__objects_10) ipcache.$(OBJEXT) int.$(OBJEXT) \
+	internal.$(OBJEXT) SquidList.$(OBJEXT) MasterXaction.$(OBJEXT) \
+	mem.$(OBJEXT) mem_node.$(OBJEXT) MemBlob.$(OBJEXT) \
 	MemBuf.$(OBJEXT) MemObject.$(OBJEXT) mime.$(OBJEXT) \
 	mime_header.$(OBJEXT) multicast.$(OBJEXT) neighbors.$(OBJEXT) \
-	Packer.$(OBJEXT) Parsing.$(OBJEXT) pconn.$(OBJEXT) \
-	peer_digest.$(OBJEXT) peer_proxy_negotiate_auth.$(OBJEXT) \
-	peer_select.$(OBJEXT) peer_sourcehash.$(OBJEXT) \
-	peer_userhash.$(OBJEXT) redirect.$(OBJEXT) refresh.$(OBJEXT) \
-	RemovalPolicy.$(OBJEXT) Server.$(OBJEXT) StrList.$(OBJEXT) \
-	$(am__objects_15) SquidMath.$(OBJEXT) stat.$(OBJEXT) \
-	StatCounters.$(OBJEXT) StatHist.$(OBJEXT) stmem.$(OBJEXT) \
-	store.$(OBJEXT) store_client.$(OBJEXT) store_digest.$(OBJEXT) \
+	Notes.$(OBJEXT) Packer.$(OBJEXT) Parsing.$(OBJEXT) \
+	pconn.$(OBJEXT) peer_digest.$(OBJEXT) \
+	peer_proxy_negotiate_auth.$(OBJEXT) peer_select.$(OBJEXT) \
+	peer_sourcehash.$(OBJEXT) peer_userhash.$(OBJEXT) \
+	redirect.$(OBJEXT) refresh.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
+	Server.$(OBJEXT) StrList.$(OBJEXT) $(am__objects_15) \
+	SquidMath.$(OBJEXT) stat.$(OBJEXT) StatCounters.$(OBJEXT) \
+	StatHist.$(OBJEXT) stmem.$(OBJEXT) store.$(OBJEXT) \
+	store_client.$(OBJEXT) store_digest.$(OBJEXT) \
 	store_dir.$(OBJEXT) store_io.$(OBJEXT) store_key_md5.$(OBJEXT) \
 	store_log.$(OBJEXT) store_rebuild.$(OBJEXT) \
 	store_swapin.$(OBJEXT) store_swapmeta.$(OBJEXT) \
 	store_swapout.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
 	StoreIOState.$(OBJEXT) StoreMeta.$(OBJEXT) \
 	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
 	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
 	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
 	StoreSwapLogData.$(OBJEXT) String.$(OBJEXT) SwapDir.$(OBJEXT) \
 	tests/testEvent.$(OBJEXT) tests/testMain.$(OBJEXT) \
 	tests/stub_main_cc.$(OBJEXT) \
-	tests/stub_ipc_Forwarder.$(OBJEXT) \
+	tests/stub_ipc_Forwarder.$(OBJEXT) tests/stub_libeui.$(OBJEXT) \
 	tests/stub_store_stats.$(OBJEXT) time.$(OBJEXT) \
 	tools.$(OBJEXT) tunnel.$(OBJEXT) MemStore.$(OBJEXT) \
 	$(am__objects_16) url.$(OBJEXT) URLScheme.$(OBJEXT) \
 	urn.$(OBJEXT) wccp2.$(OBJEXT) whois.$(OBJEXT) \
 	$(am__objects_17) wordlist.$(OBJEXT)
 nodist_tests_testEvent_OBJECTS = $(am__objects_22) $(am__objects_21)
@@ -1001,28 +1063,29 @@
 	DiskIO/DiskIOStrategy.h DiskIO/IORequestor.h \
 	DiskIO/DiskIOModule.h disk.h disk.cc dlink.h dlink.cc \
 	dns_internal.cc SquidDns.h DnsLookupDetails.h \
 	DnsLookupDetails.cc dns.cc errorpage.cc ETag.cc EventLoop.h \
 	EventLoop.cc event.cc external_acl.cc ExternalACLEntry.cc \
 	FadingCounter.cc fatal.h tests/stub_fatal.cc fd.h fd.cc fde.cc \
-	FileMap.h filemap.cc forward.cc fqdncache.h fqdncache.cc ftp.h \
-	ftp.cc gopher.h gopher.cc helper.cc HelperChildConfig.h \
-	HelperChildConfig.cc hier_code.h htcp.cc htcp.h http.cc \
-	HttpBody.h HttpBody.cc HttpHeader.h HttpHeader.cc \
-	HttpHeaderFieldInfo.h HttpHeaderTools.h HttpHeaderTools.cc \
-	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
-	HttpHdrContRange.cc HttpHdrRange.cc HttpHdrSc.cc \
-	HttpHdrScTarget.cc HttpMsg.cc HttpParser.cc HttpParser.h \
-	HttpReply.cc RequestFlags.h RequestFlags.cc HttpRequest.cc \
-	HttpRequestMethod.cc HttpStatusLine.cc icp_v2.cc icp_v3.cc \
-	SquidIpc.h ipc.cc ipc_win32.cc ipcache.cc int.h int.cc \
-	internal.h internal.cc SquidList.h SquidList.cc MemBuf.cc \
+	FileMap.h filemap.cc fqdncache.h fqdncache.cc ftp.h ftp.cc \
+	FwdState.cc FwdState.h gopher.h gopher.cc helper.cc \
+	HelperChildConfig.h HelperChildConfig.cc HelperReply.cc \
+	HelperReply.h hier_code.h htcp.cc htcp.h http.cc HttpBody.h \
+	HttpBody.cc HttpHeader.h HttpHeader.cc HttpHeaderFieldInfo.h \
+	HttpHeaderTools.h HttpHeaderTools.cc HttpHeaderFieldStat.h \
+	HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci HttpHdrContRange.cc \
+	HttpHdrRange.cc HttpHdrSc.cc HttpHdrScTarget.cc HttpMsg.cc \
+	HttpParser.cc HttpParser.h HttpReply.cc RequestFlags.h \
+	RequestFlags.cc HttpRequest.cc HttpRequestMethod.cc icp_v2.cc \
+	icp_v3.cc SquidIpc.h ipc.cc ipc_win32.cc ipcache.cc int.h \
+	int.cc internal.h internal.cc SquidList.h SquidList.cc \
+	MasterXaction.cc MasterXaction.h MemBlob.cc MemBuf.cc \
 	MemObject.cc Mem.h mem.cc mem_node.cc mime.h mime.cc \
 	mime_header.h mime_header.cc multicast.h multicast.cc \
-	neighbors.h neighbors.cc Packer.cc Parsing.cc pconn.cc \
-	peer_digest.cc peer_proxy_negotiate_auth.h \
+	neighbors.h neighbors.cc Notes.cc Notes.h Packer.cc Parsing.cc \
+	pconn.cc peer_digest.cc peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc peer_select.cc peer_sourcehash.h \
 	peer_sourcehash.cc peer_userhash.h peer_userhash.cc \
 	RemovalPolicy.cc redirect.h redirect.cc refresh.h refresh.cc \
 	Server.cc SnmpRequest.h snmp_core.h snmp_core.cc snmp_agent.h \
 	snmp_agent.cc SquidMath.h SquidMath.cc IoStats.h stat.h \
 	stat.cc StatCounters.h StatCounters.cc StatHist.h StatHist.cc \
@@ -1034,16 +1097,16 @@
 	StoreFileSystem.cc StoreIOState.cc StoreMeta.cc \
 	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
 	StoreMetaUnpacker.cc StoreMetaURL.cc StoreMetaVary.cc \
 	StoreSwapLogData.cc String.cc StrList.h StrList.cc SwapDir.cc \
 	tests/testEventLoop.cc tests/testEventLoop.h tests/testMain.cc \
 	tests/stub_main_cc.cc tests/stub_ipc_Forwarder.cc \
-	tests/stub_store_stats.cc time.cc tools.h tools.cc tunnel.cc \
-	MemStore.cc unlinkd.h unlinkd.cc url.cc URLScheme.cc urn.h \
-	urn.cc wccp2.h wccp2.cc whois.h whois.cc win32.cc wordlist.h \
-	wordlist.cc
+	tests/stub_libeui.cc tests/stub_store_stats.cc time.cc tools.h \
+	tools.cc tunnel.cc MemStore.cc unlinkd.h unlinkd.cc url.cc \
+	URLScheme.cc urn.h urn.cc wccp2.h wccp2.cc whois.h whois.cc \
+	win32.cc wordlist.h wordlist.cc
 am_tests_testEventLoop_OBJECTS = AccessLogEntry.$(OBJEXT) \
 	$(am__objects_4) BodyPipe.$(OBJEXT) CacheDigest.$(OBJEXT) \
 	cache_manager.$(OBJEXT) YesNoNone.$(OBJEXT) cache_cf.$(OBJEXT) \
 	carp.$(OBJEXT) cbdata.$(OBJEXT) ChunkedCodingParser.$(OBJEXT) \
 	client_db.$(OBJEXT) client_side.$(OBJEXT) \
 	client_side_reply.$(OBJEXT) client_side_request.$(OBJEXT) \
@@ -1052,47 +1115,49 @@
 	CpuAffinitySet.$(OBJEXT) debug.$(OBJEXT) $(am__objects_6) \
 	$(am__objects_7) disk.$(OBJEXT) dlink.$(OBJEXT) \
 	$(am__objects_8) errorpage.$(OBJEXT) ETag.$(OBJEXT) \
 	EventLoop.$(OBJEXT) event.$(OBJEXT) external_acl.$(OBJEXT) \
 	ExternalACLEntry.$(OBJEXT) FadingCounter.$(OBJEXT) \
 	tests/stub_fatal.$(OBJEXT) fd.$(OBJEXT) fde.$(OBJEXT) \
-	filemap.$(OBJEXT) forward.$(OBJEXT) fqdncache.$(OBJEXT) \
-	ftp.$(OBJEXT) gopher.$(OBJEXT) helper.$(OBJEXT) \
-	HelperChildConfig.$(OBJEXT) $(am__objects_9) http.$(OBJEXT) \
-	HttpBody.$(OBJEXT) HttpHeader.$(OBJEXT) \
-	HttpHeaderTools.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
-	HttpHdrContRange.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
-	HttpHdrSc.$(OBJEXT) HttpHdrScTarget.$(OBJEXT) \
-	HttpMsg.$(OBJEXT) HttpParser.$(OBJEXT) HttpReply.$(OBJEXT) \
+	filemap.$(OBJEXT) fqdncache.$(OBJEXT) ftp.$(OBJEXT) \
+	FwdState.$(OBJEXT) gopher.$(OBJEXT) helper.$(OBJEXT) \
+	HelperChildConfig.$(OBJEXT) HelperReply.$(OBJEXT) \
+	$(am__objects_9) http.$(OBJEXT) HttpBody.$(OBJEXT) \
+	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
+	HttpHdrCc.$(OBJEXT) HttpHdrContRange.$(OBJEXT) \
+	HttpHdrRange.$(OBJEXT) HttpHdrSc.$(OBJEXT) \
+	HttpHdrScTarget.$(OBJEXT) HttpMsg.$(OBJEXT) \
+	HttpParser.$(OBJEXT) HttpReply.$(OBJEXT) \
 	RequestFlags.$(OBJEXT) HttpRequest.$(OBJEXT) \
-	HttpRequestMethod.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
-	icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) $(am__objects_10) \
-	ipcache.$(OBJEXT) int.$(OBJEXT) internal.$(OBJEXT) \
-	SquidList.$(OBJEXT) MemBuf.$(OBJEXT) MemObject.$(OBJEXT) \
+	HttpRequestMethod.$(OBJEXT) icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) \
+	$(am__objects_10) ipcache.$(OBJEXT) int.$(OBJEXT) \
+	internal.$(OBJEXT) SquidList.$(OBJEXT) MasterXaction.$(OBJEXT) \
+	MemBlob.$(OBJEXT) MemBuf.$(OBJEXT) MemObject.$(OBJEXT) \
 	mem.$(OBJEXT) mem_node.$(OBJEXT) mime.$(OBJEXT) \
 	mime_header.$(OBJEXT) multicast.$(OBJEXT) neighbors.$(OBJEXT) \
-	Packer.$(OBJEXT) Parsing.$(OBJEXT) pconn.$(OBJEXT) \
-	peer_digest.$(OBJEXT) peer_proxy_negotiate_auth.$(OBJEXT) \
-	peer_select.$(OBJEXT) peer_sourcehash.$(OBJEXT) \
-	peer_userhash.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
-	redirect.$(OBJEXT) refresh.$(OBJEXT) Server.$(OBJEXT) \
-	$(am__objects_15) SquidMath.$(OBJEXT) stat.$(OBJEXT) \
-	StatCounters.$(OBJEXT) StatHist.$(OBJEXT) stmem.$(OBJEXT) \
-	store.$(OBJEXT) store_client.$(OBJEXT) store_digest.$(OBJEXT) \
-	store_dir.$(OBJEXT) store_io.$(OBJEXT) store_key_md5.$(OBJEXT) \
-	store_log.$(OBJEXT) store_rebuild.$(OBJEXT) \
-	store_swapin.$(OBJEXT) store_swapmeta.$(OBJEXT) \
-	store_swapout.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
-	StoreIOState.$(OBJEXT) StoreMeta.$(OBJEXT) \
-	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
-	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
-	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
-	StoreSwapLogData.$(OBJEXT) String.$(OBJEXT) StrList.$(OBJEXT) \
-	SwapDir.$(OBJEXT) tests/testEventLoop.$(OBJEXT) \
-	tests/testMain.$(OBJEXT) tests/stub_main_cc.$(OBJEXT) \
-	tests/stub_ipc_Forwarder.$(OBJEXT) \
+	Notes.$(OBJEXT) Packer.$(OBJEXT) Parsing.$(OBJEXT) \
+	pconn.$(OBJEXT) peer_digest.$(OBJEXT) \
+	peer_proxy_negotiate_auth.$(OBJEXT) peer_select.$(OBJEXT) \
+	peer_sourcehash.$(OBJEXT) peer_userhash.$(OBJEXT) \
+	RemovalPolicy.$(OBJEXT) redirect.$(OBJEXT) refresh.$(OBJEXT) \
+	Server.$(OBJEXT) $(am__objects_15) SquidMath.$(OBJEXT) \
+	stat.$(OBJEXT) StatCounters.$(OBJEXT) StatHist.$(OBJEXT) \
+	stmem.$(OBJEXT) store.$(OBJEXT) store_client.$(OBJEXT) \
+	store_digest.$(OBJEXT) store_dir.$(OBJEXT) store_io.$(OBJEXT) \
+	store_key_md5.$(OBJEXT) store_log.$(OBJEXT) \
+	store_rebuild.$(OBJEXT) store_swapin.$(OBJEXT) \
+	store_swapmeta.$(OBJEXT) store_swapout.$(OBJEXT) \
+	StoreFileSystem.$(OBJEXT) StoreIOState.$(OBJEXT) \
+	StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
+	StoreMetaSTD.$(OBJEXT) StoreMetaSTDLFS.$(OBJEXT) \
+	StoreMetaUnpacker.$(OBJEXT) StoreMetaURL.$(OBJEXT) \
+	StoreMetaVary.$(OBJEXT) StoreSwapLogData.$(OBJEXT) \
+	String.$(OBJEXT) StrList.$(OBJEXT) SwapDir.$(OBJEXT) \
+	tests/testEventLoop.$(OBJEXT) tests/testMain.$(OBJEXT) \
+	tests/stub_main_cc.$(OBJEXT) \
+	tests/stub_ipc_Forwarder.$(OBJEXT) tests/stub_libeui.$(OBJEXT) \
 	tests/stub_store_stats.$(OBJEXT) time.$(OBJEXT) \
 	tools.$(OBJEXT) tunnel.$(OBJEXT) MemStore.$(OBJEXT) \
 	$(am__objects_16) url.$(OBJEXT) URLScheme.$(OBJEXT) \
 	urn.$(OBJEXT) wccp2.$(OBJEXT) whois.$(OBJEXT) \
 	$(am__objects_17) wordlist.$(OBJEXT)
 nodist_tests_testEventLoop_OBJECTS = $(am__objects_22) \
@@ -1115,21 +1180,22 @@
 tests_testHttpParser_OBJECTS = $(am_tests_testHttpParser_OBJECTS) \
 	$(nodist_tests_testHttpParser_OBJECTS)
 tests_testHttpParser_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
 	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testHttpParser_LDFLAGS) \
 	$(LDFLAGS) -o $@
-am_tests_testHttpReply_OBJECTS = cbdata.$(OBJEXT) ETag.$(OBJEXT) \
+am_tests_testHttpReply_OBJECTS = cbdata.$(OBJEXT) \
+	ConfigParser.$(OBJEXT) ETag.$(OBJEXT) \
 	tests/stub_fatal.$(OBJEXT) HttpBody.$(OBJEXT) \
 	HttpHdrCc.$(OBJEXT) HttpHdrContRange.$(OBJEXT) \
 	HttpHdrRange.$(OBJEXT) HttpHdrSc.$(OBJEXT) \
 	HttpHdrScTarget.$(OBJEXT) HttpHeader.$(OBJEXT) \
 	HttpHeaderTools.$(OBJEXT) HttpMsg.$(OBJEXT) \
-	HttpReply.$(OBJEXT) HttpStatusLine.$(OBJEXT) mem.$(OBJEXT) \
-	RegexList.$(OBJEXT) MemBuf.$(OBJEXT) mime_header.$(OBJEXT) \
-	Packer.$(OBJEXT) String.$(OBJEXT) StrList.$(OBJEXT) \
+	HttpReply.$(OBJEXT) mem.$(OBJEXT) RegexList.$(OBJEXT) \
+	MemBuf.$(OBJEXT) mime_header.$(OBJEXT) Packer.$(OBJEXT) \
+	String.$(OBJEXT) StrList.$(OBJEXT) \
 	tests/stub_access_log.$(OBJEXT) tests/stub_cache_cf.$(OBJEXT) \
 	tests/stub_cache_manager.$(OBJEXT) tests/stub_debug.$(OBJEXT) \
 	tests/stub_errorpage.$(OBJEXT) \
 	tests/stub_HelperChildConfig.$(OBJEXT) \
 	tests/stub_libformat.$(OBJEXT) StatCounters.$(OBJEXT) \
 	tests/stub_StatHist.$(OBJEXT) tests/stub_store.$(OBJEXT) \
@@ -1148,217 +1214,136 @@
 	AuthReg.cc HttpParser.cc HttpParser.h RequestFlags.h \
 	RequestFlags.cc HttpRequest.cc HttpRequestMethod.cc Mem.h \
 	mem.cc String.cc tests/testHttpRequest.h \
 	tests/testHttpRequest.cc tests/testHttpRequestMethod.h \
 	tests/testHttpRequestMethod.cc tests/testMain.cc \
 	tests/stub_DiskIOModule.cc tests/stub_main_cc.cc \
-	tests/stub_ipc_Forwarder.cc tests/stub_store_stats.cc time.cc \
-	BodyPipe.cc cache_manager.cc cache_cf.h AuthReg.h YesNoNone.h \
-	YesNoNone.cc RefreshPattern.h cache_cf.cc debug.cc \
-	CacheDigest.h CacheDigest.cc carp.h carp.cc cbdata.cc \
-	ChunkedCodingParser.cc client_db.h client_db.cc client_side.h \
-	client_side.cc client_side_reply.cc client_side_request.cc \
-	ClientInfo.h clientStream.cc ConfigOption.cc ConfigParser.cc \
-	CpuAffinityMap.cc CpuAffinityMap.h CpuAffinitySet.cc \
-	CpuAffinitySet.h CommonPool.h CompositePoolNode.h \
-	delay_pools.cc DelayId.cc DelayId.h DelayIdComposite.h \
-	DelayBucket.cc DelayBucket.h DelayConfig.cc DelayConfig.h \
-	DelayPool.cc DelayPool.h DelayPools.h DelaySpec.cc DelaySpec.h \
-	DelayTagged.cc DelayTagged.h DelayUser.cc DelayUser.h \
-	DelayVector.cc DelayVector.h NullDelayId.cc NullDelayId.h \
+	tests/stub_ipc_Forwarder.cc tests/stub_libeui.cc \
+	tests/stub_store_stats.cc time.cc BodyPipe.cc cache_manager.cc \
+	cache_cf.h AuthReg.h YesNoNone.h YesNoNone.cc RefreshPattern.h \
+	cache_cf.cc debug.cc CacheDigest.h CacheDigest.cc carp.h \
+	carp.cc cbdata.cc ChunkedCodingParser.cc client_db.h \
+	client_db.cc client_side.h client_side.cc client_side_reply.cc \
+	client_side_request.cc ClientInfo.h clientStream.cc \
+	ConfigOption.cc ConfigParser.cc CpuAffinityMap.cc \
+	CpuAffinityMap.h CpuAffinitySet.cc CpuAffinitySet.h \
+	CommonPool.h CompositePoolNode.h delay_pools.cc DelayId.cc \
+	DelayId.h DelayIdComposite.h DelayBucket.cc DelayBucket.h \
+	DelayConfig.cc DelayConfig.h DelayPool.cc DelayPool.h \
+	DelayPools.h DelaySpec.cc DelaySpec.h DelayTagged.cc \
+	DelayTagged.h DelayUser.cc DelayUser.h DelayVector.cc \
+	DelayVector.h NullDelayId.cc NullDelayId.h \
 	ClientDelayConfig.cc ClientDelayConfig.h disk.h disk.cc \
 	dlink.h dlink.cc dns_internal.cc SquidDns.h DnsLookupDetails.h \
 	DnsLookupDetails.cc dns.cc errorpage.cc ETag.cc \
 	external_acl.cc ExternalACLEntry.cc fatal.h \
-	tests/stub_fatal.cc fd.h fd.cc fde.cc forward.cc fqdncache.h \
-	fqdncache.cc ftp.h ftp.cc gopher.h gopher.cc helper.cc \
-	HelperChildConfig.h HelperChildConfig.cc hier_code.h htcp.cc \
-	htcp.h http.cc HttpBody.h HttpBody.cc HttpHeader.h \
-	HttpHeader.cc HttpHeaderFieldInfo.h HttpHeaderTools.h \
-	HttpHeaderTools.cc HttpHeaderFieldStat.h HttpHdrCc.h \
-	HttpHdrCc.cc HttpHdrCc.cci HttpHdrContRange.cc HttpHdrRange.cc \
-	HttpHdrSc.cc HttpHdrScTarget.cc HttpMsg.cc HttpReply.cc \
-	HttpStatusLine.cc icp_v2.cc icp_v3.cc SquidIpc.h ipc.cc \
-	ipc_win32.cc ipcache.cc int.h int.cc internal.h internal.cc \
-	SquidList.h SquidList.cc multicast.h multicast.cc mem_node.cc \
-	MemBuf.cc MemObject.cc mime.h mime.cc mime_header.h \
-	mime_header.cc neighbors.h neighbors.cc Packer.cc Parsing.cc \
-	pconn.cc peer_digest.cc peer_proxy_negotiate_auth.h \
-	peer_proxy_negotiate_auth.cc peer_select.cc peer_sourcehash.h \
-	peer_sourcehash.cc peer_userhash.h peer_userhash.cc redirect.h \
-	redirect.cc refresh.h refresh.cc RemovalPolicy.cc Server.cc \
-	SnmpRequest.h snmp_core.h snmp_core.cc snmp_agent.h \
-	snmp_agent.cc SquidMath.h SquidMath.cc IoStats.h stat.h \
-	stat.cc StatCounters.h StatCounters.cc StatHist.h StatHist.cc \
-	stmem.cc repl_modules.h store.cc store_client.cc \
-	store_digest.h store_digest.cc store_dir.cc store_io.cc \
-	store_key_md5.h store_key_md5.cc store_log.h store_log.cc \
-	store_rebuild.h store_rebuild.cc store_swapin.h \
-	store_swapin.cc store_swapmeta.cc store_swapout.cc \
-	StoreFileSystem.cc StoreIOState.cc StoreMeta.cc \
-	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
-	StoreMetaUnpacker.cc StoreMetaURL.cc StoreMetaVary.cc \
-	StoreSwapLogData.cc StrList.h StrList.cc event.cc tools.h \
-	tools.cc tunnel.cc SwapDir.cc MemStore.cc url.cc URLScheme.cc \
-	urn.h urn.cc wccp2.h wccp2.cc whois.h whois.cc \
-	FadingCounter.cc win32.cc wordlist.h wordlist.cc
+	tests/stub_fatal.cc fd.h fd.cc fde.cc fqdncache.h fqdncache.cc \
+	ftp.h ftp.cc FwdState.cc FwdState.h gopher.h gopher.cc \
+	helper.cc HelperChildConfig.h HelperChildConfig.cc \
+	HelperReply.cc HelperReply.h hier_code.h htcp.cc htcp.h \
+	http.cc HttpBody.h HttpBody.cc HttpHeader.h HttpHeader.cc \
+	HttpHeaderFieldInfo.h HttpHeaderTools.h HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
+	HttpHdrContRange.cc HttpHdrRange.cc HttpHdrSc.cc \
+	HttpHdrScTarget.cc HttpMsg.cc HttpReply.cc icp_v2.cc icp_v3.cc \
+	SquidIpc.h ipc.cc ipc_win32.cc ipcache.cc int.h int.cc \
+	internal.h internal.cc SquidList.h SquidList.cc \
+	MasterXaction.cc MasterXaction.h multicast.h multicast.cc \
+	mem_node.cc MemBlob.cc MemBuf.cc MemObject.cc mime.h mime.cc \
+	mime_header.h mime_header.cc neighbors.h neighbors.cc Notes.cc \
+	Notes.h Packer.cc Parsing.cc pconn.cc peer_digest.cc \
+	peer_proxy_negotiate_auth.h peer_proxy_negotiate_auth.cc \
+	peer_select.cc peer_sourcehash.h peer_sourcehash.cc \
+	peer_userhash.h peer_userhash.cc redirect.h redirect.cc \
+	refresh.h refresh.cc RemovalPolicy.cc Server.cc SnmpRequest.h \
+	snmp_core.h snmp_core.cc snmp_agent.h snmp_agent.cc \
+	SquidMath.h SquidMath.cc IoStats.h stat.h stat.cc \
+	StatCounters.h StatCounters.cc StatHist.h StatHist.cc stmem.cc \
+	repl_modules.h store.cc store_client.cc store_digest.h \
+	store_digest.cc store_dir.cc store_io.cc store_key_md5.h \
+	store_key_md5.cc store_log.h store_log.cc store_rebuild.h \
+	store_rebuild.cc store_swapin.h store_swapin.cc \
+	store_swapmeta.cc store_swapout.cc StoreFileSystem.cc \
+	StoreIOState.cc StoreMeta.cc StoreMetaMD5.cc StoreMetaSTD.cc \
+	StoreMetaSTDLFS.cc StoreMetaUnpacker.cc StoreMetaURL.cc \
+	StoreMetaVary.cc StoreSwapLogData.cc StrList.h StrList.cc \
+	event.cc tools.h tools.cc tunnel.cc SwapDir.cc MemStore.cc \
+	url.cc URLScheme.cc urn.h urn.cc wccp2.h wccp2.cc whois.h \
+	whois.cc FadingCounter.cc win32.cc wordlist.h wordlist.cc
 am_tests_testHttpRequest_OBJECTS = AccessLogEntry.$(OBJEXT) \
 	$(am__objects_4) HttpParser.$(OBJEXT) RequestFlags.$(OBJEXT) \
 	HttpRequest.$(OBJEXT) HttpRequestMethod.$(OBJEXT) \
 	mem.$(OBJEXT) String.$(OBJEXT) tests/testHttpRequest.$(OBJEXT) \
 	tests/testHttpRequestMethod.$(OBJEXT) tests/testMain.$(OBJEXT) \
 	tests/stub_DiskIOModule.$(OBJEXT) tests/stub_main_cc.$(OBJEXT) \
-	tests/stub_ipc_Forwarder.$(OBJEXT) \
+	tests/stub_ipc_Forwarder.$(OBJEXT) tests/stub_libeui.$(OBJEXT) \
 	tests/stub_store_stats.$(OBJEXT) time.$(OBJEXT) \
 	BodyPipe.$(OBJEXT) cache_manager.$(OBJEXT) YesNoNone.$(OBJEXT) \
 	cache_cf.$(OBJEXT) debug.$(OBJEXT) CacheDigest.$(OBJEXT) \
 	carp.$(OBJEXT) cbdata.$(OBJEXT) ChunkedCodingParser.$(OBJEXT) \
 	client_db.$(OBJEXT) client_side.$(OBJEXT) \
 	client_side_reply.$(OBJEXT) client_side_request.$(OBJEXT) \
 	clientStream.$(OBJEXT) ConfigOption.$(OBJEXT) \
 	ConfigParser.$(OBJEXT) CpuAffinityMap.$(OBJEXT) \
 	CpuAffinitySet.$(OBJEXT) $(am__objects_6) disk.$(OBJEXT) \
 	dlink.$(OBJEXT) $(am__objects_8) errorpage.$(OBJEXT) \
 	ETag.$(OBJEXT) external_acl.$(OBJEXT) \
 	ExternalACLEntry.$(OBJEXT) tests/stub_fatal.$(OBJEXT) \
-	fd.$(OBJEXT) fde.$(OBJEXT) forward.$(OBJEXT) \
-	fqdncache.$(OBJEXT) ftp.$(OBJEXT) gopher.$(OBJEXT) \
-	helper.$(OBJEXT) HelperChildConfig.$(OBJEXT) $(am__objects_9) \
-	http.$(OBJEXT) HttpBody.$(OBJEXT) HttpHeader.$(OBJEXT) \
-	HttpHeaderTools.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
-	HttpHdrContRange.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
-	HttpHdrSc.$(OBJEXT) HttpHdrScTarget.$(OBJEXT) \
-	HttpMsg.$(OBJEXT) HttpReply.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
-	icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) $(am__objects_10) \
-	ipcache.$(OBJEXT) int.$(OBJEXT) internal.$(OBJEXT) \
-	SquidList.$(OBJEXT) multicast.$(OBJEXT) mem_node.$(OBJEXT) \
+	fd.$(OBJEXT) fde.$(OBJEXT) fqdncache.$(OBJEXT) ftp.$(OBJEXT) \
+	FwdState.$(OBJEXT) gopher.$(OBJEXT) helper.$(OBJEXT) \
+	HelperChildConfig.$(OBJEXT) HelperReply.$(OBJEXT) \
+	$(am__objects_9) http.$(OBJEXT) HttpBody.$(OBJEXT) \
+	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
+	HttpHdrCc.$(OBJEXT) HttpHdrContRange.$(OBJEXT) \
+	HttpHdrRange.$(OBJEXT) HttpHdrSc.$(OBJEXT) \
+	HttpHdrScTarget.$(OBJEXT) HttpMsg.$(OBJEXT) \
+	HttpReply.$(OBJEXT) icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) \
+	$(am__objects_10) ipcache.$(OBJEXT) int.$(OBJEXT) \
+	internal.$(OBJEXT) SquidList.$(OBJEXT) MasterXaction.$(OBJEXT) \
+	multicast.$(OBJEXT) mem_node.$(OBJEXT) MemBlob.$(OBJEXT) \
 	MemBuf.$(OBJEXT) MemObject.$(OBJEXT) mime.$(OBJEXT) \
-	mime_header.$(OBJEXT) neighbors.$(OBJEXT) Packer.$(OBJEXT) \
-	Parsing.$(OBJEXT) pconn.$(OBJEXT) peer_digest.$(OBJEXT) \
-	peer_proxy_negotiate_auth.$(OBJEXT) peer_select.$(OBJEXT) \
-	peer_sourcehash.$(OBJEXT) peer_userhash.$(OBJEXT) \
-	redirect.$(OBJEXT) refresh.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
-	Server.$(OBJEXT) $(am__objects_15) SquidMath.$(OBJEXT) \
-	stat.$(OBJEXT) StatCounters.$(OBJEXT) StatHist.$(OBJEXT) \
-	stmem.$(OBJEXT) store.$(OBJEXT) store_client.$(OBJEXT) \
-	store_digest.$(OBJEXT) store_dir.$(OBJEXT) store_io.$(OBJEXT) \
-	store_key_md5.$(OBJEXT) store_log.$(OBJEXT) \
-	store_rebuild.$(OBJEXT) store_swapin.$(OBJEXT) \
-	store_swapmeta.$(OBJEXT) store_swapout.$(OBJEXT) \
-	StoreFileSystem.$(OBJEXT) StoreIOState.$(OBJEXT) \
-	StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
-	StoreMetaSTD.$(OBJEXT) StoreMetaSTDLFS.$(OBJEXT) \
-	StoreMetaUnpacker.$(OBJEXT) StoreMetaURL.$(OBJEXT) \
-	StoreMetaVary.$(OBJEXT) StoreSwapLogData.$(OBJEXT) \
-	StrList.$(OBJEXT) event.$(OBJEXT) tools.$(OBJEXT) \
-	tunnel.$(OBJEXT) SwapDir.$(OBJEXT) MemStore.$(OBJEXT) \
-	url.$(OBJEXT) URLScheme.$(OBJEXT) urn.$(OBJEXT) \
-	wccp2.$(OBJEXT) whois.$(OBJEXT) FadingCounter.$(OBJEXT) \
-	$(am__objects_17) wordlist.$(OBJEXT)
+	mime_header.$(OBJEXT) neighbors.$(OBJEXT) Notes.$(OBJEXT) \
+	Packer.$(OBJEXT) Parsing.$(OBJEXT) pconn.$(OBJEXT) \
+	peer_digest.$(OBJEXT) peer_proxy_negotiate_auth.$(OBJEXT) \
+	peer_select.$(OBJEXT) peer_sourcehash.$(OBJEXT) \
+	peer_userhash.$(OBJEXT) redirect.$(OBJEXT) refresh.$(OBJEXT) \
+	RemovalPolicy.$(OBJEXT) Server.$(OBJEXT) $(am__objects_15) \
+	SquidMath.$(OBJEXT) stat.$(OBJEXT) StatCounters.$(OBJEXT) \
+	StatHist.$(OBJEXT) stmem.$(OBJEXT) store.$(OBJEXT) \
+	store_client.$(OBJEXT) store_digest.$(OBJEXT) \
+	store_dir.$(OBJEXT) store_io.$(OBJEXT) store_key_md5.$(OBJEXT) \
+	store_log.$(OBJEXT) store_rebuild.$(OBJEXT) \
+	store_swapin.$(OBJEXT) store_swapmeta.$(OBJEXT) \
+	store_swapout.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
+	StoreIOState.$(OBJEXT) StoreMeta.$(OBJEXT) \
+	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
+	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
+	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
+	StoreSwapLogData.$(OBJEXT) StrList.$(OBJEXT) event.$(OBJEXT) \
+	tools.$(OBJEXT) tunnel.$(OBJEXT) SwapDir.$(OBJEXT) \
+	MemStore.$(OBJEXT) url.$(OBJEXT) URLScheme.$(OBJEXT) \
+	urn.$(OBJEXT) wccp2.$(OBJEXT) whois.$(OBJEXT) \
+	FadingCounter.$(OBJEXT) $(am__objects_17) wordlist.$(OBJEXT)
 nodist_tests_testHttpRequest_OBJECTS = $(am__objects_22)
 tests_testHttpRequest_OBJECTS = $(am_tests_testHttpRequest_OBJECTS) \
 	$(nodist_tests_testHttpRequest_OBJECTS)
 tests_testHttpRequest_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
 	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testHttpRequest_LDFLAGS) \
 	$(LDFLAGS) -o $@
-am__tests_testNull_SOURCES_DIST = tests/testNull.cc tests/testMain.cc \
-	tests/testNull.h internal.h tests/stub_internal.cc \
-	store_rebuild.h tests/stub_store_rebuild.cc \
-	tests/stub_store_stats.cc fd.h fd.cc disk.h disk.cc FileMap.h \
-	filemap.cc HttpBody.h HttpBody.cc HttpReply.cc \
-	HttpStatusLine.cc int.h int.cc SquidList.h SquidList.cc \
-	MemObject.cc StoreSwapLogData.cc StoreIOState.cc StoreMeta.cc \
-	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
-	StoreMetaUnpacker.cc StoreMetaURL.cc StoreMetaVary.cc \
-	StoreFileSystem.cc store_io.cc store_swapout.cc \
-	store_swapmeta.cc unlinkd.h unlinkd.cc win32.cc event.cc \
-	CommonPool.h CompositePoolNode.h delay_pools.cc DelayId.cc \
-	DelayId.h DelayIdComposite.h DelayBucket.cc DelayBucket.h \
-	DelayConfig.cc DelayConfig.h DelayPool.cc DelayPool.h \
-	DelayPools.h DelaySpec.cc DelaySpec.h DelayTagged.cc \
-	DelayTagged.h DelayUser.cc DelayUser.h DelayVector.cc \
-	DelayVector.h NullDelayId.cc NullDelayId.h \
-	ClientDelayConfig.cc ClientDelayConfig.h CacheDigest.h \
-	CacheDigest.cc ConfigParser.cc EventLoop.cc HttpMsg.cc \
-	RemovalPolicy.cc store_dir.cc repl_modules.h store.cc \
-	HttpRequestMethod.cc store_key_md5.h store_key_md5.cc \
-	Parsing.cc ConfigOption.cc SwapDir.cc tests/stub_acl.cc \
-	cache_cf.h YesNoNone.h tests/stub_cache_cf.cc \
-	tests/stub_helper.cc cbdata.cc String.cc tests/stub_comm.cc \
-	tests/stub_debug.cc tests/stub_client_side_request.cc \
-	tests/stub_http.cc mem_node.cc stmem.cc mime.h \
-	tests/stub_mime.cc HttpHeaderFieldInfo.h HttpHeaderTools.h \
-	HttpHeaderTools.cc HttpHeader.h HttpHeader.cc Mem.h mem.cc \
-	ClientInfo.h MemBuf.cc HttpHdrContRange.cc Packer.cc \
-	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
-	HttpHdrSc.cc HttpHdrScTarget.cc url.cc StatCounters.h \
-	StatCounters.cc StatHist.h tests/stub_StatHist.cc \
-	tests/stub_errorpage.cc tests/stub_HttpRequest.cc \
-	log/access_log.h tests/stub_access_log.cc refresh.h refresh.cc \
-	tests/stub_store_client.cc tools.h tests/stub_tools.cc \
-	tests/testStoreSupport.cc tests/testStoreSupport.h time.cc \
-	URLScheme.cc wordlist.h wordlist.cc DiskIO/DiskIOModule.cc \
-	DiskIO/ReadRequest.cc DiskIO/ReadRequest.h \
-	DiskIO/WriteRequest.cc DiskIO/WriteRequest.h DiskIO/DiskFile.h \
-	DiskIO/DiskIOStrategy.h DiskIO/IORequestor.h \
-	DiskIO/DiskIOModule.h
-am_tests_testNull_OBJECTS = tests/testNull.$(OBJEXT) \
-	tests/testMain.$(OBJEXT) tests/stub_internal.$(OBJEXT) \
-	tests/stub_store_rebuild.$(OBJEXT) \
-	tests/stub_store_stats.$(OBJEXT) fd.$(OBJEXT) disk.$(OBJEXT) \
-	filemap.$(OBJEXT) HttpBody.$(OBJEXT) HttpReply.$(OBJEXT) \
-	HttpStatusLine.$(OBJEXT) int.$(OBJEXT) SquidList.$(OBJEXT) \
-	MemObject.$(OBJEXT) StoreSwapLogData.$(OBJEXT) \
-	StoreIOState.$(OBJEXT) StoreMeta.$(OBJEXT) \
-	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
-	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
-	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
-	StoreFileSystem.$(OBJEXT) store_io.$(OBJEXT) \
-	store_swapout.$(OBJEXT) store_swapmeta.$(OBJEXT) \
-	$(am__objects_16) $(am__objects_17) event.$(OBJEXT) \
-	$(am__objects_6) CacheDigest.$(OBJEXT) ConfigParser.$(OBJEXT) \
-	EventLoop.$(OBJEXT) HttpMsg.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
-	store_dir.$(OBJEXT) store.$(OBJEXT) \
-	HttpRequestMethod.$(OBJEXT) store_key_md5.$(OBJEXT) \
-	Parsing.$(OBJEXT) ConfigOption.$(OBJEXT) SwapDir.$(OBJEXT) \
-	tests/stub_acl.$(OBJEXT) tests/stub_cache_cf.$(OBJEXT) \
-	tests/stub_helper.$(OBJEXT) cbdata.$(OBJEXT) String.$(OBJEXT) \
-	tests/stub_comm.$(OBJEXT) tests/stub_debug.$(OBJEXT) \
-	tests/stub_client_side_request.$(OBJEXT) \
-	tests/stub_http.$(OBJEXT) mem_node.$(OBJEXT) stmem.$(OBJEXT) \
-	tests/stub_mime.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
-	HttpHeader.$(OBJEXT) mem.$(OBJEXT) MemBuf.$(OBJEXT) \
-	HttpHdrContRange.$(OBJEXT) Packer.$(OBJEXT) \
-	HttpHdrCc.$(OBJEXT) HttpHdrSc.$(OBJEXT) \
-	HttpHdrScTarget.$(OBJEXT) url.$(OBJEXT) StatCounters.$(OBJEXT) \
-	tests/stub_StatHist.$(OBJEXT) tests/stub_errorpage.$(OBJEXT) \
-	tests/stub_HttpRequest.$(OBJEXT) \
-	tests/stub_access_log.$(OBJEXT) refresh.$(OBJEXT) \
-	tests/stub_store_client.$(OBJEXT) \
-	tests/stub_store_stats.$(OBJEXT) tests/stub_tools.$(OBJEXT) \
-	tests/testStoreSupport.$(OBJEXT) time.$(OBJEXT) \
-	URLScheme.$(OBJEXT) wordlist.$(OBJEXT) $(am__objects_7)
-nodist_tests_testNull_OBJECTS = $(am__objects_23) $(am__objects_21)
-tests_testNull_OBJECTS = $(am_tests_testNull_OBJECTS) \
-	$(nodist_tests_testNull_OBJECTS)
-tests_testNull_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
-	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testNull_LDFLAGS) \
-	$(LDFLAGS) -o $@
 am__tests_testRock_SOURCES_DIST = cbdata.cc CacheDigest.h \
 	CacheDigest.cc ConfigOption.cc ConfigParser.cc disk.h disk.cc \
-	ETag.cc EventLoop.cc event.cc fatal.h tests/stub_fatal.cc fd.h \
-	fd.cc fde.h fde.cc FileMap.h filemap.cc HttpHeaderFieldStat.h \
+	ETag.cc EventLoop.cc event.cc fatal.h fatal.cc fd.h fd.cc \
+	fde.h fde.cc FileMap.h filemap.cc HttpHeaderFieldStat.h \
 	HttpBody.h HttpBody.cc HttpHdrCc.cc HttpHdrContRange.cc \
 	HttpHdrRange.cc HttpHdrSc.cc HttpHdrScTarget.cc HttpHeader.h \
 	HttpHeader.cc HttpHeaderFieldInfo.h HttpHeaderTools.h \
 	HttpHeaderTools.cc HttpMsg.cc HttpReply.cc \
-	HttpRequestMethod.cc HttpStatusLine.cc int.h int.cc \
-	SquidList.h SquidList.cc Mem.h mem.cc MemBuf.cc MemObject.cc \
-	mem_node.cc Packer.cc Parsing.cc RemovalPolicy.cc \
+	HttpRequestMethod.cc int.h int.cc SquidList.h SquidList.cc \
+	MasterXaction.cc MasterXaction.h Mem.h mem.cc MemBuf.cc \
+	MemObject.cc mem_node.cc Packer.cc Parsing.cc RemovalPolicy.cc \
 	RequestFlags.cc RequestFlags.h StatCounters.h StatCounters.cc \
 	StatHist.h tests/stub_StatHist.cc stmem.cc repl_modules.h \
 	store.cc StoreFileSystem.cc StoreIOState.cc StoreMeta.cc \
 	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
 	StoreMetaURL.cc StoreMetaUnpacker.cc StoreMetaVary.cc \
 	StoreSwapLogData.cc store_dir.cc store_io.cc store_key_md5.h \
@@ -1369,16 +1354,16 @@
 	tests/stub_access_log.cc cache_cf.h YesNoNone.h \
 	tests/stub_cache_cf.cc client_db.h tests/stub_cache_manager.cc \
 	tests/stub_client_db.cc tests/stub_client_side_request.cc \
 	tests/stub_debug.cc tests/stub_errorpage.cc \
 	tests/stub_HelperChildConfig.cc tests/stub_http.cc \
 	tests/stub_HttpRequest.cc tests/stub_icp.cc tests/stub_ipc.cc \
-	tests/stub_ipcache.cc tests/stub_libformat.cc \
-	tests/stub_libicmp.cc tests/stub_libmgr.cc \
-	tests/stub_MemStore.cc mime.h tests/stub_mime.cc \
-	tests/stub_Port.cc tests/stub_pconn.cc \
+	tests/stub_ipcache.cc tests/stub_libeui.cc \
+	tests/stub_libformat.cc tests/stub_libicmp.cc \
+	tests/stub_libmgr.cc tests/stub_MemStore.cc mime.h \
+	tests/stub_mime.cc tests/stub_Port.cc tests/stub_pconn.cc \
 	tests/stub_store_client.cc store_rebuild.h \
 	tests/stub_store_rebuild.cc tests/stub_store_stats.cc tools.h \
 	tests/stub_tools.cc time.cc url.cc URLScheme.cc wordlist.h \
 	wordlist.cc CommonPool.h CompositePoolNode.h delay_pools.cc \
 	DelayId.cc DelayId.h DelayIdComposite.h DelayBucket.cc \
 	DelayBucket.h DelayConfig.cc DelayConfig.h DelayPool.cc \
@@ -1391,22 +1376,22 @@
 	DiskIO/WriteRequest.h DiskIO/DiskFile.h \
 	DiskIO/DiskIOStrategy.h DiskIO/IORequestor.h \
 	DiskIO/DiskIOModule.h unlinkd.h unlinkd.cc
 am_tests_testRock_OBJECTS = cbdata.$(OBJEXT) CacheDigest.$(OBJEXT) \
 	ConfigOption.$(OBJEXT) ConfigParser.$(OBJEXT) disk.$(OBJEXT) \
 	ETag.$(OBJEXT) EventLoop.$(OBJEXT) event.$(OBJEXT) \
-	tests/stub_fatal.$(OBJEXT) fd.$(OBJEXT) fde.$(OBJEXT) \
-	filemap.$(OBJEXT) HttpBody.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
+	fatal.$(OBJEXT) fd.$(OBJEXT) fde.$(OBJEXT) filemap.$(OBJEXT) \
+	HttpBody.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
 	HttpHdrContRange.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
 	HttpHdrSc.$(OBJEXT) HttpHdrScTarget.$(OBJEXT) \
 	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
 	HttpMsg.$(OBJEXT) HttpReply.$(OBJEXT) \
-	HttpRequestMethod.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
-	int.$(OBJEXT) SquidList.$(OBJEXT) mem.$(OBJEXT) \
-	MemBuf.$(OBJEXT) MemObject.$(OBJEXT) mem_node.$(OBJEXT) \
-	Packer.$(OBJEXT) Parsing.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
+	HttpRequestMethod.$(OBJEXT) int.$(OBJEXT) SquidList.$(OBJEXT) \
+	MasterXaction.$(OBJEXT) mem.$(OBJEXT) MemBuf.$(OBJEXT) \
+	MemObject.$(OBJEXT) mem_node.$(OBJEXT) Packer.$(OBJEXT) \
+	Parsing.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
 	RequestFlags.$(OBJEXT) StatCounters.$(OBJEXT) \
 	tests/stub_StatHist.$(OBJEXT) stmem.$(OBJEXT) store.$(OBJEXT) \
 	StoreFileSystem.$(OBJEXT) StoreIOState.$(OBJEXT) \
 	StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
 	StoreMetaSTD.$(OBJEXT) StoreMetaSTDLFS.$(OBJEXT) \
 	StoreMetaURL.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
@@ -1421,17 +1406,17 @@
 	tests/stub_client_db.$(OBJEXT) \
 	tests/stub_client_side_request.$(OBJEXT) \
 	tests/stub_debug.$(OBJEXT) tests/stub_errorpage.$(OBJEXT) \
 	tests/stub_HelperChildConfig.$(OBJEXT) \
 	tests/stub_http.$(OBJEXT) tests/stub_HttpRequest.$(OBJEXT) \
 	tests/stub_icp.$(OBJEXT) tests/stub_ipc.$(OBJEXT) \
-	tests/stub_ipcache.$(OBJEXT) tests/stub_libformat.$(OBJEXT) \
-	tests/stub_libicmp.$(OBJEXT) tests/stub_libmgr.$(OBJEXT) \
-	tests/stub_MemStore.$(OBJEXT) tests/stub_mime.$(OBJEXT) \
-	tests/stub_Port.$(OBJEXT) tests/stub_pconn.$(OBJEXT) \
-	tests/stub_store_client.$(OBJEXT) \
+	tests/stub_ipcache.$(OBJEXT) tests/stub_libeui.$(OBJEXT) \
+	tests/stub_libformat.$(OBJEXT) tests/stub_libicmp.$(OBJEXT) \
+	tests/stub_libmgr.$(OBJEXT) tests/stub_MemStore.$(OBJEXT) \
+	tests/stub_mime.$(OBJEXT) tests/stub_Port.$(OBJEXT) \
+	tests/stub_pconn.$(OBJEXT) tests/stub_store_client.$(OBJEXT) \
 	tests/stub_store_rebuild.$(OBJEXT) \
 	tests/stub_store_stats.$(OBJEXT) tests/stub_tools.$(OBJEXT) \
 	time.$(OBJEXT) url.$(OBJEXT) URLScheme.$(OBJEXT) \
 	wordlist.$(OBJEXT) $(am__objects_6) $(am__objects_7) \
 	$(am__objects_16)
 nodist_tests_testRock_OBJECTS = $(am__objects_21) \
@@ -1474,15 +1459,16 @@
 	EventLoop.cc fatal.h tests/stub_fatal.cc FileMap.h filemap.cc \
 	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
 	HttpHdrContRange.cc HttpHdrRange.cc HttpHdrSc.cc \
 	HttpHdrScTarget.cc HttpHeaderFieldInfo.h HttpHeaderTools.h \
 	HttpHeaderTools.cc HttpHeader.h HttpHeader.cc HttpMsg.cc \
 	HttpRequestMethod.cc RequestFlags.cc RequestFlags.h int.h \
-	int.cc SquidList.h SquidList.cc Mem.h mem.cc mem_node.cc \
-	MemBuf.cc MemObject.cc Packer.cc Parsing.cc RemovalPolicy.cc \
-	refresh.h refresh.cc StatCounters.h StatCounters.cc StatHist.h \
+	int.cc SquidList.h SquidList.cc MasterXaction.cc \
+	MasterXaction.h Mem.h mem.cc mem_node.cc MemBuf.cc \
+	MemObject.cc Packer.cc Parsing.cc RemovalPolicy.cc refresh.h \
+	refresh.cc StatCounters.h StatCounters.cc StatHist.h \
 	StatHist.cc stmem.cc repl_modules.h store.cc store_dir.cc \
 	store_io.cc store_swapout.cc StoreIOState.cc StoreMeta.cc \
 	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
 	StoreMetaUnpacker.cc StoreMetaURL.cc StoreMetaVary.cc \
 	StoreSwapLogData.cc store_key_md5.h store_key_md5.cc String.cc \
 	StrList.h StrList.cc SwapDir.cc tests/CapturingStoreEntry.h \
@@ -1490,14 +1476,14 @@
 	cache_cf.h YesNoNone.h tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc tests/stub_client_side_request.cc \
 	tests/stub_comm.cc tests/stub_debug.cc \
 	tests/stub_DiskIOModule.cc tests/stub_errorpage.cc fd.h fde.h \
 	tests/stub_fd.cc tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc tests/stub_http.cc \
-	tests/stub_libformat.cc HttpBody.h HttpBody.cc \
-	tests/stub_HttpReply.cc tests/stub_HttpRequest.cc \
+	tests/stub_libeui.cc tests/stub_libformat.cc HttpBody.h \
+	HttpBody.cc tests/stub_HttpReply.cc tests/stub_HttpRequest.cc \
 	tests/stub_libcomm.cc tests/stub_MemStore.cc mime.h \
 	tests/stub_mime.cc tests/stub_Port.cc \
 	tests/stub_store_client.cc tests/stub_store_stats.cc \
 	store_rebuild.h tests/stub_store_rebuild.cc \
 	tests/stub_store_swapout.cc tools.h tests/stub_tools.cc \
 	tests/stub_UdsOp.cc tests/testMain.cc tests/testStore.cc \
@@ -1516,15 +1502,15 @@
 	filemap.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
 	HttpHdrContRange.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
 	HttpHdrSc.$(OBJEXT) HttpHdrScTarget.$(OBJEXT) \
 	HttpHeaderTools.$(OBJEXT) HttpHeader.$(OBJEXT) \
 	HttpMsg.$(OBJEXT) HttpRequestMethod.$(OBJEXT) \
 	RequestFlags.$(OBJEXT) int.$(OBJEXT) SquidList.$(OBJEXT) \
-	mem.$(OBJEXT) mem_node.$(OBJEXT) MemBuf.$(OBJEXT) \
-	MemObject.$(OBJEXT) Packer.$(OBJEXT) Parsing.$(OBJEXT) \
-	RemovalPolicy.$(OBJEXT) refresh.$(OBJEXT) \
+	MasterXaction.$(OBJEXT) mem.$(OBJEXT) mem_node.$(OBJEXT) \
+	MemBuf.$(OBJEXT) MemObject.$(OBJEXT) Packer.$(OBJEXT) \
+	Parsing.$(OBJEXT) RemovalPolicy.$(OBJEXT) refresh.$(OBJEXT) \
 	StatCounters.$(OBJEXT) StatHist.$(OBJEXT) stmem.$(OBJEXT) \
 	store.$(OBJEXT) store_dir.$(OBJEXT) store_io.$(OBJEXT) \
 	store_swapout.$(OBJEXT) StoreIOState.$(OBJEXT) \
 	StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
 	StoreMetaSTD.$(OBJEXT) StoreMetaSTDLFS.$(OBJEXT) \
 	StoreMetaUnpacker.$(OBJEXT) StoreMetaURL.$(OBJEXT) \
@@ -1536,14 +1522,15 @@
 	tests/stub_client_side_request.$(OBJEXT) \
 	tests/stub_comm.$(OBJEXT) tests/stub_debug.$(OBJEXT) \
 	tests/stub_DiskIOModule.$(OBJEXT) \
 	tests/stub_errorpage.$(OBJEXT) tests/stub_fd.$(OBJEXT) \
 	tests/stub_helper.$(OBJEXT) \
 	tests/stub_HelperChildConfig.$(OBJEXT) \
-	tests/stub_http.$(OBJEXT) tests/stub_libformat.$(OBJEXT) \
-	HttpBody.$(OBJEXT) tests/stub_HttpReply.$(OBJEXT) \
+	tests/stub_http.$(OBJEXT) tests/stub_libeui.$(OBJEXT) \
+	tests/stub_libformat.$(OBJEXT) HttpBody.$(OBJEXT) \
+	tests/stub_HttpReply.$(OBJEXT) \
 	tests/stub_HttpRequest.$(OBJEXT) tests/stub_libcomm.$(OBJEXT) \
 	tests/stub_MemStore.$(OBJEXT) tests/stub_mime.$(OBJEXT) \
 	tests/stub_Port.$(OBJEXT) tests/stub_store_client.$(OBJEXT) \
 	tests/stub_store_stats.$(OBJEXT) \
 	tests/stub_store_rebuild.$(OBJEXT) \
 	tests/stub_store_swapout.$(OBJEXT) tests/stub_tools.$(OBJEXT) \
@@ -1592,27 +1579,29 @@
 	ClientDelayConfig.cc ClientDelayConfig.h disk.h disk.cc \
 	DiskIO/ReadRequest.cc DiskIO/WriteRequest.cc dlink.h dlink.cc \
 	dns_internal.cc SquidDns.h DnsLookupDetails.h \
 	DnsLookupDetails.cc dns.cc errorpage.cc ETag.cc event.cc \
 	external_acl.cc ExternalACLEntry.cc fatal.h \
 	tests/stub_fatal.cc fd.h fd.cc fde.cc FileMap.h filemap.cc \
-	forward.cc fqdncache.h fqdncache.cc ftp.h ftp.cc gopher.h \
-	gopher.cc helper.cc HelperChildConfig.h HelperChildConfig.cc \
-	hier_code.h htcp.cc htcp.h http.cc HttpBody.h HttpBody.cc \
+	fqdncache.h fqdncache.cc ftp.h ftp.cc FwdState.cc FwdState.h \
+	gopher.h gopher.cc helper.cc HelperChildConfig.h \
+	HelperChildConfig.cc HelperReply.cc HelperReply.h hier_code.h \
+	htcp.cc htcp.h http.cc HttpBody.h HttpBody.cc \
 	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
 	HttpHdrContRange.cc HttpHdrRange.cc HttpHdrSc.cc \
 	HttpHdrScTarget.cc HttpHeader.h HttpHeader.cc \
 	HttpHeaderFieldInfo.h HttpHeaderTools.h HttpHeaderTools.cc \
 	HttpMsg.cc HttpParser.cc HttpParser.h HttpReply.cc \
 	RequestFlags.h RequestFlags.cc HttpRequest.cc \
-	HttpRequestMethod.cc HttpStatusLine.cc icp_v2.cc icp_v3.cc \
-	SquidIpc.h ipc.cc ipc_win32.cc ipcache.cc int.h int.cc \
-	internal.h internal.cc SquidList.h SquidList.cc multicast.h \
-	multicast.cc Mem.h mem.cc mem_node.cc MemBuf.cc MemObject.cc \
-	mime.h mime.cc mime_header.h mime_header.cc neighbors.h \
-	neighbors.cc Packer.cc Parsing.cc pconn.cc peer_digest.cc \
+	HttpRequestMethod.cc icp_v2.cc icp_v3.cc SquidIpc.h ipc.cc \
+	ipc_win32.cc ipcache.cc int.h int.cc internal.h internal.cc \
+	SquidList.h SquidList.cc MasterXaction.cc MasterXaction.h \
+	multicast.h multicast.cc Mem.h mem.cc mem_node.cc MemBlob.cc \
+	MemBuf.cc MemObject.cc mime.h mime.cc mime_header.h \
+	mime_header.cc neighbors.h neighbors.cc Notes.cc Notes.h \
+	Packer.cc Parsing.cc pconn.cc peer_digest.cc \
 	peer_proxy_negotiate_auth.h peer_proxy_negotiate_auth.cc \
 	peer_select.cc peer_sourcehash.h peer_sourcehash.cc \
 	peer_userhash.h peer_userhash.cc redirect.h redirect.cc \
 	refresh.h refresh.cc RemovalPolicy.cc Server.cc SnmpRequest.h \
 	snmp_core.h snmp_core.cc snmp_agent.h snmp_agent.cc \
 	SquidMath.h SquidMath.cc IoStats.h stat.h stat.cc \
@@ -1643,33 +1632,35 @@
 	ConfigParser.$(OBJEXT) CpuAffinityMap.$(OBJEXT) \
 	CpuAffinitySet.$(OBJEXT) $(am__objects_6) disk.$(OBJEXT) \
 	DiskIO/ReadRequest.$(OBJEXT) DiskIO/WriteRequest.$(OBJEXT) \
 	dlink.$(OBJEXT) $(am__objects_8) errorpage.$(OBJEXT) \
 	ETag.$(OBJEXT) event.$(OBJEXT) external_acl.$(OBJEXT) \
 	ExternalACLEntry.$(OBJEXT) tests/stub_fatal.$(OBJEXT) \
-	fd.$(OBJEXT) fde.$(OBJEXT) filemap.$(OBJEXT) forward.$(OBJEXT) \
-	fqdncache.$(OBJEXT) ftp.$(OBJEXT) gopher.$(OBJEXT) \
-	helper.$(OBJEXT) HelperChildConfig.$(OBJEXT) $(am__objects_9) \
-	http.$(OBJEXT) HttpBody.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
+	fd.$(OBJEXT) fde.$(OBJEXT) filemap.$(OBJEXT) \
+	fqdncache.$(OBJEXT) ftp.$(OBJEXT) FwdState.$(OBJEXT) \
+	gopher.$(OBJEXT) helper.$(OBJEXT) HelperChildConfig.$(OBJEXT) \
+	HelperReply.$(OBJEXT) $(am__objects_9) http.$(OBJEXT) \
+	HttpBody.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
 	HttpHdrContRange.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
 	HttpHdrSc.$(OBJEXT) HttpHdrScTarget.$(OBJEXT) \
 	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
 	HttpMsg.$(OBJEXT) HttpParser.$(OBJEXT) HttpReply.$(OBJEXT) \
 	RequestFlags.$(OBJEXT) HttpRequest.$(OBJEXT) \
-	HttpRequestMethod.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
-	icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) $(am__objects_10) \
-	ipcache.$(OBJEXT) int.$(OBJEXT) internal.$(OBJEXT) \
-	SquidList.$(OBJEXT) multicast.$(OBJEXT) mem.$(OBJEXT) \
-	mem_node.$(OBJEXT) MemBuf.$(OBJEXT) MemObject.$(OBJEXT) \
+	HttpRequestMethod.$(OBJEXT) icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) \
+	$(am__objects_10) ipcache.$(OBJEXT) int.$(OBJEXT) \
+	internal.$(OBJEXT) SquidList.$(OBJEXT) MasterXaction.$(OBJEXT) \
+	multicast.$(OBJEXT) mem.$(OBJEXT) mem_node.$(OBJEXT) \
+	MemBlob.$(OBJEXT) MemBuf.$(OBJEXT) MemObject.$(OBJEXT) \
 	mime.$(OBJEXT) mime_header.$(OBJEXT) neighbors.$(OBJEXT) \
-	Packer.$(OBJEXT) Parsing.$(OBJEXT) pconn.$(OBJEXT) \
-	peer_digest.$(OBJEXT) peer_proxy_negotiate_auth.$(OBJEXT) \
-	peer_select.$(OBJEXT) peer_sourcehash.$(OBJEXT) \
-	peer_userhash.$(OBJEXT) redirect.$(OBJEXT) refresh.$(OBJEXT) \
-	RemovalPolicy.$(OBJEXT) Server.$(OBJEXT) $(am__objects_15) \
-	SquidMath.$(OBJEXT) stat.$(OBJEXT) StatCounters.$(OBJEXT) \
+	Notes.$(OBJEXT) Packer.$(OBJEXT) Parsing.$(OBJEXT) \
+	pconn.$(OBJEXT) peer_digest.$(OBJEXT) \
+	peer_proxy_negotiate_auth.$(OBJEXT) peer_select.$(OBJEXT) \
+	peer_sourcehash.$(OBJEXT) peer_userhash.$(OBJEXT) \
+	redirect.$(OBJEXT) refresh.$(OBJEXT) RemovalPolicy.$(OBJEXT) \
+	Server.$(OBJEXT) $(am__objects_15) SquidMath.$(OBJEXT) \
+	stat.$(OBJEXT) StatCounters.$(OBJEXT) \
 	tests/stub_StatHist.$(OBJEXT) stmem.$(OBJEXT) store.$(OBJEXT) \
 	store_client.$(OBJEXT) store_digest.$(OBJEXT) \
 	store_dir.$(OBJEXT) store_io.$(OBJEXT) store_key_md5.$(OBJEXT) \
 	store_log.$(OBJEXT) store_rebuild.$(OBJEXT) \
 	store_swapin.$(OBJEXT) store_swapmeta.$(OBJEXT) \
 	store_swapout.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
@@ -1689,37 +1680,38 @@
 	whois.$(OBJEXT) FadingCounter.$(OBJEXT) $(am__objects_17) \
 	wordlist.$(OBJEXT)
 nodist_tests_testURL_OBJECTS = $(am__objects_22)
 tests_testURL_OBJECTS = $(am_tests_testURL_OBJECTS) \
 	$(nodist_tests_testURL_OBJECTS)
 tests_testURL_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
-	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testURL_LDFLAGS) $(LDFLAGS) \
-	-o $@
-am__tests_testUfs_SOURCES_DIST = tests/testUfs.cc tests/testMain.cc \
-	tests/testUfs.h tests/stub_cache_manager.cc \
-	tests/stub_client_db.cc tests/stub_HelperChildConfig.cc \
-	tests/stub_icp.cc tests/stub_ipc.cc tests/stub_MemStore.cc \
-	tests/stub_pconn.cc tests/stub_Port.cc tests/stub_UdsOp.cc \
-	internal.h tests/stub_internal.cc tests/stub_libformat.cc \
-	store_rebuild.h tests/stub_store_rebuild.cc \
-	tests/stub_store_stats.cc fatal.h tests/stub_fatal.cc fd.h \
-	fd.cc fde.h fde.cc client_db.h disk.h disk.cc FileMap.h \
-	filemap.cc HttpBody.h HttpBody.cc HttpReply.cc \
-	HttpStatusLine.cc int.h int.cc RequestFlags.h RequestFlags.cc \
-	SquidList.h SquidList.cc MemObject.cc StoreSwapLogData.cc \
-	StoreIOState.cc StoreMeta.cc StoreMetaMD5.cc StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc StoreMetaUnpacker.cc StoreMetaURL.cc \
-	StoreMetaVary.cc StoreFileSystem.cc store_io.cc \
-	store_swapout.cc store_swapmeta.cc unlinkd.h unlinkd.cc \
-	win32.cc event.cc CommonPool.h CompositePoolNode.h \
-	delay_pools.cc DelayId.cc DelayId.h DelayIdComposite.h \
-	DelayBucket.cc DelayBucket.h DelayConfig.cc DelayConfig.h \
-	DelayPool.cc DelayPool.h DelayPools.h DelaySpec.cc DelaySpec.h \
-	DelayTagged.cc DelayTagged.h DelayUser.cc DelayUser.h \
-	DelayVector.cc DelayVector.h NullDelayId.cc NullDelayId.h \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
+	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testURL_LDFLAGS) $(LDFLAGS) \
+	-o $@
+am__tests_testUfs_SOURCES_DIST = tests/testUfs.cc tests/testMain.cc \
+	tests/testUfs.h tests/stub_cache_manager.cc \
+	tests/stub_client_db.cc tests/stub_HelperChildConfig.cc \
+	tests/stub_icp.cc tests/stub_ipc.cc tests/stub_libeui.cc \
+	tests/stub_MemStore.cc tests/stub_pconn.cc tests/stub_Port.cc \
+	tests/stub_UdsOp.cc internal.h tests/stub_internal.cc \
+	tests/stub_libformat.cc store_rebuild.h \
+	tests/stub_store_rebuild.cc tests/stub_store_stats.cc fatal.h \
+	tests/stub_fatal.cc fd.h fd.cc fde.h fde.cc client_db.h disk.h \
+	disk.cc FileMap.h filemap.cc HttpBody.h HttpBody.cc \
+	HttpReply.cc int.h int.cc RequestFlags.h RequestFlags.cc \
+	SquidList.h SquidList.cc MasterXaction.cc MasterXaction.h \
+	MemObject.cc StoreSwapLogData.cc StoreIOState.cc StoreMeta.cc \
+	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
+	StoreMetaUnpacker.cc StoreMetaURL.cc StoreMetaVary.cc \
+	StoreFileSystem.cc store_io.cc store_swapout.cc \
+	store_swapmeta.cc unlinkd.h unlinkd.cc win32.cc event.cc \
+	CommonPool.h CompositePoolNode.h delay_pools.cc DelayId.cc \
+	DelayId.h DelayIdComposite.h DelayBucket.cc DelayBucket.h \
+	DelayConfig.cc DelayConfig.h DelayPool.cc DelayPool.h \
+	DelayPools.h DelaySpec.cc DelaySpec.h DelayTagged.cc \
+	DelayTagged.h DelayUser.cc DelayUser.h DelayVector.cc \
+	DelayVector.h NullDelayId.cc NullDelayId.h \
 	ClientDelayConfig.cc ClientDelayConfig.h CacheDigest.h \
 	CacheDigest.cc ConfigParser.cc EventLoop.cc HttpMsg.cc \
 	RemovalPolicy.cc store_dir.cc repl_modules.h store.cc \
 	HttpRequestMethod.cc store_key_md5.h store_key_md5.cc \
 	Parsing.cc ConfigOption.cc SwapDir.cc tests/stub_acl.cc \
 	cache_cf.h YesNoNone.h tests/stub_cache_cf.cc \
@@ -1743,21 +1735,22 @@
 	DiskIO/DiskIOModule.h
 am_tests_testUfs_OBJECTS = tests/testUfs.$(OBJEXT) \
 	tests/testMain.$(OBJEXT) tests/stub_cache_manager.$(OBJEXT) \
 	tests/stub_client_db.$(OBJEXT) \
 	tests/stub_HelperChildConfig.$(OBJEXT) \
 	tests/stub_icp.$(OBJEXT) tests/stub_ipc.$(OBJEXT) \
-	tests/stub_MemStore.$(OBJEXT) tests/stub_pconn.$(OBJEXT) \
-	tests/stub_Port.$(OBJEXT) tests/stub_UdsOp.$(OBJEXT) \
-	tests/stub_internal.$(OBJEXT) tests/stub_libformat.$(OBJEXT) \
+	tests/stub_libeui.$(OBJEXT) tests/stub_MemStore.$(OBJEXT) \
+	tests/stub_pconn.$(OBJEXT) tests/stub_Port.$(OBJEXT) \
+	tests/stub_UdsOp.$(OBJEXT) tests/stub_internal.$(OBJEXT) \
+	tests/stub_libformat.$(OBJEXT) \
 	tests/stub_store_rebuild.$(OBJEXT) \
 	tests/stub_store_stats.$(OBJEXT) tests/stub_fatal.$(OBJEXT) \
 	fd.$(OBJEXT) fde.$(OBJEXT) disk.$(OBJEXT) filemap.$(OBJEXT) \
-	HttpBody.$(OBJEXT) HttpReply.$(OBJEXT) \
-	HttpStatusLine.$(OBJEXT) int.$(OBJEXT) RequestFlags.$(OBJEXT) \
-	SquidList.$(OBJEXT) MemObject.$(OBJEXT) \
+	HttpBody.$(OBJEXT) HttpReply.$(OBJEXT) int.$(OBJEXT) \
+	RequestFlags.$(OBJEXT) SquidList.$(OBJEXT) \
+	MasterXaction.$(OBJEXT) MemObject.$(OBJEXT) \
 	StoreSwapLogData.$(OBJEXT) StoreIOState.$(OBJEXT) \
 	StoreMeta.$(OBJEXT) StoreMetaMD5.$(OBJEXT) \
 	StoreMetaSTD.$(OBJEXT) StoreMetaSTDLFS.$(OBJEXT) \
 	StoreMetaUnpacker.$(OBJEXT) StoreMetaURL.$(OBJEXT) \
 	StoreMetaVary.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
 	store_io.$(OBJEXT) store_swapout.$(OBJEXT) \
@@ -1789,12 +1782,21 @@
 tests_testUfs_OBJECTS = $(am_tests_testUfs_OBJECTS) \
 	$(nodist_tests_testUfs_OBJECTS)
 tests_testUfs_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
 	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testUfs_LDFLAGS) $(LDFLAGS) \
 	-o $@
+am_tests_testVector_OBJECTS = tests/testVector.$(OBJEXT) \
+	tests/testMain.$(OBJEXT) time.$(OBJEXT)
+nodist_tests_testVector_OBJECTS = $(am__objects_23)
+tests_testVector_OBJECTS = $(am_tests_testVector_OBJECTS) \
+	$(nodist_tests_testVector_OBJECTS)
+tests_testVector_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
+	$(AM_CXXFLAGS) $(CXXFLAGS) $(tests_testVector_LDFLAGS) \
+	$(LDFLAGS) -o $@
 am__tests_test_http_range_SOURCES_DIST = AccessLogEntry.cc AclRegs.cc \
 	AuthReg.cc BodyPipe.cc cache_cf.h AuthReg.h YesNoNone.h \
 	YesNoNone.cc RefreshPattern.h cache_cf.cc cache_manager.cc \
 	CacheDigest.h CacheDigest.cc carp.h carp.cc cbdata.cc \
 	ChunkedCodingParser.cc client_db.h client_db.cc client_side.h \
 	client_side.cc client_side_reply.cc client_side_request.cc \
@@ -1813,27 +1815,29 @@
 	DiskIO/DiskIOStrategy.h DiskIO/IORequestor.h \
 	DiskIO/DiskIOModule.h disk.h disk.cc dlink.h dlink.cc \
 	dns_internal.cc SquidDns.h DnsLookupDetails.h \
 	DnsLookupDetails.cc dns.cc errorpage.cc ETag.cc event.cc \
 	external_acl.cc ExternalACLEntry.cc FadingCounter.cc fatal.h \
 	tests/stub_fatal.cc fd.h fd.cc fde.cc FileMap.h filemap.cc \
-	forward.cc fqdncache.h fqdncache.cc ftp.h ftp.cc gopher.h \
-	gopher.cc helper.cc HelperChildConfig.h HelperChildConfig.cc \
-	hier_code.h htcp.cc htcp.h http.cc HttpBody.h HttpBody.cc \
+	fqdncache.h fqdncache.cc ftp.h ftp.cc FwdState.cc FwdState.h \
+	gopher.h gopher.cc helper.cc HelperChildConfig.h \
+	HelperChildConfig.cc HelperReply.cc HelperReply.h hier_code.h \
+	htcp.cc htcp.h http.cc HttpBody.h HttpBody.cc \
 	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
 	HttpHdrContRange.cc HttpHdrRange.cc HttpHdrSc.cc \
 	HttpHdrScTarget.cc HttpHeader.h HttpHeader.cc \
 	HttpHeaderFieldInfo.h HttpHeaderTools.h HttpHeaderTools.cc \
 	HttpMsg.cc HttpParser.cc HttpParser.h HttpReply.cc \
 	RequestFlags.h RequestFlags.cc HttpRequest.cc \
-	HttpRequestMethod.cc HttpStatusLine.cc icp_v2.cc icp_v3.cc \
-	int.h int.cc internal.h internal.cc SquidIpc.h ipc.cc \
-	ipc_win32.cc ipcache.cc SquidList.h SquidList.cc MemBuf.cc \
-	MemObject.cc Mem.h mem.cc mem_node.cc mime.h mime.cc \
-	mime_header.h mime_header.cc multicast.h multicast.cc \
-	neighbors.h neighbors.cc Packer.cc Parsing.cc peer_digest.cc \
+	HttpRequestMethod.cc icp_v2.cc icp_v3.cc int.h int.cc \
+	internal.h internal.cc SquidIpc.h ipc.cc ipc_win32.cc \
+	ipcache.cc SquidList.h SquidList.cc MasterXaction.cc \
+	MasterXaction.h MemBlob.cc MemBuf.cc MemObject.cc Mem.h mem.cc \
+	mem_node.cc mime.h mime.cc mime_header.h mime_header.cc \
+	multicast.h multicast.cc neighbors.h neighbors.cc Notes.cc \
+	Notes.h Packer.cc Parsing.cc peer_digest.cc \
 	peer_proxy_negotiate_auth.h peer_proxy_negotiate_auth.cc \
 	peer_select.cc peer_sourcehash.h peer_sourcehash.cc \
 	peer_userhash.h peer_userhash.cc pconn.cc redirect.h \
 	redirect.cc refresh.h refresh.cc RemovalPolicy.cc Server.cc \
 	SnmpRequest.h snmp_core.h snmp_core.cc snmp_agent.h \
 	snmp_agent.cc SquidMath.h SquidMath.cc IoStats.h stat.h \
@@ -1845,16 +1849,17 @@
 	store_swapin.cc store_swapmeta.cc store_swapout.cc \
 	StoreFileSystem.cc StoreIOState.cc StoreMeta.cc \
 	StoreMetaMD5.cc StoreMetaSTD.cc StoreMetaSTDLFS.cc \
 	StoreMetaUnpacker.cc StoreMetaURL.cc StoreMetaVary.cc \
 	StoreSwapLogData.cc String.cc StrList.h StrList.cc SwapDir.cc \
 	tests/test_http_range.cc tests/stub_ipc_Forwarder.cc \
-	tests/stub_main_cc.cc tests/stub_MemStore.cc \
-	tests/stub_store_stats.cc time.cc tools.h tools.cc tunnel.cc \
-	unlinkd.h unlinkd.cc url.cc URLScheme.cc urn.h urn.cc wccp2.h \
-	wccp2.cc whois.h whois.cc win32.cc wordlist.h wordlist.cc
+	tests/stub_libeui.cc tests/stub_main_cc.cc \
+	tests/stub_MemStore.cc tests/stub_store_stats.cc time.cc \
+	tools.h tools.cc tunnel.cc unlinkd.h unlinkd.cc url.cc \
+	URLScheme.cc urn.h urn.cc wccp2.h wccp2.cc whois.h whois.cc \
+	win32.cc wordlist.h wordlist.cc
 am_tests_test_http_range_OBJECTS = AccessLogEntry.$(OBJEXT) \
 	$(am__objects_4) BodyPipe.$(OBJEXT) YesNoNone.$(OBJEXT) \
 	cache_cf.$(OBJEXT) cache_manager.$(OBJEXT) \
 	CacheDigest.$(OBJEXT) carp.$(OBJEXT) cbdata.$(OBJEXT) \
 	ChunkedCodingParser.$(OBJEXT) client_db.$(OBJEXT) \
 	client_side.$(OBJEXT) client_side_reply.$(OBJEXT) \
@@ -1863,46 +1868,47 @@
 	CpuAffinityMap.$(OBJEXT) CpuAffinitySet.$(OBJEXT) \
 	debug.$(OBJEXT) $(am__objects_6) $(am__objects_7) \
 	disk.$(OBJEXT) dlink.$(OBJEXT) $(am__objects_8) \
 	errorpage.$(OBJEXT) ETag.$(OBJEXT) event.$(OBJEXT) \
 	external_acl.$(OBJEXT) ExternalACLEntry.$(OBJEXT) \
 	FadingCounter.$(OBJEXT) tests/stub_fatal.$(OBJEXT) \
-	fd.$(OBJEXT) fde.$(OBJEXT) filemap.$(OBJEXT) forward.$(OBJEXT) \
-	fqdncache.$(OBJEXT) ftp.$(OBJEXT) gopher.$(OBJEXT) \
-	helper.$(OBJEXT) HelperChildConfig.$(OBJEXT) $(am__objects_9) \
-	http.$(OBJEXT) HttpBody.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
+	fd.$(OBJEXT) fde.$(OBJEXT) filemap.$(OBJEXT) \
+	fqdncache.$(OBJEXT) ftp.$(OBJEXT) FwdState.$(OBJEXT) \
+	gopher.$(OBJEXT) helper.$(OBJEXT) HelperChildConfig.$(OBJEXT) \
+	HelperReply.$(OBJEXT) $(am__objects_9) http.$(OBJEXT) \
+	HttpBody.$(OBJEXT) HttpHdrCc.$(OBJEXT) \
 	HttpHdrContRange.$(OBJEXT) HttpHdrRange.$(OBJEXT) \
 	HttpHdrSc.$(OBJEXT) HttpHdrScTarget.$(OBJEXT) \
 	HttpHeader.$(OBJEXT) HttpHeaderTools.$(OBJEXT) \
 	HttpMsg.$(OBJEXT) HttpParser.$(OBJEXT) HttpReply.$(OBJEXT) \
 	RequestFlags.$(OBJEXT) HttpRequest.$(OBJEXT) \
-	HttpRequestMethod.$(OBJEXT) HttpStatusLine.$(OBJEXT) \
-	icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) int.$(OBJEXT) \
-	internal.$(OBJEXT) $(am__objects_10) ipcache.$(OBJEXT) \
-	SquidList.$(OBJEXT) MemBuf.$(OBJEXT) MemObject.$(OBJEXT) \
+	HttpRequestMethod.$(OBJEXT) icp_v2.$(OBJEXT) icp_v3.$(OBJEXT) \
+	int.$(OBJEXT) internal.$(OBJEXT) $(am__objects_10) \
+	ipcache.$(OBJEXT) SquidList.$(OBJEXT) MasterXaction.$(OBJEXT) \
+	MemBlob.$(OBJEXT) MemBuf.$(OBJEXT) MemObject.$(OBJEXT) \
 	mem.$(OBJEXT) mem_node.$(OBJEXT) mime.$(OBJEXT) \
 	mime_header.$(OBJEXT) multicast.$(OBJEXT) neighbors.$(OBJEXT) \
-	Packer.$(OBJEXT) Parsing.$(OBJEXT) peer_digest.$(OBJEXT) \
-	peer_proxy_negotiate_auth.$(OBJEXT) peer_select.$(OBJEXT) \
-	peer_sourcehash.$(OBJEXT) peer_userhash.$(OBJEXT) \
-	pconn.$(OBJEXT) redirect.$(OBJEXT) refresh.$(OBJEXT) \
-	RemovalPolicy.$(OBJEXT) Server.$(OBJEXT) $(am__objects_15) \
-	SquidMath.$(OBJEXT) stat.$(OBJEXT) StatCounters.$(OBJEXT) \
-	StatHist.$(OBJEXT) stmem.$(OBJEXT) store.$(OBJEXT) \
-	store_client.$(OBJEXT) store_digest.$(OBJEXT) \
+	Notes.$(OBJEXT) Packer.$(OBJEXT) Parsing.$(OBJEXT) \
+	peer_digest.$(OBJEXT) peer_proxy_negotiate_auth.$(OBJEXT) \
+	peer_select.$(OBJEXT) peer_sourcehash.$(OBJEXT) \
+	peer_userhash.$(OBJEXT) pconn.$(OBJEXT) redirect.$(OBJEXT) \
+	refresh.$(OBJEXT) RemovalPolicy.$(OBJEXT) Server.$(OBJEXT) \
+	$(am__objects_15) SquidMath.$(OBJEXT) stat.$(OBJEXT) \
+	StatCounters.$(OBJEXT) StatHist.$(OBJEXT) stmem.$(OBJEXT) \
+	store.$(OBJEXT) store_client.$(OBJEXT) store_digest.$(OBJEXT) \
 	store_dir.$(OBJEXT) store_key_md5.$(OBJEXT) store_io.$(OBJEXT) \
 	store_log.$(OBJEXT) store_rebuild.$(OBJEXT) \
 	store_swapin.$(OBJEXT) store_swapmeta.$(OBJEXT) \
 	store_swapout.$(OBJEXT) StoreFileSystem.$(OBJEXT) \
 	StoreIOState.$(OBJEXT) StoreMeta.$(OBJEXT) \
 	StoreMetaMD5.$(OBJEXT) StoreMetaSTD.$(OBJEXT) \
 	StoreMetaSTDLFS.$(OBJEXT) StoreMetaUnpacker.$(OBJEXT) \
 	StoreMetaURL.$(OBJEXT) StoreMetaVary.$(OBJEXT) \
 	StoreSwapLogData.$(OBJEXT) String.$(OBJEXT) StrList.$(OBJEXT) \
 	SwapDir.$(OBJEXT) tests/test_http_range.$(OBJEXT) \
-	tests/stub_ipc_Forwarder.$(OBJEXT) \
+	tests/stub_ipc_Forwarder.$(OBJEXT) tests/stub_libeui.$(OBJEXT) \
 	tests/stub_main_cc.$(OBJEXT) tests/stub_MemStore.$(OBJEXT) \
 	tests/stub_store_stats.$(OBJEXT) time.$(OBJEXT) \
 	tools.$(OBJEXT) tunnel.$(OBJEXT) $(am__objects_16) \
 	url.$(OBJEXT) URLScheme.$(OBJEXT) urn.$(OBJEXT) \
 	wccp2.$(OBJEXT) whois.$(OBJEXT) $(am__objects_17) \
 	wordlist.$(OBJEXT)
@@ -1995,13 +2001,13 @@
 	$(EXTRA_libDiskThreads_a_SOURCES) $(libIpcIo_a_SOURCES) \
 	$(libMmapped_a_SOURCES) $(libsquid_la_SOURCES) \
 	$(DiskIO_DiskDaemon_diskd_SOURCES) \
 	$(nodist_DiskIO_DiskDaemon_diskd_SOURCES) $(cf_gen_SOURCES) \
 	$(dnsserver_SOURCES) $(recv_announce_SOURCES) $(squid_SOURCES) \
 	$(EXTRA_squid_SOURCES) $(nodist_squid_SOURCES) \
-	$(tests_testACLMaxUserIP_SOURCES) \
+	$(testRefCount_SOURCES) $(tests_testACLMaxUserIP_SOURCES) \
 	$(nodist_tests_testACLMaxUserIP_SOURCES) \
 	$(tests_testBoilerplate_SOURCES) \
 	$(nodist_tests_testBoilerplate_SOURCES) \
 	$(tests_testCacheManager_SOURCES) \
 	$(nodist_tests_testCacheManager_SOURCES) \
 	$(tests_testConfigParser_SOURCES) \
@@ -2014,47 +2020,46 @@
 	$(tests_testHttpParser_SOURCES) \
 	$(nodist_tests_testHttpParser_SOURCES) \
 	$(tests_testHttpReply_SOURCES) \
 	$(nodist_tests_testHttpReply_SOURCES) \
 	$(tests_testHttpRequest_SOURCES) \
 	$(nodist_tests_testHttpRequest_SOURCES) \
-	$(tests_testNull_SOURCES) $(nodist_tests_testNull_SOURCES) \
 	$(tests_testRock_SOURCES) $(nodist_tests_testRock_SOURCES) \
 	$(tests_testStatHist_SOURCES) \
 	$(nodist_tests_testStatHist_SOURCES) \
 	$(tests_testStore_SOURCES) $(nodist_tests_testStore_SOURCES) \
 	$(tests_testString_SOURCES) $(nodist_tests_testString_SOURCES) \
 	$(tests_testURL_SOURCES) $(nodist_tests_testURL_SOURCES) \
 	$(tests_testUfs_SOURCES) $(nodist_tests_testUfs_SOURCES) \
+	$(tests_testVector_SOURCES) $(nodist_tests_testVector_SOURCES) \
 	$(tests_test_http_range_SOURCES) \
 	$(nodist_tests_test_http_range_SOURCES) $(ufsdump_SOURCES) \
 	$(nodist_ufsdump_SOURCES) $(unlinkd_SOURCES)
 DIST_SOURCES = $(am__libAIO_a_SOURCES_DIST) $(libBlocking_a_SOURCES) \
 	$(libDiskDaemon_a_SOURCES) \
 	$(am__libDiskThreads_a_SOURCES_DIST) \
 	$(EXTRA_libDiskThreads_a_SOURCES) $(libIpcIo_a_SOURCES) \
 	$(libMmapped_a_SOURCES) $(libsquid_la_SOURCES) \
 	$(DiskIO_DiskDaemon_diskd_SOURCES) $(cf_gen_SOURCES) \
 	$(dnsserver_SOURCES) $(recv_announce_SOURCES) \
 	$(am__squid_SOURCES_DIST) $(am__EXTRA_squid_SOURCES_DIST) \
-	$(tests_testACLMaxUserIP_SOURCES) \
+	$(testRefCount_SOURCES) $(tests_testACLMaxUserIP_SOURCES) \
 	$(tests_testBoilerplate_SOURCES) \
 	$(am__tests_testCacheManager_SOURCES_DIST) \
 	$(tests_testConfigParser_SOURCES) \
 	$(am__tests_testCoss_SOURCES_DIST) \
 	$(am__tests_testDiskIO_SOURCES_DIST) \
 	$(am__tests_testEvent_SOURCES_DIST) \
 	$(am__tests_testEventLoop_SOURCES_DIST) \
 	$(tests_testHttpParser_SOURCES) $(tests_testHttpReply_SOURCES) \
 	$(am__tests_testHttpRequest_SOURCES_DIST) \
-	$(am__tests_testNull_SOURCES_DIST) \
 	$(am__tests_testRock_SOURCES_DIST) \
 	$(tests_testStatHist_SOURCES) \
 	$(am__tests_testStore_SOURCES_DIST) \
 	$(tests_testString_SOURCES) $(am__tests_testURL_SOURCES_DIST) \
-	$(am__tests_testUfs_SOURCES_DIST) \
+	$(am__tests_testUfs_SOURCES_DIST) $(tests_testVector_SOURCES) \
 	$(am__tests_test_http_range_SOURCES_DIST) \
 	$(am__ufsdump_SOURCES_DIST) $(unlinkd_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
 	ctags-recursive dvi-recursive html-recursive info-recursive \
 	install-data-recursive install-dvi-recursive \
 	install-exec-recursive install-html-recursive \
@@ -2390,12 +2395,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -2433,12 +2439,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -2465,27 +2472,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -2555,13 +2565,13 @@
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) \
 	-I$(top_builddir)/src $(am__append_10) $(KRB5INCS)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 AUTOMAKE_OPTIONS = subdir-objects
 @ENABLE_DNSHELPER_FALSE@DNSSOURCE = dns_internal.cc SquidDns.h \
 @ENABLE_DNSHELPER_FALSE@	DnsLookupDetails.h DnsLookupDetails.cc
 @ENABLE_DNSHELPER_TRUE@DNSSOURCE = dns.cc SquidDns.h \
 @ENABLE_DNSHELPER_TRUE@	DnsLookupDetails.h DnsLookupDetails.cc
@@ -2575,16 +2585,16 @@
 LOADABLE_MODULES_SOURCES = \
 	LoadableModule.h \
 	LoadableModule.cc \
 	LoadableModules.h \
 	LoadableModules.cc
 
-SUBDIRS = base anyp comm eui acl format fs repl $(am__append_2) ip \
-	icmp ident log ipc mgr $(am__append_4) $(am__append_5) \
+SUBDIRS = base anyp comm eui acl format fs repl $(am__append_2) http \
+	ip icmp ident log ipc mgr $(am__append_4) $(am__append_5) \
 	$(am__append_6) $(am__append_7)
-DIST_SUBDIRS = base anyp comm eui acl format fs repl auth ip icmp \
+DIST_SUBDIRS = base anyp comm eui acl format fs repl auth http ip icmp \
 	ident log ipc mgr ssl snmp adaptation esi
 @ENABLE_AUTH_TRUE@AUTH_LIBS = auth/libauth.la
 @ENABLE_AUTH_TRUE@AUTH_ACL_LIBS = auth/libacls.la
 @ENABLE_SSL_TRUE@SSL_LIBS = \
 @ENABLE_SSL_TRUE@	ssl/libsslsquid.la \
 @ENABLE_SSL_TRUE@	ssl/libsslutil.la
@@ -2599,13 +2609,13 @@
 
 @ENABLE_SNMP_FALSE@SNMP_SOURCE = 
 @ENABLE_SNMP_TRUE@SNMP_SOURCE = $(SNMP_ALL_SOURCE)
 @ENABLE_SNMP_TRUE@SNMP_LIBS = snmp/libsnmp.la $(SNMPLIB)
 @USE_ESI_TRUE@ESI_LOCAL_LIBS = \
 @USE_ESI_TRUE@	esi/libesi.la \
-@USE_ESI_TRUE@	$(top_builddir)/lib/libTrie/src/libTrie.a
+@USE_ESI_TRUE@	$(top_builddir)/lib/libTrie/libTrie.a
 
 @USE_ESI_FALSE@ESI_LIBS = 
 @USE_ESI_TRUE@ESI_LIBS = $(ESI_LOCAL_LIBS) \
 @USE_ESI_TRUE@	$(XMLLIB) \
 @USE_ESI_TRUE@	$(EXPATLIB)
 
@@ -2731,34 +2741,34 @@
 	$(DELAY_POOL_SOURCE) disk.h disk.cc $(DISKIO_SOURCE) dlink.h \
 	dlink.cc $(DNSSOURCE) enums.h err_type.h err_detail_type.h \
 	errorpage.cc errorpage.h ETag.cc ETag.h event.cc event.h \
 	EventLoop.h EventLoop.cc external_acl.cc ExternalACL.h \
 	ExternalACLEntry.cc ExternalACLEntry.h FadingCounter.h \
 	FadingCounter.cc fatal.h fatal.cc fd.h fd.cc fde.cc fde.h \
-	FileMap.h filemap.cc forward.cc forward.h fqdncache.h \
-	fqdncache.cc ftp.h ftp.cc Generic.h globals.h gopher.h \
-	gopher.cc helper.cc helper.h HelperChildConfig.h \
-	HelperChildConfig.cc hier_code.h HierarchyLogEntry.h \
-	$(HTCPSOURCE) HttpStateFlags.h http.cc http.h HttpStatusCode.h \
-	HttpStatusLine.cc HttpStatusLine.h HttpHeaderFieldStat.h \
-	HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci HttpHdrRange.cc \
-	HttpHdrSc.cc HttpHdrSc.h HttpHdrScTarget.cc HttpHdrScTarget.h \
-	HttpHdrContRange.cc HttpHdrContRange.h HttpHeaderStat.h \
-	HttpHeader.h HttpHeader.cc HttpHeaderMask.h HttpHeaderRange.h \
-	HttpHeaderFieldInfo.h HttpHeaderTools.h HttpHeaderTools.cc \
-	HttpBody.h HttpBody.cc HttpControlMsg.h HttpMsg.cc HttpMsg.h \
-	HttpParser.cc HttpParser.h HttpReply.cc HttpReply.h \
-	RequestFlags.h RequestFlags.cc HttpRequest.cc HttpRequest.h \
-	HttpRequestMethod.cc HttpRequestMethod.h HttpVersion.h ICP.h \
+	FileMap.h filemap.cc fqdncache.h fqdncache.cc ftp.h ftp.cc \
+	FwdState.cc FwdState.h Generic.h globals.h gopher.h gopher.cc \
+	helper.cc helper.h HelperChildConfig.h HelperChildConfig.cc \
+	HelperReply.cc HelperReply.h hier_code.h HierarchyLogEntry.h \
+	$(HTCPSOURCE) HttpStateFlags.h http.cc http.h \
+	HttpHeaderFieldStat.h HttpHdrCc.h HttpHdrCc.cc HttpHdrCc.cci \
+	HttpHdrRange.cc HttpHdrSc.cc HttpHdrSc.h HttpHdrScTarget.cc \
+	HttpHdrScTarget.h HttpHdrContRange.cc HttpHdrContRange.h \
+	HttpHeaderStat.h HttpHeader.h HttpHeader.cc HttpHeaderMask.h \
+	HttpHeaderRange.h HttpHeaderFieldInfo.h HttpHeaderTools.h \
+	HttpHeaderTools.cc HttpBody.h HttpBody.cc HttpControlMsg.h \
+	HttpMsg.cc HttpMsg.h HttpParser.cc HttpParser.h HttpReply.cc \
+	HttpReply.h RequestFlags.h RequestFlags.cc HttpRequest.cc \
+	HttpRequest.h HttpRequestMethod.cc HttpRequestMethod.h ICP.h \
 	icp_opcode.h icp_v2.cc icp_v3.cc int.h int.cc internal.h \
 	internal.cc $(IPC_SOURCE) ipcache.cc ipcache.h \
-	$(LEAKFINDERSOURCE) SquidList.h SquidList.cc lookup_t.h \
-	main.cc Mem.h mem.cc mem_node.cc mem_node.h Mem.h MemBuf.cc \
-	MemObject.cc MemObject.h mime.h mime.cc mime_header.h \
-	mime_header.cc multicast.h multicast.cc neighbors.h \
-	neighbors.cc Packer.cc Packer.h Parsing.cc Parsing.h \
+	$(LEAKFINDERSOURCE) SquidList.h SquidList.cc LogTags.h \
+	lookup_t.h main.cc MasterXaction.cc MasterXaction.h Mem.h \
+	mem.cc mem_node.cc mem_node.h Mem.h MemBuf.cc MemObject.cc \
+	MemObject.h mime.h mime.cc mime_header.h mime_header.cc \
+	multicast.h multicast.cc neighbors.h neighbors.cc Notes.cc \
+	Notes.h Packer.cc Packer.h Parsing.cc Parsing.h \
 	$(XPROF_STATS_SOURCE) pconn.cc pconn.h PeerDigest.h \
 	peer_digest.cc peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc peer_select.cc peer_sourcehash.h \
 	peer_sourcehash.cc peer_userhash.h peer_userhash.cc \
 	PeerSelectState.h PingData.h protos.h redirect.h redirect.cc \
 	refresh.h refresh.cc RemovalPolicy.cc RemovalPolicy.h \
@@ -2821,29 +2831,30 @@
 	cf_parser.cci \
 	err_type.cc \
 	err_detail_type.cc \
 	globals.cc \
 	hier_code.cc \
 	icp_opcode.cc \
+	LogTags.cc \
 	lookup_t.cc \
 	repl_modules.cc \
 	swap_log_op.cc
 
 nodist_squid_SOURCES = \
 	$(DISKIO_GEN_SOURCE) \
 	$(BUILT_SOURCES)
 
 squid_LDADD = $(AUTH_ACL_LIBS) ident/libident.la acl/libacls.la \
-	eui/libeui.la acl/libstate.la $(AUTH_LIBS) $(DISK_LIBS) \
-	acl/libapi.la base/libbase.la libsquid.la ip/libip.la \
-	fs/libfs.la ipc/libipc.la mgr/libmgr.la anyp/libanyp.la \
-	comm/libcomm.la eui/libeui.la icmp/libicmp.la \
+	acl/libstate.la $(AUTH_LIBS) $(DISK_LIBS) acl/libapi.la \
+	base/libbase.la libsquid.la ip/libip.la fs/libfs.la \
+	ipc/libipc.la mgr/libmgr.la anyp/libanyp.la comm/libcomm.la \
+	eui/libeui.la http/libsquid-http.la icmp/libicmp.la \
 	icmp/libicmp-core.la log/liblog.la format/libformat.la \
 	$(XTRA_OBJS) $(DISK_LINKOBJS) $(REPL_OBJS) $(DISK_OS_LIBS) \
-	$(CRYPTLIB) $(REGEXLIB) $(ADAPTATION_LIBS) $(ESI_LIBS) \
-	$(SSL_LIBS) $(SNMP_LIBS) \
+	$(NETTLELIB) $(CRYPTLIB) $(REGEXLIB) $(ADAPTATION_LIBS) \
+	$(ESI_LIBS) $(SSL_LIBS) $(SNMP_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la $(SSLLIB) $(EPOLL_LIBS) \
 	$(MINGW_LIBS) $(KRB5LIBS) $(COMPAT_LIB) $(XTRA_LIBS) \
 	$(am__append_9)
 squid_DEPENDENCIES = \
@@ -2929,12 +2940,13 @@
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(XTRA_OBJS) \
 	$(REPL_OBJS) \
+	$(NETTLELIB) \
 	$(CRYPTLIB) \
 	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(EPOLL_LIBS) \
 	$(MINGW_LIBS) \
@@ -2990,13 +3002,15 @@
 
 STUB_SOURCE = tests/STUB.h \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
+	tests/stub_cbdata.cc \
 	tests/stub_client_db.cc \
+	tests/stub_client_side.cc \
 	tests/stub_client_side_request.cc \
 	tests/stub_comm.cc \
 	tests/stub_CommIO.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
 	tests/stub_DiskIOModule.cc \
@@ -3013,17 +3027,19 @@
 	tests/stub_internal.cc \
 	tests/stub_ipcache.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_ipc_TypedMsgHdr.cc \
 	tests/stub_libcomm.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_libmgr.cc \
 	tests/stub_libsslsquid.cc \
 	tests/stub_main_cc.cc \
+	tests/stub_MemBuf.cc \
 	tests/stub_mem.cc \
 	tests/stub_mem_node.cc \
 	tests/stub_MemObject.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_mime.cc \
 	tests/stub_pconn.cc \
@@ -3171,12 +3187,13 @@
 #tests_testX_DEPENDENCIES= $(SQUID_CPPUNIT_LA)
 
 # - add other component .(h|cc) files needed to link and run tests
 tests_testHttpReply_SOURCES = \
 	cbdata.cc \
 	cbdata.h \
+	ConfigParser.cc \
 	ETag.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
@@ -3198,15 +3215,12 @@
 	HttpHeaderTools.cc \
 	HttpControlMsg.h \
 	HttpMsg.cc \
 	HttpMsg.h \
 	HttpReply.cc \
 	HttpReply.h \
-	HttpStatusCode.h \
-	HttpStatusLine.cc \
-	HttpStatusLine.h \
 	Mem.h \
 	mem.cc \
 	RegexList.h \
 	RegexList.cc \
 	MemBuf.cc \
 	MemBuf.h \
@@ -3250,12 +3264,13 @@
 
 nodist_tests_testHttpReply_SOURCES = \
 	$(TESTSOURCES)
 
 tests_testHttpReply_LDFLAGS = $(LIBADD_DL)
 tests_testHttpReply_LDADD = \
+	http/libsquid-http.la \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	anyp/libanyp.la \
 	ip/libip.la \
@@ -3263,12 +3278,13 @@
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
+	$(NETTLELIB) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
 tests_testHttpReply_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 tests_testACLMaxUserIP_SOURCES = \
@@ -3301,12 +3317,16 @@
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpRequestMethod.cc \
 	int.h \
 	int.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
+	Notes.cc \
+	Notes.h \
 	SquidList.h \
 	SquidList.cc \
 	mem_node.cc \
 	Packer.cc \
 	Parsing.cc \
 	SquidMath.cc \
@@ -3336,12 +3356,13 @@
 	SwapDir.h \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
+	tests/stub_client_side.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_errorpage.cc \
 	fd.h \
 	tests/stub_fd.cc \
@@ -3382,12 +3403,13 @@
 	wordlist.cc
 
 nodist_tests_testACLMaxUserIP_SOURCES = \
 	$(TESTSOURCES)
 
 tests_testACLMaxUserIP_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
@@ -3399,12 +3421,13 @@
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_OS_LIBS) \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
@@ -3492,23 +3515,26 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	hier_code.h \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	$(HTCPSOURCE) \
 	HttpStateFlags.h \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
@@ -3523,34 +3549,38 @@
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -3627,24 +3657,25 @@
 nodist_tests_testCacheManager_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 
 # comm.cc only requires comm/libcomm.la until fdc_table is dead.
 tests_testCacheManager_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
 	comm/libcomm.la \
+	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
@@ -3655,12 +3686,13 @@
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -3709,17 +3741,18 @@
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
 	Mem.h \
 	mem.cc \
 	Packer.cc \
@@ -3774,12 +3807,13 @@
 	tests/stub_http.cc \
 	tests/stub_icp.cc \
 	internal.h \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
 	tests/stub_pconn.cc \
@@ -3809,19 +3843,19 @@
 	$(DISKIO_GEN_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 
 tests_testDiskIO_LDADD = \
+	http/libsquid-http.la \
 	SquidConfig.o \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	libsquid.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
 	ip/libip.la \
@@ -3835,12 +3869,13 @@
 	ipc/libipc.la \
 	base/libbase.la \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
@@ -3901,22 +3936,25 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
@@ -3937,36 +3975,40 @@
 	HttpParser.h \
 	HttpReply.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -4026,12 +4068,13 @@
 	tests/CapturingStoreEntry.h \
 	tests/testEvent.cc \
 	tests/testEvent.h \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
 	tools.cc \
 	tunnel.cc \
 	MemStore.cc \
@@ -4050,16 +4093,16 @@
 
 nodist_tests_testEvent_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 
 tests_testEvent_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -4078,12 +4121,13 @@
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -4145,22 +4189,25 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
@@ -4181,23 +4228,25 @@
 	HttpParser.h \
 	HttpReply.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
 	mime.h \
@@ -4205,12 +4254,14 @@
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -4270,12 +4321,13 @@
 	SwapDir.cc \
 	tests/testEventLoop.cc \
 	tests/testEventLoop.h \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
 	tools.cc \
 	tunnel.cc \
 	MemStore.cc \
@@ -4294,16 +4346,16 @@
 
 nodist_tests_testEventLoop_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 
 tests_testEventLoop_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -4322,12 +4374,13 @@
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -4387,22 +4440,25 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
@@ -4423,23 +4479,25 @@
 	HttpParser.h \
 	HttpReply.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
 	mime.h \
@@ -4447,12 +4505,14 @@
 	mime_header.h \
 	mime_header.cc \
 	multicast.h \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
 	peer_select.cc \
@@ -4508,12 +4568,13 @@
 	String.cc \
 	StrList.h \
 	StrList.cc \
 	SwapDir.cc \
 	tests/test_http_range.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
 	tools.cc \
@@ -4533,16 +4594,16 @@
 
 nodist_tests_test_http_range_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 
 tests_test_http_range_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -4561,12 +4622,13 @@
 	base/libbase.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -4602,12 +4664,13 @@
 	wordlist.cc
 
 nodist_tests_testHttpParser_SOURCES = \
 	$(TESTSOURCES)
 
 tests_testHttpParser_LDADD = \
+	http/libsquid-http.la \
 	SquidConfig.o \
 	base/libbase.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -4634,12 +4697,13 @@
 	tests/testHttpRequestMethod.h \
 	tests/testHttpRequestMethod.cc \
 	tests/testMain.cc \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
@@ -4680,22 +4744,25 @@
 	ExternalACLEntry.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
@@ -4710,34 +4777,38 @@
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -4815,13 +4886,12 @@
 	$(BUILT_SOURCES)
 
 tests_testHttpRequest_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -4831,20 +4901,22 @@
 	anyp/libanyp.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
+	http/libsquid-http.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(DISK_OS_LIBS) \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -4892,12 +4964,14 @@
 	RequestFlags.cc \
 	RequestFlags.h \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Packer.cc \
@@ -4946,12 +5020,13 @@
 	fd.h \
 	fde.h \
 	tests/stub_fd.cc \
 	tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	tests/stub_HttpReply.cc \
 	tests/stub_HttpRequest.cc \
 	tests/stub_libcomm.cc \
@@ -4990,16 +5065,16 @@
 	$(TESTSOURCES) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 
 tests_testStore_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -5008,12 +5083,13 @@
 	ipc/libipc.la \
 	anyp/libanyp.la \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	$(COMPAT_LIB) \
@@ -5065,13 +5141,12 @@
 SWAP_TEST_DS = \
 	repl_modules.o \
 	$(DISK_LIBS) \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -5087,12 +5162,13 @@
 	tests/testUfs.h \
 	tests/stub_cache_manager.cc \
 	tests/stub_client_db.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	tests/stub_UdsOp.cc \
 	internal.h \
 	tests/stub_internal.cc \
@@ -5111,19 +5187,20 @@
 	disk.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemObject.cc \
 	StoreSwapLogData.cc \
 	StoreIOState.cc \
 	StoreMeta.cc \
 	StoreMetaMD5.cc \
 	StoreMetaSTD.cc \
@@ -5216,18 +5293,18 @@
 	$(DISKIO_GEN_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
 	swap_log_op.cc
 
 tests_testUfs_LDADD = \
+	http/libsquid-http.la \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -5243,35 +5320,50 @@
 	anyp/libanyp.la \
 	base/libbase.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
 tests_testUfs_LDFLAGS = $(LIBADD_DL)
 tests_testUfs_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
+testRefCount_SOURCES = \
+	base/Lock.h \
+	base/RefCount.h \
+	tests/stub_cbdata.cc \
+	tests/stub_debug.cc \
+	tests/stub_MemBuf.cc \
+	tests/testRefCount.cc
+
+testRefCount_LDADD = \
+	base/libbase.la \
+	$(top_builddir)/lib/libmiscutil.la \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+
 tests_testRock_SOURCES = \
 	cbdata.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
 	ConfigOption.cc \
 	ConfigParser.cc \
 	disk.h \
 	disk.cc \
 	ETag.cc \
 	EventLoop.cc \
 	event.cc \
 	fatal.h \
-	tests/stub_fatal.cc \
+	fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.h \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
@@ -5288,17 +5380,18 @@
 	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpReply.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
 	Packer.cc \
@@ -5352,12 +5445,13 @@
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
 	tests/stub_HttpRequest.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_libmgr.cc \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
@@ -5383,12 +5477,13 @@
 	swap_log_op.cc \
 	SquidMath.cc \
 	SquidMath.h \
 	$(TESTSOURCES)
 
 tests_testRock_LDADD = \
+	http/libsquid-http.la \
 	libsquid.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(AUTH_LIBS) \
@@ -5396,19 +5491,19 @@
 	$(REPL_OBJS) \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
-	eui/libeui.la \
 	ipc/libipc.la \
 	base/libbase.la \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(REGEXLIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
@@ -5425,12 +5520,13 @@
 	tests/stub_client_db.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
 	internal.h \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_pconn.cc \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_stats.cc \
 	fatal.h \
 	tests/stub_fatal.cc \
@@ -5442,13 +5538,12 @@
 	disk.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpReply.cc \
-	HttpStatusLine.cc \
 	int.h \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
 	MemObject.cc \
 	StoreSwapLogData.cc \
@@ -5550,13 +5645,12 @@
 	anyp/libanyp.la \
 	libsquid.la \
 	$(REGEXLIB) \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
 	libsquid.la \
 	comm/libcomm.la \
 	ip/libip.la \
@@ -5580,158 +5674,12 @@
 	$(XTRA_LIBS)
 
 tests_testCoss_LDFLAGS = $(LIBADD_DL)
 tests_testCoss_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
-tests_testNull_SOURCES = \
-	tests/testNull.cc \
-	tests/testMain.cc \
-	tests/testNull.h \
-	internal.h \
-	tests/stub_internal.cc \
-	store_rebuild.h \
-	tests/stub_store_rebuild.cc \
-	tests/stub_store_stats.cc \
-	fd.h \
-	fd.cc \
-	disk.h \
-	disk.cc \
-	FileMap.h \
-	filemap.cc \
-	HttpBody.h \
-	HttpBody.cc \
-	HttpReply.cc \
-	HttpStatusLine.cc \
-	int.h \
-	int.cc \
-	SquidList.h \
-	SquidList.cc \
-	MemObject.cc \
-	StoreSwapLogData.cc \
-	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
-	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
-	StoreFileSystem.cc \
-	store_io.cc \
-	store_swapout.cc \
-	store_swapmeta.cc \
-	$(UNLINKDSOURCE) \
-	$(WIN32_SOURCE) \
-	event.cc \
-	$(DELAY_POOL_SOURCE) \
-	CacheDigest.h \
-	CacheDigest.cc \
-	ConfigParser.cc \
-	EventLoop.cc \
-	HttpMsg.cc \
-	RemovalPolicy.cc \
-	store_dir.cc \
-	repl_modules.h \
-	store.cc \
-	HttpRequestMethod.cc \
-	store_key_md5.h \
-	store_key_md5.cc \
-	Parsing.cc \
-	ConfigOption.cc \
-	SwapDir.cc \
-	tests/stub_acl.cc \
-	cache_cf.h \
-	YesNoNone.h \
-	tests/stub_cache_cf.cc \
-	tests/stub_helper.cc \
-	cbdata.cc \
-	String.cc \
-	tests/stub_comm.cc \
-	tests/stub_debug.cc \
-	tests/stub_client_side_request.cc \
-	tests/stub_http.cc \
-	mem_node.cc \
-	stmem.cc \
-	mime.h \
-	tests/stub_mime.cc \
-	HttpHeaderFieldInfo.h \
-	HttpHeaderTools.h \
-	HttpHeaderTools.cc \
-	HttpHeader.h \
-	HttpHeader.cc \
-	Mem.h \
-	mem.cc \
-	ClientInfo.h \
-	MemBuf.cc \
-	HttpHdrContRange.cc \
-	Packer.cc \
-	HttpHeaderFieldStat.h \
-	HttpHdrCc.h \
-	HttpHdrCc.cc \
-	HttpHdrCc.cci \
-	HttpHdrSc.cc \
-	HttpHdrScTarget.cc \
-	url.cc \
-	StatCounters.h \
-	StatCounters.cc \
-	StatHist.h \
-	tests/stub_StatHist.cc \
-	tests/stub_errorpage.cc \
-	tests/stub_HttpRequest.cc \
-	log/access_log.h \
-	tests/stub_access_log.cc \
-	refresh.h \
-	refresh.cc \
-	tests/stub_store_client.cc \
-	tests/stub_store_stats.cc \
-	tools.h \
-	tests/stub_tools.cc \
-	tests/testStoreSupport.cc \
-	tests/testStoreSupport.h \
-	time.cc \
-	URLScheme.cc \
-	wordlist.h \
-	wordlist.cc \
-	$(DISKIO_SOURCE)
-
-nodist_tests_testNull_SOURCES = \
-	$(TESTSOURCES) \
-	$(DISKIO_GEN_SOURCE)
-
-tests_testNull_LDADD = \
-	$(REGEXLIB) \
-	$(AUTH_ACL_LIBS) \
-	ident/libident.la \
-	acl/libacls.la \
-	eui/libeui.la \
-	acl/libstate.la \
-	$(AUTH_LIBS) \
-	acl/libapi.la \
-	base/libbase.la \
-	libsquid.la \
-	ip/libip.la \
-	fs/libfs.la \
-	ipc/libipc.la \
-	mgr/libmgr.la \
-	$(REPL_OBJS) \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
-	acl/libapi.la \
-	$(top_builddir)/lib/libmisccontainers.la \
-	$(top_builddir)/lib/libmiscencoding.la \
-	$(top_builddir)/lib/libmiscutil.la \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SSLLIB) \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-
-tests_testNull_LDFLAGS = $(LIBADD_DL)
-tests_testNull_DEPENDENCIES = \
-	$(SWAP_TEST_DS)
-
 tests_testURL_SOURCES = \
 	AccessLogEntry.cc \
 	$(ACL_REGISTRATION_SOURCES) \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
@@ -5777,22 +5725,25 @@
 	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
+	HelperReply.cc \
+	HelperReply.h \
 	hier_code.h \
 	$(HTCPSOURCE) \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
@@ -5813,36 +5764,40 @@
 	HttpParser.h \
 	HttpReply.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
-	HttpStatusLine.cc \
 	icp_v2.cc \
 	icp_v3.cc \
 	$(IPC_SOURCE) \
 	ipcache.cc \
 	int.h \
 	int.cc \
 	internal.h \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
 	mime.cc \
 	mime_header.h \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
 	peer_proxy_negotiate_auth.cc \
@@ -5928,12 +5883,13 @@
 	wordlist.cc
 
 nodist_tests_testURL_SOURCES = \
 	$(BUILT_SOURCES)
 
 tests_testURL_LDADD = \
+	http/libsquid-http.la \
 	anyp/libanyp.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
 	eui/libeui.la \
 	acl/libstate.la \
@@ -5956,12 +5912,13 @@
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(NETTLELIB) \
 	$(COMPAT_LIB) \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(COMPAT_LIB) \
@@ -6054,12 +6011,30 @@
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(COMPAT_LIB)
 
 tests_testStatHist_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
+tests_testVector_SOURCES = \
+	tests/testVector.cc \
+	tests/testMain.cc \
+	tests/testVector.h \
+	time.cc
+
+nodist_tests_testVector_SOURCES = \
+	$(TESTSOURCES)
+
+tests_testVector_LDADD = \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+
+tests_testVector_LDFLAGS = $(LIBADD_DL)
+tests_testVector_DEPENDENCIES = \
+	$(SQUID_CPPUNIT_LA)
+
 all: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/src/Common.am $(srcdir)/tests/Stub.list $(top_srcdir)/doc/manuals/Substitute.am $(am__configure_deps)
@@ -6441,21 +6416,33 @@
 tests/$(am__dirstamp):
 	@$(MKDIR_P) tests
 	@: > tests/$(am__dirstamp)
 tests/$(DEPDIR)/$(am__dirstamp):
 	@$(MKDIR_P) tests/$(DEPDIR)
 	@: > tests/$(DEPDIR)/$(am__dirstamp)
+tests/stub_cbdata.$(OBJEXT): tests/$(am__dirstamp) \
+	tests/$(DEPDIR)/$(am__dirstamp)
+tests/stub_debug.$(OBJEXT): tests/$(am__dirstamp) \
+	tests/$(DEPDIR)/$(am__dirstamp)
+tests/stub_MemBuf.$(OBJEXT): tests/$(am__dirstamp) \
+	tests/$(DEPDIR)/$(am__dirstamp)
+tests/testRefCount.$(OBJEXT): tests/$(am__dirstamp) \
+	tests/$(DEPDIR)/$(am__dirstamp)
+
+testRefCount$(EXEEXT): $(testRefCount_OBJECTS) $(testRefCount_DEPENDENCIES) $(EXTRA_testRefCount_DEPENDENCIES) 
+	@rm -f testRefCount$(EXEEXT)
+	$(AM_V_CXXLD)$(CXXLINK) $(testRefCount_OBJECTS) $(testRefCount_LDADD) $(LIBS)
 tests/stub_fatal.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_StatHist.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_access_log.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_cache_cf.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
-tests/stub_debug.$(OBJEXT): tests/$(am__dirstamp) \
+tests/stub_client_side.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_DelayId.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_DiskIOModule.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_errorpage.$(OBJEXT): tests/$(am__dirstamp) \
@@ -6535,12 +6522,14 @@
 tests/stub_client_db.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_internal.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_ipc.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
+tests/stub_libeui.$(OBJEXT): tests/$(am__dirstamp) \
+	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_acl.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_helper.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_client_side_request.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
@@ -6597,28 +6586,22 @@
 tests/testHttpRequestMethod.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 
 tests/testHttpRequest$(EXEEXT): $(tests_testHttpRequest_OBJECTS) $(tests_testHttpRequest_DEPENDENCIES) $(EXTRA_tests_testHttpRequest_DEPENDENCIES) tests/$(am__dirstamp)
 	@rm -f tests/testHttpRequest$(EXEEXT)
 	$(AM_V_CXXLD)$(tests_testHttpRequest_LINK) $(tests_testHttpRequest_OBJECTS) $(tests_testHttpRequest_LDADD) $(LIBS)
-tests/testNull.$(OBJEXT): tests/$(am__dirstamp) \
-	tests/$(DEPDIR)/$(am__dirstamp)
-tests/stub_comm.$(OBJEXT): tests/$(am__dirstamp) \
-	tests/$(DEPDIR)/$(am__dirstamp)
-
-tests/testNull$(EXEEXT): $(tests_testNull_OBJECTS) $(tests_testNull_DEPENDENCIES) $(EXTRA_tests_testNull_DEPENDENCIES) tests/$(am__dirstamp)
-	@rm -f tests/testNull$(EXEEXT)
-	$(AM_V_CXXLD)$(tests_testNull_LINK) $(tests_testNull_OBJECTS) $(tests_testNull_LDADD) $(LIBS)
 tests/testRock.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_libmgr.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 
 tests/testRock$(EXEEXT): $(tests_testRock_OBJECTS) $(tests_testRock_DEPENDENCIES) $(EXTRA_tests_testRock_DEPENDENCIES) tests/$(am__dirstamp)
 	@rm -f tests/testRock$(EXEEXT)
 	$(AM_V_CXXLD)$(tests_testRock_LINK) $(tests_testRock_OBJECTS) $(tests_testRock_LDADD) $(LIBS)
+tests/stub_comm.$(OBJEXT): tests/$(am__dirstamp) \
+	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_mem.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/stub_stmem.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 tests/testStatHist.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
@@ -6657,12 +6640,18 @@
 tests/testUfs.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 
 tests/testUfs$(EXEEXT): $(tests_testUfs_OBJECTS) $(tests_testUfs_DEPENDENCIES) $(EXTRA_tests_testUfs_DEPENDENCIES) tests/$(am__dirstamp)
 	@rm -f tests/testUfs$(EXEEXT)
 	$(AM_V_CXXLD)$(tests_testUfs_LINK) $(tests_testUfs_OBJECTS) $(tests_testUfs_LDADD) $(LIBS)
+tests/testVector.$(OBJEXT): tests/$(am__dirstamp) \
+	tests/$(DEPDIR)/$(am__dirstamp)
+
+tests/testVector$(EXEEXT): $(tests_testVector_OBJECTS) $(tests_testVector_DEPENDENCIES) $(EXTRA_tests_testVector_DEPENDENCIES) tests/$(am__dirstamp)
+	@rm -f tests/testVector$(EXEEXT)
+	$(AM_V_CXXLD)$(tests_testVector_LINK) $(tests_testVector_OBJECTS) $(tests_testVector_LDADD) $(LIBS)
 tests/test_http_range.$(OBJEXT): tests/$(am__dirstamp) \
 	tests/$(DEPDIR)/$(am__dirstamp)
 
 tests/test_http_range$(EXEEXT): $(tests_test_http_range_OBJECTS) $(tests_test_http_range_DEPENDENCIES) $(EXTRA_tests_test_http_range_DEPENDENCIES) tests/$(am__dirstamp)
 	@rm -f tests/test_http_range$(EXEEXT)
 	$(AM_V_CXXLD)$(tests_test_http_range_LINK) $(tests_test_http_range_OBJECTS) $(tests_test_http_range_LDADD) $(LIBS)
@@ -6715,13 +6704,15 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DescriptorSet.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DnsLookupDetails.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ETag.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/EventLoop.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ExternalACLEntry.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/FadingCounter.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/FwdState.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HelperChildConfig.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HelperReply.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpBody.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHdrCc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHdrContRange.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHdrRange.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHdrSc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHdrScTarget.Po@am__quote@
@@ -6729,20 +6720,22 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpHeaderTools.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpMsg.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpParser.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpReply.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpRequest.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpRequestMethod.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/HttpStatusLine.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LeakFinder.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LoadableModule.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LoadableModules.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/LogTags.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MasterXaction.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MemBlob.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MemBuf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MemObject.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/MemStore.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Notes.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/NullDelayId.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Packer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Parsing.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ProfStats.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/RegexList.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/RemovalPolicy.Po@am__quote@
@@ -6795,13 +6788,12 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/event.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/external_acl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fatal.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fd.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fde.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/filemap.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/forward.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fqdncache.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ftp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/globals.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gopher.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/helper.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hier_code.Po@am__quote@
@@ -6896,22 +6888,25 @@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/TestSwapDir.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_DelayId.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_DiskIOModule.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_HelperChildConfig.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_HttpReply.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_HttpRequest.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_MemBuf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_MemObject.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_MemStore.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_Port.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_StatHist.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_UdsOp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_access_log.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_acl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_cache_cf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_cache_manager.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_cbdata.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_client_db.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_client_side.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_client_side_request.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_comm.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_debug.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_errorpage.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_event.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_fatal.Po@am__quote@
@@ -6922,12 +6917,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_internal.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_ipc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_ipc_Forwarder.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_ipc_TypedMsgHdr.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_ipcache.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_libcomm.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_libeui.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_libformat.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_libicmp.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_libmgr.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_libsslsquid.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_main_cc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/stub_mem.Po@am__quote@
@@ -6950,24 +6946,25 @@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testEventLoop.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testHttpParser.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testHttpReply.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testHttpRequest.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testHttpRequestMethod.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testMain.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testNull.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testRefCount.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testRock.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testStatHist.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testStore.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testStoreController.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testStoreEntryStream.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testStoreHashIndex.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testStoreSupport.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testString.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testURL.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testURLScheme.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testUfs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/testVector.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@tests/$(DEPDIR)/test_http_range.Po@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	$(AM_V_CXX)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
 @am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
 @am__fastdepCXX_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
@@ -7426,12 +7423,19 @@
 	@p='tests/testStatHist$(EXEEXT)'; \
 	b='tests/testStatHist'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
 	"$$tst" $(AM_TESTS_FD_REDIRECT)
+tests/testVector.log: tests/testVector$(EXEEXT)
+	@p='tests/testVector$(EXEEXT)'; \
+	b='tests/testVector'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
 tests/testRock.log: tests/testRock$(EXEEXT)
 	@p='tests/testRock$(EXEEXT)'; \
 	b='tests/testRock'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
@@ -7440,12 +7444,19 @@
 	@p='tests/testUfs$(EXEEXT)'; \
 	b='tests/testUfs'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
 	"$$tst" $(AM_TESTS_FD_REDIRECT)
+testRefCount.log: testRefCount$(EXEEXT)
+	@p='testRefCount$(EXEEXT)'; \
+	b='testRefCount'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
 testHeaders.log: testHeaders
 	@p='testHeaders'; \
 	b='testHeaders'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
@@ -7692,13 +7703,13 @@
 $(OBJS): $(top_srcdir)/include/version.h $(top_builddir)/include/autoconf.h
 cf_gen.$(OBJEXT): cf_gen_defines.cci
 
 DiskIO/DiskIOModules_gen.cc: Makefile
 	$(SHELL) $(srcdir)/DiskIO/modules.sh $(DISK_MODULES) > DiskIO/DiskIOModules_gen.cc
 
-snmp_core.o snmp_agent.o: ../snmplib/libsnmplib.a $(top_srcdir)/include/cache_snmp.h
+snmp_core.o snmp_agent.o: ../snmplib/libsnmplib.la $(top_srcdir)/include/cache_snmp.h
 
 globals.cc: globals.h mk-globals-c.awk
 	$(AWK) -f $(srcdir)/mk-globals-c.awk < $(srcdir)/globals.h > $@ || ($(RM) -f $@ && exit 1)
 
 hier_code.cc: hier_code.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/hier_code.h > $@ || ($(RM) -f $@ && exit 1)
@@ -7706,12 +7717,15 @@
 err_type.cc: err_type.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/err_type.h > $@ || ($(RM) -f $@ && exit 1)
 
 err_detail_type.cc: err_detail_type.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/err_detail_type.h | sed 's/ERR_DETAIL_//' > $@ || ($(RM) -f $@ && exit 1)
 
+LogTags.cc: LogTags.h mk-string-arrays.awk
+	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/LogTags.h | sed 's/LOG_//' > $@ || ($(RM) -f $@ && exit 1)
+
 lookup_t.cc: lookup_t.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/lookup_t.h > $@ || ($(RM) -f $@ && exit 1)
 
 icp_opcode.cc: icp_opcode.h mk-string-arrays.awk
 	$(AWK) -f $(srcdir)/mk-string-arrays.awk < $(srcdir)/icp_opcode.h > $@ || ($(RM) -f $@ && exit 1)
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: MasterXaction.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: MasterXaction.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemBlob.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemBlob.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemBlob.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemBlob.cc	2015-05-01 18:05:19.000000000 +0800
@@ -138,9 +138,9 @@
 MemBlob::dump(std::ostream &os) const
 {
     os << "id @" << (void *)this
     << "mem:" << static_cast<void*>(mem)
     << ",capacity:" << capacity
     << ",size:" << size
-    << ",refs:" << RefCountCount() << "; ";
+    << ",refs:" << LockCount() << "; ";
     return os;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemBlob.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemBlob.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemBlob.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemBlob.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,14 +31,14 @@
 #ifndef SQUID_MEMBLOB_H_
 #define SQUID_MEMBLOB_H_
 
 #define MEMBLOB_DEBUGSECTION 24
 
 #include "base/InstanceId.h"
+#include "base/RefCount.h"
 #include "MemPool.h"
-#include "RefCount.h"
 
 /// Various MemBlob class-wide statistics.
 class MemBlobStats
 {
 public:
     MemBlobStats();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemBuf.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemBuf.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemBuf.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemBuf.cc	2015-05-01 18:05:19.000000000 +0800
@@ -134,12 +134,13 @@
     buf = NULL;
     size = 0;
     max_capacity = szMax;
     capacity = 0;
     stolen = 0;
     grow(szInit);
+    terminate();
 }
 
 /**
  * cleans the mb; last function to call if you do not give .buf away with
  * memBufFreeFunc
  */
@@ -217,12 +218,26 @@
 
         terminate();
     }
     PROF_stop(MemBuf_consume);
 }
 
+/// removes all whitespace prefix bytes and "packs" by moving content left
+void MemBuf::consumeWhitespacePrefix()
+{
+    PROF_start(MemBuf_consumeWhitespace);
+    if (contentSize() > 0) {
+        const char *end = buf + contentSize();
+        const char *p = buf;
+        for (; p<end && xisspace(*p); ++p);
+        if (p-buf > 0)
+            consume(p-buf);
+    }
+    PROF_stop(MemBuf_consumeWhitespace);
+}
+
 // removes last tailSize bytes
 void MemBuf::truncate(mb_size_t tailSize)
 {
     const mb_size_t cSize = contentSize();
     assert(0 <= tailSize && tailSize <= cSize);
     assert(!stolen); /* not frozen */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemBuf.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemBuf.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemBuf.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemBuf.h	2015-05-01 18:05:19.000000000 +0800
@@ -59,15 +59,20 @@
      * Whether the buffer contains any data.
      \retval true	if data exists in the buffer
      \retval false	if data exists in the buffer
      */
     bool hasContent() const { return size > 0; }
 
-    /// these space-related methods assume no growth and allow 0-termination
-    char *space() { return buf + size; } // space to add data
-    char *space(mb_size_t required) { if (size + required >= capacity) grow(size + required +1); return buf + size; } // space to add data
+    /// returns buffer after data; does not check space existence
+    char *space() { return buf + size; } ///< space to add data
+
+    /// Returns buffer following data, after possibly growing the buffer to
+    /// accommodate addition of the required bytes PLUS a 0-terminator char.
+    /// The caller is not required to terminate the buffer, but MemBuf does
+    /// terminate internally, trading termination for size calculation bugs.
+    char *space(mb_size_t required) { if (size + required >= capacity) grow(size + required + 1); return buf + size; }
 
     mb_size_t spaceSize() const;
 
     /**
      * Whether the buffer contains any data space available.
      \retval true	if data can be added to the buffer
@@ -78,12 +83,14 @@
     mb_size_t potentialSpaceSize() const; // accounts for possible growth
     bool hasPotentialSpace() const { return potentialSpaceSize() > 0; }
 
     /// \note there is currently no stretch() method to grow without appending
 
     void consume(mb_size_t sz);  // removes sz bytes, moving content left
+    void consumeWhitespacePrefix();    ///< removes all prefix whitespace, moving content left
+
     void append(const char *c, mb_size_t sz); // grows if needed and possible
     void appended(mb_size_t sz); // updates content size after external append
     void truncate(mb_size_t sz);  // removes sz last bytes
 
     void terminate(); // zero-terminates the buffer w/o increasing contentSize
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mem.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mem.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mem.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mem.cc	2015-05-01 18:05:19.000000000 +0800
@@ -33,12 +33,13 @@
 #include "squid.h"
 #include "acl/AclDenyInfoList.h"
 #include "acl/AclNameList.h"
 #include "CacheDigest.h"
 #include "ClientInfo.h"
 #include "disk.h"
+#include "dlink.h"
 #include "event.h"
 #include "md5.h"
 #include "Mem.h"
 #include "MemBuf.h"
 #include "memMeter.h"
 #include "mgr/Registration.h"
@@ -198,21 +199,21 @@
  * we have a limit on _total_ amount of idle memory so we ignore max_pages for now.
  * Will ignore repeated calls for the same pool type.
  *
  * Relies on Mem::Init() having been called beforehand.
  */
 void
-memDataInit(mem_type type, const char *name, size_t size, int max_pages_notused, bool zeroOnPush)
+memDataInit(mem_type type, const char *name, size_t size, int max_pages_notused, bool doZero)
 {
     assert(name && size);
 
     if (MemPools[type] != NULL)
         return;
 
     MemPools[type] = memPoolCreate(name, size);
-    MemPools[type]->zeroOnPush(zeroOnPush);
+    MemPools[type]->zeroBlocks(doZero);
 }
 
 /* find appropriate pool and use it (pools always init buffer with 0s) */
 void *
 memAllocate(mem_type type)
 {
@@ -474,13 +475,13 @@
     memDataInit(MEM_MD5_DIGEST, "MD5 digest", SQUID_MD5_DIGEST_LENGTH, 0);
     MemPools[MEM_MD5_DIGEST]->setChunkSize(512 * 1024);
 
     /** Lastly init the string pools. */
     for (i = 0; i < mem_str_pool_count; ++i) {
         StrPools[i].pool = memPoolCreate(StrPoolsAttrs[i].name, StrPoolsAttrs[i].obj_size);
-        StrPools[i].pool->zeroOnPush(false);
+        StrPools[i].pool->zeroBlocks(false);
 
         if (StrPools[i].pool->objectSize() != StrPoolsAttrs[i].obj_size)
             debugs(13, DBG_IMPORTANT, "Notice: " << StrPoolsAttrs[i].name << " is " << StrPools[i].pool->objectSize() << " bytes instead of requested " << StrPoolsAttrs[i].obj_size << " bytes");
     }
 
     MemIsInitialized = true;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Mem.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Mem.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Mem.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Mem.h	2015-05-01 18:05:19.000000000 +0800
@@ -72,11 +72,11 @@
 void *memReallocBuf(void *buf, size_t net_size, size_t * gross_size);
 void memFree(void *, int type);
 void memFreeString(size_t size, void *);
 void memFreeBuf(size_t size, void *);
 FREE *memFreeBufFunc(size_t size);
 int memInUse(mem_type);
-void memDataInit(mem_type, const char *, size_t, int, bool zeroOnPush = true);
+void memDataInit(mem_type, const char *, size_t, int, bool doZero = true);
 void memCheckInit(void);
 void memConfigure(void);
 
 #endif /* SQUID_MEM */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mem_node.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mem_node.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mem_node.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mem_node.cc	2015-05-01 18:05:19.000000000 +0800
@@ -57,18 +57,18 @@
  */
 void
 memNodeWriteComplete(void* d)
 {
     mem_node* n = (mem_node*)((char*)d - _mem_node_data_offset);
     assert(n->write_pending);
-    n->write_pending = 0;
+    n->write_pending = false;
 }
 
 mem_node::mem_node(int64_t offset) :
         nodeBuffer(0,offset,data),
-        write_pending(0)
+        write_pending(false)
 {
     *data = 0;
 }
 
 mem_node::~mem_node()
 {}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mem_node.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mem_node.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mem_node.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mem_node.h	2015-05-01 18:05:19.000000000 +0800
@@ -55,13 +55,13 @@
     bool canAccept (int64_t const &location) const;
     bool operator < (mem_node const & rhs) const;
     /* public */
     StoreIOBuffer nodeBuffer;
     /* Private */
     char data[SM_PAGE_SIZE];
-    unsigned int write_pending:1;
+    bool write_pending;
 };
 
 MEMPROXY_CLASS_INLINE(mem_node);
 
 inline std::ostream &
 operator << (std::ostream &os, mem_node &aNode)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemObject.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemObject.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/MemObject.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/MemObject.cc	2015-05-01 18:05:19.000000000 +0800
@@ -83,15 +83,15 @@
     url = xstrdup(aUrl);
 }
 
 MemObject::MemObject(char const *aUrl, char const *aLog_url)
 {
     debugs(20, 3, HERE << "new MemObject " << this);
-    HttpReply *rep = new HttpReply;
+    _reply = new HttpReply;
+    HTTPMSGLOCK(_reply);
 
-    _reply  = HTTPMSGLOCK(rep);
     url = xstrdup(aUrl);
 
 #if URL_CHECKSUM_DEBUG
 
     chksum = url_checksum(url);
 
@@ -192,13 +192,14 @@
 }
 
 void
 MemObject::replaceHttpReply(HttpReply *newrep)
 {
     HTTPMSGUNLOCK(_reply);
-    _reply = HTTPMSGLOCK(newrep);
+    _reply = newrep;
+    HTTPMSGLOCK(_reply);
 }
 
 struct LowestMemReader : public unary_function<store_client, void> {
     LowestMemReader(int64_t seed):current(seed) {}
 
     void operator() (store_client const &x) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/Action.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/Action.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/Action.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/Action.cc	2015-05-01 18:05:19.000000000 +0800
@@ -95,13 +95,13 @@
 {
     debugs(16, 5, HERE);
     entry->buffer();
 
     if (writeHttpHeader) {
         HttpReply *rep = new HttpReply;
-        rep->setHeaders(HTTP_OK, NULL, "text/plain", -1, squid_curtime, squid_curtime);
+        rep->setHeaders(Http::scOkay, NULL, "text/plain", -1, squid_curtime, squid_curtime);
         // Allow cachemgr and other XHR scripts access to our version string
         const ActionParams &params = command().params;
         if (params.httpOrigin.size() > 0) {
             rep->header.putExt("Access-Control-Allow-Origin", params.httpOrigin.termedBuf());
 #if HAVE_AUTH_MODULE_BASIC
             rep->header.putExt("Access-Control-Allow-Credentials","true");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/ActionParams.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/ActionParams.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/ActionParams.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/ActionParams.cc	2015-05-01 18:05:19.000000000 +0800
@@ -5,23 +5,23 @@
 
 #include "squid.h"
 #include "base/TextException.h"
 #include "ipc/TypedMsgHdr.h"
 #include "mgr/ActionParams.h"
 
-Mgr::ActionParams::ActionParams(): httpMethod(METHOD_NONE)
+Mgr::ActionParams::ActionParams(): httpMethod(Http::METHOD_NONE)
 {
 }
 
 Mgr::ActionParams::ActionParams(const Ipc::TypedMsgHdr &msg)
 {
     msg.getString(httpUri);
 
-    const int m = msg.getInt();
-    Must(METHOD_NONE <= m && m < METHOD_ENUM_END);
-    httpMethod = static_cast<_method_t>(m);
+    String method;
+    msg.getString(method);
+    httpMethod = HttpRequestMethod(method.termedBuf(), NULL);
 
     msg.getPod(httpFlags);
     msg.getString(httpOrigin);
 
     msg.getString(actionName);
     msg.getString(userName);
@@ -30,13 +30,14 @@
 }
 
 void
 Mgr::ActionParams::pack(Ipc::TypedMsgHdr &msg) const
 {
     msg.putString(httpUri);
-    msg.putInt(httpMethod);
+    String foo(httpMethod.image());
+    msg.putString(foo);
     msg.putPod(httpFlags);
     msg.putString(httpOrigin);
 
     msg.putString(actionName);
     msg.putString(userName);
     msg.putString(password);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/ActionParams.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/ActionParams.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/ActionParams.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/ActionParams.h	2015-05-01 18:05:19.000000000 +0800
@@ -23,13 +23,13 @@
     explicit ActionParams(const Ipc::TypedMsgHdr &msg); ///< load from msg
     void pack(Ipc::TypedMsgHdr &msg) const; ///< store into msg
 
 public:
     /* details of the client HTTP request that caused the action */
     String httpUri; ///< HTTP request URI
-    _method_t httpMethod; ///< HTTP request method
+    HttpRequestMethod httpMethod; ///< HTTP request method
     RequestFlags httpFlags; ///< HTTP request flags
     String httpOrigin;       ///< HTTP Origin: header (if any)
 
     /* action parameters extracted from the client HTTP request */
     String actionName; ///< action name (and credentials realm)
     String userName; ///< user login name; currently only used for logging
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/BasicActions.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/BasicActions.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/BasicActions.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/BasicActions.cc	2015-05-01 18:05:19.000000000 +0800
@@ -17,13 +17,13 @@
 Mgr::IndexAction::Pointer
 Mgr::IndexAction::Create(const Command::Pointer &cmd)
 {
     return new IndexAction(cmd);
 }
 
-Mgr::IndexAction::IndexAction(const Command::Pointer &cmd): Action(cmd)
+Mgr::IndexAction::IndexAction(const Command::Pointer &aCmd): Action(aCmd)
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::IndexAction::dump(StoreEntry* entry)
@@ -34,13 +34,13 @@
 Mgr::MenuAction::Pointer
 Mgr::MenuAction::Create(const Command::Pointer &cmd)
 {
     return new MenuAction(cmd);
 }
 
-Mgr::MenuAction::MenuAction(const Command::Pointer &cmd): Action(cmd)
+Mgr::MenuAction::MenuAction(const Command::Pointer &aCmd): Action(aCmd)
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::MenuAction::dump(StoreEntry* entry)
@@ -61,13 +61,13 @@
 Mgr::ShutdownAction::Pointer
 Mgr::ShutdownAction::Create(const Command::Pointer &cmd)
 {
     return new ShutdownAction(cmd);
 }
 
-Mgr::ShutdownAction::ShutdownAction(const Command::Pointer &cmd): Action(cmd)
+Mgr::ShutdownAction::ShutdownAction(const Command::Pointer &aCmd): Action(aCmd)
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::ShutdownAction::dump(StoreEntry* entry)
@@ -79,14 +79,14 @@
 Mgr::ReconfigureAction::Pointer
 Mgr::ReconfigureAction::Create(const Command::Pointer &cmd)
 {
     return new ReconfigureAction(cmd);
 }
 
-Mgr::ReconfigureAction::ReconfigureAction(const Command::Pointer &cmd):
-        Action(cmd)
+Mgr::ReconfigureAction::ReconfigureAction(const Command::Pointer &aCmd):
+        Action(aCmd)
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::ReconfigureAction::dump(StoreEntry* entry)
@@ -99,13 +99,13 @@
 Mgr::RotateAction::Pointer
 Mgr::RotateAction::Create(const Command::Pointer &cmd)
 {
     return new RotateAction(cmd);
 }
 
-Mgr::RotateAction::RotateAction(const Command::Pointer &cmd): Action(cmd)
+Mgr::RotateAction::RotateAction(const Command::Pointer &aCmd): Action(aCmd)
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::RotateAction::dump(StoreEntry* entry)
@@ -122,14 +122,14 @@
 Mgr::OfflineToggleAction::Pointer
 Mgr::OfflineToggleAction::Create(const Command::Pointer &cmd)
 {
     return new OfflineToggleAction(cmd);
 }
 
-Mgr::OfflineToggleAction::OfflineToggleAction(const Command::Pointer &cmd):
-        Action(cmd)
+Mgr::OfflineToggleAction::OfflineToggleAction(const Command::Pointer &aCmd):
+        Action(aCmd)
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::OfflineToggleAction::dump(StoreEntry* entry)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/CountersAction.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/CountersAction.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/CountersAction.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/CountersAction.cc	2015-05-01 18:05:19.000000000 +0800
@@ -87,14 +87,14 @@
 Mgr::CountersAction::Pointer
 Mgr::CountersAction::Create(const CommandPointer &cmd)
 {
     return new CountersAction(cmd);
 }
 
-Mgr::CountersAction::CountersAction(const CommandPointer &cmd):
-        Action(cmd), data()
+Mgr::CountersAction::CountersAction(const CommandPointer &aCmd):
+        Action(aCmd), data()
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::CountersAction::add(const Action& action)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/CountersAction.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/CountersAction.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/CountersAction.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/CountersAction.h	2015-05-01 18:05:19.000000000 +0800
@@ -4,13 +4,12 @@
  */
 
 #ifndef SQUID_MGR_COUNTERS_ACTION_H
 #define SQUID_MGR_COUNTERS_ACTION_H
 
 #include "mgr/Action.h"
-#include <sys/time.h>
 
 namespace Mgr
 {
 
 /// store traffic and resource counters
 class CountersActionData
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/Forwarder.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/Forwarder.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/Forwarder.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/Forwarder.cc	2015-05-01 18:05:19.000000000 +0800
@@ -66,28 +66,28 @@
 }
 
 void
 Mgr::Forwarder::handleError()
 {
     debugs(16, DBG_CRITICAL, "ERROR: uri " << entry->url() << " exceeds buffer size");
-    sendError(new ErrorState(ERR_INVALID_URL, HTTP_REQUEST_URI_TOO_LARGE, httpRequest));
+    sendError(new ErrorState(ERR_INVALID_URL, Http::scUriTooLong, httpRequest));
     mustStop("long URI");
 }
 
 void
 Mgr::Forwarder::handleTimeout()
 {
-    sendError(new ErrorState(ERR_LIFETIME_EXP, HTTP_REQUEST_TIMEOUT, httpRequest));
+    sendError(new ErrorState(ERR_LIFETIME_EXP, Http::scRequestTimeout, httpRequest));
     Ipc::Forwarder::handleTimeout();
 }
 
 void
 Mgr::Forwarder::handleException(const std::exception& e)
 {
     if (entry != NULL && httpRequest != NULL && Comm::IsConnOpen(conn))
-        sendError(new ErrorState(ERR_INVALID_RESP, HTTP_INTERNAL_SERVER_ERROR, httpRequest));
+        sendError(new ErrorState(ERR_INVALID_RESP, Http::scInternalServerError, httpRequest));
     Ipc::Forwarder::handleException(e);
 }
 
 /// called when the client socket gets closed by some external force
 void
 Mgr::Forwarder::noteCommClosed(const CommCloseCbParams& params)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/forward.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/forward.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/forward.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/forward.h	2015-05-01 18:05:19.000000000 +0800
@@ -3,13 +3,13 @@
  *
  */
 
 #ifndef SQUID_MGR_FORWARD_H
 #define SQUID_MGR_FORWARD_H
 
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 namespace Mgr
 {
 
 class Action;
 class ActionCreator;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/InfoAction.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/InfoAction.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/InfoAction.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/InfoAction.cc	2015-05-01 18:05:19.000000000 +0800
@@ -78,15 +78,12 @@
     if (stats.up_time > up_time)
         up_time = stats.up_time;
     cpu_time += stats.cpu_time;
     cpu_usage += stats.cpu_usage;
     cpu_usage5 += stats.cpu_usage5;
     cpu_usage60 += stats.cpu_usage60;
-#if HAVE_SBRK
-    proc_data_seg += stats.proc_data_seg;
-#endif
     maxrss += stats.maxrss;
     page_faults += stats.page_faults;
 #if HAVE_MSTATS && HAVE_GNUMALLOC_H
     ms_bytes_total += stats.ms_bytes_total;
     ms_bytes_free += stats.ms_bytes_free;
 #elif HAVE_MALLINFO && HAVE_STRUCT_MALLINFO
@@ -103,14 +100,14 @@
     mp_mxfast += stats.mp_mxfast;
     mp_nlblks += stats.mp_nlblks;
     mp_grain += stats.mp_grain;
     mp_uordbytes += stats.mp_uordbytes;
     mp_allocated += stats.mp_allocated;
     mp_treeoverhead += stats.mp_treeoverhead;
-#endif
-#endif
+#endif /* HAVE_STRUCT_MALLINFO_MXFAST */
+#endif /* HAVE_MALLINFO && HAVE_STRUCT_MALLINFO */
     total_accounted += stats.total_accounted;
 #if !(HAVE_MSTATS && HAVE_GNUMALLOC_H) && HAVE_MALLINFO && HAVE_STRUCT_MALLINFO
     mem_pool_allocated += stats.mem_pool_allocated;
 #endif
     gb_saved_count += stats.gb_saved_count;
     gb_freed_count += stats.gb_freed_count;
@@ -128,14 +125,14 @@
 Mgr::InfoAction::Pointer
 Mgr::InfoAction::Create(const CommandPointer &cmd)
 {
     return new InfoAction(cmd);
 }
 
-Mgr::InfoAction::InfoAction(const CommandPointer &cmd):
-        Action(cmd), data()
+Mgr::InfoAction::InfoAction(const CommandPointer &aCmd):
+        Action(aCmd), data()
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::InfoAction::add(const Action& action)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/InfoAction.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/InfoAction.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/InfoAction.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/InfoAction.h	2015-05-01 18:05:19.000000000 +0800
@@ -5,13 +5,12 @@
 
 #ifndef SQUID_MGR_INFO_ACTION_H
 #define SQUID_MGR_INFO_ACTION_H
 
 #include "mgr/Action.h"
 #include "StoreStats.h"
-#include <sys/time.h>
 
 namespace Mgr
 {
 
 /// store general runtime information
 /// and memory usage
@@ -66,15 +65,12 @@
     double icp_queries60;
     double up_time;
     double cpu_time;
     double cpu_usage;
     double cpu_usage5;
     double cpu_usage60;
-#if HAVE_SBRK
-    double proc_data_seg;
-#endif
     double maxrss;
     double page_faults;
 #if HAVE_MSTATS && HAVE_GNUMALLOC_H
     double ms_bytes_total;
     double ms_bytes_free;
 #elif HAVE_MALLINFO && HAVE_STRUCT_MALLINFO
@@ -91,14 +87,14 @@
     double mp_mxfast;
     double mp_nlblks;
     double mp_grain;
     double mp_uordbytes;
     double mp_allocated;
     double mp_treeoverhead;
-#endif
-#endif
+#endif /* HAVE_STRUCT_MALLINFO_MXFAST */
+#endif /* HAVE_MALLINFO && HAVE_STRUCT_MALLINFO */
     double total_accounted;
 #if !(HAVE_MSTATS && HAVE_GNUMALLOC_H) && HAVE_MALLINFO && HAVE_STRUCT_MALLINFO
     double mem_pool_allocated;
 #endif
     double gb_saved_count;
     double gb_freed_count;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/Inquirer.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/Inquirer.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/Inquirer.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/Inquirer.cc	2015-05-01 18:05:19.000000000 +0800
@@ -73,26 +73,26 @@
     std::auto_ptr<MemBuf> replyBuf;
 #endif
     if (strands.empty()) {
         LOCAL_ARRAY(char, url, MAX_URL);
         snprintf(url, MAX_URL, "%s", aggrAction->command().params.httpUri.termedBuf());
         HttpRequest *req = HttpRequest::CreateFromUrl(url);
-        ErrorState err(ERR_INVALID_URL, HTTP_NOT_FOUND, req);
+        ErrorState err(ERR_INVALID_URL, Http::scNotFound, req);
 #if HAVE_UNIQUE_PTR
         std::unique_ptr<HttpReply> reply(err.BuildHttpReply());
 #else
         std::auto_ptr<HttpReply> reply(err.BuildHttpReply());
 #endif
         replyBuf.reset(reply->pack());
     } else {
 #if HAVE_UNIQUE_PTR
         std::unique_ptr<HttpReply> reply(new HttpReply);
 #else
         std::auto_ptr<HttpReply> reply(new HttpReply);
 #endif
-        reply->setHeaders(HTTP_OK, NULL, "text/plain", -1, squid_curtime, squid_curtime);
+        reply->setHeaders(Http::scOkay, NULL, "text/plain", -1, squid_curtime, squid_curtime);
         reply->header.putStr(HDR_CONNECTION, "close"); // until we chunk response
         replyBuf.reset(reply->pack());
     }
     writer = asyncCall(16, 5, "Mgr::Inquirer::noteWroteHeader",
                        CommCbMemFunT<Inquirer, CommIoCbParams>(this, &Inquirer::noteWroteHeader));
     Comm::Write(conn, replyBuf.get(), writer);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/IntervalAction.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/IntervalAction.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/IntervalAction.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/IntervalAction.cc	2015-05-01 18:05:19.000000000 +0800
@@ -112,14 +112,14 @@
 Mgr::IntervalAction::Pointer
 Mgr::IntervalAction::Create60min(const CommandPointer &cmd)
 {
     return new IntervalAction(cmd, 60, 0);
 }
 
-Mgr::IntervalAction::IntervalAction(const CommandPointer &cmd, int aMinutes, int aHours):
-        Action(cmd), minutes(aMinutes), hours(aHours), data()
+Mgr::IntervalAction::IntervalAction(const CommandPointer &aCmd, int aMinutes, int aHours):
+        Action(aCmd), minutes(aMinutes), hours(aHours), data()
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::IntervalAction::add(const Action& action)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/IntervalAction.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/IntervalAction.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/IntervalAction.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/IntervalAction.h	2015-05-01 18:05:19.000000000 +0800
@@ -4,13 +4,12 @@
  */
 
 #ifndef SQUID_MGR_INTERVAL_ACTION_H
 #define SQUID_MGR_INTERVAL_ACTION_H
 
 #include "mgr/Action.h"
-#include <sys/time.h>
 
 namespace Mgr
 {
 
 /// auxiliary class which store stats computed
 /// from StatCounters for specified interval
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/IoAction.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/IoAction.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/IoAction.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/IoAction.cc	2015-05-01 18:05:19.000000000 +0800
@@ -40,14 +40,14 @@
 Mgr::IoAction::Pointer
 Mgr::IoAction::Create(const CommandPointer &cmd)
 {
     return new IoAction(cmd);
 }
 
-Mgr::IoAction::IoAction(const CommandPointer &cmd):
-        Action(cmd), data()
+Mgr::IoAction::IoAction(const CommandPointer &aCmd):
+        Action(aCmd), data()
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::IoAction::add(const Action& action)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/Makefile.in	2015-05-01 16:51:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/Makefile.in	2015-05-01 18:06:59.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -456,12 +502,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -499,12 +546,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -531,27 +579,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -618,13 +669,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libmgr.la
 libmgr_la_SOURCES = \
 	Action.cc \
 	ActionCreator.h \
 	Action.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/QueryParam.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/QueryParam.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/QueryParam.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/QueryParam.h	2015-05-01 18:05:19.000000000 +0800
@@ -3,14 +3,14 @@
  *
  */
 
 #ifndef SQUID_MGR_QUERY_PARAM_H
 #define SQUID_MGR_QUERY_PARAM_H
 
+#include "base/RefCount.h"
 #include "ipc/forward.h"
-#include "RefCount.h"
 
 namespace Mgr
 {
 
 class QueryParam: public RefCountable
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/ServiceTimesAction.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/ServiceTimesAction.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/ServiceTimesAction.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/ServiceTimesAction.cc	2015-05-01 18:05:19.000000000 +0800
@@ -52,14 +52,14 @@
 Mgr::ServiceTimesAction::Pointer
 Mgr::ServiceTimesAction::Create(const CommandPointer &cmd)
 {
     return new ServiceTimesAction(cmd);
 }
 
-Mgr::ServiceTimesAction::ServiceTimesAction(const CommandPointer &cmd):
-        Action(cmd), data()
+Mgr::ServiceTimesAction::ServiceTimesAction(const CommandPointer &aCmd):
+        Action(aCmd), data()
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::ServiceTimesAction::add(const Action& action)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/StoreIoAction.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/StoreIoAction.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mgr/StoreIoAction.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mgr/StoreIoAction.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,14 +30,14 @@
 Mgr::StoreIoAction::Pointer
 Mgr::StoreIoAction::Create(const CommandPointer &cmd)
 {
     return new StoreIoAction(cmd);
 }
 
-Mgr::StoreIoAction::StoreIoAction(const CommandPointer &cmd):
-        Action(cmd), data()
+Mgr::StoreIoAction::StoreIoAction(const CommandPointer &aCmd):
+        Action(aCmd), data()
 {
     debugs(16, 5, HERE);
 }
 
 void
 Mgr::StoreIoAction::add(const Action& action)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mib.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mib.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mib.txt	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mib.txt	2015-05-01 18:05:19.000000000 +0800
@@ -188,13 +188,13 @@
                 DESCRIPTION
                         " Page faults with physical i/o "
         ::= { cacheSysPerf 1 }
 
         cacheSysNumReads OBJECT-TYPE
                 SYNTAX Counter32
-                MAX-ACCESS not-accessible
+                MAX-ACCESS read-only
                 STATUS current
                 DESCRIPTION
                         " HTTP I/O number of reads "
        	::= { cacheSysPerf 2 }
 
 	cacheMemUsage OBJECT-TYPE
@@ -438,26 +438,26 @@
                 INDEX   { cacheMedianTime }
         ::= { cacheMedianSvcTable 1 }
 
         CacheMedianSvcEntry ::= SEQUENCE {
 		cacheMedianTime		Integer32,
 		cacheHttpAllSvcTime 	Integer32,
-		cacheHttpMissSvcTime 	Integer32,	
+		cacheHttpMissSvcTime 	Integer32,
 		cacheHttpNmSvcTime 	Integer32,
 		cacheHttpHitSvcTime 	Integer32,
 		cacheIcpQuerySvcTime 	Integer32,
 		cacheIcpReplySvcTime 	Integer32,
 		cacheDnsSvcTime		Integer32,
 		cacheRequestHitRatio	Integer32,
 		cacheRequestByteRatio	Integer32,
 		cacheHttpNhSvcTime	Integer32
 	}
 
 	cacheMedianTime OBJECT-TYPE
                 SYNTAX Integer32 (1|5|60)
-                MAX-ACCESS read-only
+                MAX-ACCESS not-accessible
                 STATUS current
 		DESCRIPTION
                         " The value used to index the table 1/5/60"
         ::= { cacheMedianSvcEntry 1 }
 
 	cacheHttpAllSvcTime OBJECT-TYPE
@@ -709,13 +709,13 @@
 	
 --
 -- cacheMesh group { squid 5 }
 --
 
 	cachePeerTable OBJECT-TYPE
-		SYNTAX SEQUENCE OF CachePeerEntry
+		SYNTAX SEQUENCE OF CachePeerTableEntry
 		MAX-ACCESS not-accessible
 		STATUS current
 		DESCRIPTION
 			" This table contains an enumeration of
 			  the peer caches, complete with info "
         ::= { cacheMesh 1 }
@@ -768,13 +768,13 @@
                network management system to the next
                re-initialization."
              SYNTAX       Integer32 (1..2147483647)
 
 
 	cachePeerIndex OBJECT-TYPE
-		SYNTAX CachePeerIndex
+		SYNTAX CachePeerTableIndex
 		MAX-ACCESS read-only
 		STATUS current
 		DESCRIPTION
 			   "A unique non-zero value identifying
 			     the particular cache Peer."
 	::= { cachePeerEntry 1 }
@@ -839,21 +839,21 @@
 		DESCRIPTION
 			" The port the peer listens for ICP requests
 			  should be 0 if not configured to send ICP requests "
         ::= { cachePeerEntry 6 }
 
 	cachePeerType OBJECT-TYPE
-                SYNTAX INTEGER
+                SYNTAX Integer32
                 MAX-ACCESS read-only
                 STATUS current
                 DESCRIPTION
                         " Peer Type "
 	::= { cachePeerEntry 7 }
 
 	cachePeerState OBJECT-TYPE
-                SYNTAX INTEGER
+                SYNTAX Integer32
                 MAX-ACCESS read-only
                 STATUS current
 		DESCRIPTION
 			" The operational state of this peer "
         ::= { cachePeerEntry 8 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mime.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mime.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mime.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mime.cc	2015-05-01 18:05:19.000000000 +0800
@@ -38,14 +37,14 @@
 #include "HttpHdrCc.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "internal.h"
 #include "Mem.h"
 #include "MemBuf.h"
-#include "mime.h"
 #include "MemObject.h"
+#include "mime.h"
 #include "RequestFlags.h"
 #include "SquidConfig.h"
 #include "Store.h"
 #include "StoreClient.h"
 
 #if HAVE_SYS_STAT_H
@@ -57,67 +56,57 @@
 /* forward declarations */
 static void mimeFreeMemory(void);
 static char const *mimeGetIcon(const char *fn);
 
 class MimeIcon : public StoreClient
 {
-
 public:
-    MimeIcon ();
-    ~MimeIcon ();
-    void setName (char const *);
-    char const * getName () const;
-    void _free();
+    explicit MimeIcon(const char *aName);
+    ~MimeIcon();
+    void setName(char const *);
+    char const * getName() const;
     void load();
-    void created (StoreEntry *newEntry);
+    void created(StoreEntry *newEntry);
+    MEMPROXY_CLASS(MimeIcon);
 
 private:
-    char *icon;
-    char *url;
+    const char *icon_;
+    char *url_;
 };
+MEMPROXY_CLASS_INLINE(MimeIcon);
 
-class mimeEntry
+class MimeEntry
 {
-
 public:
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
+    explicit MimeEntry(const char *aPattern, const regex_t &compiledPattern,
+                       const char *aContentType,
+                       const char *aContentEncoding, const char *aTransferMode,
+                       bool optionViewEnable, bool optionDownloadEnable,
+                       const char *anIconName);
+    ~MimeEntry();
+    MEMPROXY_CLASS(MimeEntry);
 
-    char *pattern;
+    const char *pattern;
     regex_t compiled_pattern;
-    char *icon;
-    char *content_type;
-    char *content_encoding;
+    const char *content_type;
+    const char *content_encoding;
     char transfer_mode;
-
-    unsigned int view_option:1;
-    unsigned int download_option:1;
-
-    mimeEntry *next;
+    bool view_option;
+    bool download_option;
     MimeIcon theIcon;
+    MimeEntry *next;
 };
+MEMPROXY_CLASS_INLINE(MimeEntry);
 
-static mimeEntry *MimeTable = NULL;
-static mimeEntry **MimeTableTail = &MimeTable;
-
-void *
-mimeEntry::operator new (size_t byteCount)
-{
-    return xcalloc(1, byteCount);
-}
+static MimeEntry *MimeTable = NULL;
+static MimeEntry **MimeTableTail = &MimeTable;
 
-void
-mimeEntry::operator delete (void *address)
-{
-    safe_free (address);
-}
-
-static mimeEntry *
+static MimeEntry *
 mimeGetEntry(const char *fn, int skip_encodings)
 {
-    mimeEntry *m;
+    MimeEntry *m;
     char *t;
     char *name = xstrdup(fn);
 
     do {
         t = NULL;
 
@@ -146,46 +135,43 @@
     } while (t);
 
     xfree(name);
     return m;
 }
 
-MimeIcon::MimeIcon () : icon (NULL), url (NULL)
-{}
-
-MimeIcon::~MimeIcon ()
+MimeIcon::MimeIcon(const char *aName) :
+        icon_(xstrdup(aName))
 {
-    _free();
+    url_ = xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_));
 }
 
-void
-MimeIcon::setName (char const *aString)
+MimeIcon::~MimeIcon()
 {
-    safe_free (icon);
-    safe_free (url);
-    icon = xstrdup (aString);
-    url = xstrdup (internalLocalUri("/squid-internal-static/icons/", icon));
+    xfree(icon_);
+    xfree(url_);
 }
 
-char const *
-MimeIcon::getName () const
+void
+MimeIcon::setName(char const *aString)
 {
-    return icon;
+    xfree(icon_);
+    xfree(url_);
+    icon_ = xstrdup(aString);
+    url_ = xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_));
 }
 
-void
-MimeIcon::_free()
+char const *
+MimeIcon::getName() const
 {
-    safe_free (icon);
-    safe_free (url);
+    return icon_;
 }
 
 char const *
 mimeGetIcon(const char *fn)
 {
-    mimeEntry *m = mimeGetEntry(fn, 1);
+    MimeEntry *m = mimeGetEntry(fn, 1);
 
     if (m == NULL)
         return NULL;
 
     if (!strcmp(m->theIcon.getName(), dash_str))
         return NULL;
@@ -208,30 +194,30 @@
         return mb.content();
     } else {
         return internalLocalUri("/squid-internal-static/icons/", icon);
     }
 }
 
-char *
+const char *
 mimeGetContentType(const char *fn)
 {
-    mimeEntry *m = mimeGetEntry(fn, 1);
+    MimeEntry *m = mimeGetEntry(fn, 1);
 
     if (m == NULL)
         return NULL;
 
     if (!strcmp(m->content_type, dash_str))
         return NULL;
 
     return m->content_type;
 }
 
-char *
+const char *
 mimeGetContentEncoding(const char *fn)
 {
-    mimeEntry *m = mimeGetEntry(fn, 0);
+    MimeEntry *m = mimeGetEntry(fn, 0);
 
     if (m == NULL)
         return NULL;
 
     if (!strcmp(m->content_encoding, dash_str))
         return NULL;
@@ -239,28 +225,28 @@
     return m->content_encoding;
 }
 
 char
 mimeGetTransferMode(const char *fn)
 {
-    mimeEntry *m = mimeGetEntry(fn, 0);
+    MimeEntry *m = mimeGetEntry(fn, 0);
     return m ? m->transfer_mode : 'I';
 }
 
-int
+bool
 mimeGetDownloadOption(const char *fn)
 {
-    mimeEntry *m = mimeGetEntry(fn, 1);
+    MimeEntry *m = mimeGetEntry(fn, 1);
     return m ? m->download_option : 0;
 }
 
-int
+bool
 mimeGetViewOption(const char *fn)
 {
-    mimeEntry *m = mimeGetEntry(fn, 0);
-    return m ? m->view_option : 0;
+    MimeEntry *m = mimeGetEntry(fn, 0);
+    return m != 0 ? m->view_option : false;
 }
 
 /* Initializes/reloads the mime table
  * Note: Due to Solaris STDIO problems the caller should NOT
  * call mimeFreeMemory on reconfigure. This way, if STDIO
  * fails we at least have the old copy loaded.
@@ -278,13 +264,13 @@
     char *encoding;
     char *mode;
     char *option;
     int view_option;
     int download_option;
     regex_t re;
-    mimeEntry *m;
+    MimeEntry *m;
     int re_flags = REG_EXTENDED | REG_NOSUB | REG_ICASE;
 
     if (filename == NULL)
         return;
 
     if ((fp = fopen(filename, "r")) == NULL) {
@@ -352,154 +338,137 @@
 
         if (regcomp(&re, pattern, re_flags) != 0) {
             debugs(25, DBG_IMPORTANT, "mimeInit: regcomp error: '" << buf << "'");
             continue;
         }
 
-        m = new mimeEntry;
-        m->pattern = xstrdup(pattern);
-        m->content_type = xstrdup(type);
-        m->theIcon.setName(icon);
-        m->content_encoding = xstrdup(encoding);
-        m->compiled_pattern = re;
-
-        if (!strcasecmp(mode, "ascii"))
-            m->transfer_mode = 'A';
-        else if (!strcasecmp(mode, "text"))
-            m->transfer_mode = 'A';
-        else
-            m->transfer_mode = 'I';
-
-        m->view_option = view_option;
-
-        m->download_option = download_option;
+        m = new MimeEntry(pattern,re,type,encoding,mode,view_option,
+                          download_option,icon);
 
         *MimeTableTail = m;
 
         MimeTableTail = &m->next;
 
         debugs(25, 5, "mimeInit: added '" << buf << "'");
     }
 
     fclose(fp);
-    /*
-     * Create Icon StoreEntry's
-     */
 
     for (m = MimeTable; m != NULL; m = m->next)
         m->theIcon.load();
-
-    debugs(25, DBG_IMPORTANT, "Loaded Icons.");
+    debugs(25, DBG_IMPORTANT, "Finished loading MIME types and icons.");
 }
 
 void
 mimeFreeMemory(void)
 {
-    mimeEntry *m;
+    MimeEntry *m;
 
     while ((m = MimeTable)) {
         MimeTable = m->next;
-        safe_free(m->pattern);
-        safe_free(m->content_type);
-        safe_free(m->icon);
-        safe_free(m->content_encoding);
-        regfree(&m->compiled_pattern);
         delete m;
     }
 
     MimeTableTail = &MimeTable;
 }
 
 void
 MimeIcon::load()
 {
-    const char *type = mimeGetContentType(icon);
+    const char *type = mimeGetContentType(icon_);
 
     if (type == NULL)
         fatal("Unknown icon format while reading mime.conf\n");
 
-    StoreEntry::getPublic(this, url, METHOD_GET);
+    StoreEntry::getPublic(this, url_, Http::METHOD_GET);
 }
 
 void
 MimeIcon::created (StoreEntry *newEntry)
 {
-    /* is already in the store, do nothing */
-
+    /* if the icon is already in the store, do nothing */
     if (!newEntry->isNull())
         return;
 
     int fd;
-
     int n;
-
     RequestFlags flags;
-
     struct stat sb;
-
     LOCAL_ARRAY(char, path, MAXPATHLEN);
-
     char *buf;
 
-    snprintf(path, MAXPATHLEN, "%s/%s", Config.icons.directory, icon);
+    snprintf(path, MAXPATHLEN, "%s/%s", Config.icons.directory, icon_);
 
     fd = file_open(path, O_RDONLY | O_BINARY);
-
     if (fd < 0) {
-        debugs(25, DBG_CRITICAL, "mimeLoadIconFile: " << path << ": " << xstrerror());
+        debugs(25, DBG_CRITICAL, "Problem opening icon file " << path << ": " << xstrerror());
         return;
     }
-
     if (fstat(fd, &sb) < 0) {
-        debugs(25, DBG_CRITICAL, "mimeLoadIconFile: FD " << fd << ": fstat: " << xstrerror());
+        debugs(25, DBG_CRITICAL, "Problem opening icon file. Fd: " << fd << ", fstat error " << xstrerror());
         file_close(fd);
         return;
     }
 
-    flags.cachable = 1;
-    StoreEntry *e = storeCreateEntry(url,
-                                     url,
-                                     flags,
-                                     METHOD_GET);
+    flags.cachable = true;
+    StoreEntry *e = storeCreateEntry(url_,url_,flags,Http::METHOD_GET);
     assert(e != NULL);
     EBIT_SET(e->flags, ENTRY_SPECIAL);
     e->setPublicKey();
     e->buffer();
-    HttpRequest *r = HttpRequest::CreateFromUrl(url);
+    HttpRequest *r = HttpRequest::CreateFromUrl(url_);
 
     if (NULL == r)
         fatal("mimeLoadIcon: cannot parse internal URL");
 
-    e->mem_obj->request = HTTPMSGLOCK(r);
+    e->mem_obj->request = r;
+    HTTPMSGLOCK(e->mem_obj->request);
 
     HttpReply *reply = new HttpReply;
 
-    reply->setHeaders(HTTP_OK, NULL, mimeGetContentType(icon), sb.st_size, sb.st_mtime, -1);
-
+    reply->setHeaders(Http::scOkay, NULL, mimeGetContentType(icon_), sb.st_size, sb.st_mtime, -1);
     reply->cache_control = new HttpHdrCc();
-
     reply->cache_control->maxAge(86400);
-
     reply->header.putCc(reply->cache_control);
-
     e->replaceHttpReply(reply);
 
     /* read the file into the buffer and append it to store */
     buf = (char *)memAllocate(MEM_4K_BUF);
-
     while ((n = FD_READ_METHOD(fd, buf, 4096)) > 0)
         e->append(buf, n);
 
     file_close(fd);
-
     e->flush();
-
     e->complete();
-
     e->timestampsSet();
-
-    debugs(25, 3, "Loaded icon " << url);
-
     e->unlock();
-
     memFree(buf, MEM_4K_BUF);
+    debugs(25, 3, "Loaded icon " << url_);
+}
+
+MimeEntry::~MimeEntry()
+{
+    xfree(pattern);
+    xfree(content_type);
+    xfree(content_encoding);
+    regfree(&compiled_pattern);
+}
+
+MimeEntry::MimeEntry(const char *aPattern, const regex_t &compiledPattern,
+                     const char *aContentType, const char *aContentEncoding,
+                     const char *aTransferMode, bool optionViewEnable,
+                     bool optionDownloadEnable, const char *anIconName) :
+        pattern(xstrdup(aPattern)),
+        compiled_pattern(compiledPattern),
+        content_type(xstrdup(aContentType)),
+        content_encoding(xstrdup(aContentEncoding)),
+        view_option(optionViewEnable),
+        download_option(optionViewEnable),
+        theIcon(anIconName), next(NULL)
+{
+    if (!strcasecmp(aTransferMode, "ascii"))
+        transfer_mode = 'A';
+    else if (!strcasecmp(aTransferMode, "text"))
+        transfer_mode = 'A';
+    else
+        transfer_mode = 'I';
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mime.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mime.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/mime.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/mime.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,14 +31,14 @@
  */
 
 #ifndef SQUID_MIME_H_
 #define SQUID_MIME_H_
 
 void mimeInit(char *filename);
-char *mimeGetContentEncoding(const char *fn);
-char *mimeGetContentType(const char *fn);
+const char *mimeGetContentEncoding(const char *fn);
+const char *mimeGetContentType(const char *fn);
 const char *mimeGetIconURL(const char *fn);
 char mimeGetTransferMode(const char *fn);
-int mimeGetDownloadOption(const char *fn);
-int mimeGetViewOption(const char *fn);
+bool mimeGetDownloadOption(const char *fn);
+bool mimeGetViewOption(const char *fn);
 
 #endif /* SQUID_MIME_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/multicast.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/multicast.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/multicast.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/multicast.cc	2015-05-01 18:05:19.000000000 +0800
@@ -64,18 +64,18 @@
         return;
     }
 
     for (i = 0; i < (int) ia->count; ++i) {
         debugs(7, 9, "Listening for ICP requests on " << ia->in_addrs[i] );
 
-        if ( ! ia->in_addrs[i].IsIPv4() ) {
+        if ( ! ia->in_addrs[i].isIPv4() ) {
             debugs(7, 9, "ERROR: IPv6 Multicast Listen has not been implemented!");
             continue;
         }
 
-        ia->in_addrs[i].GetInAddr(mr.imr_multiaddr);
+        ia->in_addrs[i].getInAddr(mr.imr_multiaddr);
 
         mr.imr_interface.s_addr = INADDR_ANY;
 
         if (setsockopt(icpIncomingConn->fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char *) &mr, sizeof(struct ip_mreq)) < 0)
             debugs(7, DBG_IMPORTANT, "ERROR: Join failed for " << icpIncomingConn << ", Multicast IP=" << ia->in_addrs[i]);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/neighbors.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/neighbors.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/neighbors.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/neighbors.cc	2015-05-01 18:05:19.000000000 +0800
@@ -36,13 +36,13 @@
 #include "CacheDigest.h"
 #include "CachePeer.h"
 #include "CachePeerDomainList.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "event.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "htcp.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
 #include "ICP.h"
 #include "int.h"
@@ -118,13 +118,13 @@
 
     CachePeer *p = NULL;
     debugs(15, 3, "whichPeer: from " << from);
 
     for (p = Config.peers; p; p = p->next) {
         for (j = 0; j < p->n_addresses; ++j) {
-            if (from == p->addresses[j] && from.GetPort() == p->icp.port) {
+            if (from == p->addresses[j] && from.port() == p->icp.port) {
                 return p;
             }
         }
     }
 
     return NULL;
@@ -178,13 +178,13 @@
         if (request->flags.needValidation)
             return false;
     }
 
     // CONNECT requests are proxy requests. Not to be forwarded to origin servers.
     // Unless the destination port matches, in which case we MAY perform a 'DIRECT' to this CachePeer.
-    if (p->options.originserver && request->method == METHOD_CONNECT && request->port != p->in_addr.GetPort())
+    if (p->options.originserver && request->method == Http::METHOD_CONNECT && request->port != p->in_addr.port())
         return false;
 
     if (p->peer_domain == NULL && p->access == NULL)
         return true;
 
     bool do_ping = false;
@@ -429,13 +429,13 @@
  */
 void
 peerClearRR()
 {
     CachePeer *p = NULL;
     for (p = Config.peers; p; p = p->next) {
-        p->rr_count = 0;
+        p->rr_count = 1;
     }
 }
 
 /**
  * Perform all actions when a CachePeer is detected revived.
  */
@@ -544,13 +544,13 @@
             next = thisPeer->next;
 
             if (0 != strcmp(thisPeer->host, me))
                 continue;
 
             for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
-                if (thisPeer->http_port != s->s.GetPort())
+                if (thisPeer->http_port != s->s.port())
                     continue;
 
                 debugs(15, DBG_IMPORTANT, "WARNING: Peer looks like this host");
 
                 debugs(15, DBG_IMPORTANT, "         Ignoring " <<
                        neighborTypeStr(thisPeer) << " " << thisPeer->host <<
@@ -920,25 +920,25 @@
     CachePeer *np;
 
     for (np = non_peers; np; np = np->next) {
         if (np->in_addr != from)
             continue;
 
-        if (np->in_addr.GetPort() != from.GetPort())
+        if (np->in_addr.port() != from.port())
             continue;
 
         break;
     }
 
     if (np == NULL) {
         np = (CachePeer *)xcalloc(1, sizeof(CachePeer));
         np->in_addr = from;
-        np->icp.port = from.GetPort();
+        np->icp.port = from.port();
         np->type = PEER_NONE;
         np->host = new char[MAX_IPSTRLEN];
-        from.NtoA(np->host,MAX_IPSTRLEN);
+        from.toStr(np->host,MAX_IPSTRLEN);
         np->next = non_peers;
         non_peers = np;
     }
 
     ++ np->icp.counts[opcode];
 
@@ -1218,21 +1218,21 @@
     for (j = 0; j < (int) ia->count && j < PEER_MAX_ADDRESSES; ++j) {
         p->addresses[j] = ia->in_addrs[j];
         debugs(15, 2, "--> IP address #" << j << ": " << p->addresses[j]);
         ++ p->n_addresses;
     }
 
-    p->in_addr.SetEmpty();
+    p->in_addr.setEmpty();
     p->in_addr = p->addresses[0];
-    p->in_addr.SetPort(p->icp.port);
+    p->in_addr.port(p->icp.port);
 
     if (p->type == PEER_MULTICAST)
         peerCountMcastPeersSchedule(p, 10);
 
 #if USE_ICMP
-    if (p->type != PEER_MULTICAST)
+    if (p->type != PEER_MULTICAST && IamWorkerProcess())
         if (!p->options.no_netdb_exchange)
             eventAddIsh("netdbExchangeStart", netdbExchangeStart, p, 30.0, 1);
 #endif
 
 }
 
@@ -1312,13 +1312,13 @@
         return ret;/* don't probe to often */
 
     /* for each IP address of this CachePeer. find one that we can connect to and probe it. */
     for (int i = 0; i < p->n_addresses; ++i) {
         Comm::ConnectionPointer conn = new Comm::Connection;
         conn->remote = p->addresses[i];
-        conn->remote.SetPort(p->http_port);
+        conn->remote.port(p->http_port);
         conn->setPeer(p);
         getOutgoingAddress(NULL, conn);
 
         ++ p->testing_now;
 
         AsyncCall::Pointer call = commCbCall(15,3, "peerProbeConnectDone", CommConnectCbPtrFun(peerProbeConnectDone, p));
@@ -1356,13 +1356,13 @@
 
     eventAdd("peerCountMcastPeersStart",
              peerCountMcastPeersStart,
              p,
              (double) when, 1);
 
-    p->mcast.flags.count_event_pending = 1;
+    p->mcast.flags.count_event_pending = true;
 }
 
 static void
 peerCountMcastPeersStart(void *data)
 {
     CachePeer *p = (CachePeer *)data;
@@ -1370,26 +1370,28 @@
     StoreEntry *fake;
     MemObject *mem;
     icp_common_t *query;
     int reqnum;
     LOCAL_ARRAY(char, url, MAX_URL);
     assert(p->type == PEER_MULTICAST);
-    p->mcast.flags.count_event_pending = 0;
+    p->mcast.flags.count_event_pending = false;
     snprintf(url, MAX_URL, "http://");
-    p->in_addr.ToURL(url+7, MAX_URL -8 );
+    p->in_addr.toUrl(url+7, MAX_URL -8 );
     strcat(url, "/");
-    fake = storeCreateEntry(url, url, RequestFlags(), METHOD_GET);
+    fake = storeCreateEntry(url, url, RequestFlags(), Http::METHOD_GET);
     HttpRequest *req = HttpRequest::CreateFromUrl(url);
     psstate = new ps_state;
-    psstate->request = HTTPMSGLOCK(req);
+    psstate->request = req;
+    HTTPMSGLOCK(psstate->request);
     psstate->entry = fake;
     psstate->callback = NULL;
     psstate->callback_data = cbdataReference(p);
     psstate->ping.start = current_time;
     mem = fake->mem_obj;
-    mem->request = HTTPMSGLOCK(psstate->request);
+    mem->request = psstate->request;
+    HTTPMSGLOCK(mem->request);
     mem->start_ping = current_time;
     mem->ping_reply_callback = peerCountHandleIcpReply;
     mem->ircb_data = psstate;
     mcastSetTtl(icpOutgoingConn->fd, p->mcast.ttl);
     p->mcast.id = mem->id;
     reqnum = icpSetCacheKey((const cache_key *)fake->key);
@@ -1397,25 +1399,25 @@
     icpUdpSend(icpOutgoingConn->fd, p->in_addr, query, LOG_ICP_QUERY, 0);
     fake->ping_status = PING_WAITING;
     eventAdd("peerCountMcastPeersDone",
              peerCountMcastPeersDone,
              psstate,
              Config.Timeout.mcast_icp_query / 1000.0, 1);
-    p->mcast.flags.counting = 1;
+    p->mcast.flags.counting = true;
     peerCountMcastPeersSchedule(p, MCAST_COUNT_RATE);
 }
 
 static void
 peerCountMcastPeersDone(void *data)
 {
     ps_state *psstate = (ps_state *)data;
     StoreEntry *fake = psstate->entry;
 
     if (cbdataReferenceValid(psstate->callback_data)) {
         CachePeer *p = (CachePeer *)psstate->callback_data;
-        p->mcast.flags.counting = 0;
+        p->mcast.flags.counting = false;
         p->mcast.avg_n_members = Math::doubleAverage(p->mcast.avg_n_members, (double) psstate->ping.n_recv, ++p->mcast.n_times_counted, 10);
         debugs(15, DBG_IMPORTANT, "Group " << p->host  << ": " << psstate->ping.n_recv  <<
                " replies, "<< std::setw(4)<< std::setprecision(2) <<
                p->mcast.avg_n_members <<" average, RTT " << p->stats.rtt);
         p->mcast.n_replies_expected = (int) p->mcast.avg_n_members;
     }
@@ -1603,13 +1605,13 @@
                           e->icp.port);
         storeAppendPrintf(sentry, "Flags      :");
         dump_peer_options(sentry, e);
 
         for (i = 0; i < e->n_addresses; ++i) {
             storeAppendPrintf(sentry, "Address[%d] : %s\n", i,
-                              e->addresses[i].NtoA(ntoabuf,MAX_IPSTRLEN) );
+                              e->addresses[i].toStr(ntoabuf,MAX_IPSTRLEN) );
         }
 
         storeAppendPrintf(sentry, "Status     : %s\n",
                           neighborUp(e) ? "Up" : "Down");
         storeAppendPrintf(sentry, "FETCHES    : %d\n", e->stats.fetches);
         storeAppendPrintf(sentry, "OPEN CONNS : %d\n", e->stats.conn_open);
@@ -1767,12 +1769,12 @@
         if (p->options.htcp_no_clr) {
             continue;
         }
         if (p->options.htcp_no_purge_clr && reason == HTCP_CLR_PURGE) {
             continue;
         }
-        debugs(15, 3, "neighborsHtcpClear: sending CLR to " << p->in_addr.ToURL(buf, 128));
+        debugs(15, 3, "neighborsHtcpClear: sending CLR to " << p->in_addr.toUrl(buf, 128));
         htcpClear(e, uri, req, method, p, reason);
     }
 }
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: Notes.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src: Notes.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/NullDelayId.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/NullDelayId.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/NullDelayId.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/NullDelayId.h	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,13 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 #ifndef NULLDELAYID_H
 #define NULLDELAYID_H
 
 #if USE_DELAY_POOLS
-#include "RefCount.h"
+#include "base/RefCount.h"
 #include "DelayIdComposite.h"
 
 class NullDelayId : public DelayIdComposite
 {
 
 public:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Parsing.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Parsing.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Parsing.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Parsing.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,12 +30,13 @@
  *
  */
 
 #include "squid.h"
 #include "cache_cf.h"
 #include "compat/strtoll.h"
+#include "ConfigParser.h"
 #include "Parsing.h"
 #include "globals.h"
 #include "Debug.h"
 
 /*
  * These functions is the same as atoi/l/f, except that they check for errors
@@ -158,13 +159,13 @@
  * This function is different from others (e.g., GetInteger64, GetShort)
  * because it supports octal and hexadecimal numbers
  */
 int
 GetInteger(void)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::strtokFile();
     int i;
 
     if (token == NULL)
         self_destruct();
 
     // The conversion must honor 0 and 0x prefixes, which are important for things like umask
@@ -298,17 +299,17 @@
     } else {
         host = token;
         port = 0;
     }
 
     if (NULL == host)
-        ipa->SetAnyAddr();
+        ipa->setAnyAddr();
     else if ( ipa->GetHostByName(host) ) /* dont use ipcache. Accept either FQDN or IPA. */
         (void) 0;
     else
         return false;
 
     /* port MUST be set after the IPA lookup/conversion is performed. */
-    ipa->SetPort(port);
+    ipa->port(port);
 
     return true;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/pconn.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/pconn.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/pconn.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/pconn.cc	2015-05-01 18:05:19.000000000 +0800
@@ -251,22 +251,22 @@
 Comm::ConnectionPointer
 IdleConnList::findUseable(const Comm::ConnectionPointer &key)
 {
     assert(size_);
 
     // small optimization: do the constant bool tests only once.
-    const bool keyCheckAddr = !key->local.IsAnyAddr();
-    const bool keyCheckPort = key->local.GetPort() > 0;
+    const bool keyCheckAddr = !key->local.isAnyAddr();
+    const bool keyCheckPort = key->local.port() > 0;
 
     for (int i=size_-1; i>=0; --i) {
 
         if (!isAvailable(i))
             continue;
 
         // local end port is required, but dont match.
-        if (keyCheckPort && key->local.GetPort() != theList_[i]->local.GetPort())
+        if (keyCheckPort && key->local.port() != theList_[i]->local.port())
             continue;
 
         // local address is required, but does not match.
         if (keyCheckAddr && key->local.matchIPAddr(theList_[i]->local) != 0)
             continue;
 
@@ -328,13 +328,13 @@
 
 const char *
 PconnPool::key(const Comm::ConnectionPointer &destLink, const char *domain)
 {
     LOCAL_ARRAY(char, buf, SQUIDHOSTNAMELEN * 3 + 10);
 
-    destLink->remote.ToURL(buf, SQUIDHOSTNAMELEN * 3 + 10);
+    destLink->remote.toUrl(buf, SQUIDHOSTNAMELEN * 3 + 10);
     if (domain) {
         const int used = strlen(buf);
         snprintf(buf+used, SQUIDHOSTNAMELEN * 3 + 10-used, "/%s", domain);
     }
 
     debugs(48,6,"PconnPool::key(" << destLink << ", " << (domain?domain:"[no domain]") << ") is {" << buf << "}" );
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/peer_digest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/peer_digest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/peer_digest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/peer_digest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -33,13 +33,13 @@
 
 #include "squid.h"
 #if USE_CACHE_DIGESTS
 #include "CacheDigest.h"
 #include "CachePeer.h"
 #include "event.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "internal.h"
 #include "MemObject.h"
 #include "neighbors.h"
@@ -118,27 +118,12 @@
 
     pd->host.clean();
 }
 
 CBDATA_CLASS_INIT(PeerDigest);
 
-void *
-PeerDigest::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(PeerDigest);
-    PeerDigest *result = cbdataAlloc(PeerDigest);
-    return result;
-}
-
-void
-PeerDigest::operator delete (void *address)
-{
-    PeerDigest *t = static_cast<PeerDigest *>(address);
-    cbdataFree(t);
-}
-
 /* allocate new peer digest, call Init, and lock everything */
 PeerDigest *
 peerDigestCreate(CachePeer * p)
 {
     PeerDigest *pd;
     assert(p);
@@ -177,13 +162,13 @@
 peerDigestNeeded(PeerDigest * pd)
 {
     assert(pd);
     assert(!pd->flags.needed);
     assert(!pd->cd);
 
-    pd->flags.needed = 1;
+    pd->flags.needed = true;
     pd->times.needed = squid_curtime;
     peerDigestSetCheck(pd, 0);	/* check asap */
 }
 
 /* currently we do not have a reason to disable without destroying */
 #if FUTURE_CODE
@@ -312,28 +297,27 @@
 /* ask store for a digest */
 static void
 peerDigestRequest(PeerDigest * pd)
 {
     CachePeer *p = pd->peer;
     StoreEntry *e, *old_e;
-    char *url;
+    char *url = NULL;
     const cache_key *key;
     HttpRequest *req;
     DigestFetchState *fetch = NULL;
     StoreIOBuffer tempBuffer;
 
     pd->req_result = NULL;
-    pd->flags.requested = 1;
+    pd->flags.requested = true;
 
     /* compute future request components */
 
     if (p->digest_url)
         url = xstrdup(p->digest_url);
     else
-        url = internalRemoteUri(p->host, p->http_port,
-                                "/squid-internal-periodic/", StoreDigestFileName);
+        url = xstrdup(internalRemoteUri(p->host, p->http_port, "/squid-internal-periodic/", StoreDigestFileName));
 
     req = HttpRequest::CreateFromUrl(url);
 
     assert(req);
 
     key = storeKeyPublicByRequest(req);
@@ -357,13 +341,14 @@
     }
     /* create fetch state structure */
     CBDATA_INIT_TYPE(DigestFetchState);
 
     fetch = cbdataAlloc(DigestFetchState);
 
-    fetch->request = HTTPMSGLOCK(req);
+    fetch->request = req;
+    HTTPMSGLOCK(fetch->request);
 
     fetch->pd = cbdataReference(pd);
 
     fetch->offset = 0;
 
     fetch->state = DIGEST_READ_REPLY;
@@ -372,16 +357,16 @@
     fetch->start_time = squid_curtime;
 
     pd->times.requested = squid_curtime;
 
     pd_last_req_time = squid_curtime;
 
-    req->flags.cachable = 1;
+    req->flags.cachable = true;
 
     /* the rest is based on clientProcessExpired() */
-    req->flags.refresh = 1;
+    req->flags.refresh = true;
 
     old_e = fetch->old_entry = Store::Root().get(key);
 
     if (old_e) {
         debugs(72, 5, "peerDigestRequest: found old entry");
 
@@ -409,12 +394,14 @@
     tempBuffer.length = SM_PAGE_SIZE;
 
     tempBuffer.data = fetch->buf;
 
     storeClientCopy(fetch->sc, e, tempBuffer,
                     peerDigestHandleReply, fetch);
+
+    safe_free(url);
 }
 
 /* Handle the data copying .. */
 
 /*
  * This routine handles the copy data and then redirects the
@@ -542,31 +529,30 @@
     assert(fetch->state == DIGEST_READ_REPLY);
 
     if (peerDigestFetchedEnough(fetch, buf, size, "peerDigestFetchReply"))
         return -1;
 
     if ((hdr_size = headersEnd(buf, size))) {
-        http_status status;
         HttpReply const *reply = fetch->entry->getReply();
         assert(reply);
-        assert (reply->sline.status != 0);
-        status = reply->sline.status;
+        assert(reply->sline.status() != Http::scNone);
+        const Http::StatusCode status = reply->sline.status();
         debugs(72, 3, "peerDigestFetchReply: " << pd->host << " status: " << status <<
                ", expires: " << (long int) reply->expires << " (" << std::showpos <<
                (int) (reply->expires - squid_curtime) << ")");
 
         /* this "if" is based on clientHandleIMSReply() */
 
-        if (status == HTTP_NOT_MODIFIED) {
-            HttpRequest *r = NULL;
+        if (status == Http::scNotModified) {
             /* our old entry is fine */
             assert(fetch->old_entry);
 
-            if (!fetch->old_entry->mem_obj->request)
-                fetch->old_entry->mem_obj->request = r =
-                                                         HTTPMSGLOCK(fetch->entry->mem_obj->request);
+            if (!fetch->old_entry->mem_obj->request) {
+                fetch->old_entry->mem_obj->request = fetch->entry->mem_obj->request;
+                HTTPMSGLOCK(fetch->old_entry->mem_obj->request);
+            }
 
             assert(fetch->old_entry->mem_obj->request);
 
             HttpReply *old_rep = (HttpReply *) fetch->old_entry->getReply();
 
             old_rep->updateOnNotModified(reply);
@@ -582,31 +568,31 @@
 
             fetch->old_entry = NULL;
 
             /* preserve request -- we need its size to update counters */
             /* requestUnlink(r); */
             /* fetch->entry->mem_obj->request = NULL; */
-        } else if (status == HTTP_OK) {
+        } else if (status == Http::scOkay) {
             /* get rid of old entry if any */
 
             if (fetch->old_entry) {
                 debugs(72, 3, "peerDigestFetchReply: got new digest, releasing old one");
                 storeUnregister(fetch->old_sc, fetch->old_entry, fetch);
                 fetch->old_entry->releaseRequest();
                 fetch->old_entry->unlock();
                 fetch->old_entry = NULL;
             }
         } else {
             /* some kind of a bug */
-            peerDigestFetchAbort(fetch, buf, httpStatusLineReason(&reply->sline));
+            peerDigestFetchAbort(fetch, buf, reply->sline.reason());
             return -1;		/* XXX -1 will abort stuff in ReadReply! */
         }
 
         /* must have a ready-to-use store entry if we got here */
         /* can we stay with the old in-memory digest? */
-        if (status == HTTP_NOT_MODIFIED && fetch->pd->cd) {
+        if (status == Http::scNotModified && fetch->pd->cd) {
             peerDigestFetchStop(fetch, buf, "Not modified");
             fetch->state = DIGEST_READ_DONE;
         } else {
             fetch->state = DIGEST_READ_HEADERS;
         }
     } else {
@@ -634,17 +620,17 @@
         return -1;
 
     assert(!fetch->offset);
 
     if ((hdr_size = headersEnd(buf, size))) {
         assert(fetch->entry->getReply());
-        assert (fetch->entry->getReply()->sline.status != 0);
+        assert(fetch->entry->getReply()->sline.status() != Http::scNone);
 
-        if (fetch->entry->getReply()->sline.status != HTTP_OK) {
+        if (fetch->entry->getReply()->sline.status() != Http::scOkay) {
             debugs(72, DBG_IMPORTANT, "peerDigestSwapInHeaders: " << fetch->pd->host <<
-                   " status " << fetch->entry->getReply()->sline.status <<
+                   " status " << fetch->entry->getReply()->sline.status() <<
                    " got cached!");
 
             peerDigestFetchAbort(fetch, buf, "internal status error");
             return -1;
         }
 
@@ -840,13 +826,13 @@
 {
     assert(reason);
 
     /* must go before peerDigestPDFinish */
 
     if (pdcb_valid) {
-        fetch->pd->flags.requested = 0;
+        fetch->pd->flags.requested = false;
         fetch->pd->req_result = reason;
     }
 
     /* schedule next check if peer is still out there */
     if (pcb_valid) {
         PeerDigest *pd = fetch->pd;
@@ -891,20 +877,20 @@
 
         if (pd->cd) {
             cacheDigestDestroy(pd->cd);
             pd->cd = NULL;
         }
 
-        pd->flags.usable = 0;
+        pd->flags.usable = false;
 
         if (!pcb_valid)
             peerDigestNotePeerGone(pd);
     } else {
         assert(pcb_valid);
 
-        pd->flags.usable = 1;
+        pd->flags.usable = true;
 
         /* XXX: ugly condition, but how? */
 
         if (fetch->entry->store_status == STORE_OK)
             debugs(72, 2, "re-used old digest from " << host);
         else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/PeerDigest.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/PeerDigest.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/PeerDigest.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/PeerDigest.h	2015-05-01 18:05:19.000000000 +0800
@@ -92,24 +92,21 @@
 };
 
 class PeerDigest
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete(void *);
-
     CachePeer *peer;          /**< pointer back to peer structure, argh */
     CacheDigest *cd;            /**< actual digest structure */
     String host;                /**< copy of peer->host */
     const char *req_result;     /**< text status of the last request */
 
     struct {
-        unsigned int needed:1;          /**< there were requests for this digest */
-        unsigned int usable:1;          /**< can be used for lookups */
-        unsigned int requested:1;       /**< in process of receiving [fresh] digest */
+        bool needed;          /**< there were requests for this digest */
+        bool usable;          /**< can be used for lookups */
+        bool requested;       /**< in process of receiving [fresh] digest */
     } flags;
 
     struct {
         /* all times are absolute unless augmented with _delay */
         time_t initialized;	/* creation */
         time_t needed;		/* first lookup/use by a peer */
@@ -129,13 +126,13 @@
             int msgs;
             kb_t kbytes;
         } sent, recv;
     } stats;
 
 private:
-    CBDATA_CLASS(PeerDigest);
+    CBDATA_CLASS2(PeerDigest);
 };
 
 extern const Version CacheDigestVer;
 
 PeerDigest *peerDigestCreate(CachePeer * p);
 void peerDigestNeeded(PeerDigest * pd);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/peer_proxy_negotiate_auth.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/peer_proxy_negotiate_auth.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/peer_proxy_negotiate_auth.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/peer_proxy_negotiate_auth.cc	2015-05-01 18:05:19.000000000 +0800
@@ -207,39 +207,47 @@
 
         static char *keytab_filename = NULL, *principal_name = NULL;
         static krb5_keytab keytab = 0;
         static krb5_keytab_entry entry;
         static krb5_kt_cursor cursor;
         static krb5_creds *creds = NULL;
-#if HAVE_HEIMDAL_KERBEROS
+#if HAVE_HEIMDAL_KERBEROS && !HAVE_KRB5_GET_RENEWED_CREDS
         static krb5_creds creds2;
 #endif
         static krb5_principal principal = NULL;
         static krb5_deltat skew;
 
+#if HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC
+        krb5_get_init_creds_opt *options;
+#else
         krb5_get_init_creds_opt options;
+#endif
         krb5_error_code code = 0;
         krb5_deltat rlife;
 #if HAVE_PROFILE_H && HAVE_KRB5_GET_PROFILE && HAVE_PROFILE_GET_INTEGER && HAVE_PROFILE_RELEASE
         profile_t profile;
 #endif
-#if HAVE_HEIMDAL_KERBEROS
+#if HAVE_HEIMDAL_KERBEROS && !HAVE_KRB5_GET_RENEWED_CREDS
         krb5_kdc_flags flags;
-        krb5_realm *client_realm;
+#if HAVE_KRB5_PRINCIPAL_GET_REALM
+        const char *client_realm;
+#else
+        krb5_realm client_realm;
+#endif
 #endif
         char *mem_cache;
 
 restart:
         /*
          * Check if credentials need to be renewed
          */
         if (creds &&
                 (creds->times.endtime - time(0) > skew) &&
                 (creds->times.renew_till - time(0) > 2 * skew)) {
             if (creds->times.endtime - time(0) < 2 * skew) {
-#if !HAVE_HEIMDAL_KERBEROS
+#if HAVE_KRB5_GET_RENEWED_CREDS
                 /* renew ticket */
                 code =
                     krb5_get_renewed_creds(kparam.context, creds, principal,
                                            kparam.cc, NULL);
 #else
                 /* renew ticket */
@@ -253,16 +261,21 @@
                     debugs(11, 5,
                            HERE <<
                            "Error while getting principal from credential cache : "
                            << error_message(code));
                     return (1);
                 }
+#if HAVE_KRB5_PRINCIPAL_GET_REALM
+                client_realm = krb5_principal_get_realm(kparam.context, principal);
+#else
                 client_realm = krb5_princ_realm(kparam.context, creds2.client);
+#endif
                 code =
                     krb5_make_principal(kparam.context, &creds2.server,
-                                        *client_realm, KRB5_TGS_NAME, *client_realm, NULL);
+                                        (krb5_const_realm)&client_realm, KRB5_TGS_NAME,
+                                        (krb5_const_realm)&client_realm, NULL);
                 if (code) {
                     debugs(11, 5,
                            HERE << "Error while getting krbtgt principal : " <<
                            error_message(code));
                     return (1);
                 }
@@ -397,25 +410,40 @@
                     return (1);
                 }
             }
 
             creds = (krb5_creds *) xmalloc(sizeof(*creds));
             memset(creds, 0, sizeof(*creds));
+#if HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC
+            krb5_get_init_creds_opt_alloc(kparam.context, &options);
+#else
             krb5_get_init_creds_opt_init(&options);
+#endif
             code = krb5_string_to_deltat((char *) MAX_RENEW_TIME, &rlife);
             if (code != 0 || rlife == 0) {
                 debugs(11, 5,
                        HERE << "Error bad lifetime value " << MAX_RENEW_TIME <<
                        " : " << error_message(code));
                 return (1);
             }
+#if HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC
+            krb5_get_init_creds_opt_set_renew_life(options, rlife);
+            code =
+                krb5_get_init_creds_keytab(kparam.context, creds, principal,
+                                           keytab, 0, NULL, options);
+#if HAVE_KRB5_GET_INIT_CREDS_FREE_CONTEXT
+            krb5_get_init_creds_opt_free(kparam.context, options);
+#else
+            krb5_get_init_creds_opt_free(options);
+#endif
+#else
             krb5_get_init_creds_opt_set_renew_life(&options, rlife);
-
             code =
                 krb5_get_init_creds_keytab(kparam.context, creds, principal,
                                            keytab, 0, NULL, &options);
+#endif
             if (code) {
                 debugs(11, 5,
                        HERE <<
                        "Error while initializing credentials from keytab : " <<
                        error_message(code));
                 return (1);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/peer_select.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/peer_select.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/peer_select.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/peer_select.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,13 @@
 #include "CachePeer.h"
 #include "carp.h"
 #include "client_side.h"
 #include "DnsLookupDetails.h"
 #include "errorpage.h"
 #include "event.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "hier_code.h"
 #include "htcp.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
 #include "ICP.h"
@@ -68,13 +68,12 @@
     "DIRECT_YES"
 };
 
 static void peerSelectFoo(ps_state *);
 static void peerPingTimeout(void *data);
 static IRCB peerHandlePingReply;
-static void peerSelectStateFree(ps_state * psstate);
 static void peerIcpParentMiss(CachePeer *, icp_common_t *, ps_state *);
 #if USE_HTCP
 static void peerHtcpParentMiss(CachePeer *, HtcpReplyData *, ps_state *);
 static void peerHandleHtcpReply(CachePeer *, peer_t, HtcpReplyData *, void *);
 #endif
 static int peerCheckNetdbDirect(ps_state * psstate);
@@ -86,50 +85,47 @@
 static void peerAddFwdServer(FwdServer **, CachePeer *, hier_code);
 static void peerSelectPinned(ps_state * ps);
 static void peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, void *data);
 
 CBDATA_CLASS_INIT(ps_state);
 
-static void
-peerSelectStateFree(ps_state * psstate)
+ps_state::~ps_state()
 {
-    if (psstate->entry) {
-        debugs(44, 3, HERE << psstate->entry->url());
+    if (entry) {
+        debugs(44, 3, entry->url());
 
-        if (psstate->entry->ping_status == PING_WAITING)
-            eventDelete(peerPingTimeout, psstate);
+        if (entry->ping_status == PING_WAITING)
+            eventDelete(peerPingTimeout, this);
 
-        psstate->entry->ping_status = PING_DONE;
+        entry->ping_status = PING_DONE;
     }
 
-    if (psstate->acl_checklist) {
-        debugs(44, DBG_IMPORTANT, "calling aclChecklistFree() from peerSelectStateFree");
-        delete (psstate->acl_checklist);
+    if (acl_checklist) {
+        debugs(44, DBG_IMPORTANT, "calling aclChecklistFree() from ps_state destructor");
+        delete acl_checklist;
     }
 
-    HTTPMSGUNLOCK(psstate->request);
+    HTTPMSGUNLOCK(request);
 
-    if (psstate->entry) {
-        assert(psstate->entry->ping_status != PING_WAITING);
-        psstate->entry->unlock();
-        psstate->entry = NULL;
+    if (entry) {
+        assert(entry->ping_status != PING_WAITING);
+        entry->unlock();
+        entry = NULL;
     }
 
-    delete psstate->lastError;
-
-    cbdataFree(psstate);
+    delete lastError;
 }
 
 static int
 peerSelectIcpPing(HttpRequest * request, int direct, StoreEntry * entry)
 {
     int n;
     assert(entry);
     assert(entry->ping_status == PING_NONE);
     assert(direct != DIRECT_YES);
-    debugs(44, 3, "peerSelectIcpPing: " << entry->url()  );
+    debugs(44, 3, "peerSelectIcpPing: " << entry->url());
 
     if (!request->flags.hierarchical && direct != DIRECT_NO)
         return 0;
 
     if (EBIT_TEST(entry->flags, KEY_PRIVATE) && !neighbors_do_private_keys)
         if (direct != DIRECT_NO)
@@ -155,13 +151,14 @@
         debugs(44, 3, "peerSelect: " << entry->url()  );
     else
         debugs(44, 3, "peerSelect: " << RequestMethodStr(request->method));
 
     psstate = new ps_state;
 
-    psstate->request = HTTPMSGLOCK(request);
+    psstate->request = request;
+    HTTPMSGLOCK(psstate->request);
 
     psstate->entry = entry;
     psstate->paths = paths;
 
     psstate->callback = callback;
 
@@ -233,22 +230,22 @@
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we must use only the original client destination when going DIRECT
     // on intercepted traffic which failed Host verification
     const HttpRequest *req = psstate->request;
     const bool isIntercepted = !req->flags.redirected &&
-                               (req->flags.intercepted || req->flags.spoofClientIp);
+                               (req->flags.intercepted || req->flags.interceptTproxy);
     const bool useOriginalDst = Config.onoff.client_dst_passthru || !req->flags.hostVerified;
     const bool choseDirect = fs && fs->code == HIER_DIRECT;
     if (isIntercepted && useOriginalDst && choseDirect) {
         // check the client is still around before using any of its details
         if (req->clientConnectionManager.valid()) {
             // construct a "result" adding the ORIGINAL_DST to the set instead of DIRECT
             Comm::ConnectionPointer p = new Comm::Connection();
             p->remote = req->clientConnectionManager->clientConnection->local;
-            p->peerType = fs->code;
+            p->peerType = ORIGINAL_DST; // fs->code is DIRECT. This fixes the display.
             p->setPeer(fs->_peer);
 
             // check for a configured outgoing address for this destination...
             getOutgoingAddress(psstate->request, p);
             psstate->paths->push_back(p);
         }
@@ -262,26 +259,27 @@
     }
 
     // convert the list of FwdServer destinations into destinations IP addresses
     if (fs && psstate->paths->size() < (unsigned int)Config.forward_max_tries) {
         // send the next one off for DNS lookup.
         const char *host = fs->_peer ? fs->_peer->host : psstate->request->GetHost();
-        debugs(44, 2, "Find IP destination for: " << psstate->entry->url() << "' via " << host);
+        debugs(44, 2, "Find IP destination for: " << psstate->url() << "' via " << host);
         ipcache_nbgethostbyname(host, peerSelectDnsResults, psstate);
         return;
     }
 
     // Bug 3605: clear any extra listed FwdServer destinations, when the options exceeds max_foward_tries.
     // due to the allocation method of fs, we must deallocate each manually.
     // TODO: use a std::list so we can get the size and abort adding whenever the selection loops reach Config.forward_max_tries
     if (fs && psstate->paths->size() >= (unsigned int)Config.forward_max_tries) {
+        assert(fs == psstate->servers);
         while (fs) {
-            FwdServer *next = fs->next;
+            psstate->servers = fs->next;
             cbdataReferenceDone(fs->_peer);
             memFree(fs, MEM_FWD_SERVER);
-            fs = next;
+            fs = psstate->servers;
         }
     }
 
     // done with DNS lookups. pass back to caller
     PSC *callback = psstate->callback;
     psstate->callback = NULL;
@@ -309,13 +307,13 @@
     void *cbdata;
     if (cbdataReferenceValidDone(psstate->callback_data, &cbdata)) {
         callback(psstate->paths, psstate->lastError, cbdata);
         psstate->lastError = NULL; // FwdState has taken control over the ErrorState object.
     }
 
-    peerSelectStateFree(psstate);
+    delete psstate;
 }
 
 static void
 peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, void *data)
 {
     ps_state *psstate = (ps_state *)data;
@@ -335,34 +333,34 @@
             if (ip >= ia->count) ip = 0; // looped back to zero.
 
             // Enforce forward_max_tries configuration.
             if (psstate->paths->size() >= (unsigned int)Config.forward_max_tries)
                 break;
 
-            // for TPROXY we must skip unusable addresses.
+            // for TPROXY spoofing we must skip unusable addresses.
             if (psstate->request->flags.spoofClientIp && !(fs->_peer && fs->_peer->options.no_tproxy) ) {
-                if (ia->in_addrs[n].IsIPv4() != psstate->request->client_addr.IsIPv4()) {
+                if (ia->in_addrs[ip].isIPv4() != psstate->request->client_addr.isIPv4()) {
                     // we CAN'T spoof the address on this link. find another.
                     continue;
                 }
             }
 
             p = new Comm::Connection();
-            p->remote = ia->in_addrs[n];
+            p->remote = ia->in_addrs[ip];
 
             // when IPv6 is disabled we cannot use it
-            if (!Ip::EnableIpv6 && p->remote.IsIPv6()) {
+            if (!Ip::EnableIpv6 && p->remote.isIPv6()) {
                 const char *host = (fs->_peer ? fs->_peer->host : psstate->request->GetHost());
                 ipcacheMarkBadAddr(host, p->remote);
                 continue;
             }
 
             if (fs->_peer)
-                p->remote.SetPort(fs->_peer->http_port);
+                p->remote.port(fs->_peer->http_port);
             else
-                p->remote.SetPort(psstate->request->port);
+                p->remote.port(psstate->request->port);
             p->peerType = fs->code;
             p->setPeer(fs->_peer);
 
             // check for a configured outgoing address for this destination...
             getOutgoingAddress(psstate->request, p);
             psstate->paths->push_back(p);
@@ -370,13 +368,13 @@
     } else {
         debugs(44, 3, HERE << "Unknown host: " << (fs->_peer ? fs->_peer->host : psstate->request->GetHost()));
         // discard any previous error.
         delete psstate->lastError;
         psstate->lastError = NULL;
         if (fs->code == HIER_DIRECT) {
-            psstate->lastError = new ErrorState(ERR_DNS_FAIL, HTTP_SERVICE_UNAVAILABLE, psstate->request);
+            psstate->lastError = new ErrorState(ERR_DNS_FAIL, Http::scServiceUnavailable, psstate->request);
             psstate->lastError->dnsError = details.error;
         }
     }
 
     psstate->servers = fs->next;
     cbdataReferenceDone(fs->_peer);
@@ -633,16 +631,16 @@
         return;
     }
 
     if ((p = ps->hit)) {
         code = ps->hit_type == PEER_PARENT ? PARENT_HIT : SIBLING_HIT;
     } else {
-        if (!ps->closest_parent_miss.IsAnyAddr()) {
+        if (!ps->closest_parent_miss.isAnyAddr()) {
             p = whichPeer(ps->closest_parent_miss);
             code = CLOSEST_PARENT_MISS;
-        } else if (!ps->first_parent_miss.IsAnyAddr()) {
+        } else if (!ps->first_parent_miss.isAnyAddr()) {
             p = whichPeer(ps->first_parent_miss);
             code = FIRST_PARENT_MISS;
         }
     }
     if (p && code != HIER_NONE) {
         debugs(44, 3, "peerSelect: " << hier_code_str[code] << "/" << p->host);
@@ -743,19 +741,19 @@
 peerPingTimeout(void *data)
 {
     ps_state *psstate = (ps_state *)data;
     StoreEntry *entry = psstate->entry;
 
     if (entry)
-        debugs(44, 3, "peerPingTimeout: '" << entry->url() << "'" );
+        debugs(44, 3, "peerPingTimeout: '" << psstate->url() << "'" );
 
     if (!cbdataReferenceValid(psstate->callback_data)) {
         /* request aborted */
         entry->ping_status = PING_DONE;
         cbdataReferenceDone(psstate->callback_data);
-        peerSelectStateFree(psstate);
+        delete psstate;
         return;
     }
 
     ++PeerStats.timeouts;
     psstate->ping.timedout = 1;
     peerSelectFoo(psstate);
@@ -792,32 +790,32 @@
 
     /* if closest-only is set, then don't allow FIRST_PARENT_MISS */
     if (p->options.closest_only)
         return;
 
     /* set FIRST_MISS if there is no CLOSEST parent */
-    if (!ps->closest_parent_miss.IsAnyAddr())
+    if (!ps->closest_parent_miss.isAnyAddr())
         return;
 
     rtt = (tvSubMsec(ps->ping.start, current_time) - p->basetime) / p->weight;
 
     if (rtt < 1)
         rtt = 1;
 
-    if (ps->first_parent_miss.IsAnyAddr() || rtt < ps->ping.w_rtt) {
+    if (ps->first_parent_miss.isAnyAddr() || rtt < ps->ping.w_rtt) {
         ps->first_parent_miss = p->in_addr;
         ps->ping.w_rtt = rtt;
     }
 }
 
 static void
 peerHandleIcpReply(CachePeer * p, peer_t type, icp_common_t * header, void *data)
 {
     ps_state *psstate = (ps_state *)data;
     icp_opcode op = header->getOpCode();
-    debugs(44, 3, "peerHandleIcpReply: " << icp_opcode_str[op] << " " << psstate->entry->url()  );
+    debugs(44, 3, "peerHandleIcpReply: " << icp_opcode_str[op] << " " << psstate->url()  );
 #if USE_CACHE_DIGESTS && 0
     /* do cd lookup to count false misses */
 
     if (p && request)
         peerNoteDigestLookup(request, p,
                              peerDigestLookup(p, request, psstate->entry));
@@ -844,15 +842,13 @@
 
 #if USE_HTCP
 static void
 peerHandleHtcpReply(CachePeer * p, peer_t type, HtcpReplyData * htcp, void *data)
 {
     ps_state *psstate = (ps_state *)data;
-    debugs(44, 3, "peerHandleHtcpReply: " <<
-           (htcp->hit ? "HIT" : "MISS") << " " <<
-           psstate->entry->url()  );
+    debugs(44, 3, "" << (htcp->hit ? "HIT" : "MISS") << " " << psstate->url());
     ++ psstate->ping.n_recv;
 
     if (htcp->hit) {
         psstate->hit = p;
         psstate->hit_type = type;
         peerSelectFoo(psstate);
@@ -890,21 +886,21 @@
 
     /* if closest-only is set, then don't allow FIRST_PARENT_MISS */
     if (p->options.closest_only)
         return;
 
     /* set FIRST_MISS if there is no CLOSEST parent */
-    if (!ps->closest_parent_miss.IsAnyAddr())
+    if (!ps->closest_parent_miss.isAnyAddr())
         return;
 
     rtt = (tvSubMsec(ps->ping.start, current_time) - p->basetime) / p->weight;
 
     if (rtt < 1)
         rtt = 1;
 
-    if (ps->first_parent_miss.IsAnyAddr() || rtt < ps->ping.w_rtt) {
+    if (ps->first_parent_miss.isAnyAddr() || rtt < ps->ping.w_rtt) {
         ps->first_parent_miss = p->in_addr;
         ps->ping.w_rtt = rtt;
     }
 }
 
 #endif
@@ -939,19 +935,12 @@
     while (*FSVR)
         FSVR = &(*FSVR)->next;
 
     *FSVR = fs;
 }
 
-void *
-ps_state::operator new(size_t)
-{
-    CBDATA_INIT_TYPE(ps_state);
-    return cbdataAlloc(ps_state);
-}
-
 ps_state::ps_state() : request (NULL),
         entry (NULL),
         always_direct(Config.accessList.AlwaysDirect?ACCESS_DUNNO:ACCESS_DENIED),
         never_direct(Config.accessList.NeverDirect?ACCESS_DUNNO:ACCESS_DENIED),
         direct(DIRECT_UNKNOWN),
         callback (NULL),
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/PeerSelectState.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/PeerSelectState.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/PeerSelectState.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/PeerSelectState.h	2015-05-01 18:05:19.000000000 +0800
@@ -31,13 +31,13 @@
  */
 
 #ifndef   SQUID_PEERSELECTSTATE_H
 #define   SQUID_PEERSELECTSTATE_H
 
 #include "acl/Checklist.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "hier_code.h"
 #include "PingData.h"
 #include "ip/Address.h"
 
@@ -68,14 +68,14 @@
 };
 
 class ps_state
 {
 
 public:
-    void *operator new(size_t);
     ps_state();
+    ~ps_state();
 
     // Produce a URL for display identifying the transaction we are
     // trying to locate a peer for.
     const char * url() const;
 
     HttpRequest *request;
@@ -107,10 +107,10 @@
      */
     CachePeer *hit;
     peer_t hit_type;
     ping_data ping;
     ACLChecklist *acl_checklist;
 private:
-    CBDATA_CLASS(ps_state);
+    CBDATA_CLASS2(ps_state);
 };
 
 #endif /* SQUID_PEERSELECTSTATE_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/peer_sourcehash.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/peer_sourcehash.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/peer_sourcehash.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/peer_sourcehash.cc	2015-05-01 18:05:19.000000000 +0800
@@ -180,13 +180,13 @@
     const char *key = NULL;
     char ntoabuf[MAX_IPSTRLEN];
 
     if (n_sourcehash_peers == 0)
         return NULL;
 
-    key = request->client_addr.NtoA(ntoabuf, sizeof(ntoabuf));
+    key = request->client_addr.toStr(ntoabuf, sizeof(ntoabuf));
 
     /* calculate hash key */
     debugs(39, 2, "peerSourceHashSelectParent: Calculating hash for " << key);
 
     for (c = key; *c != 0; ++c)
         user_hash += ROTATE_LEFT(user_hash, 19) + *c;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/recv-announce.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/recv-announce.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/recv-announce.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/recv-announce.cc	2015-05-01 18:05:19.000000000 +0800
@@ -118,13 +118,13 @@
 
         memcpy(ip, &R.sin_addr.s_addr, 4);
         hp = gethostbyaddr(ip, 4, AF_INET);
         ipa = R.sin_addr;
         printf("==============================================================================\n");
         printf("Received from %s [%s]\n",
-               ipa.NtoA(tmp,MAX_HOSTNAMELEN),
+               ipa.toStr(tmp,MAX_HOSTNAMELEN),
                (hp && hp->h_name) ? hp->h_name : "Unknown");
         fputs(buf, stdout);
         fflush(stdout);
     }
 
     return 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/redirect.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/redirect.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/redirect.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/redirect.cc	2015-05-01 18:05:19.000000000 +0800
@@ -37,13 +37,12 @@
 #include "client_side_request.h"
 #include "comm/Connection.h"
 #include "fde.h"
 #include "fqdncache.h"
 #include "globals.h"
 #include "HttpRequest.h"
-#include "helper.h"
 #include "mgr/Registration.h"
 #include "redirect.h"
 #include "rfc1738.h"
 #include "SquidConfig.h"
 #include "Store.h"
 #if USE_AUTH
@@ -60,38 +59,123 @@
     void *data;
     char *orig_url;
 
     Ip::Address client_addr;
     const char *client_ident;
     const char *method_s;
-    RH *handler;
+    HLPCB *handler;
 } redirectStateData;
 
 static HLPCB redirectHandleReply;
+static HLPCB storeIdHandleReply;
 static void redirectStateFree(redirectStateData * r);
 static helper *redirectors = NULL;
+static helper *storeIds = NULL;
 static OBJH redirectStats;
-static int n_bypassed = 0;
+static OBJH storeIdStats;
+static int redirectorBypassed = 0;
+static int storeIdBypassed = 0;
 CBDATA_TYPE(redirectStateData);
 
 static void
-redirectHandleReply(void *data, char *reply)
+redirectHandleReply(void *data, const HelperReply &reply)
 {
     redirectStateData *r = static_cast<redirectStateData *>(data);
-    char *t;
+    debugs(61, 5, HERE << "reply=" << reply);
+
+    // XXX: This function is now kept only to check for and display the garbage use-case
+    // and to map the old helper response format(s) into new format result code and key=value pairs
+    // it can be removed when the helpers are all updated to the normalized "OK/ERR kv-pairs" format
+
+    if (reply.result == HelperReply::Unknown) {
+        // BACKWARD COMPATIBILITY 2012-06-15:
+        // Some nasty old helpers send back the entire input line including extra format keys.
+        // This is especially bad for simple perl search-replace filter scripts.
+        //
+        // * trim all but the first word off the response.
+        // * warn once every 50 responses that this will stop being fixed-up soon.
+        //
+        if (const char * res = reply.other().content()) {
+            if (const char *t = strchr(res, ' ')) {
+                static int warn = 0;
+                debugs(61, (!(warn++%50)? DBG_CRITICAL:2), "UPGRADE WARNING: URL rewriter reponded with garbage '" << t <<
+                       "'. Future Squid will treat this as part of the URL.");
+                const mb_size_t garbageLength = reply.other().contentSize() - (t-res);
+                reply.modifiableOther().truncate(garbageLength);
+            }
+            if (reply.other().hasContent() && *res == '\0')
+                reply.modifiableOther().clean(); // drop the whole buffer of garbage.
+
+            // if we still have anything in other() after all that
+            // parse it into status=, url= and rewrite-url= keys
+            if (reply.other().hasContent()) {
+                /* 2012-06-28: This cast is due to urlParse() truncating too-long URLs itself.
+                 * At this point altering the helper buffer in that way is not harmful, but annoying.
+                 * When Bug 1961 is resolved and urlParse has a const API, this needs to die.
+                 */
+                const char * result = reply.other().content();
+                const Http::StatusCode status = static_cast<Http::StatusCode>(atoi(result));
+
+                HelperReply newReply;
+                // BACKWARD COMPATIBILITY 2012-06-15:
+                // We got HelperReply::Unknown reply result but new
+                // redirectStateData handlers require HelperReply::Okay,
+                // else will drop the helper reply
+                newReply.result = HelperReply::Okay;
+                newReply.notes.append(&reply.notes);
+
+                if (status == Http::scMovedPermanently
+                        || status == Http::scFound
+                        || status == Http::scSeeOther
+                        || status == Http::scPermanentRedirect
+                        || status == Http::scTemporaryRedirect) {
+
+                    if (const char *t = strchr(result, ':')) {
+                        char statusBuf[4];
+                        snprintf(statusBuf, sizeof(statusBuf),"%3u",status);
+                        newReply.notes.add("status", statusBuf);
+                        ++t;
+                        // TODO: validate the URL produced here is RFC 2616 compliant URI
+                        newReply.notes.add("url", t);
+                    } else {
+                        debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid " << status << " redirect Location: " << result);
+                    }
+                } else {
+                    // status code is not a redirect code (or does not exist)
+                    // treat as a re-write URL request
+                    // TODO: validate the URL produced here is RFC 2616 compliant URI
+                    newReply.notes.add("rewrite-url", reply.other().content());
+                }
+
+                void *cbdata;
+                if (cbdataReferenceValidDone(r->data, &cbdata))
+                    r->handler(cbdata, newReply);
+
+                redirectStateFree(r);
+                return;
+            }
+        }
+    }
+
     void *cbdata;
-    debugs(61, 5, "redirectHandleRead: {" << (reply && *reply != '\0' ? reply : "<NULL>") << "}");
+    if (cbdataReferenceValidDone(r->data, &cbdata))
+        r->handler(cbdata, reply);
 
-    if (reply) {
-        if ((t = strchr(reply, ' ')))
-            *t = '\0';
+    redirectStateFree(r);
+}
 
-        if (*reply == '\0')
-            reply = NULL;
-    }
+static void
+storeIdHandleReply(void *data, const HelperReply &reply)
+{
+    redirectStateData *r = static_cast<redirectStateData *>(data);
+    debugs(61, 5,"StoreId helper: reply=" << reply);
 
+    // XXX: This function is now kept only to check for and display the garbage use-case
+    // and to map the old helper response format(s) into new format result code and key=value pairs
+    // it can be removed when the helpers are all updated to the normalized "OK/ERR kv-pairs" format
+    void *cbdata;
     if (cbdataReferenceValidDone(r->data, &cbdata))
         r->handler(cbdata, reply);
 
     redirectStateFree(r);
 }
 
@@ -111,45 +195,50 @@
     }
 
     helperStats(sentry, redirectors, "Redirector Statistics");
 
     if (Config.onoff.redirector_bypass)
         storeAppendPrintf(sentry, "\nNumber of requests bypassed "
-                          "because all redirectors were busy: %d\n", n_bypassed);
+                          "because all redirectors were busy: %d\n", redirectorBypassed);
 }
 
-/**** PUBLIC FUNCTIONS ****/
+static void
+storeIdStats(StoreEntry * sentry)
+{
+    if (storeIds == NULL) {
+        storeAppendPrintf(sentry, "No StoreId helpers defined\n");
+        return;
+    }
 
-void
-redirectStart(ClientHttpRequest * http, RH * handler, void *data)
+    helperStats(sentry, storeIds, "StoreId helper Statistics");
+
+    if (Config.onoff.store_id_bypass)
+        storeAppendPrintf(sentry, "\nNumber of requests bypassed "
+                          "because all StoreId helpers were busy: %d\n", storeIdBypassed);
+}
+
+static void
+constructHelperQuery(const char *name, helper *hlp, HLPCB *replyHandler, ClientHttpRequest * http, HLPCB *handler, void *data)
 {
     ConnStateData * conn = http->getConn();
-    redirectStateData *r = NULL;
     const char *fqdn;
     char buf[MAX_REDIRECTOR_REQUEST_STRLEN];
     int sz;
-    http_status status;
+    Http::StatusCode status;
     char claddr[MAX_IPSTRLEN];
     char myaddr[MAX_IPSTRLEN];
-    assert(http);
-    assert(handler);
-    debugs(61, 5, "redirectStart: '" << http->uri << "'");
 
-    if (Config.onoff.redirector_bypass && redirectors->stats.queue_size) {
-        /* Skip redirector if there is one request queued */
-        ++n_bypassed;
-        handler(data, NULL);
-        return;
-    }
-
-    r = cbdataAlloc(redirectStateData);
+    /** TODO: create a standalone method to initialize
+     * the cbdata\redirectStateData for all the helpers.
+     */
+    redirectStateData *r = cbdataAlloc(redirectStateData);
     r->orig_url = xstrdup(http->uri);
     if (conn != NULL)
         r->client_addr = conn->log_addr;
     else
-        r->client_addr.SetNoAddr();
+        r->client_addr.setNoAddr();
     r->client_ident = NULL;
 #if USE_AUTH
     if (http->request->auth_user_request != NULL) {
         r->client_ident = http->request->auth_user_request->username();
         debugs(61, 5, HERE << "auth-user=" << (r->client_ident?r->client_ident:"NULL"));
     }
@@ -185,96 +274,178 @@
 
     if ((fqdn = fqdncache_gethostbyaddr(r->client_addr, 0)) == NULL)
         fqdn = dash_str;
 
     sz = snprintf(buf, MAX_REDIRECTOR_REQUEST_STRLEN, "%s %s/%s %s %s myip=%s myport=%d\n",
                   r->orig_url,
-                  r->client_addr.NtoA(claddr,MAX_IPSTRLEN),
+                  r->client_addr.toStr(claddr,MAX_IPSTRLEN),
                   fqdn,
                   r->client_ident[0] ? rfc1738_escape(r->client_ident) : dash_str,
                   r->method_s,
-                  http->request->my_addr.NtoA(myaddr,MAX_IPSTRLEN),
-                  http->request->my_addr.GetPort());
+                  http->request->my_addr.toStr(myaddr,MAX_IPSTRLEN),
+                  http->request->my_addr.port());
 
     if ((sz<=0) || (sz>=MAX_REDIRECTOR_REQUEST_STRLEN)) {
         if (sz<=0) {
-            status = HTTP_INTERNAL_SERVER_ERROR;
-            debugs(61, DBG_CRITICAL, "ERROR: Gateway Failure. Can not build request to be passed to redirector. Request ABORTED.");
+            status = Http::scInternalServerError;
+            debugs(61, DBG_CRITICAL, "ERROR: Gateway Failure. Can not build request to be passed to " << name << ". Request ABORTED.");
         } else {
-            status = HTTP_REQUEST_URI_TOO_LARGE;
-            debugs(61, DBG_CRITICAL, "ERROR: Gateway Failure. Request passed to redirector exceeds MAX_REDIRECTOR_REQUEST_STRLEN (" << MAX_REDIRECTOR_REQUEST_STRLEN << "). Request ABORTED.");
+            status = Http::scUriTooLong;
+            debugs(61, DBG_CRITICAL, "ERROR: Gateway Failure. Request passed to " << name << " exceeds MAX_REDIRECTOR_REQUEST_STRLEN (" << MAX_REDIRECTOR_REQUEST_STRLEN << "). Request ABORTED.");
         }
 
         clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->prev->data;
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
         Ip::Address tmpnoaddr;
-        tmpnoaddr.SetNoAddr();
+        tmpnoaddr.setNoAddr();
         repContext->setReplyToError(ERR_GATEWAY_FAILURE, status,
                                     http->request->method, NULL,
                                     http->getConn() != NULL && http->getConn()->clientConnection != NULL ?
                                     http->getConn()->clientConnection->remote : tmpnoaddr,
                                     http->request,
                                     NULL,
 #if USE_AUTH
-                                    http->getConn() != NULL && http->getConn()->auth_user_request != NULL ?
-                                    http->getConn()->auth_user_request : http->request->auth_user_request);
+                                    http->getConn() != NULL && http->getConn()->getAuth() != NULL ?
+                                    http->getConn()->getAuth() : http->request->auth_user_request);
 #else
                                     NULL);
 #endif
 
         node = (clientStreamNode *)http->client_stream.tail->data;
         clientStreamRead(node, http, node->readBuffer);
         return;
     }
 
-    debugs(61,6, HERE << "sending '" << buf << "' to the helper");
-    helperSubmit(redirectors, buf, redirectHandleReply, r);
+    debugs(61,6, HERE << "sending '" << buf << "' to the " << name << " helper");
+    helperSubmit(hlp, buf, replyHandler, r);
+}
+
+/**** PUBLIC FUNCTIONS ****/
+
+void
+redirectStart(ClientHttpRequest * http, HLPCB * handler, void *data)
+{
+    assert(http);
+    assert(handler);
+    debugs(61, 5, "redirectStart: '" << http->uri << "'");
+
+    if (Config.onoff.redirector_bypass && redirectors->stats.queue_size) {
+        /* Skip redirector if there is one request queued */
+        ++redirectorBypassed;
+        HelperReply bypassReply;
+        bypassReply.result = HelperReply::Okay;
+        bypassReply.notes.add("message","URL rewrite/redirect queue too long. Bypassed.");
+        handler(data, bypassReply);
+        return;
+    }
+
+    constructHelperQuery("redirector", redirectors, redirectHandleReply, http, handler, data);
+}
+
+/**
+ * Handles the StoreID feature helper starting.
+ * For now it cannot be done using the redirectStart method.
+ */
+void
+storeIdStart(ClientHttpRequest * http, HLPCB * handler, void *data)
+{
+    assert(http);
+    assert(handler);
+    debugs(61, 5, "storeIdStart: '" << http->uri << "'");
+
+    if (Config.onoff.store_id_bypass && storeIds->stats.queue_size) {
+        /* Skip StoreID Helper if there is one request queued */
+        ++storeIdBypassed;
+        HelperReply bypassReply;
+
+        bypassReply.result = HelperReply::Okay;
+
+        bypassReply.notes.add("message","StoreId helper queue too long. Bypassed.");
+        handler(data, bypassReply);
+        return;
+    }
+
+    constructHelperQuery("storeId helper", storeIds, storeIdHandleReply, http, handler, data);
 }
 
 static void
 redirectRegisterWithCacheManager(void)
 {
     Mgr::RegisterAction("redirector", "URL Redirector Stats", redirectStats, 0, 1);
+    Mgr::RegisterAction("store_id", "StoreId helper Stats", storeIdStats, 0, 1); /* registering the new StoreID statistics in Mgr*/
 }
 
 void
 redirectInit(void)
 {
     static int init = 0;
 
     redirectRegisterWithCacheManager();
 
-    if (!Config.Program.redirect)
+    /** FIXME: Temporary unified helpers startup
+     * When and if needed for more helpers a separated startup
+     * method will be added for each of them.
+     */
+    if (!Config.Program.redirect && !Config.Program.store_id)
         return;
 
-    if (redirectors == NULL)
-        redirectors = new helper("redirector");
+    if (Config.Program.redirect) {
 
-    redirectors->cmdline = Config.Program.redirect;
+        if (redirectors == NULL)
+            redirectors = new helper("redirector");
 
-    redirectors->childs.updateLimits(Config.redirectChildren);
+        redirectors->cmdline = Config.Program.redirect;
+
+        redirectors->childs.updateLimits(Config.redirectChildren);
+
+        redirectors->ipc_type = IPC_STREAM;
+
+        helperOpenServers(redirectors);
+    }
 
-    redirectors->ipc_type = IPC_STREAM;
+    if (Config.Program.store_id) {
 
-    helperOpenServers(redirectors);
+        if (storeIds == NULL)
+            storeIds = new helper("store_id");
+
+        storeIds->cmdline = Config.Program.store_id;
+
+        storeIds->childs.updateLimits(Config.storeIdChildren);
+
+        storeIds->ipc_type = IPC_STREAM;
+
+        helperOpenServers(storeIds);
+    }
 
     if (!init) {
         init = 1;
         CBDATA_INIT_TYPE(redirectStateData);
     }
 }
 
 void
 redirectShutdown(void)
 {
-    if (!redirectors)
+    /** FIXME: Temporary unified helpers Shutdown
+     * When and if needed for more helpers a separated shutdown
+     * method will be added for each of them.
+     */
+    if (!storeIds && !redirectors)
         return;
 
-    helperShutdown(redirectors);
+    if (redirectors)
+        helperShutdown(redirectors);
+
+    if (storeIds)
+        helperShutdown(storeIds);
 
     if (!shutting_down)
         return;
 
     delete redirectors;
     redirectors = NULL;
+
+    delete storeIds;
+    storeIds = NULL;
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/redirect.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/redirect.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/redirect.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/redirect.h	2015-05-01 18:05:19.000000000 +0800
@@ -30,10 +30,16 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
+#include "helper.h"
+
+class ClientHttpRequest;
+
 void redirectInit(void);
 void redirectShutdown(void);
+void redirectStart(ClientHttpRequest *, HLPCB *, void *);
+void storeIdStart(ClientHttpRequest *, HLPCB *, void *);
 
 #endif /* SQUID_REDIRECT_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/refresh.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/refresh.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/refresh.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/refresh.cc	2015-05-01 18:05:19.000000000 +0800
@@ -290,23 +290,23 @@
     // stale-if-error requires any failure be passed thru when its period is over.
     if (request && entry->mem_obj && entry->mem_obj->getReply() && entry->mem_obj->getReply()->cache_control &&
             entry->mem_obj->getReply()->cache_control->hasStaleIfError() &&
             entry->mem_obj->getReply()->cache_control->staleIfError() < staleness) {
 
         debugs(22, 3, "refreshCheck: stale-if-error period expired.");
-        request->flags.failOnValidationError = 1;
+        request->flags.failOnValidationError = true;
     }
 
     if (EBIT_TEST(entry->flags, ENTRY_REVALIDATE) && staleness > -1
 #if USE_HTTP_VIOLATIONS
             && !R->flags.ignore_must_revalidate
 #endif
        ) {
         debugs(22, 3, "refreshCheck: YES: Must revalidate stale response");
         if (request)
-            request->flags.failOnValidationError = 1;
+            request->flags.failOnValidationError = true;
         return STALE_MUST_REVALIDATE;
     }
 
     /* request-specific checks */
     if (request && !request->flags.ignoreCc) {
         HttpHdrCc *cc = request->cache_control;
@@ -328,13 +328,13 @@
             /* The clients no-cache header is changed into a IMS query */
             debugs(22, 3, "refreshCheck: YES: reload-into-ims");
             return STALE_RELOAD_INTO_IMS;
         } else {
             /* The clients no-cache header is not overridden on this request */
             debugs(22, 3, "refreshCheck: YES: client reload");
-            request->flags.noCache = 1;
+            request->flags.noCache = true;
             return STALE_FORCED_RELOAD;
         }
 
 #endif
         if (NULL != cc) {
             if (cc->hasMaxAge()) {
@@ -395,13 +395,13 @@
      * NOTE: max-stale config blocks the overrides.
      */
     int max_stale = (R->max_stale >= 0 ? R->max_stale : Config.maxStale);
     if ( max_stale >= 0 && staleness > max_stale) {
         debugs(22, 3, "refreshCheck: YES: max-stale limit");
         if (request)
-            request->flags.failOnValidationError = 1;
+            request->flags.failOnValidationError = true;
         return STALE_MAX_STALE;
     }
 
     if (sf.expires) {
 #if USE_HTTP_VIOLATIONS
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/RefreshPattern.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/RefreshPattern.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/RefreshPattern.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/RefreshPattern.h	2015-05-01 18:05:19.000000000 +0800
@@ -26,36 +26,38 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
+#include "compat/GnuRegex.h"
+
 /// a representation of a refresh pattern. Currently a POD.
 class RefreshPattern
 {
 public:
     const char *pattern;
     regex_t compiled_pattern;
     time_t min;
     double pct;
     time_t max;
     RefreshPattern *next;
 
     struct {
-        unsigned int icase:1;
-        unsigned int refresh_ims:1;
-        unsigned int store_stale:1;
+        bool icase;
+        bool refresh_ims;
+        bool store_stale;
 #if USE_HTTP_VIOLATIONS
-        unsigned int override_expire:1;
-        unsigned int override_lastmod:1;
-        unsigned int reload_into_ims:1;
-        unsigned int ignore_reload:1;
-        unsigned int ignore_no_store:1;
-        unsigned int ignore_must_revalidate:1;
-        unsigned int ignore_private:1;
-        unsigned int ignore_auth:1;
+        bool override_expire;
+        bool override_lastmod;
+        bool reload_into_ims;
+        bool ignore_reload;
+        bool ignore_no_store;
+        bool ignore_must_revalidate;
+        bool ignore_private;
+        bool ignore_auth;
 #endif
     } flags;
     int max_stale;
 };
 
 #endif /* SQUID_REFRESHPATTERN_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/repl/heap/store_repl_heap.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/repl/heap/store_repl_heap.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/repl/heap/store_repl_heap.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/repl/heap/store_repl_heap.cc	2015-05-01 18:05:19.000000000 +0800
@@ -98,57 +98,57 @@
     }
 }
 
 static void
 heap_add(RemovalPolicy * policy, StoreEntry * entry, RemovalPolicyNode * node)
 {
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     assert(!node->data);
 
     if (EBIT_TEST(entry->flags, ENTRY_SPECIAL))
         return;			/* We won't manage these.. they messes things up */
 
-    node->data = heap_insert(heap->theHeap, entry);
+    node->data = heap_insert(h->theHeap, entry);
 
-    heap->count += 1;
+    h->count += 1;
 
-    if (!heap->type)
-        heap->type = heap_guessType(entry, node);
+    if (!h->type)
+        h->type = heap_guessType(entry, node);
 
     /* Add a little more variance to the aging factor */
-    heap->theHeap->age += heap->theHeap->age / 100000000;
+    h->theHeap->age += h->theHeap->age / 100000000;
 }
 
 static void
 heap_remove(RemovalPolicy * policy, StoreEntry * entry,
             RemovalPolicyNode * node)
 {
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     heap_node *hnode = (heap_node *)node->data;
 
     if (!hnode)
         return;
 
-    heap_delete(heap->theHeap, hnode);
+    heap_delete(h->theHeap, hnode);
 
     node->data = NULL;
 
-    heap->count -= 1;
+    h->count -= 1;
 }
 
 static void
 heap_referenced(RemovalPolicy * policy, const StoreEntry * entry,
                 RemovalPolicyNode * node)
 {
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     heap_node *hnode = (heap_node *)node->data;
 
     if (!hnode)
         return;
 
-    heap_update(heap->theHeap, hnode, (StoreEntry *) entry);
+    heap_update(h->theHeap, hnode, (StoreEntry *) entry);
 }
 
 /** RemovalPolicyWalker **/
 
 typedef struct _HeapWalkData HeapWalkData;
 
@@ -158,42 +158,42 @@
 
 static const StoreEntry *
 heap_walkNext(RemovalPolicyWalker * walker)
 {
     HeapWalkData *heap_walk = (HeapWalkData *)walker->_data;
     RemovalPolicy *policy = walker->_policy;
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     StoreEntry *entry;
 
-    if (heap_walk->current >= heap_nodes(heap->theHeap))
+    if (heap_walk->current >= heap_nodes(h->theHeap))
         return NULL;		/* done */
 
-    entry = (StoreEntry *) heap_peep(heap->theHeap, heap_walk->current++);
+    entry = (StoreEntry *) heap_peep(h->theHeap, heap_walk->current++);
 
     return entry;
 }
 
 static void
 heap_walkDone(RemovalPolicyWalker * walker)
 {
     RemovalPolicy *policy = walker->_policy;
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     assert(strcmp(policy->_type, "heap") == 0);
-    assert(heap->nwalkers > 0);
-    heap->nwalkers -= 1;
+    assert(h->nwalkers > 0);
+    h->nwalkers -= 1;
     safe_free(walker->_data);
     delete walker;
 }
 
 static RemovalPolicyWalker *
 heap_walkInit(RemovalPolicy * policy)
 {
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     RemovalPolicyWalker *walker;
     HeapWalkData *heap_walk;
-    heap->nwalkers += 1;
+    h->nwalkers += 1;
     walker = new RemovalPolicyWalker;
     heap_walk = (HeapWalkData *)xcalloc(1, sizeof(*heap_walk));
     heap_walk->current = 0;
     walker->_policy = policy;
     walker->_data = heap_walk;
     walker->Next = heap_walkNext;
@@ -212,74 +212,74 @@
 
 static StoreEntry *
 heap_purgeNext(RemovalPurgeWalker * walker)
 {
     HeapPurgeData *heap_walker = (HeapPurgeData *)walker->_data;
     RemovalPolicy *policy = walker->_policy;
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     StoreEntry *entry;
     heap_key age;
 
 try_again:
 
-    if (!heap_nodes(heap->theHeap) > 0)
+    if (heap_empty(h->theHeap))
         return NULL;		/* done */
 
-    age = heap_peepminkey(heap->theHeap);
+    age = heap_peepminkey(h->theHeap);
 
-    entry = (StoreEntry *)heap_extractmin(heap->theHeap);
+    entry = (StoreEntry *)heap_extractmin(h->theHeap);
 
     if (entry->locked()) {
 
         entry->lock();
         linklistPush(&heap_walker->locked_entries, entry);
 
         goto try_again;
     }
 
     heap_walker->min_age = age;
-    heap->setPolicyNode(entry, NULL);
+    h->setPolicyNode(entry, NULL);
     return entry;
 }
 
 static void
 heap_purgeDone(RemovalPurgeWalker * walker)
 {
     HeapPurgeData *heap_walker = (HeapPurgeData *)walker->_data;
     RemovalPolicy *policy = walker->_policy;
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     StoreEntry *entry;
     assert(strcmp(policy->_type, "heap") == 0);
-    assert(heap->nwalkers > 0);
-    heap->nwalkers -= 1;
+    assert(h->nwalkers > 0);
+    h->nwalkers -= 1;
 
     if (heap_walker->min_age > 0) {
-        heap->theHeap->age = heap_walker->min_age;
-        debugs(81, 3, "heap_purgeDone: Heap age set to " << heap->theHeap->age  );
+        h->theHeap->age = heap_walker->min_age;
+        debugs(81, 3, "Heap age set to " << h->theHeap->age);
     }
 
     /*
      * Reinsert the locked entries
      */
     while ((entry = (StoreEntry *)linklistShift(&heap_walker->locked_entries))) {
-        heap_node *node = heap_insert(heap->theHeap, entry);
-        heap->setPolicyNode(entry, node);
+        heap_node *node = heap_insert(h->theHeap, entry);
+        h->setPolicyNode(entry, node);
         entry->unlock();
     }
 
     safe_free(walker->_data);
     delete walker;
 }
 
 static RemovalPurgeWalker *
 heap_purgeInit(RemovalPolicy * policy, int max_scan)
 {
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     RemovalPurgeWalker *walker;
     HeapPurgeData *heap_walk;
-    heap->nwalkers += 1;
+    h->nwalkers += 1;
     walker = new RemovalPurgeWalker;
     heap_walk = (HeapPurgeData *)xcalloc(1, sizeof(*heap_walk));
     heap_walk->min_age = 0.0;
     heap_walk->locked_entries = NULL;
     walker->_policy = policy;
     walker->_data = heap_walk;
@@ -289,19 +289,19 @@
     return walker;
 }
 
 static void
 heap_free(RemovalPolicy * policy)
 {
-    HeapPolicyData *heap = (HeapPolicyData *)policy->_data;
+    HeapPolicyData *h = (HeapPolicyData *)policy->_data;
     /* Make some verification of the policy state */
     assert(strcmp(policy->_type, "heap") == 0);
-    assert(heap->nwalkers);
-    assert(heap->count);
+    assert(h->nwalkers);
+    assert(h->count);
     /* Ok, time to destroy this policy */
-    safe_free(heap);
+    safe_free(h);
     memset(policy, 0, sizeof(*policy));
     delete policy;
 }
 
 RemovalPolicy *
 createRemovalPolicy_heap(wordlist * args)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/repl/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/repl/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/repl/Makefile.in	2015-05-01 16:51:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/repl/Makefile.in	2015-05-01 18:07:00.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -464,12 +510,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -507,12 +554,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -539,27 +587,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -626,13 +677,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 AUTOMAKE_OPTIONS = subdir-objects
 
 # No recursion is needed for the subdirs, we build from here.
 EXTRA_LIBRARIES = liblru.a libheap.a
 noinst_LIBRARIES = $(REPL_LIBS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/RequestFlags.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/RequestFlags.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/RequestFlags.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/RequestFlags.h	2015-05-01 18:05:19.000000000 +0800
@@ -84,13 +84,17 @@
     /** if set, ignore Cache-Control headers */
     bool ignoreCc :1;
     /** set for intercepted requests */
     bool intercepted :1;
     /** set if the Host: header passed verification */
     bool hostVerified :1;
-    /** request to spoof the client ip */
+    /// Set for requests handled by a "tproxy" port.
+    bool interceptTproxy :1;
+    /// The client IP address should be spoofed when connecting to the web server.
+    /// This applies to TPROXY traffic that has not had spoofing disabled through
+    /// the spoof_client_ip squid.conf ACL.
     bool spoofClientIp :1;
     /** set if the request is internal (\see ClientHttpRequest::flags.internal)*/
     bool internal :1;
     /** set for internally-generated requests */
     //XXX this is set in in clientBeginRequest, but never tested.
     bool internalClient :1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/send-announce.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/send-announce.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/send-announce.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/send-announce.cc	2015-05-01 18:05:19.000000000 +0800
@@ -110,12 +110,12 @@
         } else {
             debugs(50, DBG_IMPORTANT, "send_announce: " << file << ": " << xstrerror());
         }
     }
 
     Ip::Address S = ia->in_addrs[0];
-    S.SetPort(port);
+    S.port(port);
     assert(Comm::IsConnOpen(icpOutgoingConn));
 
     if (comm_udp_sendto(icpOutgoingConn->fd, S, sndbuf, strlen(sndbuf) + 1) < 0)
         debugs(27, DBG_IMPORTANT, "ERROR: Failed to announce to " << S << " from " << icpOutgoingConn->local << ": " << xstrerror());
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Server.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Server.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Server.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Server.cc	2015-05-01 18:05:19.000000000 +0800
@@ -73,13 +73,14 @@
 {
     fwd = theFwdState;
     entry = fwd->entry;
 
     entry->lock();
 
-    request = HTTPMSGLOCK(fwd->request);
+    request = fwd->request;
+    HTTPMSGLOCK(request);
 }
 
 ServerStateData::~ServerStateData()
 {
     // paranoid: check that swanSong has been called
     assert(!requestBodySource);
@@ -145,13 +146,14 @@
 HttpReply *
 ServerStateData::setVirginReply(HttpReply *rep)
 {
     debugs(11,5, HERE << this << " setting virgin reply to " << rep);
     assert(!theVirginReply);
     assert(rep);
-    theVirginReply = HTTPMSGLOCK(rep);
+    theVirginReply = rep;
+    HTTPMSGLOCK(theVirginReply);
     return theVirginReply;
 }
 
 HttpReply *
 ServerStateData::finalReply()
 {
@@ -163,13 +165,14 @@
 ServerStateData::setFinalReply(HttpReply *rep)
 {
     debugs(11,5, HERE << this << " setting final reply to " << rep);
 
     assert(!theFinalReply);
     assert(rep);
-    theFinalReply = HTTPMSGLOCK(rep);
+    theFinalReply = rep;
+    HTTPMSGLOCK(theFinalReply);
 
     // give entry the reply because haveParsedReplyHeaders() expects it there
     entry->replaceHttpReply(theFinalReply, false); // but do not write yet
     haveParsedReplyHeaders(); // update the entry/reply (e.g., set timestamps)
     entry->startWriting(); // write the updated entry to store
 
@@ -378,13 +381,13 @@
         return; // do nothing;
     }
 
     if (io.flag) {
         debugs(11, DBG_IMPORTANT, "sentRequestBody error: FD " << io.fd << ": " << xstrerr(io.xerrno));
         ErrorState *err;
-        err = new ErrorState(ERR_WRITE_ERROR, HTTP_BAD_GATEWAY, fwd->request);
+        err = new ErrorState(ERR_WRITE_ERROR, Http::scBadGateway, fwd->request);
         err->xerrno = io.xerrno;
         fwd->fail(err);
         abortTransaction("I/O error while sending request body");
         return;
     }
 
@@ -503,13 +506,13 @@
 {
     // only some HTTP methods should purge matching cache entries
     if (!request->method.purgesOthers())
         return;
 
     // and probably only if the response was successful
-    if (theFinalReply->sline.status >= 400)
+    if (theFinalReply->sline.status() >= 400)
         return;
 
     // XXX: should we use originalRequest() here?
     const char *reqUrl = urlCanonical(request);
     debugs(88, 5, "maybe purging due to " << RequestMethodStr(request->method) << ' ' << reqUrl);
     purgeEntriesByUrl(request, reqUrl);
@@ -523,13 +526,13 @@
 {
     Must(theFinalReply);
     maybePurgeOthers();
 
     // adaptation may overwrite old offset computed using the virgin response
     const bool partial = theFinalReply->content_range &&
-                         theFinalReply->sline.status == HTTP_PARTIAL_CONTENT;
+                         theFinalReply->sline.status() == Http::scPartialContent;
     currentOffset = partial ? theFinalReply->content_range->spec.offset : 0;
 }
 
 HttpRequest *
 ServerStateData::originalRequest()
 {
@@ -661,13 +664,13 @@
 ServerStateData::noteAdaptationAnswer(const Adaptation::Answer &answer)
 {
     clearAdaptation(adaptedHeadSource); // we do not expect more messages
 
     switch (answer.kind) {
     case Adaptation::Answer::akForward:
-        handleAdaptedHeader(answer.message);
+        handleAdaptedHeader(const_cast<HttpMsg*>(answer.message.getRaw()));
         break;
 
     case Adaptation::Answer::akBlock:
         handleAdaptationBlocked(answer);
         break;
 
@@ -829,13 +832,13 @@
         return;
 
     // TODO: bypass if possible
 
     if (entry->isEmpty()) {
         debugs(11,9, HERE << "creating ICAP error entry after ICAP failure");
-        ErrorState *err = new ErrorState(ERR_ICAP_FAILURE, HTTP_INTERNAL_SERVER_ERROR, request);
+        ErrorState *err = new ErrorState(ERR_ICAP_FAILURE, Http::scInternalServerError, request);
         err->detailError(ERR_DETAIL_ICAP_RESPMOD_EARLY);
         fwd->fail(err);
         fwd->dontRetry(true);
     } else if (request) { // update logged info directly
         request->detailError(ERR_ICAP_FAILURE, ERR_DETAIL_ICAP_RESPMOD_LATE);
     }
@@ -863,13 +866,13 @@
 
     err_type page_id =
         aclGetDenyInfoPage(&Config.denyInfoList, answer.ruleId.termedBuf(), 1);
     if (page_id == ERR_NONE)
         page_id = ERR_ACCESS_DENIED;
 
-    ErrorState *err = new ErrorState(page_id, HTTP_FORBIDDEN, request);
+    ErrorState *err = new ErrorState(page_id, Http::scForbidden, request);
     err->detailError(ERR_DETAIL_RESPMOD_BLOCK_EARLY);
     fwd->fail(err);
     fwd->dontRetry(true);
 
     abortTransaction("timely adaptation block");
 }
@@ -902,13 +905,13 @@
 }
 #endif
 
 void
 ServerStateData::sendBodyIsTooLargeError()
 {
-    ErrorState *err = new ErrorState(ERR_TOO_BIG, HTTP_FORBIDDEN, request);
+    ErrorState *err = new ErrorState(ERR_TOO_BIG, Http::scForbidden, request);
     fwd->fail(err);
     fwd->dontRetry(true);
     abortTransaction("Virgin body too large.");
 }
 
 // TODO: when HttpStateData sends all errors to ICAP,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Server.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Server.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Server.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Server.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,17 +29,17 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 #ifndef SQUID_SERVER_H
 #define SQUID_SERVER_H
 
-#include "StoreIOBuffer.h"
-#include "forward.h"
 #include "BodyPipe.h"
 #include "base/AsyncJob.h"
 #include "CommCalls.h"
+#include "FwdState.h"
+#include "StoreIOBuffer.h"
 #if USE_ADAPTATION
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
 #endif
 
 class HttpMsg;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/snmp/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/snmp/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/snmp/Makefile.in	2015-05-01 16:51:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/snmp/Makefile.in	2015-05-01 18:07:00.000000000 +0800
@@ -90,14 +90,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -452,12 +498,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -495,12 +542,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -527,27 +575,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -614,13 +665,13 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libsnmp.la
 libsnmp_la_SOURCES = \
 	Forwarder.cc \
 	Forwarder.h \
 	forward.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/snmp_agent.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/snmp_agent.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/snmp_agent.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/snmp_agent.cc	2015-05-01 18:05:19.000000000 +0800
@@ -242,25 +242,25 @@
         Answer->val.string = (u_char *) xstrdup(cp);
 
         break;
 
     case MESH_PTBL_ADDR_TYPE: {
         int ival;
-        ival = laddr.IsIPv4() ? INETADDRESSTYPE_IPV4 : INETADDRESSTYPE_IPV6 ;
+        ival = laddr.isIPv4() ? INETADDRESSTYPE_IPV4 : INETADDRESSTYPE_IPV6 ;
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
                                       ival, SMI_INTEGER);
     }
     break;
     case MESH_PTBL_ADDR: {
         Answer = snmp_var_new(Var->name, Var->name_length);
         // InetAddress doesn't have its own ASN.1 type,
         // like IpAddr does (SMI_IPADDRESS)
         // See: rfc4001.txt
         Answer->type = ASN_OCTET_STR;
         char host[MAX_IPSTRLEN];
-        laddr.NtoA(host,MAX_IPSTRLEN);
+        laddr.toStr(host,MAX_IPSTRLEN);
         Answer->val_len = strlen(host);
         Answer->val.string =  (u_char *) xstrdup(host);
     }
     break;
 
     case MESH_PTBL_HTTP:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/snmp_core.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/snmp_core.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/snmp_core.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/snmp_core.cc	2015-05-01 18:05:19.000000000 +0800
@@ -56,13 +56,13 @@
 Comm::ConnectionPointer snmpOutgoingConn;
 
 static mib_tree_entry * snmpAddNodeStr(const char *base_str, int o, oid_ParseFn * parsefunction, instance_Fn * instancefunction, AggrType aggrType = atNone);
 static mib_tree_entry *snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, instance_Fn * instancefunction, AggrType aggrType, int children,...);
 static oid *snmpCreateOid(int length,...);
 mib_tree_entry * snmpLookupNodeStr(mib_tree_entry *entry, const char *str);
-int snmpCreateOidFromStr(const char *str, oid **name, int *nl);
+bool snmpCreateOidFromStr(const char *str, oid **name, int *nl);
 SQUIDCEXTERN void (*snmplib_debug_hook) (int, char *);
 static oid *static_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 static oid *time_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 static oid *peer_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 static oid *client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 static void snmpDecodePacket(SnmpRequest * rq);
@@ -279,43 +279,43 @@
 
     if (Config.Port.snmp <= 0)
         return;
 
     snmpIncomingConn = new Comm::Connection;
     snmpIncomingConn->local = Config.Addrs.snmp_incoming;
-    snmpIncomingConn->local.SetPort(Config.Port.snmp);
+    snmpIncomingConn->local.port(Config.Port.snmp);
 
-    if (!Ip::EnableIpv6 && !snmpIncomingConn->local.SetIPv4()) {
+    if (!Ip::EnableIpv6 && !snmpIncomingConn->local.setIPv4()) {
         debugs(49, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << snmpIncomingConn->local << " is not an IPv4 address.");
         fatal("SNMP port cannot be opened.");
     }
     /* split-stack for now requires IPv4-only SNMP */
-    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && snmpIncomingConn->local.IsAnyAddr()) {
-        snmpIncomingConn->local.SetIPv4();
+    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && snmpIncomingConn->local.isAnyAddr()) {
+        snmpIncomingConn->local.setIPv4();
     }
 
     AsyncCall::Pointer call = asyncCall(49, 2, "snmpIncomingConnectionOpened",
                                         Comm::UdpOpenDialer(&snmpPortOpened));
     Ipc::StartListening(SOCK_DGRAM, IPPROTO_UDP, snmpIncomingConn, Ipc::fdnInSnmpSocket, call);
 
-    if (!Config.Addrs.snmp_outgoing.IsNoAddr()) {
+    if (!Config.Addrs.snmp_outgoing.isNoAddr()) {
         snmpOutgoingConn = new Comm::Connection;
         snmpOutgoingConn->local = Config.Addrs.snmp_outgoing;
-        snmpOutgoingConn->local.SetPort(Config.Port.snmp);
+        snmpOutgoingConn->local.port(Config.Port.snmp);
 
-        if (!Ip::EnableIpv6 && !snmpOutgoingConn->local.SetIPv4()) {
+        if (!Ip::EnableIpv6 && !snmpOutgoingConn->local.setIPv4()) {
             debugs(49, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << snmpOutgoingConn->local << " is not an IPv4 address.");
             fatal("SNMP port cannot be opened.");
         }
         /* split-stack for now requires IPv4-only SNMP */
-        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && snmpOutgoingConn->local.IsAnyAddr()) {
-            snmpOutgoingConn->local.SetIPv4();
+        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && snmpOutgoingConn->local.isAnyAddr()) {
+            snmpOutgoingConn->local.setIPv4();
         }
-        AsyncCall::Pointer call = asyncCall(49, 2, "snmpOutgoingConnectionOpened",
-                                            Comm::UdpOpenDialer(&snmpPortOpened));
-        Ipc::StartListening(SOCK_DGRAM, IPPROTO_UDP, snmpOutgoingConn, Ipc::fdnOutSnmpSocket, call);
+        AsyncCall::Pointer c = asyncCall(49, 2, "snmpOutgoingConnectionOpened",
+                                         Comm::UdpOpenDialer(&snmpPortOpened));
+        Ipc::StartListening(SOCK_DGRAM, IPPROTO_UDP, snmpOutgoingConn, Ipc::fdnOutSnmpSocket, c);
     } else {
         snmpOutgoingConn = snmpIncomingConn;
         debugs(1, DBG_IMPORTANT, "Sending SNMP messages from " << snmpOutgoingConn->local);
     }
 }
 
@@ -329,13 +329,13 @@
 
     if (conn->fd == snmpIncomingConn->fd)
         debugs(1, DBG_IMPORTANT, "Accepting SNMP messages on " << snmpIncomingConn->local);
     else if (conn->fd == snmpOutgoingConn->fd)
         debugs(1, DBG_IMPORTANT, "Sending SNMP messages from " << snmpOutgoingConn->local);
     else
-        fatalf("Lost SNMP port (%d) on FD %d", (int)conn->local.GetPort(), conn->fd);
+        fatalf("Lost SNMP port (%d) on FD %d", (int)conn->local.port(), conn->fd);
 }
 
 void
 snmpClosePorts(void)
 {
     if (Comm::IsConnOpen(snmpIncomingConn)) {
@@ -609,23 +609,22 @@
 }
 
 static oid_ParseFn *
 snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen)
 {
     oid_ParseFn *Fn = NULL;
-    mib_tree_entry *mibTreeEntry = NULL, *nextoid = NULL;
     int count = 0;
 
     debugs(49, 5, "snmpTreeNext: Called");
 
     MemBuf tmp;
     debugs(49, 6, "snmpTreeNext: Current : " << snmpDebugOid(Current, CurrentLen, tmp));
 
-    mibTreeEntry = mib_tree_head;
+    mib_tree_entry *mibTreeEntry = mib_tree_head;
 
-    if (Current[count] == mibTreeEntry->name[count]) {
+    if (mibTreeEntry && Current[count] == mibTreeEntry->name[count]) {
         ++count;
 
         while ((mibTreeEntry) && (count < CurrentLen) && (!mibTreeEntry->parsefunction)) {
             mib_tree_entry *nextmibTreeEntry = snmpTreeEntry(Current[count], count, mibTreeEntry);
 
             if (!nextmibTreeEntry)
@@ -644,21 +643,20 @@
         return (Fn);
 
     if ((mibTreeEntry) && (mibTreeEntry->parsefunction)) {
         *NextLen = CurrentLen;
         *Next = (*mibTreeEntry->instancefunction) (Current, NextLen, mibTreeEntry, &Fn);
         if (*Next) {
-            MemBuf tmp;
             debugs(49, 6, "snmpTreeNext: Next : " << snmpDebugOid(*Next, *NextLen, tmp));
             return (Fn);
         }
     }
 
     if ((mibTreeEntry) && (mibTreeEntry->parsefunction)) {
         --count;
-        nextoid = snmpTreeSiblingEntry(Current[count], count, mibTreeEntry->parent);
+        mib_tree_entry *nextoid = snmpTreeSiblingEntry(Current[count], count, mibTreeEntry->parent);
         if (nextoid) {
             debugs(49, 5, "snmpTreeNext: Next OID found for sibling" << nextoid );
             mibTreeEntry = nextoid;
             ++count;
         } else {
             debugs(49, 5, "snmpTreeNext: Attempting to recurse up for next object");
@@ -688,26 +686,25 @@
     if (mibTreeEntry) {
         *NextLen = mibTreeEntry->len;
         *Next = (*mibTreeEntry->instancefunction) (mibTreeEntry->name, NextLen, mibTreeEntry, &Fn);
     }
 
     if (*Next) {
-        MemBuf tmp;
         debugs(49, 6, "snmpTreeNext: Next : " << snmpDebugOid(*Next, *NextLen, tmp));
         return (Fn);
     } else
         return NULL;
 }
 
 static oid *
 static_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
 {
     oid *instance = NULL;
     if (*len <= current->len) {
-        instance = (oid *)xmalloc(sizeof(name) * (*len + 1));
-        memcpy(instance, name, (sizeof(name) * *len));
+        instance = (oid *)xmalloc(sizeof(*name) * (*len + 1));
+        memcpy(instance, name, sizeof(*name) * (*len));
         instance[*len] = 0;
         *len += 1;
     }
     *Fn = current->parsefunction;
     return (instance);
 }
@@ -717,25 +714,25 @@
 {
     oid *instance = NULL;
     int identifier = 0, loop = 0;
     int index[TIME_INDEX_LEN] = {TIME_INDEX};
 
     if (*len <= current->len) {
-        instance = (oid *)xmalloc(sizeof(name) * (*len + 1));
-        memcpy(instance, name, (sizeof(name) * *len));
+        instance = (oid *)xmalloc(sizeof(*name) * (*len + 1));
+        memcpy(instance, name, sizeof(*name) * (*len));
         instance[*len] = *index;
         *len += 1;
     } else {
         identifier = name[*len - 1];
 
         while ((loop < TIME_INDEX_LEN) && (identifier != index[loop]))
             ++loop;
 
         if (loop < (TIME_INDEX_LEN - 1)) {
-            instance = (oid *)xmalloc(sizeof(name) * (*len));
-            memcpy(instance, name, (sizeof(name) * *len));
+            instance = (oid *)xmalloc(sizeof(*name) * (*len));
+            memcpy(instance, name, sizeof(*name) * (*len));
             instance[*len - 1] = index[++loop];
         }
     }
 
     *Fn = current->parsefunction;
     return (instance);
@@ -750,29 +747,32 @@
     if (peers == NULL) {
         debugs(49, 6, "snmp peer_Inst: No Peers.");
         current = current->parent->parent->parent->leaves[1];
         while ((current) && (!current->parsefunction))
             current = current->leaves[0];
 
+        if (!current)
+            return (instance);
+
         instance = client_Inst(current->name, len, current, Fn);
     } else if (*len <= current->len) {
         debugs(49, 6, "snmp peer_Inst: *len <= current->len ???");
-        instance = (oid *)xmalloc(sizeof(name) * ( *len + 1));
-        memcpy(instance, name, (sizeof(name) * *len));
+        instance = (oid *)xmalloc(sizeof(*name) * ( *len + 1));
+        memcpy(instance, name, sizeof(*name) * (*len));
         instance[*len] = 1 ;
         *len += 1;
     } else {
         int no = name[current->len] ;
         int i;
         // Note: This works because the Config.peers keeps its index according to its position.
         for ( i=0 ; peers && (i < no) ; peers = peers->next , ++i ) ;
 
         if (peers) {
             debugs(49, 6, "snmp peer_Inst: Encode peer #" << i);
-            instance = (oid *)xmalloc(sizeof(name) * (current->len + 1 ));
-            memcpy(instance, name, (sizeof(name) * current->len ));
+            instance = (oid *)xmalloc(sizeof(*name) * (current->len + 1 ));
+            memcpy(instance, name, (sizeof(*name) * current->len ));
             instance[current->len] = no + 1 ; // i.e. the next index on cache_peeer table.
         } else {
             debugs(49, 6, "snmp peer_Inst: We have " << i << " peers. Can't find #" << no);
             return (instance);
         }
     }
@@ -791,47 +791,47 @@
 
     if (*len <= current->len) {
         aux  = client_entry(NULL);
         if (aux)
             laddr = *aux;
         else
-            laddr.SetAnyAddr();
+            laddr.setAnyAddr();
 
-        if (laddr.IsIPv4())
+        if (laddr.isIPv4())
             size = sizeof(in_addr);
         else
             size = sizeof(in6_addr);
 
         debugs(49, 6, HERE << "len" << *len << ", current-len" << current->len << ", addr=" << laddr << ", size=" << size);
 
-        instance = (oid *)xmalloc(sizeof(name) * (*len + size ));
-        memcpy(instance, name, (sizeof(name) * (*len)));
+        instance = (oid *)xmalloc(sizeof(*name) * (*len + size ));
+        memcpy(instance, name, (sizeof(*name) * (*len)));
 
-        if ( !laddr.IsAnyAddr() ) {
+        if ( !laddr.isAnyAddr() ) {
             addr2oid(laddr, &instance[ *len]);  // the addr
             *len += size ;
         }
     } else {
         int shift = *len - current->len ; // i.e 4 or 16
         oid2addr(&name[*len - shift], laddr,shift);
         aux = client_entry(&laddr);
         if (aux)
             laddr = *aux;
         else
-            laddr.SetAnyAddr();
+            laddr.setAnyAddr();
 
-        if (!laddr.IsAnyAddr()) {
-            if (laddr.IsIPv4())
+        if (!laddr.isAnyAddr()) {
+            if (laddr.isIPv4())
                 newshift = sizeof(in_addr);
             else
                 newshift = sizeof(in6_addr);
 
             debugs(49, 6, HERE << "len" << *len << ", current-len" << current->len << ", addr=" << laddr << ", newshift=" << newshift);
 
-            instance = (oid *)xmalloc(sizeof(name) * (current->len +  newshift));
-            memcpy(instance, name, (sizeof(name) * (current->len)));
+            instance = (oid *)xmalloc(sizeof(*name) * (current->len +  newshift));
+            memcpy(instance, name, (sizeof(*name) * (current->len)));
             addr2oid(laddr, &instance[current->len]);  // the addr.
             *len = current->len + newshift ;
         }
     }
 
     *Fn = current->parsefunction;
@@ -943,32 +943,35 @@
     }
 
     xfree(name);
     return e;
 }
 
-int
+bool
 snmpCreateOidFromStr(const char *str, oid **name, int *nl)
 {
     char const *delim = ".";
-    char *p;
 
     *name = NULL;
     *nl = 0;
-    char *s = xstrdup(str);
-    char *s_ = s;
+    const char *s = str;
 
     /* Parse the OID string into oid bits */
-    while ( (p = strsep(&s_, delim)) != NULL) {
+    while (size_t len = strcspn(s, delim)) {
         *name = (oid*)xrealloc(*name, sizeof(oid) * ((*nl) + 1));
-        (*name)[*nl] = atoi(p);
+        (*name)[*nl] = atoi(s); // stops at the '.' delimiter
         ++(*nl);
+        // exit with true when the last octet has been parsed
+        if (s[len] == '\0')
+            return true;
+        s += len+1;
     }
 
-    xfree(s);
-    return 1;
+    // if we aborted before the lst octet was found, return false.
+    safe_free(name);
+    return false;
 }
 
 /*
  * Create an entry. Return a pointer to the newly created node, or NULL
  * on failure.
  */
@@ -1096,20 +1099,20 @@
 addr2oid(Ip::Address &addr, oid * Dest)
 {
     u_int i ;
     u_char *cp = NULL;
     struct in_addr i4addr;
     struct in6_addr i6addr;
-    oid code = addr.IsIPv6()? INETADDRESSTYPE_IPV6  : INETADDRESSTYPE_IPV4 ;
+    oid code = addr.isIPv6()? INETADDRESSTYPE_IPV6  : INETADDRESSTYPE_IPV4 ;
     u_int size = (code == INETADDRESSTYPE_IPV4) ? sizeof(struct in_addr):sizeof(struct in6_addr);
     //  Dest[0] = code ;
     if ( code == INETADDRESSTYPE_IPV4 ) {
-        addr.GetInAddr(i4addr);
+        addr.getInAddr(i4addr);
         cp = (u_char *) &(i4addr.s_addr);
     } else {
-        addr.GetInAddr(i6addr);
+        addr.getInAddr(i6addr);
         cp = (u_char *) &i6addr;
     }
     for ( i=0 ; i < size ; ++i) {
         // OID's are in network order
         Dest[i] = *cp;
         ++cp;
@@ -1152,13 +1155,13 @@
 #include "acl/StringData.h"
 
 class ACLSNMPCommunityStrategy : public ACLStrategy<char const *>
 {
 
 public:
-    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
     static ACLSNMPCommunityStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
     /* Not private to prevent brain dead g++ warnings about
      * private constructors with no friends */
     ACLSNMPCommunityStrategy(ACLSNMPCommunityStrategy const &);
 
@@ -1178,13 +1181,13 @@
 };
 
 ACL::Prototype ACLSNMPCommunity::RegistryProtoype(&ACLSNMPCommunity::RegistryEntry_, "snmp_community");
 ACLStrategised<char const *> ACLSNMPCommunity::RegistryEntry_(new ACLStringData, ACLSNMPCommunityStrategy::Instance(), "snmp_community");
 
 int
-ACLSNMPCommunityStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
+ACLSNMPCommunityStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
     return data->match (checklist->snmp_community);
 }
 
 ACLSNMPCommunityStrategy *
 ACLSNMPCommunityStrategy::Instance()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SquidConfig.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SquidConfig.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SquidConfig.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SquidConfig.h	2015-05-01 18:05:19.000000000 +0800
@@ -26,31 +26,29 @@
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
-#include "acl/AclAddress.h"
+#include "acl/forward.h"
+#include "base/RefCount.h"
 #include "ClientDelayConfig.h"
 #include "DelayConfig.h"
 #include "HelperChildConfig.h"
 #include "HttpHeaderTools.h"
 #include "icmp/IcmpConfig.h"
 #include "ip/Address.h"
-#include "RefCount.h"
+#include "Notes.h"
 #include "YesNoNone.h"
 
 #if USE_SSL
 #include <openssl/ssl.h>
 class sslproxy_cert_sign;
 class sslproxy_cert_adapt;
 #endif
 
-class acl_access;
-class AclSizeLimit;
-class AclDenyInfoList;
 namespace Mgr
 {
 class ActionPasswordList;
 } // namespace Mgr
 class CustomLog;
 class CpuAffinityMap;
@@ -198,12 +196,13 @@
     struct {
 #if USE_DNSHELPER
         char *dnsserver;
 #endif
 
         wordlist *redirect;
+        wordlist *store_id;
 #if USE_UNLINKD
 
         char *unlinkd;
 #endif
 
         char *diskd;
@@ -215,12 +214,13 @@
     } Program;
 #if USE_DNSHELPER
     HelperChildConfig dnsChildren;
 #endif
 
     HelperChildConfig redirectChildren;
+    HelperChildConfig storeIdChildren;
     time_t authenticateGCInterval;
     time_t authenticateTTL;
     time_t authenticateIpTTL;
 
     struct {
         char *surrogate_id;
@@ -313,24 +313,24 @@
         int offline;
         int redir_rewrites_host;
         int prefer_direct;
         int nonhierarchical_direct;
         int strip_query_terms;
         int redirector_bypass;
+        int store_id_bypass;
         int ignore_unknown_nameservers;
         int client_pconns;
         int server_pconns;
         int error_pconns;
 #if USE_CACHE_DIGESTS
 
         int digest_generation;
 #endif
 
         int ie_refresh;
         int vary_ignore_expire;
-        int pipeline_prefetch;
         int surrogate_is_remote;
         int request_entities;
         int detect_broken_server_pconns;
         int balance_on_multiple_ip;
         int relaxed_header_parser;
         int check_hostnames;
@@ -352,14 +352,17 @@
 
         int WIN32_IpAddrChangeMonitor;
         int memory_cache_first;
         int memory_cache_disk;
         int hostStrictVerify;
         int client_dst_passthru;
+        int dns_mdns;
     } onoff;
 
+    int pipeline_max_prefetch;
+
     int forward_max_tries;
     int connect_retries;
 
     class ACL *aclList;
 
     struct {
@@ -368,21 +371,22 @@
         acl_access *icp;
         acl_access *miss;
         acl_access *NeverDirect;
         acl_access *AlwaysDirect;
         acl_access *ASlists;
         acl_access *noCache;
-        acl_access *log;
+        acl_access *stats_collection;
 #if SQUID_SNMP
 
         acl_access *snmp;
 #endif
 #if USE_HTTP_VIOLATIONS
         acl_access *brokenPosts;
 #endif
         acl_access *redirector;
+        acl_access *store_id;
         acl_access *reply;
         AclAddress *outgoing_address;
 #if USE_HTCP
 
         acl_access *htcp;
         acl_access *htcp_clr;
@@ -392,15 +396,15 @@
         acl_access *ssl_bump;
 #endif
 #if FOLLOW_X_FORWARDED_FOR
         acl_access *followXFF;
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
-#if ICAP_CLIENT
-        acl_access* icap;
-#endif
+        /// spoof_client_ip squid.conf acl.
+        /// nil unless configured
+        acl_access* spoof_client_ip;
     } accessList;
     AclDenyInfoList *denyInfoList;
 
     struct {
         size_t list_width;
         int list_wrap;
@@ -473,12 +477,14 @@
     /// request_header_access and request_header_replace
     HeaderManglers *request_header_access;
     /// reply_header_access and reply_header_replace
     HeaderManglers *reply_header_access;
     ///request_header_add access list
     HeaderWithAclList *request_header_add;
+    ///note
+    Notes notes;
     char *coredump_dir;
     char *chroot_dir;
 #if USE_CACHE_DIGESTS
 
     struct {
         int bits_per_entry;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SquidDns.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SquidDns.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SquidDns.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SquidDns.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,9 +1,13 @@
 #ifndef SQUID_DNS_H
 #define SQUID_DNS_H
 
+#if USE_DNSHELPER
+#include "helper.h"
+#endif
+
 namespace Ip
 {
 class Address;
 }
 
 // generic DNS API
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SquidString.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SquidString.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SquidString.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SquidString.h	2015-05-01 18:05:19.000000000 +0800
@@ -84,13 +84,13 @@
     _SQUID_INLINE_ String();
     String(char const *);
     String(String const &);
     ~String();
 
     typedef size_t size_type; //storage size intentionally unspecified
-    const static size_type npos = std::string::npos;
+    const static size_type npos = static_cast<size_type>(-1);
 
     String &operator =(char const *);
     String &operator =(String const &);
     bool operator ==(String const &) const;
     bool operator !=(String const &) const;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/certificate_db.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/certificate_db.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/certificate_db.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/certificate_db.cc	2015-05-01 18:05:19.000000000 +0800
@@ -44,19 +44,21 @@
 {
 
 #if _SQUID_WINDOWS_
     hFile = CreateFile(TEXT(filename.c_str()), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
     if (hFile == INVALID_HANDLE_VALUE)
 #else
-    fd = open(filename.c_str(), 0);
+    fd = open(filename.c_str(), O_RDWR);
     if (fd == -1)
 #endif
         throw std::runtime_error("Failed to open file " + filename);
 
 #if _SQUID_WINDOWS_
     if (!LockFile(hFile, 0, 0, 1, 0))
+#elif _SQUID_SOLARIS_
+    if (lockf(fd, F_LOCK, 0) != 0)
 #else
     if (flock(fd, LOCK_EX) != 0)
 #endif
         throw std::runtime_error("Failed to get a lock of " + filename);
 }
 
@@ -67,13 +69,17 @@
         UnlockFile(hFile, 0, 0, 1, 0);
         CloseHandle(hFile);
         hFile = INVALID_HANDLE_VALUE;
     }
 #else
     if (fd != -1) {
+#if _SQUID_SOLARIS_
+        lockf(fd, F_ULOCK, 0);
+#else
         flock(fd, LOCK_UN);
+#endif
         close(fd);
         fd = -1;
     }
 #endif
     else
         throw std::runtime_error("Lock is already unlocked for " + filename);
@@ -242,13 +248,13 @@
         :  db_path(aDb_path),
         db_full(aDb_path + "/" + db_file),
         cert_full(aDb_path + "/" + cert_dir),
         size_full(aDb_path + "/" + size_file),
         db(NULL),
         max_db_size(aMax_db_size),
-        fs_block_size(aFs_block_size),
+        fs_block_size((aFs_block_size ? aFs_block_size : 2048)),
         dbLock(db_full),
         enabled_disk_store(true) {
     if (db_path.empty() && !max_db_size)
         enabled_disk_store = false;
     else if ((db_path.empty() && max_db_size) || (!db_path.empty() && !max_db_size))
         throw std::runtime_error("ssl_crtd is missing the required parameter. There should be -s and -M parameters together.");
@@ -378,15 +384,40 @@
         throw std::runtime_error("Cannot open " + size_full + " to open");
     std::ofstream db(db_full.c_str());
     if (!db)
         throw std::runtime_error("Cannot open " + db_full + " to open");
 }
 
-void Ssl::CertificateDb::check(std::string const & db_path, size_t max_db_size) {
-    CertificateDb db(db_path, max_db_size, 0);
+void Ssl::CertificateDb::check(std::string const & db_path, size_t max_db_size, size_t fs_block_size) {
+    CertificateDb db(db_path, max_db_size, fs_block_size);
     db.load();
+
+    // Call readSize to force rebuild size file in the case it is corrupted
+    (void)db.readSize();
+}
+
+size_t Ssl::CertificateDb::rebuildSize()
+{
+    size_t dbSize = 0;
+#if SQUID_SSLTXTDB_PSTRINGDATA
+    for (int i = 0; i < sk_OPENSSL_PSTRING_num(db.get()->data); ++i) {
+#if SQUID_STACKOF_PSTRINGDATA_HACK
+        const char ** current_row = ((const char **)sk_value(CHECKED_STACK_OF(OPENSSL_PSTRING, db.get()->data), i));
+#else
+        const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db.get()->data, i));
+#endif
+#else
+    for (int i = 0; i < sk_num(db.get()->data); ++i) {
+        const char ** current_row = ((const char **)sk_value(db.get()->data, i));
+#endif
+        const std::string filename(cert_full + "/" + current_row[cnlSerial] + ".pem");
+        const size_t fSize = getFileSize(filename);
+        dbSize += fSize;        
+    }
+    writeSize(dbSize);
+    return dbSize;
 }
 
 bool Ssl::CertificateDb::pure_find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey) {
     if (!db)
         return false;
 
@@ -405,43 +436,49 @@
     readCertAndPrivateKeyFromFiles(cert, pkey, filename.c_str(), NULL);
     if (!cert || !pkey)
         return false;
     return true;
 }
 
-size_t Ssl::CertificateDb::size() const {
+size_t Ssl::CertificateDb::size() {
     return readSize();
 }
 
 void Ssl::CertificateDb::addSize(std::string const & filename) {
-    writeSize(readSize() + getFileSize(filename));
+    // readSize will rebuild 'size' file if missing or it is corrupted
+    size_t dbSize = readSize();
+    dbSize += getFileSize(filename);
+    writeSize(dbSize);
 }
 
 void Ssl::CertificateDb::subSize(std::string const & filename) {
-    writeSize(readSize() - getFileSize(filename));
+    // readSize will rebuild 'size' file if missing or it is corrupted
+    size_t dbSize = readSize();
+    dbSize -= getFileSize(filename);
+    writeSize(dbSize);
 }
 
-size_t Ssl::CertificateDb::readSize() const {
-    std::ifstream size_file(size_full.c_str());
-    if (!size_file && enabled_disk_store)
-        throw std::runtime_error("cannot open for reading: " + size_full);
+size_t Ssl::CertificateDb::readSize() {
+    std::ifstream ifstr(size_full.c_str());
     size_t db_size = 0;
-    if (!(size_file >> db_size))
-        throw std::runtime_error("error while reading " + size_full);
+    if (!ifstr || !(ifstr >> db_size))
+        return rebuildSize();
     return db_size;
 }
 
 void Ssl::CertificateDb::writeSize(size_t db_size) {
-    std::ofstream size_file(size_full.c_str());
-    if (!size_file && enabled_disk_store)
+    std::ofstream ofstr(size_full.c_str());
+    if (!ofstr)
         throw std::runtime_error("cannot write \"" + size_full + "\" file");
-    size_file << db_size;
+    ofstr << db_size;
 }
 
 size_t Ssl::CertificateDb::getFileSize(std::string const & filename) {
     std::ifstream file(filename.c_str(), std::ios::binary);
+    if (!file)
+        return 0;
     file.seekg(0, std::ios_base::end);
     size_t file_size = file.tellg();
     return ((file_size + fs_block_size - 1) / fs_block_size) * fs_block_size;
 }
 
 void Ssl::CertificateDb::load() {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/certificate_db.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/certificate_db.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/certificate_db.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/certificate_db.h	2015-05-01 18:05:19.000000000 +0800
@@ -96,25 +96,26 @@
     bool purgeCert(std::string const & key);
     /// Save certificate to disk.
     bool addCertAndPrivateKey(Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey, std::string const & useName);
     /// Create and initialize a database  under the  db_path
     static void create(std::string const & db_path);
     /// Check the database stored under the db_path.
-    static void check(std::string const & db_path, size_t max_db_size);
+    static void check(std::string const & db_path, size_t max_db_size, size_t fs_block_size);
     bool IsEnabledDiskStore() const; ///< Check enabled of dist store.
 private:
     void load(); ///< Load db from disk.
     void save(); ///< Save db to disk.
-    size_t size() const; ///< Get db size on disk in bytes.
+    size_t size(); ///< Get db size on disk in bytes.
     /// Increase db size by the given file size and update size_file
     void addSize(std::string const & filename);
     /// Decrease db size by the given file size and update size_file
     void subSize(std::string const & filename);
-    size_t readSize() const; ///< Read size from file size_file
+    size_t readSize(); ///< Read size from file size_file
     void writeSize(size_t db_size); ///< Write size to file size_file.
     size_t getFileSize(std::string const & filename); ///< get file size on disk.
+    size_t rebuildSize(); ///< Rebuild size_file
     /// Only find certificate in current db and return it.
     bool pure_find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey);
 
     void deleteRow(const char **row, int rowIndex); ///< Delete a row from TXT_DB
     bool deleteInvalidCertificate(); ///< Delete invalid certificate.
     bool deleteOldestCertificate(); ///< Delete oldest certificate.
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl: cert_validate_message.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl: cert_validate_message.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/Config.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/Config.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/Config.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/Config.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,19 +1,21 @@
 #include "squid.h"
 #include "ssl/Config.h"
 
 Ssl::Config Ssl::TheConfig;
 
-Ssl::Config::Config()
+Ssl::Config::Config():
 #if USE_SSL_CRTD
-        :
-        ssl_crtd(NULL)
+        ssl_crtd(NULL),
 #endif
+        ssl_crt_validator(NULL)
 {
+    ssl_crt_validator_Children.concurrency = 1;
 }
 
 Ssl::Config::~Config()
 {
 #if USE_SSL_CRTD
     xfree(ssl_crtd);
 #endif
+    xfree(ssl_crt_validator);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/Config.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/Config.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/Config.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/Config.h	2015-05-01 18:05:19.000000000 +0800
@@ -11,12 +11,14 @@
 public:
 #if USE_SSL_CRTD
     char *ssl_crtd; ///< Name of external ssl_crtd application.
     /// The number of processes spawn for ssl_crtd.
     HelperChildConfig ssl_crtdChildren;
 #endif
+    char *ssl_crt_validator;
+    HelperChildConfig ssl_crt_validator_Children;
     Config();
     ~Config();
 private:
     Config(const Config &); // not implemented
     Config &operator =(const Config &); // not implemented
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/context_storage.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/context_storage.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/context_storage.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/context_storage.cc	2015-05-01 18:05:19.000000000 +0800
@@ -7,20 +7,20 @@
 #include <limits>
 #endif
 #if USE_SSL
 #include <openssl/ssl.h>
 #endif
 
-Ssl::CertificateStorageAction::CertificateStorageAction(const Mgr::Command::Pointer &cmd)
-        :   Mgr::Action(cmd)
+Ssl::CertificateStorageAction::CertificateStorageAction(const Mgr::Command::Pointer &aCmd)
+        :   Mgr::Action(aCmd)
 {}
 
 Ssl::CertificateStorageAction::Pointer
-Ssl::CertificateStorageAction::Create(const Mgr::Command::Pointer &cmd)
+Ssl::CertificateStorageAction::Create(const Mgr::Command::Pointer &aCmd)
 {
-    return new CertificateStorageAction(cmd);
+    return new CertificateStorageAction(aCmd);
 }
 
 void Ssl::CertificateStorageAction::dump (StoreEntry *sentry)
 {
     StoreEntryStream stream(sentry);
     const char delimiter = '\t';
@@ -31,99 +31,22 @@
     stream << "Port" << delimiter << "Max mem(KB)" << delimiter << "Cert number" << delimiter << "KB/cert" << delimiter << "Mem used(KB)" << delimiter << "Mem free(KB)" << endString;
 
     // Add info for each port.
     for (std::map<Ip::Address, LocalContextStorage *>::iterator i = TheGlobalContextStorage.storage.begin(); i != TheGlobalContextStorage.storage.end(); ++i) {
         stream << i->first << delimiter;
         LocalContextStorage & ssl_store_policy(*(i->second));
-        stream << ssl_store_policy.max_memory / 1024 << delimiter;
-        stream << ssl_store_policy.memory_used / SSL_CTX_SIZE << delimiter;
+        stream << ssl_store_policy.memLimit() / 1024 << delimiter;
+        stream << ssl_store_policy.entries() << delimiter;
         stream << SSL_CTX_SIZE / 1024 << delimiter;
-        stream << ssl_store_policy.memory_used / 1024 << delimiter;
-        stream << (ssl_store_policy.max_memory - ssl_store_policy.memory_used) / 1024 << endString;
+        stream << ssl_store_policy.size() / 1024 << delimiter;
+        stream << ssl_store_policy.freeMem() / 1024 << endString;
     }
     stream << endString;
     stream.flush();
 }
 
-Ssl::LocalContextStorage::LocalContextStorage(size_t aMax_memory)
-        :   max_memory(aMax_memory), memory_used(0)
-{}
-
-Ssl::LocalContextStorage::~LocalContextStorage()
-{
-    for (QueueIterator i = lru_queue.begin(); i != lru_queue.end(); ++i) {
-        delete *i;
-    }
-}
-
-SSL_CTX * Ssl::LocalContextStorage::add(const char * host_name, SSL_CTX * ssl_ctx)
-{
-    if (max_memory < SSL_CTX_SIZE) {
-        return NULL;
-    }
-    remove(host_name);
-    while (SSL_CTX_SIZE + memory_used > max_memory) {
-        purgeOne();
-    }
-    lru_queue.push_front(new Item(ssl_ctx, host_name));
-    storage.insert(MapPair(host_name, lru_queue.begin()));
-    memory_used += SSL_CTX_SIZE;
-    return ssl_ctx;
-}
-
-SSL_CTX * Ssl::LocalContextStorage::find(char const * host_name)
-{
-    MapIterator i = storage.find(host_name);
-    if (i == storage.end()) {
-        return NULL;
-    }
-    lru_queue.push_front(*(i->second));
-    lru_queue.erase(i->second);
-    i->second = lru_queue.begin();
-    return (*lru_queue.begin())->ssl_ctx;
-}
-
-void Ssl::LocalContextStorage::remove(char const * host_name)
-{
-    deleteAt(storage.find(host_name));
-}
-
-void Ssl::LocalContextStorage::purgeOne()
-{
-    QueueIterator i = lru_queue.end();
-    --i;
-    if (i != lru_queue.end()) {
-        remove((*i)->host_name.c_str());
-    }
-}
-
-void Ssl::LocalContextStorage::deleteAt(LocalContextStorage::MapIterator i)
-{
-    if (i != storage.end()) {
-
-        delete *(i->second);
-        lru_queue.erase(i->second);
-        storage.erase(i);
-        memory_used -= SSL_CTX_SIZE;
-    }
-}
-
-void Ssl::LocalContextStorage::SetSize(size_t aMax_memory)
-{
-    max_memory = aMax_memory;
-}
-
-Ssl::LocalContextStorage::Item::Item(SSL_CTX * aSsl_ctx, std::string const & aName)
-        :   ssl_ctx(aSsl_ctx), host_name(aName)
-{}
-
-Ssl::LocalContextStorage::Item::~Item()
-{
-    SSL_CTX_free(ssl_ctx);
-}
-
 ///////////////////////////////////////////////////////
 
 Ssl::GlobalContextStorage::GlobalContextStorage()
         :   reconfiguring(true)
 {
     RegisterAction("cached_ssl_cert", "Statistic of cached generated ssl certificates", &CertificateStorageAction::Create, 0, 1);
@@ -139,44 +62,48 @@
 void Ssl::GlobalContextStorage::addLocalStorage(Ip::Address const & address, size_t size_of_store)
 {
     assert(reconfiguring);
     configureStorage.insert(std::pair<Ip::Address, size_t>(address, size_of_store));
 }
 
-Ssl::LocalContextStorage & Ssl::GlobalContextStorage::getLocalStorage(Ip::Address const & address)
+Ssl::LocalContextStorage *Ssl::GlobalContextStorage::getLocalStorage(Ip::Address const & address)
 {
     reconfigureFinish();
     std::map<Ip::Address, LocalContextStorage *>::iterator i = storage.find(address);
-    assert (i != storage.end());
-    return *(i->second);
+
+    if (i == storage.end())
+        return NULL;
+    else
+        return i->second;
 }
 
 void Ssl::GlobalContextStorage::reconfigureStart()
 {
+    configureStorage.clear();
     reconfiguring = true;
 }
 
 void Ssl::GlobalContextStorage::reconfigureFinish()
 {
     if (reconfiguring) {
         reconfiguring = false;
 
         // remove or change old local storages.
         for (std::map<Ip::Address, LocalContextStorage *>::iterator i = storage.begin(); i != storage.end(); ++i) {
             std::map<Ip::Address, size_t>::iterator conf_i = configureStorage.find(i->first);
-            if (conf_i == configureStorage.end()) {
+            if (conf_i == configureStorage.end() || conf_i->second <= 0) {
                 storage.erase(i);
             } else {
-                i->second->SetSize(conf_i->second);
+                i->second->setMemLimit(conf_i->second);
             }
         }
 
         // add new local storages.
         for (std::map<Ip::Address, size_t>::iterator conf_i = configureStorage.begin(); conf_i != configureStorage.end(); ++conf_i ) {
-            if (storage.find(conf_i->first) == storage.end()) {
-                storage.insert(std::pair<Ip::Address, LocalContextStorage *>(conf_i->first, new LocalContextStorage(conf_i->second)));
+            if (storage.find(conf_i->first) == storage.end() && conf_i->second > 0) {
+                storage.insert(std::pair<Ip::Address, LocalContextStorage *>(conf_i->first, new LocalContextStorage(-1, conf_i->second)));
             }
         }
     }
 }
 
 Ssl::GlobalContextStorage Ssl::TheGlobalContextStorage;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/context_storage.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/context_storage.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/context_storage.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/context_storage.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,16 +1,18 @@
 #ifndef SQUID_SSL_CONTEXT_STORAGE_H
 #define SQUID_SSL_CONTEXT_STORAGE_H
 
 #if USE_SSL
 
+#include "base/LruMap.h"
 #include "SquidTime.h"
 #include "CacheManager.h"
 #include "ip/Address.h"
 #include "mgr/Action.h"
 #include "mgr/Command.h"
+#include "ssl/gadgets.h"
 #if HAVE_MAP
 #include <map>
 #endif
 #if HAVE_LIST
 #include <list>
 #endif
@@ -35,71 +37,25 @@
      * We do not support aggregation of information across workers
      * TODO: aggregate these stats
      */
     virtual bool aggregatable() const { return false; }
 };
 
-/**
- * Memory cache for store generated SSL context. Enforces total size limits
- * using an LRU algorithm.
- */
-class LocalContextStorage
-{
-    friend class CertificateStorageAction;
-public:
-    /// Cache item is an (SSL_CTX, host name) tuple.
-    class Item
-    {
-    public:
-        Item(SSL_CTX * aSsl_ctx, std::string const & aName);
-        ~Item();
-    public:
-        SSL_CTX * ssl_ctx; ///< The SSL context.
-        std::string host_name; ///< The host name of the SSL context.
-    };
-
-    typedef std::list<Item *> Queue;
-    typedef Queue::iterator QueueIterator;
-
-    /// host_name:queue_item mapping for fast lookups by host name
-    typedef std::map<std::string, QueueIterator> Map;
-    typedef Map::iterator MapIterator;
-    typedef std::pair<std::string, QueueIterator> MapPair;
-
-    LocalContextStorage(size_t aMax_memory);
-    ~LocalContextStorage();
-    /// Set maximum memory size for this storage.
-    void SetSize(size_t aMax_memory);
-    /// Return a pointer to the  added ssl_ctx or NULL if fails (eg. max cache size equal 0).
-    SSL_CTX * add(char const * host_name, SSL_CTX * ssl_ctx);
-    /// Find SSL_CTX in storage by host name. Lru queue will be updated.
-    SSL_CTX * find(char const * host_name);
-    void remove(char const * host_name); ///< Delete the SSL context by hostname
-
-private:
-    void purgeOne(); ///< Delete oldest object.
-    /// Delete object by iterator. It is used in deletePurge() and remove(...) methods.
-    void deleteAt(MapIterator i);
-
-    size_t max_memory; ///< Max cache size.
-    size_t memory_used; ///< Used cache size.
-    Map storage; ///< The hostnames/SSL_CTX * pairs
-    Queue lru_queue; ///< LRU cache index
-};
+typedef LruMap<SSL_CTX_Pointer, SSL_CTX_SIZE> LocalContextStorage;
 
 /// Class for storing/manipulating LocalContextStorage per local listening address/port.
 class GlobalContextStorage
 {
     friend class CertificateStorageAction;
 public:
     GlobalContextStorage();
     ~GlobalContextStorage();
     /// Create new SSL context storage for the local listening address/port.
     void addLocalStorage(Ip::Address const & address, size_t size_of_store);
     /// Return the local storage for the given listening address/port.
-    LocalContextStorage & getLocalStorage(Ip::Address const & address);
+    LocalContextStorage *getLocalStorage(Ip::Address const & address);
     /// When reconfigring should be called this method.
     void reconfigureStart();
 private:
     /// Called by getLocalStorage method
     void reconfigureFinish();
     bool reconfiguring; ///< True if system reconfiguring now.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/crtd_message.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/crtd_message.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/crtd_message.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/crtd_message.cc	2015-05-01 18:05:19.000000000 +0800
@@ -8,14 +8,14 @@
 #include <cstring>
 #endif
 #if HAVE_STDEXCEPT
 #include <stdexcept>
 #endif
 
-Ssl::CrtdMessage::CrtdMessage()
-        :   body_size(0), state(BEFORE_CODE)
+Ssl::CrtdMessage::CrtdMessage(MessageKind kind)
+        :   body_size(0), state(kind == REPLY ? BEFORE_LENGTH: BEFORE_CODE)
 {}
 
 Ssl::CrtdMessage::ParseResult Ssl::CrtdMessage::parse(const char * buffer, size_t len)
 {
     char const *current_pos = buffer;
     while (current_pos != buffer + len && state != END) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/crtd_message.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/crtd_message.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/crtd_message.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/crtd_message.h	2015-05-01 18:05:19.000000000 +0800
@@ -24,13 +24,17 @@
     /// Parse result codes.
     enum ParseResult {
         OK,
         INCOMPLETE,
         ERROR
     };
-    CrtdMessage();
+    enum MessageKind {
+        REPLY,
+        REQUEST
+    };
+    CrtdMessage(MessageKind kind);
     /**Parse buffer of length len
      \retval OK          if parsing completes
      \retval INCOMPLETE  if more data required
      \retval ERROR       if there is an error.
      */
     ParseResult parse(const char * buffer, size_t len);
@@ -73,13 +77,13 @@
     /// Parameter name for passing SetValidBefore cert adaptation variable
     static const std::string param_SetValidBefore;
     /// Parameter name for passing SetCommonName cert adaptation variable
     static const std::string param_SetCommonName;
     /// Parameter name for passing signing algorithm
     static const std::string param_Sign;
-private:
+protected:
     enum ParseState {
         BEFORE_CODE,
         CODE,
         BEFORE_LENGTH,
         LENGTH,
         BEFORE_BODY,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ErrorDetail.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ErrorDetail.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ErrorDetail.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ErrorDetail.cc	2015-05-01 18:05:19.000000000 +0800
@@ -16,14 +16,16 @@
 static const char *SslErrorDetailDefaultStr = "SSL handshake error (%err_name)";
 //Use std::map to optimize search
 typedef std::map<Ssl::ssl_error_t, const SslErrorEntry *> SslErrors;
 SslErrors TheSslErrors;
 
 static SslErrorEntry TheSslErrorArray[] = {
+    {SQUID_X509_V_ERR_INFINITE_VALIDATION,
+        "SQUID_X509_V_ERR_INFINITE_VALIDATION"},
     {SQUID_X509_V_ERR_CERT_CHANGE,
-        "SQUID_X509_V_ERR_CERT_CHANGE"},
+     "SQUID_X509_V_ERR_CERT_CHANGE"},
     {SQUID_ERR_SSL_HANDSHAKE,
      "SQUID_ERR_SSL_HANDSHAKE"},
     {SQUID_X509_V_ERR_DOMAIN_MISMATCH,
      "SQUID_X509_V_ERR_DOMAIN_MISMATCH"},
     {X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT,
      "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT"},
@@ -496,13 +498,15 @@
         return err;
     return "[Not available]";
 }
 
 const char *Ssl::ErrorDetail::err_lib_error() const
 {
-    if (lib_error_no != SSL_ERROR_NONE)
+    if (errReason.defined())
+        return errReason.termedBuf();
+    else if (lib_error_no != SSL_ERROR_NONE)
         return ERR_error_string(lib_error_no, NULL);
     else
         return "[No Error]";
 }
 
 /**
@@ -546,13 +550,13 @@
 {
     char const *s = NULL;
     char const *p;
     char const *t;
     int code_len = 0;
 
-    if (ErrorDetailsManager::GetInstance().getErrorDetail(error_no, request.raw(), detailEntry))
+    if (ErrorDetailsManager::GetInstance().getErrorDetail(error_no, request, detailEntry))
         s = detailEntry.detail.termedBuf();
 
     if (!s)
         s = SslErrorDetailDefaultStr;
 
     assert(s);
@@ -572,13 +576,13 @@
 {
     if (!errDetailStr.defined())
         buildDetail();
     return errDetailStr;
 }
 
-Ssl::ErrorDetail::ErrorDetail( Ssl::ssl_error_t err_no, X509 *cert, X509 *broken): error_no (err_no), lib_error_no(SSL_ERROR_NONE)
+Ssl::ErrorDetail::ErrorDetail( Ssl::ssl_error_t err_no, X509 *cert, X509 *broken, const char *aReason): error_no (err_no), lib_error_no(SSL_ERROR_NONE), errReason(aReason)
 {
     if (cert)
         peer_cert.resetAndLock(cert);
 
     if (broken)
         broken_cert.resetAndLock(broken);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ErrorDetail.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ErrorDetail.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ErrorDetail.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ErrorDetail.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,14 +1,12 @@
 #ifndef _SQUID_SSL_ERROR_DETAIL_H
 #define _SQUID_SSL_ERROR_DETAIL_H
 
 #include "err_detail_type.h"
-#include "HttpRequest.h"
 #include "ErrorDetailManager.h"
-#include "ssl/support.h"
-#include "ssl/gadgets.h"
+#include "HttpRequest.h"
 
 #if HAVE_OPENSSL_SSL_H
 #include <openssl/ssl.h>
 #endif
 
 namespace Ssl
@@ -54,13 +52,13 @@
  * end user.
  */
 class ErrorDetail
 {
 public:
     // if broken certificate is nil, the peer certificate is broken
-    ErrorDetail(ssl_error_t err_no, X509 *peer, X509 *broken);
+    ErrorDetail(ssl_error_t err_no, X509 *peer, X509 *broken, const char *aReason = NULL);
     ErrorDetail(ErrorDetail const &);
     const String &toString() const;  ///< An error detail string to embed in squid error pages
     void useRequest(HttpRequest *aRequest) { if (aRequest != NULL) request = aRequest;}
     /// The error name to embed in squid error pages
     const char *errorName() const {return err_code();}
     /// The error no
@@ -98,12 +96,13 @@
 
     mutable String errDetailStr; ///< Caches the error detail message
     ssl_error_t error_no;   ///< The error code
     unsigned long lib_error_no; ///< low-level error returned by OpenSSL ERR_get_error(3SSL)
     X509_Pointer peer_cert; ///< A pointer to the peer certificate
     X509_Pointer broken_cert; ///< A pointer to the broken certificate (peer or intermediate)
+    String errReason; ///< A custom reason for error, else retrieved from OpenSSL.
     mutable ErrorDetailEntry detailEntry;
     HttpRequest::Pointer request;
 };
 
 }//namespace Ssl
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ErrorDetailManager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ErrorDetailManager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ErrorDetailManager.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ErrorDetailManager.cc	2015-05-01 18:05:19.000000000 +0800
@@ -112,30 +112,30 @@
     assert(lang);
     if (cache.find(lang) == cache.end())
         cache[lang] = errorDetails;
 }
 
 bool
-Ssl::ErrorDetailsManager::getErrorDetail(Ssl::ssl_error_t value, HttpRequest *request, ErrorDetailEntry &entry)
+Ssl::ErrorDetailsManager::getErrorDetail(Ssl::ssl_error_t value, const HttpRequest::Pointer &request, ErrorDetailEntry &entry)
 {
 #if USE_ERR_LOCALES
     String hdr;
-    if (request && request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr)) {
+    if (request != NULL && request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr)) {
         ErrorDetailsList::Pointer errDetails = NULL;
         //Try to retrieve from cache
         size_t pos = 0;
         char lang[256];
         // Get the first ellement of the Accept-Language header
         strHdrAcptLangGetItem(hdr, lang, 256, pos);
         errDetails = getCachedDetails(lang); // search in cache
 
         if (!errDetails) { // Else try to load from disk
             debugs(83, 8, HERE << "Creating new ErrDetailList to read from disk");
             errDetails = new ErrorDetailsList();
             ErrorDetailFile detailTmpl(errDetails);
-            if (detailTmpl.loadFor(request)) {
+            if (detailTmpl.loadFor(request.getRaw())) {
                 if (detailTmpl.language()) {
                     debugs(83, 8, HERE << "Found details on disk for language " << detailTmpl.language());
                     errDetails->errLanguage = detailTmpl.language();
                     cacheDetails(errDetails);
                 }
             }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ErrorDetailManager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ErrorDetailManager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ErrorDetailManager.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ErrorDetailManager.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,12 @@
 #ifndef _SQUID_SSL_ERRORDETAILMANAGER_H
 #define _SQUID_SSL_ERRORDETAILMANAGER_H
 
-#include "ssl/gadgets.h"
+#include "base/RefCount.h"
+#include "HttpRequest.h"
 #include "ssl/support.h"
-#include "RefCount.h"
 #include "SquidString.h"
 
 #if HAVE_MAP
 #include <map>
 #endif
 #if HAVE_STRING
@@ -66,13 +66,13 @@
      * the default error details.
      * \param vale the error code
      * \param request the current HTTP request.
      * \param entry where to store error details
      * \return true on success, false otherwise
      */
-    bool getErrorDetail(Ssl::ssl_error_t value, HttpRequest *request, ErrorDetailEntry &entry);
+    bool getErrorDetail(Ssl::ssl_error_t value, const HttpRequest::Pointer &request, ErrorDetailEntry &entry);
     const char *getDefaultErrorDescr(Ssl::ssl_error_t value); ///< the default error description for a given error
     const char *getDefaultErrorDetail(Ssl::ssl_error_t value); ///< the default error details for a given error
 
 private:
     /// Return cached error details list for a given language if exist
     ErrorDetailsList::Pointer getCachedDetails(const char *lang);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/gadgets.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/gadgets.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/gadgets.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/gadgets.cc	2015-05-01 18:05:19.000000000 +0800
@@ -246,35 +246,85 @@
         certKey.append(certSignAlgorithm(signAlgorithm));
     }
 
     return certKey;
 }
 
-// Copy certificate extensions from cert to mimicCert.
+/// Copy certificate extensions from cert to mimicCert.
+/// Returns the number of extensions copied.
 // Currently only extensions which are reported by the users that required are
 // mimicked. More safe to mimic extensions would be added here if users request
 // them.
-static void
+static int
 mimicExtensions(Ssl::X509_Pointer & cert, Ssl::X509_Pointer const & mimicCert)
 {
     static int extensions[]= {
         NID_key_usage,
         NID_ext_key_usage,
         NID_basic_constraints,
         0
     };
 
+    // key usage bit names
+    enum {
+        DigitalSignature,
+        NonRepudiation,
+        KeyEncipherment, // NSS requires for RSA but not EC
+        DataEncipherment,
+        KeyAgreement,
+        KeyCertificateSign,
+        CRLSign,
+        EncipherOnly,
+        DecipherOnly
+    };
+
+    int mimicAlgo = OBJ_obj2nid(mimicCert.get()->cert_info->key->algor->algorithm);
+
+    int added = 0;
     int nid;
     for (int i = 0; (nid = extensions[i]) != 0; ++i) {
         const int pos = X509_get_ext_by_NID(mimicCert.get(), nid, -1);
-        if (X509_EXTENSION *ext = X509_get_ext(mimicCert.get(), pos))
-            X509_add_ext(cert.get(), ext, -1);
+        if (X509_EXTENSION *ext = X509_get_ext(mimicCert.get(), pos)) {
+            // Mimic extension exactly.
+            if (X509_add_ext(cert.get(), ext, -1))
+                ++added;
+            if ( nid == NID_key_usage && mimicAlgo != NID_rsaEncryption ) {
+                // NSS does not requre the KeyEncipherment flag on EC keys
+                // but it does require it for RSA keys.  Since ssl-bump
+                // substitutes RSA keys for EC ones, we need to ensure that
+                // that the more stringent requirements are met.
+
+                const int p = X509_get_ext_by_NID(cert.get(), NID_key_usage, -1);
+                if ((ext = X509_get_ext(cert.get(), p)) != NULL) {
+                    ASN1_BIT_STRING *keyusage = (ASN1_BIT_STRING *)X509V3_EXT_d2i(ext);
+                    ASN1_BIT_STRING_set_bit(keyusage, KeyEncipherment, 1);
+
+                    //Build the ASN1_OCTET_STRING
+                    const X509V3_EXT_METHOD *method = X509V3_EXT_get(ext);
+                    assert(method && method->it);
+                    unsigned char *ext_der = NULL;
+                    int ext_len = ASN1_item_i2d((ASN1_VALUE *)keyusage,
+                                                &ext_der, 
+                                                (const ASN1_ITEM *)ASN1_ITEM_ptr(method->it));
+
+                    ASN1_OCTET_STRING *ext_oct = M_ASN1_OCTET_STRING_new();
+                    ext_oct->data = ext_der;
+                    ext_oct->length = ext_len;
+                    X509_EXTENSION_set_data(ext, ext_oct);
+
+                    M_ASN1_OCTET_STRING_free(ext_oct);
+                    ASN1_BIT_STRING_free(keyusage);
+                }
+            }
+        }
     }
 
     // We could also restrict mimicking of the CA extension to CA:FALSE
     // because Squid does not generate valid fake CA certificates.
+
+    return added;
 }
 
 static bool buildCertificate(Ssl::X509_Pointer & cert, Ssl::CertificateProperties const &properties)
 {
     // not an Ssl::X509_NAME_Pointer because X509_REQ_get_subject_name()
     // returns a pointer to the existing subject name. Nothing to clean here.
@@ -328,28 +378,30 @@
         int alLen;
         alStr = X509_alias_get0(properties.mimicCert.get(), &alLen);
         if (alStr) {
             X509_alias_set1(cert.get(), alStr, alLen);
         }
 
+        int addedExtensions = 0;
+
         // Mimic subjectAltName unless we used a configured CN: browsers reject
         // certificates with CN unrelated to subjectAltNames.
         if (!properties.setCommonName) {
             int pos=X509_get_ext_by_NID (properties.mimicCert.get(), OBJ_sn2nid("subjectAltName"), -1);
             X509_EXTENSION *ext=X509_get_ext(properties.mimicCert.get(), pos);
             if (ext) {
-                X509_add_ext(cert.get(), ext, -1);
-                /* According the RFC 5280 using extensions requires version 3
-                   certificate.
-                   Set version value to 2 for version 3 certificates.
-                 */
-                X509_set_version(cert.get(), 2);
+                if (X509_add_ext(cert.get(), ext, -1))
+                    ++addedExtensions;
             }
         }
 
-        mimicExtensions(cert, properties.mimicCert);
+        addedExtensions += mimicExtensions(cert, properties.mimicCert);
+
+        // According to RFC 5280, using extensions requires v3 certificate.
+        if (addedExtensions)
+            X509_set_version(cert.get(), 2); // value 2 means v3
     }
 
     return true;
 }
 
 static bool generateFakeSslCertificate(Ssl::X509_Pointer & certToStore, Ssl::EVP_PKEY_Pointer & pkeyToStore, Ssl::CertificateProperties const &properties,  Ssl::BIGNUM_Pointer const &serial)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/helper.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/helper.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/helper.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/helper.cc	2015-05-01 18:05:19.000000000 +0800
@@ -2,15 +2,19 @@
 #include "anyp/PortCfg.h"
 #include "ssl/Config.h"
 #include "ssl/helper.h"
 #include "SquidString.h"
 #include "SquidTime.h"
 #include "SwapDir.h"
+#include "ssl/cert_validate_message.h"
 #include "wordlist.h"
 #include "SquidConfig.h"
 
+LruMap<Ssl::CertValidationResponse> *Ssl::CertValidationHelper::HelperCache = NULL;
+
+#if USE_SSL_CRTD
 Ssl::Helper * Ssl::Helper::GetInstance()
 {
     static Ssl::Helper sslHelper;
     return &sslHelper;
 }
 
@@ -27,15 +31,15 @@
 {
     assert(ssl_crtd == NULL);
 
     // we need to start ssl_crtd only if some port(s) need to bump SSL
     bool found = false;
     for (AnyP::PortCfg *s = ::Config.Sockaddr.http; !found && s; s = s->next)
-        found = s->sslBump;
+        found = s->flags.tunnelSslBumping;
     for (AnyP::PortCfg *s = ::Config.Sockaddr.https; !found && s; s = s->next)
-        found = s->sslBump;
+        found = s->flags.tunnelSslBumping;
     if (!found)
         return;
 
     ssl_crtd = new helper("ssl_crtd");
     ssl_crtd->childs.updateLimits(Ssl::TheConfig.ssl_crtdChildren);
     ssl_crtd->ipc_type = IPC_STREAM;
@@ -90,15 +94,187 @@
     if (ssl_crtd->stats.queue_size >= (int)(ssl_crtd->childs.n_running * 2)) {
         if (first_warn == 0)
             first_warn = squid_curtime;
         if (squid_curtime - first_warn > 3 * 60)
             fatal("SSL servers not responding for 3 minutes");
         debugs(34, DBG_IMPORTANT, HERE << "Queue overload, rejecting");
-        callback(data, (char *)"error 45 Temporary network problem, please retry later");
+        HelperReply failReply;
+        failReply.result = HelperReply::BrokenHelper;
+        failReply.notes.add("message", "error 45 Temporary network problem, please retry later");
+        callback(data, failReply);
         return;
     }
 
     first_warn = 0;
     std::string msg = message.compose();
     msg += '\n';
     helperSubmit(ssl_crtd, msg.c_str(), callback, data);
 }
+#endif //USE_SSL_CRTD
+
+Ssl::CertValidationHelper * Ssl::CertValidationHelper::GetInstance()
+{
+    static Ssl::CertValidationHelper sslHelper;
+    if (!Ssl::TheConfig.ssl_crt_validator)
+        return NULL;
+    return &sslHelper;
+}
+
+Ssl::CertValidationHelper::CertValidationHelper() : ssl_crt_validator(NULL)
+{
+}
+
+Ssl::CertValidationHelper::~CertValidationHelper()
+{
+    Shutdown();
+}
+
+void Ssl::CertValidationHelper::Init()
+{
+    assert(ssl_crt_validator == NULL);
+
+    // we need to start ssl_crtd only if some port(s) need to bump SSL
+    bool found = false;
+    for (AnyP::PortCfg *s = ::Config.Sockaddr.http; !found && s; s = s->next)
+        found = s->flags.tunnelSslBumping;
+    for (AnyP::PortCfg *s = ::Config.Sockaddr.https; !found && s; s = s->next)
+        found = s->flags.tunnelSslBumping;
+    if (!found)
+        return;
+
+    ssl_crt_validator = new helper("ssl_crt_validator");
+    ssl_crt_validator->childs.updateLimits(Ssl::TheConfig.ssl_crt_validator_Children);
+    ssl_crt_validator->ipc_type = IPC_STREAM;
+    // The crtd messages may contain the eol ('\n') character. We are
+    // going to use the '\1' char as the end-of-message mark.
+    ssl_crt_validator->eom = '\1';
+    assert(ssl_crt_validator->cmdline == NULL);
+
+    int ttl = 60;
+    size_t cache = 2048;
+    {
+        char *tmp = xstrdup(Ssl::TheConfig.ssl_crt_validator);
+        char *tmp_begin = tmp;
+        char * token = NULL;
+        bool parseParams = true;
+        while ((token = strwordtok(NULL, &tmp))) {
+            if (parseParams) {
+                if (strncmp(token, "ttl=", 4) == 0) {
+                    ttl = atoi(token + 4);
+                    continue;
+                } else if (strncmp(token, "cache=", 6) == 0) {
+                    cache = atoi(token + 6);
+                    continue;
+                } else
+                    parseParams = false;
+            }
+            wordlistAdd(&ssl_crt_validator->cmdline, token);
+        }
+        xfree(tmp_begin);
+    }
+    helperOpenServers(ssl_crt_validator);
+
+    //WARNING: initializing static member in an object initialization method
+    assert(HelperCache == NULL);
+    HelperCache = new LruMap<Ssl::CertValidationResponse>(ttl, cache);
+}
+
+void Ssl::CertValidationHelper::Shutdown()
+{
+    if (!ssl_crt_validator)
+        return;
+    helperShutdown(ssl_crt_validator);
+    wordlistDestroy(&ssl_crt_validator->cmdline);
+    delete ssl_crt_validator;
+    ssl_crt_validator = NULL;
+
+    // CertValidationHelper::HelperCache is a static member, it is not good policy to
+    // reset it here. Will work because the current Ssl::CertValidationHelper is
+    // always the same static object.
+    delete HelperCache;
+    HelperCache = NULL;
+}
+
+struct submitData {
+    std::string query;
+    Ssl::CertValidationHelper::CVHCB *callback;
+    void *data;
+    SSL *ssl;
+    CBDATA_CLASS2(submitData);
+};
+CBDATA_CLASS_INIT(submitData);
+
+static void
+sslCrtvdHandleReplyWrapper(void *data, const HelperReply &reply)
+{
+    Ssl::CertValidationMsg replyMsg(Ssl::CrtdMessage::REPLY);
+    Ssl::CertValidationResponse *validationResponse = new Ssl::CertValidationResponse;
+    std::string error;
+
+    submitData *crtdvdData = static_cast<submitData *>(data);
+    STACK_OF(X509) *peerCerts = SSL_get_peer_cert_chain(crtdvdData->ssl);
+    if (reply.result == HelperReply::BrokenHelper) {
+        debugs(83, DBG_IMPORTANT, "\"ssl_crtvd\" helper error response: " << reply.other().content());
+        validationResponse->resultCode = HelperReply::BrokenHelper;
+    } else if (replyMsg.parse(reply.other().content(), reply.other().contentSize()) != Ssl::CrtdMessage::OK ||
+               !replyMsg.parseResponse(*validationResponse, peerCerts, error) ) {
+        debugs(83, DBG_IMPORTANT, "WARNING: Reply from ssl_crtvd for " << " is incorrect");
+        debugs(83, DBG_IMPORTANT, "Certificate cannot be validated. ssl_crtvd response: " << replyMsg.getBody());
+        validationResponse->resultCode = HelperReply::BrokenHelper;
+    } else
+        validationResponse->resultCode = reply.result;
+
+    crtdvdData->callback(crtdvdData->data, *validationResponse);
+
+    if (Ssl::CertValidationHelper::HelperCache &&
+            (validationResponse->resultCode == HelperReply::Okay || validationResponse->resultCode == HelperReply::Error)) {
+        Ssl::CertValidationHelper::HelperCache->add(crtdvdData->query.c_str(), validationResponse);
+    } else
+        delete validationResponse;
+
+    cbdataReferenceDone(crtdvdData->data);
+    SSL_free(crtdvdData->ssl);
+    delete crtdvdData;
+}
+
+void Ssl::CertValidationHelper::sslSubmit(Ssl::CertValidationRequest const &request, Ssl::CertValidationHelper::CVHCB * callback, void * data)
+{
+    static time_t first_warn = 0;
+    assert(ssl_crt_validator);
+
+    if (ssl_crt_validator->stats.queue_size >= (int)(ssl_crt_validator->childs.n_running * 2)) {
+        if (first_warn == 0)
+            first_warn = squid_curtime;
+        if (squid_curtime - first_warn > 3 * 60)
+            fatal("ssl_crtvd queue being overloaded for long time");
+        debugs(83, DBG_IMPORTANT, "WARNING: ssl_crtvd queue overload, rejecting");
+        Ssl::CertValidationResponse resp;
+        resp.resultCode = HelperReply::BrokenHelper;
+        callback(data, resp);
+        return;
+    }
+    first_warn = 0;
+
+    Ssl::CertValidationMsg message(Ssl::CrtdMessage::REQUEST);
+    message.setCode(Ssl::CertValidationMsg::code_cert_validate);
+    message.composeRequest(request);
+    debugs(83, 5, "SSL crtvd request: " << message.compose().c_str());
+
+    submitData *crtdvdData = new submitData;
+    crtdvdData->query = message.compose();
+    crtdvdData->query += '\n';
+    crtdvdData->callback = callback;
+    crtdvdData->data = cbdataReference(data);
+    crtdvdData->ssl = request.ssl;
+    CRYPTO_add(&crtdvdData->ssl->references,1,CRYPTO_LOCK_SSL);
+    Ssl::CertValidationResponse const*validationResponse;
+
+    if (CertValidationHelper::HelperCache &&
+            (validationResponse = CertValidationHelper::HelperCache->get(crtdvdData->query.c_str()))) {
+        callback(data, *validationResponse);
+        cbdataReferenceDone(crtdvdData->data);
+        SSL_free(crtdvdData->ssl);
+        delete crtdvdData;
+        return;
+    }
+    helperSubmit(ssl_crt_validator, crtdvdData->query.c_str(), sslCrtvdHandleReplyWrapper, crtdvdData);
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/helper.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/helper.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/helper.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/helper.h	2015-05-01 18:05:19.000000000 +0800
@@ -1,19 +1,22 @@
 #ifndef SQUID_SSL_HELPER_H
 #define SQUID_SSL_HELPER_H
 
+#include "base/LruMap.h"
 #include "../helper.h"
+#include "ssl/cert_validate_message.h"
 #include "ssl/crtd_message.h"
 
 namespace Ssl
 {
 /**
  * Set of thread for ssl_crtd. This class is singleton. Use this class only
  * over GetIntance() static method. This class use helper structure
  * for threads management.
  */
+#if USE_SSL_CRTD
 class Helper
 {
 public:
     static Helper * GetInstance(); ///< Instance class.
     void Init(); ///< Init helper structure.
     void Shutdown(); ///< Shutdown helper structure.
@@ -22,9 +25,30 @@
 private:
     Helper();
     ~Helper();
 
     helper * ssl_crtd; ///< helper for management of ssl_crtd.
 };
+#endif
+
+class CertValidationRequest;
+class CertValidationResponse;
+class CertValidationHelper
+{
+public:
+    typedef void CVHCB(void *, Ssl::CertValidationResponse const &);
+    static CertValidationHelper * GetInstance(); ///< Instance class.
+    void Init(); ///< Init helper structure.
+    void Shutdown(); ///< Shutdown helper structure.
+    /// Submit crtd request message to external crtd server.
+    void sslSubmit(Ssl::CertValidationRequest const & request, CVHCB * callback, void *data);
+private:
+    CertValidationHelper();
+    ~CertValidationHelper();
+
+    helper * ssl_crt_validator; ///< helper for management of ssl_crtd.
+public:
+    static LruMap<Ssl::CertValidationResponse> *HelperCache; ///< cache for cert validation helper
+};
 
 } //namespace Ssl
 #endif // SQUID_SSL_HELPER_H
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -8,22 +8,20 @@
 
 EXTRA_DIST = \
 	ssl_crtd.8
 
 if USE_SSL_CRTD
 SSL_CRTD = ssl_crtd
-SSL_CRTD_SOURCE = \
-    helper.cc \
-    helper.h
 else
 SSL_CRTD =
-SSL_CRTD_SOURCE =
 endif
 
 ## SSL stuff used by main Squid but not by ssl_crtd
 libsslsquid_la_SOURCES = \
+	cert_validate_message.cc \
+	cert_validate_message.h \
 	context_storage.cc \
 	context_storage.h \
 	Config.cc \
 	Config.h \
 	ErrorDetail.cc \
 	ErrorDetail.h \
@@ -31,14 +29,14 @@
 	ErrorDetailManager.h \
 	ProxyCerts.h \
 	ServerBump.cc \
 	ServerBump.h \
 	support.cc \
 	support.h \
-	\
-	$(SSL_CRTD_SOURCE)
+	helper.cc \
+	helper.h
 
 ## SSL stuff used by main Squid and ssl_crtd
 libsslutil_la_SOURCES = \
 	gadgets.cc \
 	gadgets.h \
 	crtd_message.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/Makefile.in	2015-05-01 16:51:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/Makefile.in	2015-05-01 18:07:01.000000000 +0800
@@ -93,32 +93,72 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
 LTLIBRARIES = $(noinst_LTLIBRARIES)
 libsslsquid_la_LIBADD =
-am__libsslsquid_la_SOURCES_DIST = context_storage.cc context_storage.h \
-	Config.cc Config.h ErrorDetail.cc ErrorDetail.h \
-	ErrorDetailManager.cc ErrorDetailManager.h ProxyCerts.h \
-	ServerBump.cc ServerBump.h support.cc support.h helper.cc \
-	helper.h
-@USE_SSL_CRTD_TRUE@am__objects_1 = helper.lo
-am_libsslsquid_la_OBJECTS = context_storage.lo Config.lo \
-	ErrorDetail.lo ErrorDetailManager.lo ServerBump.lo support.lo \
-	$(am__objects_1)
+am_libsslsquid_la_OBJECTS = cert_validate_message.lo \
+	context_storage.lo Config.lo ErrorDetail.lo \
+	ErrorDetailManager.lo ServerBump.lo support.lo helper.lo
 libsslsquid_la_OBJECTS = $(am_libsslsquid_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 libsslutil_la_LIBADD =
@@ -131,13 +171,14 @@
 	certificate_db.h
 @USE_SSL_CRTD_TRUE@am_ssl_crtd_OBJECTS = ssl_crtd.$(OBJEXT) \
 @USE_SSL_CRTD_TRUE@	certificate_db.$(OBJEXT)
 ssl_crtd_OBJECTS = $(am_ssl_crtd_OBJECTS)
 am__DEPENDENCIES_1 =
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_2 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_3 = $(am__DEPENDENCIES_2)
+am__DEPENDENCIES_3 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_2)
 @USE_SSL_CRTD_TRUE@ssl_crtd_DEPENDENCIES = libsslutil.la \
 @USE_SSL_CRTD_TRUE@	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_3)
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
 am__v_P_0 = false
 am__v_P_1 = :
@@ -188,14 +229,14 @@
 AM_V_CCLD = $(am__v_CCLD_@AM_V@)
 am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
 am__v_CCLD_0 = @echo "  CCLD    " $@;
 am__v_CCLD_1 = 
 SOURCES = $(libsslsquid_la_SOURCES) $(libsslutil_la_SOURCES) \
 	$(ssl_crtd_SOURCES)
-DIST_SOURCES = $(am__libsslsquid_la_SOURCES_DIST) \
-	$(libsslutil_la_SOURCES) $(am__ssl_crtd_SOURCES_DIST)
+DIST_SOURCES = $(libsslsquid_la_SOURCES) $(libsslutil_la_SOURCES) \
+	$(am__ssl_crtd_SOURCES_DIST)
 am__can_run_installinfo = \
   case $$AM_UPDATE_INFO_DIR in \
     n|no|NO) false;; \
     *) (install-info --version) >/dev/null 2>&1;; \
   esac
 am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
@@ -480,12 +521,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -523,12 +565,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -555,27 +598,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -642,26 +688,23 @@
 TESTS = testHeaders
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 noinst_LTLIBRARIES = libsslsquid.la libsslutil.la
 EXTRA_DIST = \
 	ssl_crtd.8
 
 @USE_SSL_CRTD_FALSE@SSL_CRTD = 
 @USE_SSL_CRTD_TRUE@SSL_CRTD = ssl_crtd
-@USE_SSL_CRTD_FALSE@SSL_CRTD_SOURCE = 
-@USE_SSL_CRTD_TRUE@SSL_CRTD_SOURCE = \
-@USE_SSL_CRTD_TRUE@    helper.cc \
-@USE_SSL_CRTD_TRUE@    helper.h
-
 libsslsquid_la_SOURCES = \
+	cert_validate_message.cc \
+	cert_validate_message.h \
 	context_storage.cc \
 	context_storage.h \
 	Config.cc \
 	Config.h \
 	ErrorDetail.cc \
 	ErrorDetail.h \
@@ -669,14 +712,14 @@
 	ErrorDetailManager.h \
 	ProxyCerts.h \
 	ServerBump.cc \
 	ServerBump.h \
 	support.cc \
 	support.h \
-	\
-	$(SSL_CRTD_SOURCE)
+	helper.cc \
+	helper.h
 
 libsslutil_la_SOURCES = \
 	gadgets.cc \
 	gadgets.h \
 	crtd_message.cc \
 	crtd_message.h
@@ -805,12 +848,13 @@
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Config.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ErrorDetail.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ErrorDetailManager.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ServerBump.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cert_validate_message.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/certificate_db.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/context_storage.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/crtd_message.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gadgets.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/helper.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ssl_crtd.Po@am__quote@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ProxyCerts.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ProxyCerts.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ProxyCerts.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ProxyCerts.h	2015-05-01 18:05:19.000000000 +0800
@@ -27,13 +27,13 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #if USE_SSL
-class ACLList;
+#include "acl/forward.h"
 
 class sslproxy_cert_sign
 {
 public:
     int alg;
     ACLList *aclList;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ServerBump.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ServerBump.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ServerBump.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ServerBump.cc	2015-05-01 18:05:19.000000000 +0800
@@ -3,26 +3,26 @@
  *
  */
 
 #include "squid.h"
 
 #include "client_side.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "ssl/ServerBump.h"
 #include "Store.h"
 #include "StoreClient.h"
 #include "URL.h"
 
 CBDATA_NAMESPACED_CLASS_INIT(Ssl, ServerBump);
 
 Ssl::ServerBump::ServerBump(HttpRequest *fakeRequest, StoreEntry *e):
         request(fakeRequest),
         sslErrors(NULL)
 {
     debugs(33, 4, HERE << "will peek at " << request->GetHost() << ':' << request->port);
-    const char *uri = urlCanonical(request);
+    const char *uri = urlCanonical(request.getRaw());
     if (e) {
         entry = e;
         entry->lock();
     } else
         entry = storeCreateEntry(uri, uri, request->flags, request->method);
     // We do not need to be a client because the error contents will be used
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ServerBump.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ServerBump.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ServerBump.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ServerBump.h	2015-05-01 18:05:19.000000000 +0800
@@ -24,13 +24,13 @@
     ~ServerBump();
 
     /// faked, minimal request; required by server-side API
     HttpRequest::Pointer request;
     StoreEntry *entry; ///< for receiving Squid-generated error messages
     Ssl::X509_Pointer serverCert; ///< HTTPS server certificate
-    Ssl::Errors *sslErrors; ///< SSL [certificate validation] errors
+    Ssl::CertErrors *sslErrors; ///< SSL [certificate validation] errors
 
 private:
     store_client *sc; ///< dummy client to prevent entry trimming
 
     CBDATA_CLASS2(ServerBump);
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ssl_crtd.8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ssl_crtd.8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ssl_crtd.8	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ssl_crtd.8	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH ssl_crtd 8
 .
 .SH NAME
-.if !'po4a'hide' .B ssl_crtd
-.if !'po4a'hide' \-
-SSL certificate generator.
+ssl_crtd \- SSL certificate generator for Squid.
 .PP
 Version 1.0
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B ssl_crtd
 .if !'po4a'hide' .B [\-dhv]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ssl_crtd.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ssl_crtd.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/ssl_crtd.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/ssl_crtd.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,9 +1,8 @@
 #include "squid.h"
 #include "helpers/defines.h"
-#include "ssl/gadgets.h"
 #include "ssl/crtd_message.h"
 #include "ssl/certificate_db.h"
 
 #if HAVE_CSTRING
 #include <cstring>
 #endif
@@ -229,13 +228,13 @@
     }
 
     std::string bufferToWrite;
     if (!Ssl::writeCertAndPrivateKeyToMemory(cert, pkey, bufferToWrite))
         throw std::runtime_error("Cannot write ssl certificate or/and private key to memory.");
 
-    Ssl::CrtdMessage response_message;
+    Ssl::CrtdMessage response_message(Ssl::CrtdMessage::REPLY);
     response_message.setCode("OK");
     response_message.setBody(bufferToWrite);
 
     // Use the '\1' char as end-of-message character
     std::cout << response_message.compose() << '\1' << std::flush;
 
@@ -293,18 +292,18 @@
             Ssl::CertificateDb::create(db_path);
             std::cout << "Done" << std::endl;
             exit(0);
         }
 
         {
-            Ssl::CertificateDb::check(db_path, max_db_size);
+            Ssl::CertificateDb::check(db_path, max_db_size, fs_block_size);
         }
         // proccess request.
         for (;;) {
             char request[HELPER_INPUT_BUFFER];
-            Ssl::CrtdMessage request_message;
+            Ssl::CrtdMessage request_message(Ssl::CrtdMessage::REQUEST);
             Ssl::CrtdMessage::ParseResult parse_result = Ssl::CrtdMessage::INCOMPLETE;
 
             while (parse_result == Ssl::CrtdMessage::INCOMPLETE) {
                 if (fgets(request, HELPER_INPUT_BUFFER, stdin) == NULL)
                     return 1;
                 size_t gcount = strlen(request);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/support.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/support.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/support.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/support.cc	2015-05-01 18:05:19.000000000 +0800
@@ -40,12 +40,13 @@
 
 #include "acl/FilledChecklist.h"
 #include "anyp/PortCfg.h"
 #include "fde.h"
 #include "globals.h"
 #include "SquidConfig.h"
+#include "ssl/Config.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/support.h"
 #include "ssl/gadgets.h"
 #include "URL.h"
 
 #if HAVE_ERRNO_H
@@ -241,16 +242,34 @@
     X509 *peeked_cert = (X509 *)SSL_get_ex_data(ssl, ssl_ex_index_ssl_peeked_cert);
     X509 *peer_cert = ctx->cert;
 
     X509_NAME_oneline(X509_get_subject_name(peer_cert), buffer,
                       sizeof(buffer));
 
+    // detect infinite loops
+    uint32_t *validationCounter = static_cast<uint32_t *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_validation_counter));
+    if (!validationCounter) {
+        validationCounter = new uint32_t(1);
+        SSL_set_ex_data(ssl, ssl_ex_index_ssl_validation_counter, validationCounter);
+    } else {
+        // overflows allowed if SQUID_CERT_VALIDATION_ITERATION_MAX >= UINT32_MAX
+        (*validationCounter)++;
+    }
+
+    if ((*validationCounter) >= SQUID_CERT_VALIDATION_ITERATION_MAX) {
+        ok = 0; // or the validation loop will never stop
+        error_no = SQUID_X509_V_ERR_INFINITE_VALIDATION;
+        debugs(83, 2, "SQUID_X509_V_ERR_INFINITE_VALIDATION: " <<
+               *validationCounter << " iterations while checking " << buffer);
+    }
+
     if (ok) {
         debugs(83, 5, "SSL Certificate signature OK: " << buffer);
 
-        if (server) {
+        // Check for domain mismatch only if the current certificate is the peer certificate.
+        if (server && peer_cert == X509_STORE_CTX_get_current_cert(ctx)) {
             if (!Ssl::checkX509ServerValidity(peer_cert, server)) {
                 debugs(83, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " << buffer << " does not match domainname " << server);
                 ok = 0;
                 error_no = SQUID_X509_V_ERR_DOMAIN_MISMATCH;
             }
         }
@@ -263,40 +282,61 @@
             ok = 0;
             error_no =  SQUID_X509_V_ERR_CERT_CHANGE;
         }
     }
 
     if (!ok) {
-        Ssl::Errors *errs = static_cast<Ssl::Errors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors));
+        X509 *broken_cert =  X509_STORE_CTX_get_current_cert(ctx);
+        if (!broken_cert)
+            broken_cert = peer_cert;
+
+        Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors));
         if (!errs) {
-            errs = new Ssl::Errors(error_no);
+            errs = new Ssl::CertErrors(Ssl::CertError(error_no, broken_cert));
             if (!SSL_set_ex_data(ssl, ssl_ex_index_ssl_errors,  (void *)errs)) {
                 debugs(83, 2, "Failed to set ssl error_no in ssl_verify_cb: Certificate " << buffer);
                 delete errs;
                 errs = NULL;
             }
         } else // remember another error number
-            errs->push_back_unique(error_no);
+            errs->push_back_unique(Ssl::CertError(error_no, broken_cert));
 
         if (const char *err_descr = Ssl::GetErrorDescr(error_no))
             debugs(83, 5, err_descr << ": " << buffer);
         else
             debugs(83, DBG_IMPORTANT, "SSL unknown certificate error " << error_no << " in " << buffer);
 
-        if (check) {
-            ACLFilledChecklist *filledCheck = Filled(check);
-            assert(!filledCheck->sslErrors);
-            filledCheck->sslErrors = new Ssl::Errors(error_no);
-            if (check->fastCheck() == ACCESS_ALLOWED) {
-                debugs(83, 3, "bypassing SSL error " << error_no << " in " << buffer);
+        // Check if the certificate error can be bypassed.
+        // Infinity validation loop errors can not bypassed.
+        if (error_no != SQUID_X509_V_ERR_INFINITE_VALIDATION) {
+            if (check) {
+                ACLFilledChecklist *filledCheck = Filled(check);
+                assert(!filledCheck->sslErrors);
+                filledCheck->sslErrors = new Ssl::CertErrors(Ssl::CertError(error_no, broken_cert));
+                filledCheck->serverCert.resetAndLock(peer_cert);
+                if (check->fastCheck() == ACCESS_ALLOWED) {
+                    debugs(83, 3, "bypassing SSL error " << error_no << " in " << buffer);
+                    ok = 1;
+                } else {
+                    debugs(83, 5, "confirming SSL error " << error_no);
+                }
+                delete filledCheck->sslErrors;
+                filledCheck->sslErrors = NULL;
+                filledCheck->serverCert.reset(NULL);
+            }
+            // If the certificate validator is used then we need to allow all errors and
+            // pass them to certficate validator for more processing
+            else if (Ssl::TheConfig.ssl_crt_validator) {
                 ok = 1;
-            } else {
-                debugs(83, 5, "confirming SSL error " << error_no);
+                // Check if we have stored certificates chain. Store if not.
+                if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_cert_chain)) {
+                    STACK_OF(X509) *certStack = X509_STORE_CTX_get1_chain(ctx);
+                    if (certStack && !SSL_set_ex_data(ssl, ssl_ex_index_ssl_cert_chain, certStack))
+                        sk_X509_pop_free(certStack, X509_free);
+                }
             }
-            delete filledCheck->sslErrors;
-            filledCheck->sslErrors = NULL;
         }
     }
 
     if (!dont_verify_domain && server) {}
 
     if (!ok && !SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail) ) {
@@ -451,12 +491,17 @@
 #endif
 #if SSL_OP_NO_COMPRESSION
     {
         "No_Compression", SSL_OP_NO_COMPRESSION
     },
 #endif
+#if SSL_OP_NO_TICKET
+    {
+        "NO_TICKET", SSL_OP_NO_TICKET
+    },
+#endif
     {
         "", 0
     },
     {
         NULL, 0
     }
@@ -631,16 +676,36 @@
 }
 
 static void
 ssl_free_SslErrors(void *, void *ptr, CRYPTO_EX_DATA *,
                    int, long, void *)
 {
-    Ssl::Errors *errs = static_cast <Ssl::Errors*>(ptr);
+    Ssl::CertErrors *errs = static_cast <Ssl::CertErrors*>(ptr);
     delete errs;
 }
 
+// "free" function for SSL_get_ex_new_index("ssl_ex_index_ssl_validation_counter")
+static void
+ssl_free_int(void *, void *ptr, CRYPTO_EX_DATA *,
+             int, long, void *)
+{
+    uint32_t *counter = static_cast <uint32_t *>(ptr);
+    delete counter;
+}
+
+/// \ingroup ServerProtocolSSLInternal
+/// Callback handler function to release STACK_OF(X509) "ex" data stored
+/// in an SSL object.
+static void
+ssl_free_CertChain(void *, void *ptr, CRYPTO_EX_DATA *,
+                   int, long, void *)
+{
+    STACK_OF(X509) *certsChain = static_cast <STACK_OF(X509) *>(ptr);
+    sk_X509_pop_free(certsChain,X509_free);
+}
+
 // "free" function for X509 certificates
 static void
 ssl_free_X509(void *, void *ptr, CRYPTO_EX_DATA *,
               int, long, void *)
 {
     X509  *cert = static_cast <X509 *>(ptr);
@@ -648,49 +713,44 @@
 }
 
 /// \ingroup ServerProtocolSSLInternal
 static void
 ssl_initialize(void)
 {
-    static int ssl_initialized = 0;
-
-    if (!ssl_initialized) {
-        ssl_initialized = 1;
-        SSL_load_error_strings();
-        SSLeay_add_ssl_algorithms();
-#if HAVE_OPENSSL_ENGINE_H
+    static bool initialized = false;
+    if (initialized)
+        return;
+    initialized = true;
 
-        if (Config.SSL.ssl_engine) {
-            ENGINE *e;
+    SSL_load_error_strings();
+    SSLeay_add_ssl_algorithms();
 
-            if (!(e = ENGINE_by_id(Config.SSL.ssl_engine))) {
-                fatalf("Unable to find SSL engine '%s'\n", Config.SSL.ssl_engine);
-            }
-
-            if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
-                int ssl_error = ERR_get_error();
-                fatalf("Failed to initialise SSL engine: %s\n",
-                       ERR_error_string(ssl_error, NULL));
-            }
+#if HAVE_OPENSSL_ENGINE_H
+    if (Config.SSL.ssl_engine) {
+        ENGINE *e;
+        if (!(e = ENGINE_by_id(Config.SSL.ssl_engine)))
+            fatalf("Unable to find SSL engine '%s'\n", Config.SSL.ssl_engine);
+
+        if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+            int ssl_error = ERR_get_error();
+            fatalf("Failed to initialise SSL engine: %s\n", ERR_error_string(ssl_error, NULL));
         }
-
+    }
 #else
-        if (Config.SSL.ssl_engine) {
-            fatalf("Your OpenSSL has no SSL engine support\n");
-        }
-
+    if (Config.SSL.ssl_engine)
+        fatalf("Your OpenSSL has no SSL engine support\n");
 #endif
 
-    }
-
     ssl_ex_index_server = SSL_get_ex_new_index(0, (void *) "server", NULL, NULL, NULL);
     ssl_ctx_ex_index_dont_verify_domain = SSL_CTX_get_ex_new_index(0, (void *) "dont_verify_domain", NULL, NULL, NULL);
     ssl_ex_index_cert_error_check = SSL_get_ex_new_index(0, (void *) "cert_error_check", NULL, &ssl_dupAclChecklist, &ssl_freeAclChecklist);
     ssl_ex_index_ssl_error_detail = SSL_get_ex_new_index(0, (void *) "ssl_error_detail", NULL, NULL, &ssl_free_ErrorDetail);
     ssl_ex_index_ssl_peeked_cert  = SSL_get_ex_new_index(0, (void *) "ssl_peeked_cert", NULL, NULL, &ssl_free_X509);
     ssl_ex_index_ssl_errors =  SSL_get_ex_new_index(0, (void *) "ssl_errors", NULL, NULL, &ssl_free_SslErrors);
+    ssl_ex_index_ssl_cert_chain = SSL_get_ex_new_index(0, (void *) "ssl_cert_chain", NULL, NULL, &ssl_free_CertChain);
+    ssl_ex_index_ssl_validation_counter = SSL_get_ex_new_index(0, (void *) "ssl_validation_counter", NULL, NULL, &ssl_free_int);
 }
 
 /// \ingroup ServerProtocolSSLInternal
 static int
 ssl_load_crl(SSL_CTX *sslContext, const char *CRLfile)
 {
@@ -1112,15 +1172,15 @@
 #endif
 
     i = SSL_read(ssl, buf, len);
 
     if (i > 0 && SSL_pending(ssl) > 0) {
         debugs(83, 2, "SSL FD " << fd << " is pending");
-        fd_table[fd].flags.read_pending = 1;
+        fd_table[fd].flags.read_pending = true;
     } else
-        fd_table[fd].flags.read_pending = 0;
+        fd_table[fd].flags.read_pending = false;
 
     return i;
 }
 
 /// \ingroup ServerProtocolSSLInternal
 int
@@ -1171,58 +1231,92 @@
 done:
     return *buffer ? buffer : NULL;
 }
 
 /// \ingroup ServerProtocolSSLInternal
 const char *
-sslGetUserAttribute(SSL * ssl, const char *attribute_name)
+Ssl::GetX509UserAttribute(X509 * cert, const char *attribute_name)
 {
-    X509 *cert;
     X509_NAME *name;
     const char *ret;
 
-    if (!ssl)
+    if (!cert)
         return NULL;
 
-    cert = SSL_get_peer_certificate(ssl);
+    name = X509_get_subject_name(cert);
+
+    ret = ssl_get_attribute(name, attribute_name);
 
+    return ret;
+}
+
+const char *
+Ssl::GetX509Fingerprint(X509 * cert, const char *)
+{
+    static char buf[1024];
     if (!cert)
         return NULL;
 
-    name = X509_get_subject_name(cert);
+    unsigned int n;
+    unsigned char md[EVP_MAX_MD_SIZE];
+    if (!X509_digest(cert, EVP_sha1(), md, &n))
+        return NULL;
 
-    ret = ssl_get_attribute(name, attribute_name);
+    assert(3 * n + 1 < sizeof(buf));
 
-    X509_free(cert);
+    char *s = buf;
+    for (unsigned int i=0; i < n; ++i, s += 3) {
+        const char term = (i + 1 < n) ? ':' : '\0';
+        snprintf(s, 4, "%02X%c", md[i], term);
+    }
 
-    return ret;
+    return buf;
 }
 
 /// \ingroup ServerProtocolSSLInternal
 const char *
-sslGetCAAttribute(SSL * ssl, const char *attribute_name)
+Ssl::GetX509CAAttribute(X509 * cert, const char *attribute_name)
 {
-    X509 *cert;
+
     X509_NAME *name;
     const char *ret;
 
-    if (!ssl)
-        return NULL;
-
-    cert = SSL_get_peer_certificate(ssl);
-
     if (!cert)
         return NULL;
 
     name = X509_get_issuer_name(cert);
 
     ret = ssl_get_attribute(name, attribute_name);
 
+    return ret;
+}
+
+const char *sslGetUserAttribute(SSL *ssl, const char *attribute_name)
+{
+    if (!ssl)
+        return NULL;
+
+    X509 *cert = SSL_get_peer_certificate(ssl);
+
+    const char *attr = Ssl::GetX509UserAttribute(cert, attribute_name);
+
     X509_free(cert);
+    return attr;
+}
 
-    return ret;
+const char *sslGetCAAttribute(SSL *ssl, const char *attribute_name)
+{
+    if (!ssl)
+        return NULL;
+
+    X509 *cert = SSL_get_peer_certificate(ssl);
+
+    const char *attr = Ssl::GetX509CAAttribute(cert, attribute_name);
+
+    X509_free(cert);
+    return attr;
 }
 
 const char *
 sslGetUserEmail(SSL * ssl)
 {
     return sslGetUserAttribute(ssl, "emailAddress");
@@ -1550,7 +1644,37 @@
     certProperties.signAlgorithm = Ssl::algSignSelf;
     certProperties.signWithPkey.resetAndLock(pkey.get());
     certProperties.mimicCert.resetAndLock(cert.get());
     return Ssl::generateSslCertificate(untrustedCert, untrustedPkey, certProperties);
 }
 
+Ssl::CertError::CertError(ssl_error_t anErr, X509 *aCert): code(anErr)
+{
+    cert.resetAndLock(aCert);
+}
+
+Ssl::CertError::CertError(CertError const &err): code(err.code)
+{
+    cert.resetAndLock(err.cert.get());
+}
+
+Ssl::CertError &
+Ssl::CertError::operator = (const CertError &old)
+{
+    code = old.code;
+    cert.resetAndLock(old.cert.get());
+    return *this;
+}
+
+bool
+Ssl::CertError::operator == (const CertError &ce) const
+{
+    return code == ce.code && cert.get() == ce.cert.get();
+}
+
+bool
+Ssl::CertError::operator != (const CertError &ce) const
+{
+    return code != ce.code || cert.get() != ce.cert.get();
+}
+
 #endif /* USE_SSL */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/support.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/support.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/ssl/support.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/ssl/support.h	2015-05-01 18:05:19.000000000 +0800
@@ -52,31 +52,57 @@
 /**
  \defgroup ServerProtocolSSLAPI Server-Side SSL API
  \ingroup ServerProtocol
  */
 
 // Custom SSL errors; assumes all official errors are positive
+#define SQUID_X509_V_ERR_INFINITE_VALIDATION -4
 #define SQUID_X509_V_ERR_CERT_CHANGE -3
 #define SQUID_ERR_SSL_HANDSHAKE -2
 #define SQUID_X509_V_ERR_DOMAIN_MISMATCH -1
 // All SSL errors range: from smallest (negative) custom to largest SSL error
 #define SQUID_SSL_ERROR_MIN SQUID_X509_V_ERR_CERT_CHANGE
 #define SQUID_SSL_ERROR_MAX INT_MAX
 
+// Maximum certificate validation callbacks. OpenSSL versions exceeding this
+// limit are deemed stuck in an infinite validation loop (OpenSSL bug #3090)
+// and will trigger the SQUID_X509_V_ERR_INFINITE_VALIDATION error.
+// Can be set to a number up to UINT32_MAX
+#ifndef SQUID_CERT_VALIDATION_ITERATION_MAX
+#define SQUID_CERT_VALIDATION_ITERATION_MAX 16384
+#endif
+
 namespace AnyP
 {
 class PortCfg;
 };
 
 namespace Ssl
 {
 /// Squid defined error code (<0),  an error code returned by SSL X509 api, or SSL_ERROR_NONE
 typedef int ssl_error_t;
 
 typedef CbDataList<Ssl::ssl_error_t> Errors;
 
+/// An SSL certificate-related error.
+/// Pairs an error code with the certificate experiencing the error.
+class CertError
+{
+public:
+    ssl_error_t code; ///< certificate error code
+    X509_Pointer cert; ///< certificate with the above error code
+    CertError(ssl_error_t anErr, X509 *aCert);
+    CertError(CertError const &err);
+    CertError & operator = (const CertError &old);
+    bool operator == (const CertError &ce) const;
+    bool operator != (const CertError &ce) const;
+};
+
+/// Holds a list of certificate SSL errors
+typedef CbDataList<Ssl::CertError> CertErrors;
+
 } //namespace Ssl
 
 /// \ingroup ServerProtocolSSLAPI
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &port);
 
 /// \ingroup ServerProtocolSSLAPI
@@ -92,28 +118,37 @@
 void ssl_shutdown_method(SSL *ssl);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetUserEmail(SSL *ssl);
 
 /// \ingroup ServerProtocolSSLAPI
-typedef char const *SSLGETATTRIBUTE(SSL *, const char *);
-
-/// \ingroup ServerProtocolSSLAPI
-SSLGETATTRIBUTE sslGetUserAttribute;
+const char *sslGetUserAttribute(SSL *ssl, const char *attribute_name);
 
 /// \ingroup ServerProtocolSSLAPI
-SSLGETATTRIBUTE sslGetCAAttribute;
+const char *sslGetCAAttribute(SSL *ssl, const char *attribute_name);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetUserCertificatePEM(SSL *ssl);
 
 /// \ingroup ServerProtocolSSLAPI
 const char *sslGetUserCertificateChainPEM(SSL *ssl);
 
 namespace Ssl
 {
+/// \ingroup ServerProtocolSSLAPI
+typedef char const *GETX509ATTRIBUTE(X509 *, const char *);
+
+/// \ingroup ServerProtocolSSLAPI
+GETX509ATTRIBUTE GetX509UserAttribute;
+
+/// \ingroup ServerProtocolSSLAPI
+GETX509ATTRIBUTE GetX509CAAttribute;
+
+/// \ingroup ServerProtocolSSLAPI
+GETX509ATTRIBUTE GetX509Fingerprint;
+
 /**
   \ingroup ServerProtocolSSLAPI
  * Supported ssl-bump modes
  */
 enum BumpMode {bumpNone = 0, bumpClientFirst, bumpServerFirst, bumpEnd};
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/stat.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/stat.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/stat.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/stat.cc	2015-05-01 18:05:19.000000000 +0800
@@ -588,18 +588,12 @@
     stats.up_time = runtime;
     stats.cpu_time = cputime;
     stats.cpu_usage = Math::doublePercent(cputime, runtime);
     stats.cpu_usage5 = statCPUUsage(5);
     stats.cpu_usage60 = statCPUUsage(60);
 
-#if HAVE_SBRK
-
-    stats.proc_data_seg = ((char *) sbrk(0) - (char *) sbrk_start);
-
-#endif
-
     stats.maxrss = rusage_maxrss(&rusage);
 
     stats.page_faults = rusage_pagefaults(&rusage);
 
 #if HAVE_MSTATS && HAVE_GNUMALLOC_H
 
@@ -670,12 +664,14 @@
 void
 DumpInfo(Mgr::InfoActionData& stats, StoreEntry* sentry)
 {
     storeAppendPrintf(sentry, "Squid Object Cache: Version %s\n",
                       version_string);
 
+    storeAppendPrintf(sentry, "Build Info: " SQUID_BUILD_INFO "\n");
+
 #if _SQUID_WINDOWS_
     if (WIN32_run_mode == _WIN_SQUID_RUN_MODE_SERVICE) {
         storeAppendPrintf(sentry,"\nRunning as %s Windows System Service on %s\n",
                           WIN32_Service_name, WIN32_OS_string);
         storeAppendPrintf(sentry,"Service command line is: %s\n", WIN32_Service_Command_Line);
     } else
@@ -810,19 +806,12 @@
     storeAppendPrintf(sentry, "\tCPU Usage, 5 minute avg:\t%.2f%%\n",
                       stats.cpu_usage5);
 
     storeAppendPrintf(sentry, "\tCPU Usage, 60 minute avg:\t%.2f%%\n",
                       stats.cpu_usage60);
 
-#if HAVE_SBRK
-
-    storeAppendPrintf(sentry, "\tProcess Data Segment Size via sbrk(): %.0f KB\n",
-                      stats.proc_data_seg / 1024);
-
-#endif
-
     storeAppendPrintf(sentry, "\tMaximum Resident Size: %.0f KB\n",
                       stats.maxrss);
 
     storeAppendPrintf(sentry, "\tPage faults with physical i/o: %.0f\n",
                       stats.page_faults);
 
@@ -1457,24 +1446,18 @@
         }
     }
 
     if (Config.warnings.high_memory) {
         size_t i = 0;
 #if HAVE_MSTATS && HAVE_GNUMALLOC_H
-
         struct mstats ms = mstats();
         i = ms.bytes_total;
 #elif HAVE_MALLINFO && HAVE_STRUCT_MALLINFO
-
         struct mallinfo mp = mallinfo();
         i = mp.arena;
-#elif HAVE_SBRK
-
-        i = (size_t) ((char *) sbrk(0) - (char *) sbrk_start);
 #endif
-
         if (Config.warnings.high_memory < i)
             debugs(18, DBG_CRITICAL, "WARNING: Memory usage at " << ((unsigned long int)(i >> 20)) << " MB");
     }
 }
 
 static void
@@ -2022,32 +2005,26 @@
             storeAppendPrintf(s, "\tFD %d, read %" PRId64 ", wrote %" PRId64 "\n", fd,
                               fd_table[fd].bytes_read, fd_table[fd].bytes_written);
             storeAppendPrintf(s, "\tFD desc: %s\n", fd_table[fd].desc);
             storeAppendPrintf(s, "\tin: buf %p, offset %ld, size %ld\n",
                               conn->in.buf, (long int) conn->in.notYetUsed, (long int) conn->in.allocatedSize);
             storeAppendPrintf(s, "\tremote: %s\n",
-                              conn->clientConnection->remote.ToURL(buf,MAX_IPSTRLEN));
+                              conn->clientConnection->remote.toUrl(buf,MAX_IPSTRLEN));
             storeAppendPrintf(s, "\tlocal: %s\n",
-                              conn->clientConnection->local.ToURL(buf,MAX_IPSTRLEN));
+                              conn->clientConnection->local.toUrl(buf,MAX_IPSTRLEN));
             storeAppendPrintf(s, "\tnrequests: %d\n",
                               conn->nrequests);
         }
 
         storeAppendPrintf(s, "uri %s\n", http->uri);
-        storeAppendPrintf(s, "logType %s\n", Format::log_tags[http->logType]);
+        storeAppendPrintf(s, "logType %s\n", LogTags_str[http->logType]);
         storeAppendPrintf(s, "out.offset %ld, out.size %lu\n",
                           (long int) http->out.offset, (unsigned long int) http->out.size);
         storeAppendPrintf(s, "req_sz %ld\n", (long int) http->req_sz);
         e = http->storeEntry();
         storeAppendPrintf(s, "entry %p/%s\n", e, e ? e->getMD5Text() : "N/A");
-#if 0
-        /* Not a member anymore */
-        e = http->old_entry;
-        storeAppendPrintf(s, "old_entry %p/%s\n", e, e ? e->getMD5Text() : "N/A");
-#endif
-
         storeAppendPrintf(s, "start %ld.%06d (%f seconds ago)\n",
                           (long int) http->start_time.tv_sec,
                           (int) http->start_time.tv_usec,
                           tvSubDsec(http->start_time, current_time));
 #if USE_AUTH
         if (http->request->auth_user_request != NULL)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StatHist.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StatHist.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StatHist.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StatHist.cc	2015-05-01 18:05:19.000000000 +0800
@@ -70,17 +70,17 @@
         bins = static_cast<bins_type *>(xcalloc(src.capacity_, sizeof(bins_type)));
         memcpy(bins,src.bins,capacity_*sizeof(*bins));
     }
 }
 
 void
-StatHist::count(double val)
+StatHist::count(double v)
 {
     if (bins==NULL) //do not count before initialization or after destruction
         return;
-    const unsigned int bin = findBin(val);
+    const unsigned int bin = findBin(v);
     ++bins[bin];
 }
 
 unsigned int
 StatHist::findBin(double v)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/stmem.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/stmem.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/stmem.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/stmem.cc	2015-05-01 18:05:19.000000000 +0800
@@ -47,13 +47,13 @@
  * mem_node.cc.
  */
 char *
 mem_hdr::NodeGet(mem_node * aNode)
 {
     assert(!aNode->write_pending);
-    aNode->write_pending = 1;
+    aNode->write_pending = true;
     return aNode->data;
 }
 
 int64_t
 mem_hdr::lowestOffset () const
 {
@@ -266,13 +266,13 @@
     mem_node *p = getBlockContainingLocation(target.offset);
 
     if (!p) {
         debugs(19, DBG_IMPORTANT, "memCopy: could not find start of " << target.range() <<
                " in memory.");
         debugDump();
-        fatal("Squid has attempted to read data from memory that is not present. This is an indication of of (pre-3.0) code that hasn't been updated to deal with sparse objects in memory. Squid should coredump.allowing to review the cause. Immediately preceeding this message is a dump of the available data in the format [start,end). The [ means from the value, the ) means up to the value. I.e. [1,5) means that there are 4 bytes of data, at offsets 1,2,3,4.\n");
+        fatal("Squid has attempted to read data from memory that is not present. This is an indication of of (pre-3.0) code that hasn't been updated to deal with sparse objects in memory. Squid should coredump.allowing to review the cause. Immediately preceding this message is a dump of the available data in the format [start,end). The [ means from the value, the ) means up to the value. I.e. [1,5) means that there are 4 bytes of data, at offsets 1,2,3,4.\n");
         return 0;
     }
 
     size_t bytes_to_go = target.length;
     char *ptr_to_buf = target.data;
     int64_t location = target.offset;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store.cc	2015-05-01 18:05:19.000000000 +0800
@@ -377,38 +377,53 @@
      * otherwise, make subsequent clients read from disk so they
      * can not delay the first, and vice-versa.
      */
     return STORE_DISK_CLIENT;
 }
 
-StoreEntry::StoreEntry():
+StoreEntry::StoreEntry() :
+        mem_obj(NULL),
         hidden_mem_obj(NULL),
-        swap_file_sz(0)
+        timestamp(-1),
+        lastref(-1),
+        expires(-1),
+        lastmod(-1),
+        swap_file_sz(0),
+        refcount(0),
+        flags(0),
+        swap_filen(-1),
+        swap_dirn(-1),
+        lock_count(0),
+        mem_status(NOT_IN_MEMORY),
+        ping_status(PING_NONE),
+        store_status(STORE_PENDING),
+        swap_status(SWAPOUT_NONE)
 {
     debugs(20, 3, HERE << "new StoreEntry " << this);
-    mem_obj = NULL;
-
-    expires = lastmod = lastref = timestamp = -1;
-
-    swap_status = SWAPOUT_NONE;
-    swap_filen = -1;
-    swap_dirn = -1;
 }
 
-StoreEntry::StoreEntry(const char *aUrl, const char *aLogUrl):
+StoreEntry::StoreEntry(const char *aUrl, const char *aLogUrl) :
+        mem_obj(NULL),
         hidden_mem_obj(NULL),
-        swap_file_sz(0)
+        timestamp(-1),
+        lastref(-1),
+        expires(-1),
+        lastmod(-1),
+        swap_file_sz(0),
+        refcount(0),
+        flags(0),
+        swap_filen(-1),
+        swap_dirn(-1),
+        lock_count(0),
+        mem_status(NOT_IN_MEMORY),
+        ping_status(PING_NONE),
+        store_status(STORE_PENDING),
+        swap_status(SWAPOUT_NONE)
 {
     debugs(20, 3, HERE << "new StoreEntry " << this);
     mem_obj = new MemObject(aUrl, aLogUrl);
-
-    expires = lastmod = lastref = timestamp = -1;
-
-    swap_status = SWAPOUT_NONE;
-    swap_filen = -1;
-    swap_dirn = -1;
 }
 
 StoreEntry::~StoreEntry()
 {
     if (swap_filen >= 0) {
         SwapDir &sd = dynamic_cast<SwapDir&>(*store());
@@ -639,15 +654,15 @@
 
 StoreEntry *
 storeGetPublicByRequest(HttpRequest * req)
 {
     StoreEntry *e = storeGetPublicByRequestMethod(req, req->method);
 
-    if (e == NULL && req->method == METHOD_HEAD)
+    if (e == NULL && req->method == Http::METHOD_HEAD)
         /* We can generate a HEAD reply from a cached GET object */
-        e = storeGetPublicByRequestMethod(req, METHOD_GET);
+        e = storeGetPublicByRequestMethod(req, Http::METHOD_GET);
 
     return e;
 }
 
 static int
 getKeyCounter(void)
@@ -685,13 +700,13 @@
     }
 
     if (mem_obj != NULL) {
         mem_obj->id = getKeyCounter();
         newkey = storeKeyPrivate(mem_obj->url, mem_obj->method, mem_obj->id);
     } else {
-        newkey = storeKeyPrivate("JUNK", METHOD_NONE, getKeyCounter());
+        newkey = storeKeyPrivate("JUNK", Http::METHOD_NONE, getKeyCounter());
     }
 
     assert(hash_lookup(store_table, newkey) == NULL);
     EBIT_SET(flags, KEY_PRIVATE);
     hashInsert(newkey);
 }
@@ -758,13 +773,13 @@
         if (mem_obj->vary_headers && !storeGetPublic(mem_obj->url, mem_obj->method)) {
             /* Create "vary" base object */
             String vary;
             StoreEntry *pe = storeCreateEntry(mem_obj->url, mem_obj->log_url, request->flags, request->method);
             /* We are allowed to do this typecast */
             HttpReply *rep = new HttpReply;
-            rep->setHeaders(HTTP_OK, "Internal marker object", "x-squid-internal/vary", 0, -1, squid_curtime + 100000);
+            rep->setHeaders(Http::scOkay, "Internal marker object", "x-squid-internal/vary", -1, -1, squid_curtime + 100000);
             vary = mem_obj->getReply()->header.getList(HDR_VARY);
 
             if (vary.size()) {
                 /* Again, we own this structure layout */
                 rep->header.putStr(HDR_VARY, vary.termedBuf());
                 vary.clean();
@@ -981,13 +996,13 @@
 // TODO: move "too many open..." checks outside -- we are called too early/late
 int
 StoreEntry::checkCachable()
 {
 #if CACHE_ALL_METHODS
 
-    if (mem_obj->method != METHOD_GET) {
+    if (mem_obj->method != Http::METHOD_GET) {
         debugs(20, 2, "StoreEntry::checkCachable: NO: non-GET method");
         ++store_check_cachable_hist.no.non_get;
     } else
 #endif
         if (store_status == STORE_OK && EBIT_TEST(flags, ENTRY_BAD_LENGTH)) {
             debugs(20, 2, "StoreEntry::checkCachable: NO: wrong content-length");
@@ -1381,21 +1396,21 @@
 
     if (reply->hdr_sz == 0) {
         debugs(20, 5, "storeEntryValidLength: Zero header size: " << getMD5Text());
         return 1;
     }
 
-    if (mem_obj->method == METHOD_HEAD) {
+    if (mem_obj->method == Http::METHOD_HEAD) {
         debugs(20, 5, "storeEntryValidLength: HEAD request: " << getMD5Text());
         return 1;
     }
 
-    if (reply->sline.status == HTTP_NOT_MODIFIED)
+    if (reply->sline.status() == Http::scNotModified)
         return 1;
 
-    if (reply->sline.status == HTTP_NO_CONTENT)
+    if (reply->sline.status() == Http::scNoContent)
         return 1;
 
     diff = reply->hdr_sz + reply->content_length - objectLen();
 
     if (diff == 0)
         return 1;
@@ -1677,12 +1692,14 @@
         return mem_obj->url;
 }
 
 void
 StoreEntry::createMemObject(const char *aUrl, const char *aLogUrl)
 {
+    debugs(20, 3, "A mem_obj create attempted using : " << aUrl);
+
     if (mem_obj)
         return;
 
     if (hidden_mem_obj) {
         debugs(20, 3, HERE << "restoring " << hidden_mem_obj);
         mem_obj = hidden_mem_obj;
@@ -1974,13 +1991,13 @@
 bool
 StoreEntry::hasIfNoneMatchEtag(const HttpRequest &request) const
 {
     const String reqETags = request.header.getList(HDR_IF_NONE_MATCH);
     // weak comparison is allowed only for HEAD or full-body GET requests
     const bool allowWeakMatch = !request.flags.isRanged &&
-                                (request.method == METHOD_GET || request.method == METHOD_HEAD);
+                                (request.method == Http::METHOD_GET || request.method == Http::METHOD_HEAD);
     return hasOneOfEtags(reqETags, allowWeakMatch);
 }
 
 /// whether at least one of the request ETags matches entity ETag
 bool
 StoreEntry::hasOneOfEtags(const String &reqETags, const bool allowWeakMatch) const
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_client.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_client.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_client.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_client.cc	2015-05-01 18:05:19.000000000 +0800
@@ -65,27 +65,12 @@
 static EVH storeClientCopyEvent;
 static bool CheckQuickAbortIsReasonable(StoreEntry * entry);
 static void CheckQuickAbort(StoreEntry * entry);
 
 CBDATA_CLASS_INIT(store_client);
 
-void *
-store_client::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(store_client);
-    store_client *result = cbdataAlloc(store_client);
-    return result;
-}
-
-void
-store_client::operator delete (void *address)
-{
-    store_client *t = static_cast<store_client *>(address);
-    cbdataFree(t);
-}
-
 bool
 store_client::memReaderHasLowerOffset(int64_t anOffset) const
 {
     return getType() == STORE_MEM_CLIENT && copyInto.offset < anOffset;
 }
 
@@ -172,13 +157,13 @@
 static void
 storeClientCopyEvent(void *data)
 {
     store_client *sc = (store_client *)data;
     debugs(90, 3, "storeClientCopyEvent: Running");
     assert (sc->flags.copy_event_pending);
-    sc->flags.copy_event_pending = 0;
+    sc->flags.copy_event_pending = false;
 
     if (!sc->_callback.pending())
         return;
 
     storeClientCopy2(sc->entry, sc);
 }
@@ -188,13 +173,13 @@
         , delayId()
 #endif
         , type (e->storeClientType())
         ,  object_ok(true)
 {
     cmp_offset = 0;
-    flags.disk_io_pending = 0;
+    flags.disk_io_pending = false;
     ++ entry->refcount;
 
     if (getType() == STORE_DISK_CLIENT)
         /* assert we'll be able to get the data we want */
         /* maybe we should open swapin_sio here */
         assert(entry->swap_filen > -1 || entry->swappingOut());
@@ -320,13 +305,13 @@
     if (EBIT_TEST(e->flags, ENTRY_FWD_HDR_WAIT)) {
         debugs(90, 5, "storeClientCopy2: returning because ENTRY_FWD_HDR_WAIT set");
         return;
     }
 
     if (sc->flags.store_copying) {
-        sc->flags.copy_event_pending = 1;
+        sc->flags.copy_event_pending = true;
         debugs(90, 3, "storeClientCopy2: Queueing storeClientCopyEvent()");
         eventAdd("storeClientCopyEvent", storeClientCopyEvent, sc, 0.0, 0);
         return;
     }
 
     debugs(90, 3, "storeClientCopy2: " << e->getMD5Text());
@@ -343,41 +328,41 @@
      * this function
      * XXX: Locking does not prevent calling sc destructor (it only prevents
      * freeing sc memory) so sc may become invalid from C++ p.o.v.
      *
      */
     cbdataInternalLock(sc);
-    assert (sc->flags.store_copying == 0);
+    assert (!sc->flags.store_copying);
     sc->doCopy(e);
-    assert (sc->flags.store_copying == 0);
+    assert (!sc->flags.store_copying);
     cbdataInternalUnlock(sc);
 }
 
 void
 store_client::doCopy(StoreEntry *anEntry)
 {
     assert (anEntry == entry);
-    flags.store_copying = 1;
+    flags.store_copying = true;
     MemObject *mem = entry->mem_obj;
 
     debugs(33, 5, "store_client::doCopy: co: " <<
            copyInto.offset << ", hi: " <<
            mem->endOffset());
 
     if (storeClientNoMoreToSend(entry, this)) {
         /* There is no more to send! */
         debugs(33, 3, HERE << "There is no more to send!");
         callback(0);
-        flags.store_copying = 0;
+        flags.store_copying = false;
         return;
     }
 
     /* Check that we actually have data */
     if (anEntry->store_status == STORE_PENDING && copyInto.offset >= mem->endOffset()) {
         debugs(90, 3, "store_client::doCopy: Waiting for more");
-        flags.store_copying = 0;
+        flags.store_copying = false;
         return;
     }
 
     /*
      * Slight weirdness here.  We open a swapin file for any
      * STORE_DISK_CLIENT, even if we can copy the requested chunk
@@ -402,34 +387,34 @@
     debugs(90, 3, "store_client::doCopy: Need to open swap in file");
     /* gotta open the swapin file */
 
     if (storeTooManyDiskFilesOpen()) {
         /* yuck -- this causes a TCP_SWAPFAIL_MISS on the client side */
         fail();
-        flags.store_copying = 0;
+        flags.store_copying = false;
         return;
     } else if (!flags.disk_io_pending) {
         /* Don't set store_io_pending here */
         storeSwapInStart(this);
 
         if (swapin_sio == NULL) {
             fail();
-            flags.store_copying = 0;
+            flags.store_copying = false;
             return;
         }
 
         /*
          * If the open succeeds we either copy from memory, or
          * schedule a disk read in the next block.
          */
         scheduleRead();
 
         return;
     } else {
         debugs(90, DBG_IMPORTANT, "WARNING: Averted multiple fd operation (1)");
-        flags.store_copying = 0;
+        flags.store_copying = false;
         return;
     }
 }
 
 void
 store_client::scheduleRead()
@@ -451,34 +436,34 @@
     assert(!flags.disk_io_pending);
 
     debugs(90, 3, "store_client::doCopy: reading from STORE");
 
     fileRead();
 
-    flags.store_copying = 0;
+    flags.store_copying = false;
 }
 
 void
 store_client::scheduleMemRead()
 {
     /* What the client wants is in memory */
     /* Old style */
     debugs(90, 3, "store_client::doCopy: Copying normal from memory");
     size_t sz = entry->mem_obj->data_hdr.copy(copyInto);
     callback(sz);
-    flags.store_copying = 0;
+    flags.store_copying = false;
 }
 
 void
 store_client::fileRead()
 {
     MemObject *mem = entry->mem_obj;
 
     assert(_callback.pending());
     assert(!flags.disk_io_pending);
-    flags.disk_io_pending = 1;
+    flags.disk_io_pending = true;
 
     if (mem->swap_hdr_sz != 0)
         if (entry->swap_status == SWAPOUT_WRITING)
             assert(mem->swapout.sio->offset() > copyInto.offset + (int64_t)mem->swap_hdr_sz);
 
     storeRead(swapin_sio,
@@ -499,17 +484,17 @@
 void
 store_client::readBody(const char *buf, ssize_t len)
 {
     int parsed_header = 0;
 
     // Don't assert disk_io_pending here.. may be called by read_header
-    flags.disk_io_pending = 0;
+    flags.disk_io_pending = false;
     assert(_callback.pending());
     debugs(90, 3, "storeClientReadBody: len " << len << "");
 
-    if (copyInto.offset == 0 && len > 0 && entry->getReply()->sline.status == 0) {
+    if (copyInto.offset == 0 && len > 0 && entry->getReply()->sline.status() == Http::scNone) {
         /* Our structure ! */
         HttpReply *rep = (HttpReply *) entry->getReply(); // bypass const
 
         if (!rep->parseCharBuf(copyInto.data, headersEnd(copyInto.data, len))) {
             debugs(90, DBG_CRITICAL, "Could not parse headers from on disk object");
         } else {
@@ -623,13 +608,13 @@
 void
 store_client::readHeader(char const *buf, ssize_t len)
 {
     MemObject *const mem = entry->mem_obj;
 
     assert(flags.disk_io_pending);
-    flags.disk_io_pending = 0;
+    flags.disk_io_pending = false;
     assert(_callback.pending());
 
     unpackHeader (buf, len);
 
     if (!object_ok)
         return;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreClient.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreClient.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreClient.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreClient.h	2015-05-01 18:05:19.000000000 +0800
@@ -56,14 +56,12 @@
 /* keep track each client receiving data from that particular StoreEntry */
 
 class store_client
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
     store_client(StoreEntry *);
     ~store_client();
     bool memReaderHasLowerOffset(int64_t) const;
     int getType() const;
     void fail();
     void callback(ssize_t len, bool error = false);
@@ -80,15 +78,15 @@
 #endif
 
     StoreEntry *entry;		/* ptr to the parent StoreEntry, argh! */
     StoreIOState::Pointer swapin_sio;
 
     struct {
-        unsigned int disk_io_pending:1;
-        unsigned int store_copying:1;
-        unsigned int copy_event_pending:1;
+        bool disk_io_pending;
+        bool store_copying;
+        bool copy_event_pending;
     } flags;
 
 #if USE_DELAY_POOLS
     DelayId delayId;
     void setDelayId(DelayId delay_id);
 #endif
@@ -119,13 +117,13 @@
         bool pending() const;
         STCB *callback_handler;
         void *callback_data;
     } _callback;
 
 private:
-    CBDATA_CLASS(store_client);
+    CBDATA_CLASS2(store_client);
 };
 
 void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
 store_client* storeClientListAdd(StoreEntry * e, void *data);
 int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
 int storeUnregister(store_client * sc, StoreEntry * e, void *data);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_digest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_digest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_digest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_digest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -389,19 +389,20 @@
         return;
     }
 
     debugs(71, 2, "storeDigestRewrite: start rewrite #" << sd_state.rewrite_count + 1);
     /* make new store entry */
     url = internalLocalUri("/squid-internal-periodic/", StoreDigestFileName);
-    flags.cachable = 1;
-    e = storeCreateEntry(url, url, flags, METHOD_GET);
+    flags.cachable = true;
+    e = storeCreateEntry(url, url, flags, Http::METHOD_GET);
     assert(e);
     sd_state.rewrite_lock = e;
     debugs(71, 3, "storeDigestRewrite: url: " << url << " key: " << e->getMD5Text());
     HttpRequest *req = HttpRequest::CreateFromUrl(url);
-    e->mem_obj->request = HTTPMSGLOCK(req);
+    e->mem_obj->request = req;
+    HTTPMSGLOCK(e->mem_obj->request);
     /* wait for rebuild (if any) to finish */
 
     if (sd_state.rebuild_lock) {
         debugs(71, 2, "storeDigestRewriteStart: waiting for rebuild to finish.");
         return;
     }
@@ -420,13 +421,13 @@
     sd_state.rewrite_offset = 0;
     EBIT_SET(e->flags, ENTRY_SPECIAL);
     /* setting public key will purge old digest entry if any */
     e->setPublicKey();
     /* fake reply */
     HttpReply *rep = new HttpReply;
-    rep->setHeaders(HTTP_OK, "Cache Digest OK",
+    rep->setHeaders(Http::scOkay, "Cache Digest OK",
                     "application/cache-digest", (store_digest->mask_size + sizeof(sd_state.cblock)),
                     squid_curtime, (squid_curtime + Config.digest.rewrite_period) );
     debugs(71, 3, "storeDigestRewrite: entry expires on " << rep->expires <<
            " (" << std::showpos << (int) (rep->expires - squid_curtime) << ")");
     e->buffer();
     e->replaceHttpReply(rep);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_dir.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_dir.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_dir.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_dir.cc	2015-05-01 18:05:19.000000000 +0800
@@ -262,13 +262,13 @@
 
     if (objsize != -1)
         objsize += e->mem_obj->swap_hdr_sz;
 
     for (i = 0; i < Config.cacheSwap.n_configured; ++i) {
         SD = dynamic_cast<SwapDir *>(INDEXSD(i));
-        SD->flags.selected = 0;
+        SD->flags.selected = false;
 
         if (!SD->canStore(*e, objsize, load))
             continue;
 
         if (load < 0 || load > 1000)
             continue;
@@ -295,13 +295,13 @@
         least_objsize = SD->maxObjectSize();
         most_free = cur_free;
         dirn = i;
     }
 
     if (dirn >= 0)
-        dynamic_cast<SwapDir *>(INDEXSD(dirn))->flags.selected = 1;
+        dynamic_cast<SwapDir *>(INDEXSD(dirn))->flags.selected = true;
 
     return dirn;
 }
 
 /*
  * An entry written to the swap log MUST have the following
@@ -1128,13 +1128,18 @@
 
     return new StoreSearchHashIndex (this);
 }
 
 CBDATA_CLASS_INIT(StoreSearchHashIndex);
 
-StoreSearchHashIndex::StoreSearchHashIndex(RefCount<StoreHashIndex> aSwapDir) : sd(aSwapDir), _done (false), bucket (0)
+StoreSearchHashIndex::StoreSearchHashIndex(RefCount<StoreHashIndex> aSwapDir) :
+        sd(aSwapDir),
+        callback(NULL),
+        cbdata(NULL),
+        _done(false),
+        bucket(0)
 {}
 
 /* do not link
 StoreSearchHashIndex::StoreSearchHashIndex(StoreSearchHashIndex const &);
 */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreFileSystem.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreFileSystem.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreFileSystem.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreFileSystem.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,13 +28,13 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #ifndef SQUID_STOREFILESYSTEM_H
 #define SQUID_STOREFILESYSTEM_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* ****** DOCUMENTATION ***** */
 
 /**
  \defgroup FileSystems	Storage Filesystems
  *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Store.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Store.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/Store.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/Store.h	2015-05-01 18:05:19.000000000 +0800
@@ -32,19 +32,19 @@
 
 /**
  \defgroup StoreAPI  Store API
  \ingroup FileSystems
  */
 
+#include "base/RefCount.h"
 #include "comm/forward.h"
 #include "CommRead.h"
 #include "hash.h"
 #include "HttpReply.h"
 #include "HttpRequestMethod.h"
 #include "Range.h"
-#include "RefCount.h"
 #include "RemovalPolicy.h"
 #include "StoreIOBuffer.h"
 #include "StoreStats.h"
 
 #if USE_SQUID_ESI
 #include "esi/Element.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_io.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_io.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_io.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_io.cc	2015-05-01 18:05:19.000000000 +0800
@@ -60,13 +60,13 @@
 {
     if (sio->flags.closing) {
         debugs(20,3,HERE << "storeClose: flags.closing already set, bailing");
         return;
     }
 
-    sio->flags.closing = 1;
+    sio->flags.closing = true;
 
     debugs(20,3,HERE << "storeClose: calling sio->close(" << how << ")");
     sio->close(how);
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreIOState.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreIOState.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreIOState.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreIOState.cc	2015-05-01 18:05:19.000000000 +0800
@@ -43,15 +43,19 @@
     return (void *)1;
 }
 
 void
 StoreIOState::operator delete (void *address) {assert (0);}
 
-StoreIOState::StoreIOState()
+StoreIOState::StoreIOState() :
+        swap_dirn(-1), swap_filen(-1), e(NULL), mode(O_BINARY),
+        offset_(0), file_callback(NULL), callback(NULL), callback_data(NULL)
 {
-    mode = O_BINARY;
+    read.callback = NULL;
+    read.callback_data = NULL;
+    flags.closing = false;
 }
 
 off_t
 StoreIOState::offset() const
 {
     return offset_;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreIOState.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreIOState.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreIOState.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreIOState.h	2015-05-01 18:05:19.000000000 +0800
@@ -29,14 +29,14 @@
  *
  */
 
 #ifndef SQUID_STOREIOSTATE_H
 #define SQUID_STOREIOSTATE_H
 
+#include "base/RefCount.h"
 #include "cbdata.h"
-#include "RefCount.h"
 
 class StoreIOState : public RefCountable
 {
 
 public:
     typedef RefCount<StoreIOState> Pointer;
@@ -102,13 +102,13 @@
     struct {
         STRCB *callback;
         void *callback_data;
     } read;
 
     struct {
-        unsigned int closing:1;	/* debugging aid */
+        bool closing;	/* debugging aid */
     } flags;
 };
 
 StoreIOState::Pointer storeCreate(StoreEntry *, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
 StoreIOState::Pointer storeOpen(StoreEntry *, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
 void storeClose(StoreIOState::Pointer, int how);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_key_md5.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_key_md5.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_key_md5.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_key_md5.cc	2015-05-01 18:05:19.000000000 +0800
@@ -103,13 +103,13 @@
 const cache_key *
 storeKeyPrivate(const char *url, const HttpRequestMethod& method, int id)
 {
     static cache_key digest[SQUID_MD5_DIGEST_LENGTH];
     SquidMD5_CTX M;
     assert(id > 0);
-    debugs(20, 3, "storeKeyPrivate: " << RequestMethodStr(method) << " " << url);
+    debugs(20, 3, "storeKeyPrivate: " << method << " " << url);
     SquidMD5Init(&M);
     SquidMD5Update(&M, (unsigned char *) &id, sizeof(id));
     SquidMD5Update(&M, (unsigned char *) &method, sizeof(method));
     SquidMD5Update(&M, (unsigned char *) url, strlen(url));
     SquidMD5Final(digest, &M);
     return digest;
@@ -136,20 +136,22 @@
 
 const cache_key *
 storeKeyPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method)
 {
     static cache_key digest[SQUID_MD5_DIGEST_LENGTH];
     unsigned char m = (unsigned char) method.id();
-    const char *url = urlCanonical(request);
+    const char *url = request->storeId(); /* storeId returns the right storeID\canonical URL for the md5 calc */
     SquidMD5_CTX M;
     SquidMD5Init(&M);
     SquidMD5Update(&M, &m, sizeof(m));
     SquidMD5Update(&M, (unsigned char *) url, strlen(url));
 
-    if (request->vary_headers)
+    if (request->vary_headers) {
         SquidMD5Update(&M, (unsigned char *) request->vary_headers, strlen(request->vary_headers));
+        debugs(20, 3, "updating public key by vary headers: " << request->vary_headers << " for: " << url);
+    }
 
     SquidMD5Final(digest, &M);
 
     return digest;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_log.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_log.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_log.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_log.cc	2015-05-01 18:05:19.000000000 +0800
@@ -90,13 +90,13 @@
                       (int) current_time.tv_sec,
                       (int) current_time.tv_usec / 1000,
                       storeLogTags[tag],
                       e->swap_dirn,
                       e->swap_filen,
                       e->getMD5Text(),
-                      reply->sline.status,
+                      reply->sline.status(),
                       (int) reply->date,
                       (int) reply->last_modified,
                       (int) reply->expires,
                       SQUIDSTRINGPRINT(ctype),
                       reply->content_length,
                       e->contentLen(),
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_rebuild.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_rebuild.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_rebuild.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_rebuild.cc	2015-05-01 18:05:19.000000000 +0800
@@ -291,14 +291,13 @@
 
     StoreEntry *what;
     cache_key *index;
 };
 
 bool
-storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf,
-                      StoreRebuildData &counts)
+storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf, StoreRebuildData &)
 {
     if (fd < 0)
         return false;
 
     assert(buf.hasSpace()); // caller must allocate
 
@@ -314,13 +313,13 @@
     buf.appended(len);
     return true;
 }
 
 bool
 storeRebuildParseEntry(MemBuf &buf, StoreEntry &tmpe, cache_key *key,
-                       StoreRebuildData &counts,
+                       StoreRebuildData &stats,
                        uint64_t expectedSize)
 {
     int swap_hdr_len = 0;
     StoreMetaUnpacker aBuilder(buf.content(), buf.contentSize(), &swap_hdr_len);
     if (aBuilder.isBufferZero()) {
         debugs(47,5, HERE << "skipping empty record.");
@@ -371,22 +370,21 @@
         debugs(47, DBG_IMPORTANT, "WARNING: Ignoring cache entry with " <<
                "unknown size: " << tmpe);
         return false;
     }
 
     if (EBIT_TEST(tmpe.flags, KEY_PRIVATE)) {
-        ++ counts.badflags;
+        ++ stats.badflags;
         return false;
     }
 
     return true;
 }
 
 bool
-storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key,
-                      StoreRebuildData &counts)
+storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key, StoreRebuildData &stats)
 {
     /* this needs to become
      * 1) unpack url
      * 2) make synthetic request with headers ?? or otherwise search
      * for a matching object in the store
      * TODO FIXME change to new async api
@@ -405,24 +403,24 @@
      */
     if (StoreEntry *e = Store::Root().get(key)) {
 
         if (e->lastref >= tmpe.lastref) {
             /* key already exists, old entry is newer */
             /* keep old, ignore new */
-            ++counts.dupcount;
+            ++stats.dupcount;
 
             // For some stores, get() creates/unpacks a store entry. Signal
             // such stores that we will no longer use the get() result:
             e->lock();
             e->unlock();
 
             return false;
         } else {
             /* URL already exists, this swapfile not being used */
             /* junk old, load new */
             e->release();	/* release old entry */
-            ++counts.dupcount;
+            ++stats.dupcount;
         }
     }
 
     return true;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreSearch.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreSearch.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/StoreSearch.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/StoreSearch.h	2015-05-01 18:05:19.000000000 +0800
@@ -28,13 +28,13 @@
  *
  */
 
 #ifndef SQUID_STORESEARCH_H
 #define SQUID_STORESEARCH_H
 
-#include "RefCount.h"
+#include "base/RefCount.h"
 #include "Store.h"
 
 class StoreSearch : public RefCountable
 {
 
 public:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_swapmeta.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_swapmeta.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/store_swapmeta.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/store_swapmeta.cc	2015-05-01 18:05:19.000000000 +0800
@@ -64,14 +64,21 @@
     tlv **T = &TLV;
     const char *url;
     const char *vary;
     assert(e->mem_obj != NULL);
     const int64_t objsize = e->mem_obj->expectedReplySize();
     assert(e->swap_status == SWAPOUT_WRITING);
-    url = e->url();
-    debugs(20, 3, "storeSwapMetaBuild: " << url  );
+
+    // e->mem_obj->request may be nil in this context
+    if (e->mem_obj->request)
+        url = e->mem_obj->request->storeId();
+    else
+        url = e->url();
+
+    debugs(20, 3, "storeSwapMetaBuild URL: " << url);
+
     tlv *t = StoreMeta::Factory (STORE_META_KEY,SQUID_MD5_DIGEST_LENGTH, e->key);
 
     if (!t) {
         storeSwapTLVFree(TLV);
         return NULL;
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/String.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/String.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/String.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/String.cc	2015-05-01 18:05:19.000000000 +0800
@@ -373,13 +373,14 @@
     word = d = p;
 
     while ((ch = *p)) {
         switch (ch) {
 
         case '\\':
-            ++p;
+            if (quoted)
+                ++p;
 
             switch (*p) {
 
             case 'n':
                 ch = '\n';
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SwapDir.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SwapDir.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SwapDir.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SwapDir.cc	2015-05-01 18:05:19.000000000 +0800
@@ -268,13 +268,13 @@
     return result;
 }
 
 void
 SwapDir::parseOptions(int isaReconfig)
 {
-    unsigned int old_read_only = flags.read_only;
+    const bool old_read_only = flags.read_only;
     char *name, *value;
 
     ConfigOption *newOption = getOptionTree();
 
     while ((name = strtok(NULL, w_space)) != NULL) {
         value = strchr(name, '=');
@@ -324,18 +324,18 @@
         return false;
 
     if (strcmp(option, "read-only") == 0) {
         debugs(3, DBG_PARSE_NOTE(3), "UPGRADE WARNING: Replace cache_dir option 'read-only' with 'no-store'.");
     }
 
-    int read_only = 0;
+    bool read_only = 0;
 
     if (value)
-        read_only = xatoi(value);
+        read_only = (xatoi(value) != 0);
     else
-        read_only = 1;
+        read_only = true;
 
     flags.read_only = read_only;
 
     return true;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SwapDir.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SwapDir.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/SwapDir.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/SwapDir.h	2015-05-01 18:05:19.000000000 +0800
@@ -195,15 +195,15 @@
     int disker; ///< disker kid id dedicated to this SwapDir or -1
     RemovalPolicy *repl;
     int removals;
     int scanned;
 
     struct Flags {
-        Flags() : selected(0), read_only(0) {}
-        unsigned int selected:1;
-        unsigned int read_only:1;
+        Flags() : selected(false), read_only(false) {}
+        bool selected;
+        bool read_only;
     } flags;
     virtual void init() = 0;	/* Initialise the fs */
     virtual void create();	/* Create a new fs */
     virtual void dump(StoreEntry &)const;	/* Dump fs config snippet */
     virtual bool doubleCheck(StoreEntry &);	/* Double check the obj integrity */
     virtual void statfs(StoreEntry &) const;	/* Dump fs statistics */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_cache_cf.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_cache_cf.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_cache_cf.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_cache_cf.cc	2015-05-01 18:05:19.000000000 +0800
@@ -45,8 +45,10 @@
 void parse_eol(char *volatile *var) STUB
 void parse_wordlist(wordlist ** list) STUB
 void requirePathnameExists(const char *name, const char *path) STUB_NOP
 void parse_time_t(time_t * var) STUB
 char * strtokFile(void) STUB_RETVAL(NULL)
 void ConfigParser::ParseUShort(unsigned short *var) STUB
+void ConfigParser::ParseString(String*) STUB
 void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head) STUB
+void dump_acl_list(StoreEntry*, ACLList*) STUB
 YesNoNone::operator void*() const { STUB_NOP; return NULL; }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests: stub_cbdata.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_client_db.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_client_db.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_client_db.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_client_db.cc	2015-05-01 18:05:19.000000000 +0800
@@ -4,13 +4,13 @@
 #define STUB_API "client_db.cc"
 #include "tests/STUB.h"
 
 class ClientInfo;
 
 void clientdbInit(void) STUB
-void clientdbUpdate(const Ip::Address &, log_type, AnyP::ProtocolType, size_t) STUB
+void clientdbUpdate(const Ip::Address &, LogTags, AnyP::ProtocolType, size_t) STUB
 int clientdbCutoffDenied(const Ip::Address &) STUB_RETVAL(-1)
 void clientdbDump(StoreEntry *) STUB
 void clientdbFreeMemory(void) STUB
 int clientdbEstablished(const Ip::Address &, int) STUB_RETVAL(-1)
 #if USE_DELAY_POOLS
 void clientdbSetWriteLimiter(ClientInfo * info, const int writeSpeedLimit,const double initialBurst,const double highWatermark) STUB
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests: stub_client_side.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_comm.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_comm.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_comm.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_comm.cc	2015-05-01 18:05:19.000000000 +0800
@@ -41,13 +41,13 @@
 
 void comm_read(const Comm::ConnectionPointer &conn, char *buf, int size, IOCB *handler, void *handler_data) STUB
 void comm_read(const Comm::ConnectionPointer &conn, char*, int, AsyncCall::Pointer &callback) STUB
 
 /* should be in stub_CommRead */
 #include "CommRead.h"
-CommRead::CommRead(const Comm::ConnectionPointer &, char *buf, int len, AsyncCall::Pointer &callback) STUB
+CommRead::CommRead(const Comm::ConnectionPointer &, char *, int, AsyncCall::Pointer &) STUB
 CommRead::CommRead() STUB
 DeferredReadManager::~DeferredReadManager() STUB
 DeferredRead::DeferredRead(DeferrableRead *, void *, CommRead const &) STUB
 void DeferredReadManager::delayRead(DeferredRead const &aRead) STUB
 void DeferredReadManager::kickReads(int const count) STUB
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_debug.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_debug.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_debug.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_debug.cc	2015-05-01 18:05:19.000000000 +0800
@@ -17,12 +17,13 @@
 
 char *Debug::debugOptions;
 char *Debug::cache_log= NULL;
 int Debug::rotateNumber = 0;
 int Debug::Levels[MAX_DEBUG_SECTIONS];
 int Debug::level;
+int Debug::sectionLevel;
 int Debug::override_X = 0;
 int Debug::log_stderr = 1;
 bool Debug::log_syslog = false;
 
 Ctx
 ctx_enter(const char *descr)
@@ -137,6 +138,26 @@
 
 const char*
 SkipBuildPrefix(const char* path)
 {
     return path;
 }
+
+std::ostream &
+Raw::print(std::ostream &os) const
+{
+    if (label_)
+        os << ' ' << label_ << '[' << size_ << ']';
+
+    if (!size_)
+        return os;
+
+    // finalize debugging level if no level was set explicitly via minLevel()
+    const int finalLevel = (level >= 0) ? level :
+                           (size_ > 40 ? DBG_DATA : Debug::sectionLevel);
+    if (finalLevel <= Debug::sectionLevel) {
+        os << (label_ ? '=' : ' ');
+        os.write(data_, size_);
+    }
+
+    return os;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_DelayId.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_DelayId.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_DelayId.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_DelayId.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,12 +35,12 @@
 #if USE_DELAY_POOLS
 #include "DelayId.h"
 
 #define STUB_API "stub_DelayId.cc"
 #include "tests/STUB.h"
 
-DelayId::DelayId() {}
+DelayId::DelayId(): pool_(0), compositeId(NULL), markedAsNoDelay(false) {}
 DelayId::~DelayId() {}
 
 void DelayId::delayRead(DeferredRead const&) STUB_NOP
 
 #endif /* USE_DELAY_POOLS */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_errorpage.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_errorpage.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_errorpage.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_errorpage.cc	2015-05-01 18:05:19.000000000 +0800
@@ -6,7 +6,7 @@
 
 err_type errorReservePageId(const char *page_name) STUB_RETVAL(err_type())
 void errorAppendEntry(StoreEntry * entry, ErrorState * err) STUB
 bool strHdrAcptLangGetItem(const String &hdr, char *lang, int langLen, size_t &pos) STUB_RETVAL(false)
 bool TemplateFile::loadDefault() STUB_RETVAL(false)
 TemplateFile::TemplateFile(char const*, err_type) STUB
-bool TemplateFile::loadFor(HttpRequest*) STUB_RETVAL(false)
+bool TemplateFile::loadFor(const HttpRequest *) STUB_RETVAL(false)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_helper.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_helper.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_helper.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_helper.cc	2015-05-01 18:05:19.000000000 +0800
@@ -2,13 +2,13 @@
 #include "helper.h"
 
 #define STUB_API "helper.cc"
 #include "tests/STUB.h"
 
 void helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data) STUB
-void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPSCB * callback, void *data, helper_stateful_server * lastserver) STUB
+void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver) STUB
 helper::~helper() STUB
 CBDATA_CLASS_INIT(helper);
 
 void helperStats(StoreEntry * sentry, helper * hlp, const char *label) STUB
 void helperStatefulStats(StoreEntry * sentry, statefulhelper * hlp, const char *label) STUB
 void helperShutdown(helper * hlp) STUB
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_HttpReply.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_HttpReply.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_HttpReply.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_HttpReply.cc	2015-05-01 18:05:19.000000000 +0800
@@ -1,25 +1,23 @@
 #include "squid.h"
 #include "HttpReply.h"
 
 #define STUB_API "HttpReply.cc"
 #include "tests/STUB.h"
 
-HttpReply::HttpReply() : HttpMsg(hoReply)
-{
-// XXX: required by testStore
-// STUB
-}
-HttpReply::~HttpReply() STUB
-void HttpReply::setHeaders(http_status status, const char *reason, const char *ctype, int64_t clen, time_t lmt, time_t expires_) STUB
-void HttpReply::packHeadersInto(Packer * p) const STUB
-void HttpReply::reset() STUB
-void httpBodyPackInto(const HttpBody * body, Packer * p) STUB
-bool HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error) STUB_RETVAL(false)
-int HttpReply::httpMsgParseError() STUB_RETVAL(0)
-bool HttpReply::expectingBody(const HttpRequestMethod&, int64_t&) const STUB_RETVAL(false)
-void HttpReply::packFirstLineInto(Packer * p, bool) const STUB
-bool HttpReply::parseFirstLine(const char *start, const char *end) STUB_RETVAL(false)
-void HttpReply::hdrCacheInit() STUB
-HttpReply * HttpReply::clone() const STUB_RETVAL(NULL)
-bool HttpReply::inheritProperties(const HttpMsg *aMsg) STUB_RETVAL(false)
-int64_t HttpReply::bodySize(const HttpRequestMethod&) const STUB_RETVAL(0)
+HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
+        expires (0), surrogate_control (NULL), content_range (NULL), keep_alive (0),
+        protoPrefix("HTTP/"), bodySizeMax(-2)
+        STUB_NOP
+        HttpReply::~HttpReply() STUB
+        void HttpReply::setHeaders(Http::StatusCode status, const char *reason, const char *ctype, int64_t clen, time_t lmt, time_t expires_) STUB
+        void HttpReply::packHeadersInto(Packer * p) const STUB
+        void HttpReply::reset() STUB
+        void httpBodyPackInto(const HttpBody * body, Packer * p) STUB
+        bool HttpReply::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error) STUB_RETVAL(false)
+        int HttpReply::httpMsgParseError() STUB_RETVAL(0)
+        bool HttpReply::expectingBody(const HttpRequestMethod&, int64_t&) const STUB_RETVAL(false)
+        bool HttpReply::parseFirstLine(const char *start, const char *end) STUB_RETVAL(false)
+        void HttpReply::hdrCacheInit() STUB
+        HttpReply * HttpReply::clone() const STUB_RETVAL(NULL)
+        bool HttpReply::inheritProperties(const HttpMsg *aMsg) STUB_RETVAL(false)
+        int64_t HttpReply::bodySize(const HttpRequestMethod&) const STUB_RETVAL(0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_HttpRequest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_HttpRequest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_HttpRequest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_HttpRequest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -3,18 +3,19 @@
 #include "HttpRequest.h"
 
 #define STUB_API "HttpRequest.cc"
 #include "tests/STUB.h"
 
 HttpRequest::HttpRequest() : HttpMsg(hoRequest) STUB
-        HttpRequest::HttpRequest(const HttpRequestMethod& method, AnyP::ProtocolType protocol, const char *aUrlpath) : HttpMsg(hoRequest) STUB
+        HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) : HttpMsg(hoRequest) STUB
         HttpRequest::~HttpRequest() STUB
         void HttpRequest::packFirstLineInto(Packer * p, bool full_uri) const STUB
-        bool HttpRequest::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status *error) STUB_RETVAL(false)
+        bool HttpRequest::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, Http::StatusCode *error) STUB_RETVAL(false)
         void HttpRequest::hdrCacheInit() STUB
         void HttpRequest::reset() STUB
         bool HttpRequest::expectingBody(const HttpRequestMethod& unused, int64_t&) const STUB_RETVAL(false)
         void HttpRequest::initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) STUB
         bool HttpRequest::parseFirstLine(const char *start, const char *end) STUB_RETVAL(false)
         HttpRequest * HttpRequest::clone() const STUB_RETVAL(NULL)
         bool HttpRequest::inheritProperties(const HttpMsg *aMsg) STUB_RETVAL(false)
         int64_t HttpRequest::getRangeOffsetLimit() STUB_RETVAL(0)
+        const char *HttpRequest::storeId() STUB_RETVAL(".")
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_icp.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_icp.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_icp.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_icp.cc	2015-05-01 18:05:19.000000000 +0800
@@ -21,14 +21,14 @@
 Ip::Address theIcpPublicHostID;
 
 HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from) STUB_RETVAL(NULL)
 bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request) STUB_RETVAL(false)
 void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from) STUB
 icp_opcode icpGetCommonOpcode() STUB_RETVAL(ICP_INVALID)
-int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int) STUB_RETVAL(0)
-log_type icpLogFromICPCode(icp_opcode opcode) STUB_RETVAL(LOG_TAG_NONE)
+int icpUdpSend(int, const Ip::Address &, icp_common_t *, LogTags, int) STUB_RETVAL(0)
+LogTags icpLogFromICPCode(icp_opcode opcode) STUB_RETVAL(LOG_TAG_NONE)
 void icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd) STUB
 void icpHandleIcpV3(int, Ip::Address &, char *, int) STUB
 int icpCheckUdpHit(StoreEntry *, HttpRequest * request) STUB_RETVAL(0)
 void icpConnectionsOpen(void) STUB
 void icpConnectionShutdown(void) STUB
 void icpConnectionClose(void) STUB
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_libcomm.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_libcomm.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_libcomm.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_libcomm.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,13 +30,13 @@
         const char * Comm::ConnOpener::getHost() const STUB_RETVAL(NULL)
 
 #include "comm/forward.h"
         bool Comm::IsConnOpen(const Comm::ConnectionPointer &) STUB_RETVAL(false)
 
 #include "comm/IoCallback.h"
-        void Comm::IoCallback::setCallback(iocb_type type, AsyncCall::Pointer &cb, char *buf, FREE *func, int sz) STUB
+        void Comm::IoCallback::setCallback(iocb_type, AsyncCall::Pointer &, char *, FREE *, int) STUB
         void Comm::IoCallback::selectOrQueueWrite() STUB
         void Comm::IoCallback::cancel(const char *reason) STUB
         void Comm::IoCallback::finish(comm_err_t code, int xerrn) STUB
         Comm::CbEntry *Comm::iocb_table = NULL;
 void Comm::CallbackTableInit() STUB
 void Comm::CallbackTableDestruct() STUB
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests: stub_libeui.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_libsslsquid.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_libsslsquid.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_libsslsquid.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_libsslsquid.cc	2015-05-01 18:05:19.000000000 +0800
@@ -7,53 +7,51 @@
 /* Stub File for the ssl/libsslsquid.la convenience library */
 
 #define STUB_API "ssl/libsslsquid.la"
 #include "tests/STUB.h"
 
 #include "ssl/Config.h"
-Ssl::Config::Config() { printf("Ssl::Config::Config No implemented\n"); }
-Ssl::Config::~Config() { printf("Ssl::Config::Config No implemented\n"); }
+Ssl::Config::Config():
+#if USE_SSL_CRTD
+        ssl_crtd(NULL),
+#endif
+        ssl_crt_validator(NULL)
+{
+    ssl_crt_validator_Children.concurrency = 1;
+    STUB_NOP
+}
+Ssl::Config::~Config() STUB_NOP
 Ssl::Config Ssl::TheConfig;
 
 #include "ssl/context_storage.h"
 //Ssl::CertificateStorageAction::CertificateStorageAction(const Mgr::Command::Pointer &cmd) STUB
 Ssl::CertificateStorageAction::Pointer Ssl::CertificateStorageAction::Create(const Mgr::Command::Pointer &cmd) STUB_RETSTATREF(Ssl::CertificateStorageAction::Pointer)
 void Ssl::CertificateStorageAction::dump(StoreEntry *sentry) STUB
-Ssl::LocalContextStorage::Item::Item(SSL_CTX * aSsl_ctx, std::string const & aName) STUB
-Ssl::LocalContextStorage::Item::~Item() STUB
-Ssl::LocalContextStorage::LocalContextStorage(size_t aMax_memory) STUB
-Ssl::LocalContextStorage::~LocalContextStorage() STUB
-void Ssl::LocalContextStorage::SetSize(size_t aMax_memory) STUB
-SSL_CTX * Ssl::LocalContextStorage::add(char const * host_name, SSL_CTX * ssl_ctx) STUB_RETVAL(NULL)
-SSL_CTX * Ssl::LocalContextStorage::find(char const * host_name) STUB_RETVAL(NULL)
-void Ssl::LocalContextStorage::remove(char const * host_name) STUB
-//Ssl::GlobalContextStorage::GlobalContextStorage() STUB
-//Ssl::GlobalContextStorage::~GlobalContextStorage() STUB
 void Ssl::GlobalContextStorage::addLocalStorage(Ip::Address const & address, size_t size_of_store) STUB
-Ssl::LocalContextStorage & Ssl::GlobalContextStorage::getLocalStorage(Ip::Address const & address)
-{ fatal(STUB_API " required"); static Ssl::LocalContextStorage v(0); return v; }
+Ssl::LocalContextStorage *Ssl::GlobalContextStorage::getLocalStorage(Ip::Address const & address)
+{ fatal(STUB_API " required"); static Ssl::LocalContextStorage v(0,0); return &v; }
 void Ssl::GlobalContextStorage::reconfigureStart() STUB
 //Ssl::GlobalContextStorage Ssl::TheGlobalContextStorage;
 
 #include "ssl/ErrorDetail.h"
 Ssl::ssl_error_t parseErrorString(const char *name) STUB_RETVAL(0)
 //const char *Ssl::getErrorName(ssl_error_t value) STUB_RETVAL(NULL)
-Ssl::ErrorDetail::ErrorDetail(ssl_error_t err_no, X509 *, X509 *) STUB
+Ssl::ErrorDetail::ErrorDetail(ssl_error_t err_no, X509 *, X509 *, const char *) STUB
 Ssl::ErrorDetail::ErrorDetail(ErrorDetail const &) STUB
 const String & Ssl::ErrorDetail::toString() const STUB_RETSTATREF(String)
 
 #include "ssl/support.h"
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &) STUB_RETVAL(NULL)
 SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile) STUB_RETVAL(NULL)
 int ssl_read_method(int, char *, int) STUB_RETVAL(0)
 int ssl_write_method(int, const char *, int) STUB_RETVAL(0)
 void ssl_shutdown_method(SSL *) STUB
 const char *sslGetUserEmail(SSL *ssl) STUB_RETVAL(NULL)
-// typedef char const *SSLGETATTRIBUTE(SSL *, const char *);
-// SSLGETATTRIBUTE sslGetUserAttribute;
-// SSLGETATTRIBUTE sslGetCAAttribute;
+// typedef char const *Ssl::GETATTRIBUTE(X509 *, const char *);
+// Ssl::GETATTRIBUTE Ssl::GetX509UserAttribute;
+// Ssl::GETATTRIBUTE Ssl::GetX509CAAttribute;
 const char *sslGetUserCertificatePEM(SSL *ssl) STUB_RETVAL(NULL)
 const char *sslGetUserCertificateChainPEM(SSL *ssl) STUB_RETVAL(NULL)
 SSL_CTX * Ssl::generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &) STUB_RETVAL(NULL)
 SSL_CTX * Ssl::generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &) STUB_RETVAL(NULL)
 int Ssl::matchX509CommonNames(X509 *peer_cert, void *check_data, int (*check_func)(void *check_data,  ASN1_STRING *cn_data)) STUB_RETVAL(0)
 int Ssl::asn1timeToString(ASN1_TIME *tm, char *buf, int len) STUB_RETVAL(0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/Stub.list /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/Stub.list
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/Stub.list	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/Stub.list	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,14 @@
 STUB_SOURCE= tests/STUB.h \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
+	tests/stub_cbdata.cc \
 	tests/stub_client_db.cc \
+	tests/stub_client_side.cc \
 	tests/stub_client_side_request.cc \
 	tests/stub_comm.cc \
 	tests/stub_CommIO.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
 	tests/stub_DiskIOModule.cc \
@@ -23,17 +25,19 @@
 	tests/stub_internal.cc \
 	tests/stub_ipcache.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipc_Forwarder.cc \
 	tests/stub_ipc_TypedMsgHdr.cc \
 	tests/stub_libcomm.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_libmgr.cc \
 	tests/stub_libsslsquid.cc \
 	tests/stub_main_cc.cc \
+	tests/stub_MemBuf.cc \
 	tests/stub_mem.cc \
 	tests/stub_mem_node.cc \
 	tests/stub_MemObject.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_mime.cc \
 	tests/stub_pconn.cc \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests: stub_MemBuf.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_store.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_store.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/stub_store.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/stub_store.cc	2015-05-01 18:05:19.000000000 +0800
@@ -13,13 +13,13 @@
 #include "Store.h"
 StorePointer Store::CurrentRoot = NULL;
 StoreIoStats store_io_stats;
 bool StoreEntry::checkDeferRead(int fd) const STUB_RETVAL(false)
 const char *StoreEntry::getMD5Text() const STUB_RETVAL(NULL)
 StoreEntry::StoreEntry() STUB
-StoreEntry::StoreEntry(const char *url, const char *log_url) STUB
+StoreEntry::StoreEntry(const char *, const char *) STUB
 StoreEntry::~StoreEntry() STUB
 HttpReply const *StoreEntry::getReply() const STUB_RETVAL(NULL)
 void StoreEntry::write(StoreIOBuffer) STUB
 bool StoreEntry::isAccepting() const STUB_RETVAL(false)
 size_t StoreEntry::bytesWanted(Range<size_t> const, bool) const STUB_RETVAL(0)
 void StoreEntry::complete() STUB
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testACLMaxUserIP.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testACLMaxUserIP.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testACLMaxUserIP.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testACLMaxUserIP.cc	2015-05-01 18:05:19.000000000 +0800
@@ -3,12 +3,13 @@
 #include "squid.h"
 
 #if USE_AUTH
 
 #include "testACLMaxUserIP.h"
 #include "auth/AclMaxUserIp.h"
+#include "ConfigParser.h"
 
 #if HAVE_STDEXCEPT
 #include <stdexcept>
 #endif
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testACLMaxUserIP );
@@ -26,20 +27,19 @@
 }
 
 void
 testACLMaxUserIP::testParseLine()
 {
     /* a config line to pass with a lead-in token to seed the parser. */
-    char * line = xstrdup("token -s 1");
+    char * line = xstrdup("max_user_ip 1");
     /* seed the parser */
     strtok(line, w_space);
     ACLMaxUserIP anACL("max_user_ip");
     anACL.parse();
-    /* we want a maximum of one, and strict to be true */
+    /* we want a maximum of one */
     CPPUNIT_ASSERT(anACL.getMaximum() == 1);
-    CPPUNIT_ASSERT(anACL.getStrict() == true);
     /* the acl must be vaid */
     CPPUNIT_ASSERT(anACL.valid());
     xfree(line);
 }
 
 #endif /* USE_AUTH */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testCoss.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testCoss.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testCoss.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testCoss.cc	2015-05-01 18:05:19.000000000 +0800
@@ -187,16 +187,16 @@
     CPPUNIT_ASSERT_EQUAL(1, StoreController::store_dirs_rebuilding);
 
     /* add an entry */
     {
         /* Create "vary" base object */
         RequestFlags flags;
-        flags.cachable = 1;
+        flags.cachable = true;
         StoreEntry *pe = storeCreateEntry("dummy url", "dummy log url", flags, METHOD_GET);
         HttpReply *rep = (HttpReply *) pe->getReply();	// bypass const
-        rep->setHeaders(HTTP_OK, "dummy test object", "x-squid-internal/test", -1, -1, squid_curtime + 100000);
+        rep->setHeaders(Http::scOkay, "dummy test object", "x-squid-internal/test", -1, -1, squid_curtime + 100000);
 
         pe->setPublicKey();
 
         pe->buffer();
         /* TODO: remove this when the metadata is separated */
         {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testEventLoop.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testEventLoop.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testEventLoop.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testEventLoop.cc	2015-05-01 18:05:19.000000000 +0800
@@ -61,14 +61,13 @@
 {
 
 public:
     int calls;
     int lasttimeout;
     int return_timeout;
-    RecordingEngine(int return_timeout=0): calls(0), lasttimeout(0),
-            return_timeout(return_timeout) {}
+    RecordingEngine(int aTimeout=0): calls(0), lasttimeout(0), return_timeout(aTimeout) {}
 
     virtual int checkEvents(int timeout) {
         ++calls;
         lasttimeout = timeout;
         return return_timeout;
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testHttpParser.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testHttpParser.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testHttpParser.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testHttpParser.cc	2015-05-01 18:05:19.000000000 +0800
@@ -36,13 +36,13 @@
     // TEST: Do we comply with RFC 2616 section 5.1 ?
 
     // RFC 1945 : HTTP/0.9 simple-request
     input.append("GET /\r\n", 7);
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET /\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start], (output.req.m_end-output.req.m_start+1)) == 0);
@@ -57,13 +57,13 @@
 
     // RFC 1945 : invalid HTTP/0.9 simple-request (only GET is valid)
 #if 0
     input.append("POST /\r\n", 7);
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET /\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start], (output.req.m_end-output.req.m_start+1)) == 0);
@@ -78,13 +78,13 @@
 #endif
 
     // RFC 1945 and 2616 : HTTP/1.0 request
     input.append("GET / HTTP/1.0\r\n", 16);
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.0\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -99,13 +99,13 @@
     input.reset();
 
     // RFC 2616 : HTTP/1.1 request
     input.append("GET / HTTP/1.1\r\n", 16);
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -121,13 +121,13 @@
 
     // RFC 2616 : future version full-request
     input.append("GET / HTTP/1.2\r\n", 16);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.2\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -144,13 +144,13 @@
     // RFC 2616 : future version full-request
     // XXX: IETF HTTPbis WG has made this two-digits format invalid.
     input.append("GET / HTTP/10.12\r\n", 18);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/10.12\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -168,20 +168,20 @@
     // violations mode treats them as HTTP/0.9 requests!
     input.append("GET / FOO/1.0\n", 14);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
 #if USE_HTTP_VIOLATIONS
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(12, output.req.u_end);
     CPPUNIT_ASSERT(memcmp("/ FOO/1.0", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
     CPPUNIT_ASSERT_EQUAL(9, output.req.v_min);
 #else
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(4, output.req.u_end);
     CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.u_start],(output.req.u_end-output.req.u_start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.v_maj);
     CPPUNIT_ASSERT_EQUAL(0, output.req.v_min);
 #endif
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
@@ -198,13 +198,13 @@
 
     // no version
     input.append("GET / HTTP/\n", 12);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -220,13 +220,13 @@
 
     // no major version
     input.append("GET / HTTP/.1\n", 14);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -242,13 +242,13 @@
 
     // no version dot
     input.append("GET / HTTP/11\n", 14);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/11\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -264,13 +264,13 @@
 
     // negative major version (bug 3062)
     input.append("GET / HTTP/-999999.1\n", 21);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/-999999.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -286,13 +286,13 @@
 
     // no minor version
     input.append("GET / HTTP/1.\n", 14);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -308,13 +308,13 @@
 
     // negative major version (bug 3062 corollary)
     input.append("GET / HTTP/1.-999999\n", 21);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_HTTP_VERSION_NOT_SUPPORTED, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scHttpVersionNotSupported, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.-999999\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -341,13 +341,13 @@
 
     // space padded URL
     input.append("GET  /     HTTP/1.1\r\n", 21);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET  /     HTTP/1.1\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -363,13 +363,13 @@
 
     // whitespace inside URI. (nasty but happens)
     input.append("GET /fo o/ HTTP/1.1\n", 20);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET /fo o/ HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -385,13 +385,13 @@
 
     // additional data in buffer
     input.append("GET /     HTTP/1.1\nboo!", 23);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-5, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET /     HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -418,13 +418,13 @@
 
     // alternative EOL sequence: NL-only
     input.append("GET / HTTP/1.1\n", 15);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -440,13 +440,13 @@
 
     // alternative EOL sequence: double-NL-only
     input.append("GET / HTTP/1.1\n\n", 16);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-2, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -464,13 +464,13 @@
     input.append("GET / HTTP/1.1\r\r\r\n", 18);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     Config.onoff.relaxed_header_parser = 1;
     // Being tolerant we can ignore and elide these apparently benign CR
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\r\r\r\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -488,13 +488,13 @@
     input.append("GET / HTTP/1.1\r\r\r\n", 18);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     // strict mode treats these as several bare-CR in the request line which is explicitly invalid.
     Config.onoff.relaxed_header_parser = 0;
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
@@ -508,13 +508,13 @@
     // RFC 1945 and 2616 specify version is followed by CRLF. No intermediary bytes.
     // NP: the terminal whitespace is a special case: invalid for even HTTP/0.9 with no version tag
     input.append("GET / HTTP/1.1 \n", 16);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1 \n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -530,13 +530,13 @@
     // incomplete line at various positions
 
     input.append("GET", 3);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
@@ -547,13 +547,13 @@
     input.reset();
 
     input.append("GET ", 4);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
@@ -564,13 +564,13 @@
     input.reset();
 
     input.append("GET / HT", 8);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
@@ -581,13 +581,13 @@
     input.reset();
 
     input.append("GET / HTTP/1.1", 14);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(0, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_STATUS_NONE, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scNone, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
@@ -610,13 +610,13 @@
 
     // RFC 2616 : . method
     input.append(". / HTTP/1.1\n", 13);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp(". / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_end);
     CPPUNIT_ASSERT(memcmp(".", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -632,13 +632,13 @@
 
     // OPTIONS with * URL
     input.append("OPTIONS * HTTP/1.1\n", 19);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("OPTIONS * HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(6, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("OPTIONS", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -654,13 +654,13 @@
 
     // unknown method
     input.append("HELLOWORLD / HTTP/1.1\n", 22);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("HELLOWORLD / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(9, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("HELLOWORLD", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -676,13 +676,13 @@
 
     // method-only
     input.append("A\n", 2);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("A\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
@@ -694,13 +694,13 @@
     input.reset();
 
     input.append("GET\n", 4);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
@@ -714,13 +714,13 @@
     // RELAXED space padded method (in strict mode SP is reserved so invalid as a method byte)
     input.append(" GET / HTTP/1.1\n", 16);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     Config.onoff.relaxed_header_parser = 1;
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(1, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(1, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -737,13 +737,13 @@
     // STRICT space padded method (in strict mode SP is reserved so invalid as a method byte)
     input.append(" GET / HTTP/1.1\n", 16);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     Config.onoff.relaxed_header_parser = 0;
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp(" GET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
@@ -756,13 +756,13 @@
 
     // tab padded method (NP: tab is not SP so treated as any other binary)
     input.append("\tGET / HTTP/1.1\n", 16);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("\tGET / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("\tGET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -790,13 +790,13 @@
     // no method (but in a form which is ambiguous with HTTP/0.9 simple-request)
     // XXX: Bug: HTTP/0.9 requires method to be "GET"
     input.append("/ HTTP/1.0\n", 11);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("/ HTTP/1.0\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -813,13 +813,13 @@
     input.append(" / HTTP/1.0\n", 12);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     // When tolerantly ignoring SP prefix this case becomes ambiguous with HTTP/0.9 simple-request)
     Config.onoff.relaxed_header_parser = 1;
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(1, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("/ HTTP/1.0\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(1, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(1, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("/", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -836,13 +836,13 @@
     input.append(" / HTTP/1.0\n", 12);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     // When tolerantly ignoring SP prefix this case becomes ambiguous with HTTP/0.9 simple-request)
     Config.onoff.relaxed_header_parser = 0;
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp(" / HTTP/1.0\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
@@ -855,13 +855,13 @@
 
     // binary code in method (strange but ...)
     input.append("GET\x0B / HTTP/1.1\n", 16);
     //printf("TEST: %d-%d/%d '%.*s'\n", output.req.start, output.req.end, input.contentSize(), 16, input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET\x0B / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET\x0B", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -878,13 +878,13 @@
     // CR in method
     // RFC 2616 sec 5.1 prohibits CR other than in terminator.
     input.append("GET\r / HTTP/1.1\r\n", 16);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
@@ -896,13 +896,13 @@
 
     // binary code NUL! in method (strange but ...)
     input.append("GET\0 / HTTP/1.1\n", 16);
     //printf("TEST: %d-%d/%d '%.*s'\n", output.req.start, output.req.end, input.contentSize(), 16, input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET\0 / HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(3, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET\0", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -918,13 +918,13 @@
 
     // no URL (grammer otherwise correct)
     input.append("GET  HTTP/1.1\n", 14);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET  HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -939,13 +939,13 @@
 
     // no URL (grammer invalid, ambiguous with RFC 1945 HTTP/0.9 simple-request)
     input.append("GET HTTP/1.1\n", 13);
     //printf("TEST: '%s'\n",input.content());
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_OK, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scOkay, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("GET HTTP/1.1\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(2, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("GET", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -960,13 +960,13 @@
 
     // binary line
     input.append("\xB\xC\xE\xF\n", 5);
     //printf("TEST: binary-line\n");
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("\xB\xC\xE\xF\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
@@ -981,13 +981,13 @@
     // We accept non-space binary bytes for method so first \t shows up as that
     // but remaining space and tabs are skipped searching for URI-start
     input.append("\t \t \t\n", 6);
     //printf("TEST: mixed whitespace\n");
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL((int)input.contentSize()-1, output.req.end);
     CPPUNIT_ASSERT(memcmp("\t \t \t\n", &output.buf[output.req.start],(output.req.end-output.req.start+1)) == 0);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(0, output.req.m_end);
     CPPUNIT_ASSERT(memcmp("\t", &output.buf[output.req.m_start],(output.req.m_end-output.req.m_start+1)) == 0);
@@ -1003,13 +1003,13 @@
     // CR aborts on sight, so even initial \t method is not marked as above
     // (not when parsing clean with whole line available anyway)
     input.append("\t  \r \n", 6);
     //printf("TEST: mixed whitespace with CR\n");
     output.reset(input.content(), input.contentSize());
     CPPUNIT_ASSERT_EQUAL(-1, HttpParserParseReqLine(&output));
-    CPPUNIT_ASSERT_EQUAL(HTTP_BAD_REQUEST, output.request_parse_status);
+    CPPUNIT_ASSERT_EQUAL(Http::scBadRequest, output.request_parse_status);
     CPPUNIT_ASSERT_EQUAL(0, output.req.start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.m_end);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_start);
     CPPUNIT_ASSERT_EQUAL(-1, output.req.u_end);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testHttpReply.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testHttpReply.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testHttpReply.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testHttpReply.cc	2015-05-01 18:05:19.000000000 +0800
@@ -20,18 +20,12 @@
 MemObject::endOffset() const
 {
     return 0;
 }
 
 #include "ConfigParser.h"
-void
-ConfigParser::destruct()
-{
-// CALLED as shutdown no-op
-//    fatal("ConfigParser::destruct. Not implemented.");
-}
 
 void
 eventAdd(const char *name, EVH * func, void *arg, double when, int, bool cbdata)
 {
 // CALLED as setUp no-op
 //    fatal("eventAdd. Not implemented.");
@@ -48,164 +42,164 @@
 
 void
 testHttpReply::testSanityCheckFirstLine()
 {
     MemBuf input;
     HttpReply engine;
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
     size_t hdr_len;
     input.init();
 
     // a valid status line
     input.append("HTTP/1.1 200 Okay\n\n", 19);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT( 1 && engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/1.1    200  Okay     \n\n", 28);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT( 2 && engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
 #if TODO // these cases are only checked after parse...
     // invalid status line
     input.append("HTTP/1.1 999 Okay\n\n", 19);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT( 3 && !engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_INVALID_HEADER);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/1.1    2000  Okay     \n\n", 29);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT( 4 && engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 #endif
 
     // valid ICY protocol status line
     input.append("ICY 200 Okay\n\n", 14);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT( engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
     /* NP: the engine saves details about the protocol. even when being reset :( */
     engine.protoPrefix="HTTP/";
     engine.reset();
 
     // empty status line
     input.append("\n\n", 2);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT( 5 && !engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_INVALID_HEADER);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("      \n\n", 8);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT( 6 && !engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_INVALID_HEADER);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     // status line with no message
     input.append("HTTP/1.1 200\n\n", 14); /* real case seen */
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/1.1 200 \n\n", 15); /* real case seen */
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     // incomplete (short) status lines... not sane (yet), but no error either.
     input.append("H", 1);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/", 5);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/1", 6);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/1.1", 8);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/1.1 ", 9); /* real case seen */
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/1.1    20", 14);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     // status line with no status
     input.append("HTTP/1.1 \n\n", 11);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_INVALID_HEADER);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/1.1     \n\n", 15);
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_INVALID_HEADER);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("HTTP/1.1  Okay\n\n", 16); /* real case seen */
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_INVALID_HEADER);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     // status line with nul-byte
     input.append("HTTP/1.1" "\0" "200 Okay\n\n", 19); /* real case seen */
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_INVALID_HEADER);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     // status line with negative status
     input.append("HTTP/1.1 -000\n\n", 15); /* real case seen */
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_INVALID_HEADER);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testHttpRequest.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testHttpRequest.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testHttpRequest.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testHttpRequest.cc	2015-05-01 18:05:19.000000000 +0800
@@ -12,13 +12,13 @@
 CPPUNIT_TEST_SUITE_REGISTRATION( testHttpRequest );
 
 /** wrapper for testing HttpRequest object private and protected functions */
 class PrivateHttpRequest : public HttpRequest
 {
 public:
-    bool doSanityCheckStartLine(MemBuf *b, const size_t h, http_status *e) { return sanityCheckStartLine(b,h,e); };
+    bool doSanityCheckStartLine(MemBuf *b, const size_t h, Http::StatusCode *e) { return sanityCheckStartLine(b,h,e); };
 };
 
 /* init memory pools */
 
 void
 testHttpRequest::setUp()
@@ -33,47 +33,47 @@
 void
 testHttpRequest::testCreateFromUrlAndMethod()
 {
     /* vanilla url */
     unsigned short expected_port;
     char * url = xstrdup("http://foo:90/bar");
-    HttpRequest *aRequest = HttpRequest::CreateFromUrlAndMethod(url, METHOD_GET);
+    HttpRequest *aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 90;
     HttpRequest *nullRequest = NULL;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
-    CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
+    CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
 
     /* vanilla url, different method */
     url = xstrdup("http://foo/bar");
-    aRequest = HttpRequest::CreateFromUrlAndMethod(url, METHOD_PUT);
+    aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_PUT);
     expected_port = 80;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
-    CPPUNIT_ASSERT(aRequest->method == METHOD_PUT);
+    CPPUNIT_ASSERT(aRequest->method == Http::METHOD_PUT);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://foo/bar"), String(url));
     xfree(url);
 
     /* a connect url with non-CONNECT data */
     url = xstrdup(":foo/bar");
-    aRequest = HttpRequest::CreateFromUrlAndMethod(url, METHOD_CONNECT);
+    aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_CONNECT);
     xfree(url);
     CPPUNIT_ASSERT_EQUAL(nullRequest, aRequest);
 
     /* a CONNECT url with CONNECT data */
     url = xstrdup("foo:45");
-    aRequest = HttpRequest::CreateFromUrlAndMethod(url, METHOD_CONNECT);
+    aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_CONNECT);
     expected_port = 45;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
-    CPPUNIT_ASSERT(aRequest->method == METHOD_CONNECT);
+    CPPUNIT_ASSERT(aRequest->method == Http::METHOD_CONNECT);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String(""), aRequest->urlpath);
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("foo:45"), String(url));
     xfree(url);
 }
@@ -87,13 +87,13 @@
     /* vanilla url */
     unsigned short expected_port;
     char * url = xstrdup("http://foo:90/bar");
     HttpRequest *aRequest = HttpRequest::CreateFromUrl(url);
     expected_port = 90;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
-    CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
+    CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
 }
@@ -107,85 +107,85 @@
     unsigned short expected_port;
     char * url = NULL;
     HttpRequest *aRequest = NULL;
 
     /* valid IPv6 address without port */
     url = xstrdup("http://[2000:800::45]/foo");
-    aRequest = HttpRequest::CreateFromUrlAndMethod(url, METHOD_GET);
+    aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 80;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
-    CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
+    CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]/foo"), String(url));
     xfree(url);
 
     /* valid IPv6 address with port */
     url = xstrdup("http://[2000:800::45]:90/foo");
-    aRequest = HttpRequest::CreateFromUrlAndMethod(url, METHOD_GET);
+    aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 90;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
-    CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
+    CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]:90/foo"), String(url));
     xfree(url);
 
     /* IPv6 address as invalid (bug trigger) */
     url = xstrdup("http://2000:800::45/foo");
-    aRequest = HttpRequest::CreateFromUrlAndMethod(url, METHOD_GET);
+    aRequest = HttpRequest::CreateFromUrlAndMethod(url, Http::METHOD_GET);
     expected_port = 80;
     CPPUNIT_ASSERT_EQUAL(expected_port, aRequest->port);
-    CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
+    CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
     CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://2000:800::45/foo"), String(url));
     xfree(url);
 }
 
 void
 testHttpRequest::testSanityCheckStartLine()
 {
     MemBuf input;
     PrivateHttpRequest engine;
-    http_status error = HTTP_STATUS_NONE;
+    Http::StatusCode error = Http::scNone;
     size_t hdr_len;
     input.init();
 
     // a valid request line
     input.append("GET / HTTP/1.1\n\n", 16);
     hdr_len = headersEnd(input.content(), input.contentSize());
     CPPUNIT_ASSERT(engine.doSanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("GET  /  HTTP/1.1\n\n", 18);
     hdr_len = headersEnd(input.content(), input.contentSize());
     CPPUNIT_ASSERT(engine.doSanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     // strange but valid methods
     input.append(". / HTTP/1.1\n\n", 14);
     hdr_len = headersEnd(input.content(), input.contentSize());
     CPPUNIT_ASSERT(engine.doSanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
     input.append("OPTIONS * HTTP/1.1\n\n", 20);
     hdr_len = headersEnd(input.content(), input.contentSize());
     CPPUNIT_ASSERT(engine.doSanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_STATUS_NONE);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scNone);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 
 // TODO no method
 
 // TODO binary code in method
 
 // TODO no URL
@@ -194,10 +194,10 @@
 
 // TODO non-HTTP protocol
 
     input.append("      \n\n", 8);
     hdr_len = headersEnd(input.content(), input.contentSize());
     CPPUNIT_ASSERT(!engine.doSanityCheckStartLine(&input, hdr_len, &error) );
-    CPPUNIT_ASSERT_EQUAL(error, HTTP_INVALID_HEADER);
+    CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
     input.reset();
-    error = HTTP_STATUS_NONE;
+    error = Http::scNone;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testHttpRequestMethod.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testHttpRequestMethod.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testHttpRequestMethod.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testHttpRequestMethod.cc	2015-05-01 18:05:19.000000000 +0800
@@ -16,102 +16,102 @@
 /*
  * We should be able to make an HttpRequestMethod straight from a string.
  */
 void
 testHttpRequestMethod::testConstructCharStart()
 {
-    /* parse an empty string -> METHOD_NONE */
-    CPPUNIT_ASSERT(HttpRequestMethod(NULL,NULL) == METHOD_NONE);
+    /* parse an empty string -> Http::METHOD_NONE */
+    CPPUNIT_ASSERT(HttpRequestMethod(NULL,NULL) == Http::METHOD_NONE);
     /* parsing a literal should work */
-    CPPUNIT_ASSERT(HttpRequestMethod("GET", NULL) == METHOD_GET);
-    CPPUNIT_ASSERT(HttpRequestMethod("QWERTY", NULL) == METHOD_OTHER);
+    CPPUNIT_ASSERT(HttpRequestMethod("GET", NULL) == Http::METHOD_GET);
+    CPPUNIT_ASSERT(HttpRequestMethod("QWERTY", NULL) == Http::METHOD_OTHER);
 }
 
 /*
  * We can also parse precise ranges of characters
  */
 void
 testHttpRequestMethod::testConstructCharStartEnd()
 {
     char const * buffer;
-    /* parse an empty string -> METHOD_NONE */
-    CPPUNIT_ASSERT(HttpRequestMethod(NULL, NULL) == METHOD_NONE);
+    /* parse an empty string -> Http::METHOD_NONE */
+    CPPUNIT_ASSERT(HttpRequestMethod(NULL, NULL) == Http::METHOD_NONE);
     /* parsing a literal should work */
-    CPPUNIT_ASSERT(HttpRequestMethod("GET", NULL) == METHOD_GET);
+    CPPUNIT_ASSERT(HttpRequestMethod("GET", NULL) == Http::METHOD_GET);
     /* parsing with an explicit end should work */
     buffer = "POSTPLUS";
-    CPPUNIT_ASSERT(HttpRequestMethod(buffer, buffer + 4) == METHOD_POST);
+    CPPUNIT_ASSERT(HttpRequestMethod(buffer, buffer + 4) == Http::METHOD_POST);
 }
 
 /*
- * we should be able to assign a method_t to a HttpRequestMethod
+ * we should be able to assign a Http::MethodType to a HttpRequestMethod
  */
 void
 testHttpRequestMethod::testAssignFrommethod_t()
 {
     HttpRequestMethod method;
-    method = METHOD_NONE;
-    CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(METHOD_NONE), method);
-    method = METHOD_POST;
-    CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(METHOD_POST), method);
+    method = Http::METHOD_NONE;
+    CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_NONE), method);
+    method = Http::METHOD_POST;
+    CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_POST), method);
 }
 
 /*
- * a default constructed HttpRequestMethod is == METHOD_NONE
+ * a default constructed HttpRequestMethod is == Http::METHOD_NONE
  */
 void
 testHttpRequestMethod::testDefaultConstructor()
 {
     HttpRequestMethod lhs;
-    HttpRequestMethod rhs(METHOD_NONE);
+    HttpRequestMethod rhs(Http::METHOD_NONE);
     CPPUNIT_ASSERT_EQUAL(lhs, rhs);
 }
 
 /*
- * we should be able to construct a HttpRequestMethod from a method_t
+ * we should be able to construct a HttpRequestMethod from a Http::MethodType
  */
 void
 testHttpRequestMethod::testConstructmethod_t()
 {
-    CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(METHOD_NONE), HttpRequestMethod(METHOD_NONE));
-    CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(METHOD_POST), HttpRequestMethod(METHOD_POST));
-    CPPUNIT_ASSERT(HttpRequestMethod(METHOD_NONE) != HttpRequestMethod(METHOD_POST));
+    CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_NONE), HttpRequestMethod(Http::METHOD_NONE));
+    CPPUNIT_ASSERT_EQUAL(HttpRequestMethod(Http::METHOD_POST), HttpRequestMethod(Http::METHOD_POST));
+    CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_NONE) != HttpRequestMethod(Http::METHOD_POST));
 }
 
 /*
  * we should be able to get a char const * version of the method.
  */
 void
 testHttpRequestMethod::testImage()
 {
     CPPUNIT_ASSERT_EQUAL(String("POST"), String(HttpRequestMethod("post",NULL).image()));
 }
 
 /*
- * an HttpRequestMethod should be comparable to a method_t without false
+ * an HttpRequestMethod should be comparable to a Http::MethodType without false
  * matches
  */
 void
 testHttpRequestMethod::testEqualmethod_t()
 {
-    CPPUNIT_ASSERT(HttpRequestMethod(METHOD_NONE) == METHOD_NONE);
-    CPPUNIT_ASSERT(not (HttpRequestMethod(METHOD_POST) == METHOD_GET));
-    CPPUNIT_ASSERT(HttpRequestMethod(METHOD_GET) == METHOD_GET);
-    CPPUNIT_ASSERT(not (HttpRequestMethod(METHOD_TRACE) == METHOD_SEARCH));
+    CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_NONE) == Http::METHOD_NONE);
+    CPPUNIT_ASSERT(not (HttpRequestMethod(Http::METHOD_POST) == Http::METHOD_GET));
+    CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_GET) == Http::METHOD_GET);
+    CPPUNIT_ASSERT(not (HttpRequestMethod(Http::METHOD_TRACE) == Http::METHOD_SEARCH));
 }
 
 /*
  * an HttpRequestMethod should testable for inequality without fail maatches
  */
 void
 testHttpRequestMethod::testNotEqualmethod_t()
 {
-    CPPUNIT_ASSERT(HttpRequestMethod(METHOD_NONE) != METHOD_GET);
-    CPPUNIT_ASSERT(not (HttpRequestMethod(METHOD_POST) != METHOD_POST));
-    CPPUNIT_ASSERT(HttpRequestMethod(METHOD_GET) != METHOD_NONE);
-    CPPUNIT_ASSERT(not (HttpRequestMethod(METHOD_SEARCH) != METHOD_SEARCH));
+    CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_NONE) != Http::METHOD_GET);
+    CPPUNIT_ASSERT(not (HttpRequestMethod(Http::METHOD_POST) != Http::METHOD_POST));
+    CPPUNIT_ASSERT(HttpRequestMethod(Http::METHOD_GET) != Http::METHOD_NONE);
+    CPPUNIT_ASSERT(not (HttpRequestMethod(Http::METHOD_SEARCH) != Http::METHOD_SEARCH));
 }
 
 /*
  * we should be able to send it to a stream and get the normalised version
  */
 void
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests: testNull.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests: testNull.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests: testRefCount.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testRock.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testRock.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testRock.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testRock.cc	2015-05-01 18:05:19.000000000 +0800
@@ -170,20 +170,20 @@
 }
 
 StoreEntry *
 testRock::createEntry(const int i)
 {
     RequestFlags flags;
-    flags.cachable = 1;
+    flags.cachable = true;
     char url[64];
     snprintf(url, sizeof(url), "dummy url %i", i);
     url[sizeof(url) - 1] = '\0';
     StoreEntry *const pe =
-        storeCreateEntry(url, "dummy log url", flags, METHOD_GET);
+        storeCreateEntry(url, "dummy log url", flags, Http::METHOD_GET);
     HttpReply *const rep = const_cast<HttpReply *>(pe->getReply());
-    rep->setHeaders(HTTP_OK, "dummy test object", "x-squid-internal/test", 0, -1, squid_curtime + 100000);
+    rep->setHeaders(Http::scOkay, "dummy test object", "x-squid-internal/test", 0, -1, squid_curtime + 100000);
 
     pe->setPublicKey();
 
     return pe;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testRock.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testRock.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testRock.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testRock.h	2015-05-01 18:05:19.000000000 +0800
@@ -12,12 +12,13 @@
     CPPUNIT_TEST_SUITE( testRock );
     CPPUNIT_TEST( testRockCreate );
     CPPUNIT_TEST( testRockSwapOut );
     CPPUNIT_TEST_SUITE_END();
 
 public:
+    testRock() : rr(NULL) {}
     virtual void setUp();
     virtual void tearDown();
 
     typedef RefCount<Rock::SwapDir> SwapDirPointer;
 
 protected:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testStatHist.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testStatHist.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testStatHist.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testStatHist.cc	2015-05-01 18:05:19.000000000 +0800
@@ -10,14 +10,14 @@
 } number ;
 
 class InspectingStatHist : public StatHist
 {
 public:
     bool operator==(const InspectingStatHist &);
-    bins_type counter(double val) {
-        return bins[findBin(val)];
+    bins_type counter(double v) {
+        return bins[findBin(v)];
     }
 };
 
 bool
 InspectingStatHist::operator ==(const InspectingStatHist & src)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testUfs.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testUfs.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tests/testUfs.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests/testUfs.cc	2015-05-01 18:05:19.000000000 +0800
@@ -140,16 +140,16 @@
     CPPUNIT_ASSERT_EQUAL(1, StoreController::store_dirs_rebuilding);
 
     /* add an entry */
     {
         /* Create "vary" base object */
         RequestFlags flags;
-        flags.cachable = 1;
-        StoreEntry *pe = storeCreateEntry("dummy url", "dummy log url", flags, METHOD_GET);
+        flags.cachable = true;
+        StoreEntry *pe = storeCreateEntry("dummy url", "dummy log url", flags, Http::METHOD_GET);
         HttpReply *rep = (HttpReply *) pe->getReply();	// bypass const
-        rep->setHeaders(HTTP_OK, "dummy test object", "x-squid-internal/test", 0, -1, squid_curtime + 100000);
+        rep->setHeaders(Http::scOkay, "dummy test object", "x-squid-internal/test", 0, -1, squid_curtime + 100000);
 
         pe->setPublicKey();
 
         pe->buffer();
         /* TODO: remove this when the metadata is separated */
         {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests: testVector.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tests: testVector.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tools.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tools.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tools.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tools.cc	2015-05-01 18:05:19.000000000 +0800
@@ -52,12 +52,15 @@
 #include "SwapDir.h"
 #include "wordlist.h"
 
 #if HAVE_SYS_PRCTL_H
 #include <sys/prctl.h>
 #endif
+#if HAVE_WIN32_PSAPI
+#include <psapi.h>
+#endif
 #if HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 #if HAVE_SYS_WAIT_H
 #include <sys/wait.h>
 #endif
@@ -246,28 +249,65 @@
 
 #endif /* HAVE_STRUCT_MALLINFO_MXFAST */
 #endif /* HAVE_MALLINFO */
 }
 
 void
-
 squid_getrusage(struct rusage *r)
 {
-
     memset(r, '\0', sizeof(struct rusage));
-#if HAVE_GETRUSAGE && defined(RUSAGE_SELF)
+#if HAVE_GETRUSAGE && defined(RUSAGE_SELF) && !_SQUID_WINDOWS_
 #if _SQUID_SOLARIS_
     /* Solaris 2.5 has getrusage() permission bug -- Arjan de Vet */
     enter_suid();
 #endif
 
     getrusage(RUSAGE_SELF, r);
-#if _SQUID_SOLARIS_
 
+#if _SQUID_SOLARIS_
     leave_suid();
 #endif
+
+#elif _SQUID_WINDOWS_ && HAVE_WIN32_PSAPI
+    // Windows has an alternative method if there is no POSIX getrusage defined.
+    if (WIN32_OS_version >= _WIN_OS_WINNT) {
+        /* On Windows NT and later call PSAPI.DLL for process Memory */
+        /* informations -- Guido Serassio                       */
+        HANDLE hProcess;
+        PROCESS_MEMORY_COUNTERS pmc;
+        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
+                               PROCESS_VM_READ,
+                               FALSE, GetCurrentProcessId());
+        {
+            /* Microsoft CRT doesn't have getrusage function,  */
+            /* so we get process CPU time information from PSAPI.DLL. */
+            FILETIME ftCreate, ftExit, ftKernel, ftUser;
+            if (GetProcessTimes(hProcess, &ftCreate, &ftExit, &ftKernel, &ftUser)) {
+                int64_t *ptUser = (int64_t *)&ftUser;
+                int64_t tUser64 = *ptUser / 10;
+                int64_t *ptKernel = (int64_t *)&ftKernel;
+                int64_t tKernel64 = *ptKernel / 10;
+                r->ru_utime.tv_sec =(long)(tUser64 / 1000000);
+                r->ru_stime.tv_sec =(long)(tKernel64 / 1000000);
+                r->ru_utime.tv_usec =(long)(tUser64 % 1000000);
+                r->ru_stime.tv_usec =(long)(tKernel64 % 1000000);
+            } else {
+                CloseHandle( hProcess );
+                return;
+            }
+        }
+        if (GetProcessMemoryInfo( hProcess, &pmc, sizeof(pmc))) {
+            r->ru_maxrss=(DWORD)(pmc.WorkingSetSize / getpagesize());
+            r->ru_majflt=pmc.PageFaultCount;
+        } else {
+            CloseHandle( hProcess );
+            return;
+        }
+
+        CloseHandle( hProcess );
+    }
 #endif
 }
 
 double
 
 rusage_cputime(struct rusage *r)
@@ -513,44 +553,44 @@
 
     if (present)
         return host;
 
     host[0] = '\0';
 
-    if (Config.Sockaddr.http && sa.IsAnyAddr())
+    if (Config.Sockaddr.http && sa.isAnyAddr())
         sa = Config.Sockaddr.http->s;
 
 #if USE_SSL
 
-    if (Config.Sockaddr.https && sa.IsAnyAddr())
+    if (Config.Sockaddr.https && sa.isAnyAddr())
         sa = Config.Sockaddr.https->s;
 
 #endif
 
     /*
      * If the first http_port address has a specific address, try a
      * reverse DNS lookup on it.
      */
-    if ( !sa.IsAnyAddr() ) {
+    if ( !sa.isAnyAddr() ) {
 
-        sa.GetAddrInfo(AI);
+        sa.getAddrInfo(AI);
         /* we are looking for a name. */
         if (getnameinfo(AI->ai_addr, AI->ai_addrlen, host, SQUIDHOSTNAMELEN, NULL, 0, NI_NAMEREQD ) == 0) {
             /* DNS lookup successful */
             /* use the official name from DNS lookup */
             debugs(50, 4, "getMyHostname: resolved " << sa << " to '" << host << "'");
 
             present = 1;
 
-            sa.FreeAddrInfo(AI);
+            Ip::Address::FreeAddrInfo(AI);
 
             if (strchr(host, '.'))
                 return host;
         }
 
-        sa.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
         debugs(50, 2, "WARNING: failed to resolve " << sa << " to a fully qualified hostname");
     }
 
     // still no host. fallback to gethostname()
     if (gethostname(host, SQUIDHOSTNAMELEN) < 0) {
         debugs(50, DBG_IMPORTANT, "WARNING: gethostname failed: " << xstrerror());
@@ -564,21 +604,20 @@
             /* DNS lookup successful */
             /* use the official name from DNS lookup */
             debugs(50, 6, "getMyHostname: '" << host << "' has DNS resolution.");
             present = 1;
 
             /* AYJ: do we want to flag AI_ALL and cache the result anywhere. ie as our local host IPs? */
-            if (AI) {
+            if (AI)
                 freeaddrinfo(AI);
-                AI = NULL;
-            }
 
             return host;
         }
 
-        if (AI) freeaddrinfo(AI);
+        if (AI)
+            freeaddrinfo(AI);
         debugs(50, DBG_IMPORTANT, "WARNING: '" << host << "' rDNS test failed: " << xstrerror());
     }
 
     /* throw a configuration error when the Host/IP given has bad DNS/rDNS. */
     debugs(50, DBG_CRITICAL, "WARNING: Could not determine this machines public hostname. " <<
            "Please configure one or set 'visible_hostname'.");
@@ -1171,25 +1210,25 @@
 int
 getMyPort(void)
 {
     AnyP::PortCfg *p = NULL;
     if ((p = Config.Sockaddr.http)) {
         // skip any special interception ports
-        while (p && (p->intercepted || p->spoof_client_ip))
+        while (p && p->flags.isIntercepted())
             p = p->next;
         if (p)
-            return p->s.GetPort();
+            return p->s.port();
     }
 
 #if USE_SSL
     if ((p = Config.Sockaddr.https)) {
         // skip any special interception ports
-        while (p && (p->intercepted || p->spoof_client_ip))
+        while (p && p->flags.isIntercepted())
             p = p->next;
         if (p)
-            return p->s.GetPort();
+            return p->s.port();
     }
 #endif
 
     debugs(21, DBG_CRITICAL, "ERROR: No forward-proxy ports configured.");
     return 0; // Invalid port. This will result in invalid URLs on bad configurations.
 }
@@ -1277,13 +1316,16 @@
     } else {
         int ncaps = 0;
         int rc = 0;
         cap_value_t cap_list[10];
         cap_list[ncaps] = CAP_NET_BIND_SERVICE;
         ++ncaps;
-        if (Ip::Interceptor.TransparentActive() || Ip::Qos::TheConfig.isHitNfmarkActive() || Ip::Qos::TheConfig.isAclNfmarkActive()) {
+        if (Ip::Interceptor.TransparentActive() ||
+                Ip::Qos::TheConfig.isHitNfmarkActive() ||
+                Ip::Qos::TheConfig.isAclNfmarkActive() ||
+                Ip::Qos::TheConfig.isAclTosActive()) {
             cap_list[ncaps] = CAP_NET_ADMIN;
             ++ncaps;
         }
 
         cap_clear_flag(caps, CAP_EFFECTIVE);
         rc |= cap_set_flag(caps, CAP_EFFECTIVE, ncaps, cap_list, CAP_SET);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tunnel.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tunnel.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/tunnel.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/tunnel.cc	2015-05-01 18:05:19.000000000 +0800
@@ -30,13 +30,14 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
-#include "Array.h"
+#include "base/CbcPointer.h"
+#include "base/Vector.h"
 #include "CachePeer.h"
 #include "client_side_request.h"
 #include "client_side.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
@@ -60,35 +61,70 @@
 #include <limits.h>
 #endif
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
 
+/**
+ * TunnelStateData is the state engine performing the tasks for
+ * setup of a TCP tunnel from an existing open client FD to a server
+ * then shuffling binary data between the resulting FD pair.
+ */
+/*
+ * TODO 1: implement a read/write API on ConnStateData to send/receive blocks
+ * of pre-formatted data. Then we can use that as the client side of the tunnel
+ * instead of re-implementing it here and occasionally getting the ConnStateData
+ * read/write state wrong.
+ *
+ * TODO 2: then convert this into a AsyncJob, possibly a child of 'Server'
+ */
 class TunnelStateData
 {
 
 public:
+    TunnelStateData();
+    ~TunnelStateData();
+    TunnelStateData(const TunnelStateData &); // do not implement
+    TunnelStateData &operator =(const TunnelStateData &); // do not implement
 
     class Connection;
-    void *operator new(size_t);
-    void operator delete (void *);
     static void ReadClient(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t errcode, int xerrno, void *data);
     static void ReadServer(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t errcode, int xerrno, void *data);
     static void WriteClientDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t flag, int xerrno, void *data);
     static void WriteServerDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t flag, int xerrno, void *data);
 
+    /// Starts reading peer response to our CONNECT request.
+    void readConnectResponse();
+
+    /// Called when we may be done handling a CONNECT exchange with the peer.
+    void connectExchangeCheckpoint();
+
     bool noConnections() const;
     char *url;
-    HttpRequest *request;
+    CbcPointer<ClientHttpRequest> http;
+    HttpRequest::Pointer request;
     AccessLogEntryPointer al;
     Comm::ConnectionList serverDestinations;
 
     const char * getHost() const {
         return (server.conn != NULL && server.conn->getPeer() ? server.conn->getPeer()->host : request->GetHost());
     };
 
+    /// Whether we are writing a CONNECT request to a peer.
+    bool waitingForConnectRequest() const { return connectReqWriting; }
+    /// Whether we are reading a CONNECT response from a peer.
+    bool waitingForConnectResponse() const { return connectRespBuf; }
+    /// Whether we are waiting for the CONNECT request/response exchange with the peer.
+    bool waitingForConnectExchange() const { return waitingForConnectRequest() || waitingForConnectResponse(); }
+
+    /// Whether the client sent a CONNECT request to us.
+    bool clientExpectsConnectResponse() const {
+        return !(request != NULL &&
+                 (request->flags.interceptTproxy || request->flags.intercepted));
+    }
+
     class Connection
     {
 
     public:
         Connection() : len (0), buf ((char *)xmalloc(SQUID_TCP_SO_RCVBUF)), size_ptr(NULL) {}
 
@@ -100,12 +136,14 @@
 
         void setDelayId(DelayId const &);
 #endif
 
         void error(int const xerrno);
         int debugLevelForError(int const xerrno) const;
+        /// handles a non-I/O error associated with this Connection
+        void logicError(const char *errMsg);
         void closeIfOpen();
         void dataSent (size_t amount);
         int len;
         char *buf;
         int64_t *size_ptr;		/* pointer to size in an ConnStateData for logging */
 
@@ -118,44 +156,51 @@
 #endif
 
     };
 
     Connection client, server;
     int *status_ptr;		/* pointer to status for logging */
+    MemBuf *connectRespBuf; ///< accumulates peer CONNECT response when we need it
+    bool connectReqWriting; ///< whether we are writing a CONNECT request to a peer
+
     void copyRead(Connection &from, IOCB *completion);
 
 private:
-    CBDATA_CLASS(TunnelStateData);
-    void copy (size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, IOCB *);
+    CBDATA_CLASS2(TunnelStateData);
+    bool keepGoingAfterRead(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to);
+    void copy(size_t len, Connection &from, Connection &to, IOCB *);
+    void handleConnectResponse(const size_t chunkSize);
     void readServer(char *buf, size_t len, comm_err_t errcode, int xerrno);
     void readClient(char *buf, size_t len, comm_err_t errcode, int xerrno);
     void writeClientDone(char *buf, size_t len, comm_err_t flag, int xerrno);
     void writeServerDone(char *buf, size_t len, comm_err_t flag, int xerrno);
+
+    static void ReadConnectResponseDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t errcode, int xerrno, void *data);
+    void readConnectResponseDone(char *buf, size_t len, comm_err_t errcode, int xerrno);
 };
 
 static const char *const conn_established = "HTTP/1.1 200 Connection established\r\n\r\n";
 
 static CNCB tunnelConnectDone;
 static ERCB tunnelErrorComplete;
 static CLCB tunnelServerClosed;
 static CLCB tunnelClientClosed;
 static CTCB tunnelTimeout;
 static PSC tunnelPeerSelectComplete;
-static void tunnelStateFree(TunnelStateData * tunnelState);
 static void tunnelConnected(const Comm::ConnectionPointer &server, void *);
 static void tunnelRelayConnectRequest(const Comm::ConnectionPointer &server, void *);
 
 static void
 tunnelServerClosed(const CommCloseCbParams &params)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)params.data;
     debugs(26, 3, HERE << tunnelState->server.conn);
     tunnelState->server.conn = NULL;
 
     if (tunnelState->noConnections()) {
-        tunnelStateFree(tunnelState);
+        delete tunnelState;
         return;
     }
 
     if (!tunnelState->server.len) {
         tunnelState->client.conn->close();
         return;
@@ -167,32 +212,40 @@
 {
     TunnelStateData *tunnelState = (TunnelStateData *)params.data;
     debugs(26, 3, HERE << tunnelState->client.conn);
     tunnelState->client.conn = NULL;
 
     if (tunnelState->noConnections()) {
-        tunnelStateFree(tunnelState);
+        delete tunnelState;
         return;
     }
 
     if (!tunnelState->client.len) {
         tunnelState->server.conn->close();
         return;
     }
 }
 
-static void
-tunnelStateFree(TunnelStateData * tunnelState)
-{
-    debugs(26, 3, HERE << "tunnelState=" << tunnelState);
-    assert(tunnelState != NULL);
-    assert(tunnelState->noConnections());
-    safe_free(tunnelState->url);
-    tunnelState->serverDestinations.clean();
-    HTTPMSGUNLOCK(tunnelState->request);
-    delete tunnelState;
+TunnelStateData::TunnelStateData() :
+        url(NULL),
+        http(),
+        request(NULL),
+        status_ptr(NULL),
+        connectRespBuf(NULL),
+        connectReqWriting(false)
+{
+    debugs(26, 3, "TunnelStateData constructed this=" << this);
+}
+
+TunnelStateData::~TunnelStateData()
+{
+    debugs(26, 3, "TunnelStateData destructed this=" << this);
+    assert(noConnections());
+    xfree(url);
+    serverDestinations.clean();
+    delete connectRespBuf;
 }
 
 TunnelStateData::Connection::~Connection()
 {
     safe_free(buf);
 }
@@ -262,13 +315,114 @@
     if (len > 0) {
         server.bytesIn(len);
         kb_incr(&(statCounter.server.all.kbytes_in), len);
         kb_incr(&(statCounter.server.other.kbytes_in), len);
     }
 
-    copy (len, errcode, xerrno, server, client, WriteClientDone);
+    if (keepGoingAfterRead(len, errcode, xerrno, server, client))
+        copy(len, server, client, WriteClientDone);
+}
+
+/// Called when we read [a part of] CONNECT response from the peer
+void
+TunnelStateData::readConnectResponseDone(char *buf, size_t len, comm_err_t errcode, int xerrno)
+{
+    debugs(26, 3, server.conn << ", read " << len << " bytes, err=" << errcode);
+    assert(waitingForConnectResponse());
+
+    if (errcode == COMM_ERR_CLOSING)
+        return;
+
+    if (len > 0) {
+        connectRespBuf->appended(len);
+        server.bytesIn(len);
+        kb_incr(&(statCounter.server.all.kbytes_in), len);
+        kb_incr(&(statCounter.server.other.kbytes_in), len);
+    }
+
+    if (keepGoingAfterRead(len, errcode, xerrno, server, client))
+        handleConnectResponse(len);
+}
+
+/* Read from client side and queue it for writing to the server */
+void
+TunnelStateData::ReadConnectResponseDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t errcode, int xerrno, void *data)
+{
+    TunnelStateData *tunnelState = (TunnelStateData *)data;
+    assert (cbdataReferenceValid (tunnelState));
+
+    tunnelState->readConnectResponseDone(buf, len, errcode, xerrno);
+}
+
+/// Parses [possibly incomplete] CONNECT response and reacts to it.
+/// If the tunnel is being closed or more response data is needed, returns false.
+/// Otherwise, the caller should handle the remaining read data, if any.
+void
+TunnelStateData::handleConnectResponse(const size_t chunkSize)
+{
+    assert(waitingForConnectResponse());
+
+    // Ideally, client and server should use MemBuf or better, but current code
+    // never accumulates more than one read when shoveling data (XXX) so it does
+    // not need to deal with MemBuf complexity. To keep it simple, we use a
+    // dedicated MemBuf for accumulating CONNECT responses. TODO: When shoveling
+    // is optimized, reuse server.buf for CONNEC response accumulation instead.
+
+    /* mimic the basic parts of HttpStateData::processReplyHeader() */
+    HttpReply rep;
+    Http::StatusCode parseErr = Http::scNone;
+    const bool eof = !chunkSize;
+    const bool parsed = rep.parse(connectRespBuf, eof, &parseErr);
+    if (!parsed) {
+        if (parseErr > 0) { // unrecoverable parsing error
+            server.logicError("malformed CONNECT response from peer");
+            return;
+        }
+
+        // need more data
+        assert(!eof);
+        assert(!parseErr);
+
+        if (!connectRespBuf->hasSpace()) {
+            server.logicError("huge CONNECT response from peer");
+            return;
+        }
+
+        // keep reading
+        readConnectResponse();
+        return;
+    }
+
+    // CONNECT response was successfully parsed
+    *status_ptr = rep.sline.status();
+
+    // bail if we did not get an HTTP 200 (Connection Established) response
+    if (rep.sline.status() != Http::scOkay) {
+        server.logicError("unsupported CONNECT response status code");
+        return;
+    }
+
+    if (rep.hdr_sz < connectRespBuf->contentSize()) {
+        // preserve bytes that the server already sent after the CONNECT response
+        server.len = connectRespBuf->contentSize() - rep.hdr_sz;
+        memcpy(server.buf, connectRespBuf->content()+rep.hdr_sz, server.len);
+    } else {
+        // reset; delay pools were using this field to throttle CONNECT response
+        server.len = 0;
+    }
+
+    delete connectRespBuf;
+    connectRespBuf = NULL;
+    connectExchangeCheckpoint();
+}
+
+void
+TunnelStateData::Connection::logicError(const char *errMsg)
+{
+    debugs(50, 3, conn << " closing on error: " << errMsg);
+    conn->close();
 }
 
 void
 TunnelStateData::Connection::error(int const xerrno)
 {
     /* XXX fixme xstrerror and xerrno... */
@@ -305,25 +459,28 @@
 
     if (len > 0) {
         client.bytesIn(len);
         kb_incr(&(statCounter.client_http.kbytes_in), len);
     }
 
-    copy (len, errcode, xerrno, client, server, WriteServerDone);
+    if (keepGoingAfterRead(len, errcode, xerrno, client, server))
+        copy(len, client, server, WriteServerDone);
 }
 
-void
-TunnelStateData::copy (size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, IOCB *completion)
+/// Updates state after reading from client or server.
+/// Returns whether the caller should use the data just read.
+bool
+TunnelStateData::keepGoingAfterRead(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to)
 {
     debugs(26, 3, HERE << "from={" << from.conn << "}, to={" << to.conn << "}");
 
     /* I think this is to prevent free-while-in-a-callback behaviour
      * - RBC 20030229
      * from.conn->close() / to.conn->close() done here trigger close callbacks which may free TunnelStateData
      */
-    cbdataInternalLock(this);	/* ??? should be locked by the caller... */
+    const CbcPointer<TunnelStateData> safetyLock(this);
 
     /* Bump the source connection read timeout on any activity */
     if (Comm::IsConnOpen(from.conn)) {
         AsyncCall::Pointer timeoutCall = commCbCall(5, 4, "tunnelTimeout",
                                          CommTimeoutCbPtrFun(tunnelTimeout, this));
         commSetConnTimeout(from.conn, Config.Timeout.read, timeoutCall);
@@ -345,19 +502,25 @@
 
         /* Only close the remote end if we've finished queueing data to it */
         if (from.len == 0 && Comm::IsConnOpen(to.conn) ) {
             to.conn->close();
         }
     } else if (cbdataReferenceValid(this)) {
-        debugs(26, 3, HERE << "Schedule Write");
-        AsyncCall::Pointer call = commCbCall(5,5, "TunnelBlindCopyWriteHandler",
-                                             CommIoCbPtrFun(completion, this));
-        Comm::Write(to.conn, from.buf, len, call, NULL);
+        return true;
     }
 
-    cbdataInternalUnlock(this);	/* ??? */
+    return false;
+}
+
+void
+TunnelStateData::copy(size_t len, Connection &from, Connection &to, IOCB *completion)
+{
+    debugs(26, 3, HERE << "Schedule Write");
+    AsyncCall::Pointer call = commCbCall(5,5, "TunnelBlindCopyWriteHandler",
+                                         CommIoCbPtrFun(completion, this));
+    Comm::Write(to.conn, from.buf, len, call, NULL);
 }
 
 /* Writes data from the client buffer to the server side */
 void
 TunnelStateData::WriteServerDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t flag, int xerrno, void *data)
 {
@@ -397,18 +560,16 @@
     if (!Comm::IsConnOpen(client.conn)) {
         debugs(26, 4, HERE << "Client gone away. Shutting down server connection.");
         server.conn->close();
         return;
     }
 
-    cbdataInternalLock(this);	/* ??? should be locked by the caller... */
+    const CbcPointer<TunnelStateData> safetyLock(this);	/* ??? should be locked by the caller... */
 
     if (cbdataReferenceValid(this))
         copyRead(client, ReadClient);
-
-    cbdataInternalUnlock(this);	/* ??? */
 }
 
 /* Writes data from the server buffer to the client side */
 void
 TunnelStateData::WriteClientDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t flag, int xerrno, void *data)
 {
@@ -459,31 +620,28 @@
     if (!Comm::IsConnOpen(server.conn)) {
         debugs(26, 4, HERE << "Server has gone away. Terminating client connection.");
         client.conn->close();
         return;
     }
 
-    cbdataInternalLock(this);	/* ??? should be locked by the caller... */
+    CbcPointer<TunnelStateData> safetyLock(this);	/* ??? should be locked by the caller... */
 
     if (cbdataReferenceValid(this))
         copyRead(server, ReadServer);
-
-    cbdataInternalUnlock(this);	/* ??? */
 }
 
 static void
 tunnelTimeout(const CommTimeoutCbParams &io)
 {
     TunnelStateData *tunnelState = static_cast<TunnelStateData *>(io.data);
     debugs(26, 3, HERE << io.conn);
     /* Temporary lock to protect our own feets (comm_close -> tunnelClientClosed -> Free) */
-    cbdataInternalLock(tunnelState);
+    CbcPointer<TunnelStateData> safetyLock(tunnelState);
 
     tunnelState->client.closeIfOpen();
     tunnelState->server.closeIfOpen();
-    cbdataInternalUnlock(tunnelState);
 }
 
 void
 TunnelStateData::Connection::closeIfOpen()
 {
     if (Comm::IsConnOpen(conn))
@@ -496,23 +654,54 @@
     assert(from.len == 0);
     AsyncCall::Pointer call = commCbCall(5,4, "TunnelBlindCopyReadHandler",
                                          CommIoCbPtrFun(completion, this));
     comm_read(from.conn, from.buf, from.bytesWanted(1, SQUID_TCP_SO_RCVBUF), call);
 }
 
+void
+TunnelStateData::readConnectResponse()
+{
+    assert(waitingForConnectResponse());
+
+    AsyncCall::Pointer call = commCbCall(5,4, "readConnectResponseDone",
+                                         CommIoCbPtrFun(ReadConnectResponseDone, this));
+    comm_read(server.conn, connectRespBuf->space(),
+              server.bytesWanted(1, connectRespBuf->spaceSize()), call);
+}
+
 /**
  * Set the HTTP status for this request and sets the read handlers for client
  * and server side connections.
  */
 static void
 tunnelStartShoveling(TunnelStateData *tunnelState)
 {
-    *tunnelState->status_ptr = HTTP_OK;
+    assert(!tunnelState->waitingForConnectExchange());
+    *tunnelState->status_ptr = Http::scOkay;
     if (cbdataReferenceValid(tunnelState)) {
-        tunnelState->copyRead(tunnelState->server, TunnelStateData::ReadServer);
-        tunnelState->copyRead(tunnelState->client, TunnelStateData::ReadClient);
+
+        // Shovel any payload already pushed into reply buffer by the server response
+        if (!tunnelState->server.len)
+            tunnelState->copyRead(tunnelState->server, TunnelStateData::ReadServer);
+        else {
+            debugs(26, DBG_DATA, "Tunnel server PUSH Payload: \n" << Raw("", tunnelState->server.buf, tunnelState->server.len) << "\n----------");
+            tunnelState->copy(tunnelState->server.len, tunnelState->server, tunnelState->client, TunnelStateData::WriteClientDone);
+        }
+
+        // Bug 3371: shovel any payload already pushed into ConnStateData by the client request
+        if (tunnelState->http.valid() && tunnelState->http->getConn() && tunnelState->http->getConn()->in.notYetUsed) {
+            struct ConnStateData::In *in = &tunnelState->http->getConn()->in;
+            debugs(26, DBG_DATA, "Tunnel client PUSH Payload: \n" << Raw("", in->buf, in->notYetUsed) << "\n----------");
+
+            // We just need to ensure the bytes from ConnStateData are in client.buf already to deliver
+            memcpy(tunnelState->client.buf, in->buf, in->notYetUsed);
+            // NP: readClient() takes care of buffer length accounting.
+            tunnelState->readClient(tunnelState->client.buf, in->notYetUsed, COMM_OK, 0);
+            in->notYetUsed = 0; // ConnStateData buffer accounting after the shuffle.
+        } else
+            tunnelState->copyRead(tunnelState->client, TunnelStateData::ReadClient);
     }
 }
 
 /**
  * All the pieces we need to write to client and/or server connection
  * have been written.
@@ -522,30 +711,62 @@
 tunnelConnectedWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t size, comm_err_t flag, int xerrno, void *data)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, HERE << conn << ", flag=" << flag);
 
     if (flag != COMM_OK) {
-        *tunnelState->status_ptr = HTTP_INTERNAL_SERVER_ERROR;
+        *tunnelState->status_ptr = Http::scInternalServerError;
         tunnelErrorComplete(conn->fd, data, 0);
         return;
     }
 
     tunnelStartShoveling(tunnelState);
 }
 
+/// Called when we are done writing CONNECT request to a peer.
+static void
+tunnelConnectReqWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t size, comm_err_t flag, int xerrno, void *data)
+{
+    TunnelStateData *tunnelState = (TunnelStateData *)data;
+    debugs(26, 3, conn << ", flag=" << flag);
+    assert(tunnelState->waitingForConnectRequest());
+
+    if (flag != COMM_OK) {
+        *tunnelState->status_ptr = Http::scInternalServerError;
+        tunnelErrorComplete(conn->fd, data, 0);
+        return;
+    }
+
+    tunnelState->connectReqWriting = false;
+    tunnelState->connectExchangeCheckpoint();
+}
+
+void
+TunnelStateData::connectExchangeCheckpoint()
+{
+    if (waitingForConnectResponse()) {
+        debugs(26, 5, "still reading CONNECT response on " << server.conn);
+    } else if (waitingForConnectRequest()) {
+        debugs(26, 5, "still writing CONNECT request on " << server.conn);
+    } else {
+        assert(!waitingForConnectExchange());
+        debugs(26, 3, "done with CONNECT exchange on " << server.conn);
+        tunnelConnected(server.conn, this);
+    }
+}
+
 /*
  * handle the write completion from a proxy request to an upstream origin
  */
 static void
 tunnelConnected(const Comm::ConnectionPointer &server, void *data)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, HERE << server << ", tunnelState=" << tunnelState);
 
-    if (tunnelState->request && (tunnelState->request->flags.spoofClientIp || tunnelState->request->flags.intercepted))
+    if (!tunnelState->clientExpectsConnectResponse())
         tunnelStartShoveling(tunnelState); // ssl-bumped connection, be quiet
     else {
         AsyncCall::Pointer call = commCbCall(5,5, "tunnelConnectedWriteDone",
                                              CommIoCbPtrFun(tunnelConnectedWriteDone, tunnelState));
         Comm::Write(tunnelState->client.conn, conn_established, strlen(conn_established), call, NULL);
     }
@@ -555,21 +776,19 @@
 tunnelErrorComplete(int fd/*const Comm::ConnectionPointer &*/, void *data, size_t)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, HERE << "FD " << fd);
     assert(tunnelState != NULL);
     /* temporary lock to save our own feets (comm_close -> tunnelClientClosed -> Free) */
-    cbdataInternalLock(tunnelState);
+    CbcPointer<TunnelStateData> safetyLock(tunnelState);
 
     if (Comm::IsConnOpen(tunnelState->client.conn))
         tunnelState->client.conn->close();
 
     if (Comm::IsConnOpen(tunnelState->server.conn))
         tunnelState->server.conn->close();
-
-    cbdataInternalUnlock(tunnelState);
 }
 
 static void
 tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xerrno, void *data)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
@@ -581,31 +800,31 @@
          */
         tunnelState->serverDestinations.shift();
         if (status != COMM_TIMEOUT && tunnelState->serverDestinations.size() > 0) {
             /* Try another IP of this destination host */
 
             if (Ip::Qos::TheConfig.isAclTosActive()) {
-                tunnelState->serverDestinations[0]->tos = GetTosToServer(tunnelState->request);
+                tunnelState->serverDestinations[0]->tos = GetTosToServer(tunnelState->request.getRaw());
             }
 
 #if SO_MARK && USE_LIBCAP
-            tunnelState->serverDestinations[0]->nfmark = GetNfmarkToServer(tunnelState->request);
+            tunnelState->serverDestinations[0]->nfmark = GetNfmarkToServer(tunnelState->request.getRaw());
 #endif
 
             debugs(26, 4, HERE << "retry with : " << tunnelState->serverDestinations[0]);
             AsyncCall::Pointer call = commCbCall(26,3, "tunnelConnectDone", CommConnectCbPtrFun(tunnelConnectDone, tunnelState));
             Comm::ConnOpener *cs = new Comm::ConnOpener(tunnelState->serverDestinations[0], call, Config.Timeout.connect);
             cs->setHost(tunnelState->url);
             AsyncJob::Start(cs);
         } else {
             debugs(26, 4, HERE << "terminate with error.");
-            ErrorState *err = new ErrorState(ERR_CONNECT_FAIL, HTTP_SERVICE_UNAVAILABLE, tunnelState->request);
-            *tunnelState->status_ptr = HTTP_SERVICE_UNAVAILABLE;
+            ErrorState *err = new ErrorState(ERR_CONNECT_FAIL, Http::scServiceUnavailable, tunnelState->request.getRaw());
+            *tunnelState->status_ptr = Http::scServiceUnavailable;
             err->xerrno = xerrno;
             // on timeout is this still:    err->xerrno = ETIMEDOUT;
-            err->port = conn->remote.GetPort();
+            err->port = conn->remote.port();
             err->callback = tunnelErrorComplete;
             err->callback_data = tunnelState;
             errorSend(tunnelState->client.conn, err);
         }
         return;
     }
@@ -622,16 +841,16 @@
     tunnelState->request->peer_host = conn->getPeer() ? conn->getPeer()->host : NULL;
     comm_add_close_handler(conn->fd, tunnelServerClosed, tunnelState);
 
     debugs(26, 4, HERE << "determine post-connect handling pathway.");
     if (conn->getPeer()) {
         tunnelState->request->peer_login = conn->getPeer()->login;
-        tunnelState->request->flags.proxying = (conn->getPeer()->options.originserver?0:1);
+        tunnelState->request->flags.proxying = !(conn->getPeer()->options.originserver);
     } else {
         tunnelState->request->peer_login = NULL;
-        tunnelState->request->flags.proxying = 0;
+        tunnelState->request->flags.proxying = false;
     }
 
     if (tunnelState->request->flags.proxying)
         tunnelRelayConnectRequest(conn, tunnelState);
     else {
         tunnelConnected(conn, tunnelState);
@@ -653,29 +872,29 @@
     TunnelStateData *tunnelState = NULL;
     ErrorState *err = NULL;
     HttpRequest *request = http->request;
     char *url = http->uri;
 
     /*
-     * client_addr.IsNoAddr()  indicates this is an "internal" request
+     * client_addr.isNoAddr()  indicates this is an "internal" request
      * from peer_digest.c, asn.c, netdb.c, etc and should always
      * be allowed.  yuck, I know.
      */
 
-    if (Config.accessList.miss && !request->client_addr.IsNoAddr()) {
+    if (Config.accessList.miss && !request->client_addr.isNoAddr()) {
         /*
          * Check if this host is allowed to fetch MISSES from us (miss_access)
          * default is to allow.
          */
         ACLFilledChecklist ch(Config.accessList.miss, request, NULL);
         ch.src_addr = request->client_addr;
         ch.my_addr = request->my_addr;
         if (ch.fastCheck() == ACCESS_DENIED) {
             debugs(26, 4, HERE << "MISS access forbidden.");
-            err = new ErrorState(ERR_FORWARDING_DENIED, HTTP_FORBIDDEN, request);
-            *status_ptr = HTTP_FORBIDDEN;
+            err = new ErrorState(ERR_FORWARDING_DENIED, Http::scForbidden, request);
+            *status_ptr = Http::scForbidden;
             errorSend(http->getConn()->clientConnection, err);
             return;
         }
     }
 
     debugs(26, 3, HERE << "'" << RequestMethodStr(request->method) << " " << url << " " << request->http_ver << "'");
@@ -684,16 +903,17 @@
 
     tunnelState = new TunnelStateData;
 #if USE_DELAY_POOLS
     tunnelState->server.setDelayId(DelayId::DelayClient(http));
 #endif
     tunnelState->url = xstrdup(url);
-    tunnelState->request = HTTPMSGLOCK(request);
+    tunnelState->request = request;
     tunnelState->server.size_ptr = size_ptr;
     tunnelState->status_ptr = status_ptr;
     tunnelState->client.conn = http->getConn()->clientConnection;
+    tunnelState->http = http;
     tunnelState->al = al;
 
     comm_add_close_handler(tunnelState->client.conn->fd,
                            tunnelClientClosed,
                            tunnelState);
 
@@ -708,35 +928,59 @@
 }
 
 static void
 tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
+    assert(!tunnelState->waitingForConnectExchange());
     HttpHeader hdr_out(hoRequest);
     Packer p;
     HttpStateFlags flags;
     debugs(26, 3, HERE << srv << ", tunnelState=" << tunnelState);
     memset(&flags, '\0', sizeof(flags));
     flags.proxying = tunnelState->request->flags.proxying;
     MemBuf mb;
     mb.init();
     mb.Printf("CONNECT %s HTTP/1.1\r\n", tunnelState->url);
-    HttpStateData::httpBuildRequestHeader(tunnelState->request,
+    HttpStateData::httpBuildRequestHeader(tunnelState->request.getRaw(),
                                           NULL,			/* StoreEntry */
                                           tunnelState->al,			/* AccessLogEntry */
                                           &hdr_out,
                                           flags);			/* flags */
     packerToMemInit(&p, &mb);
     hdr_out.packInto(&p);
     hdr_out.clean();
     packerClean(&p);
     mb.append("\r\n", 2);
 
-    AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectedWriteDone",
-                                   CommIoCbPtrFun(tunnelConnectedWriteDone, tunnelState));
-    Comm::Write(srv, &mb, writeCall);
+    debugs(11, 2, "Tunnel Server REQUEST: " << tunnelState->server.conn << ":\n----------\n" <<
+           Raw("tunnelRelayConnectRequest", mb.content(), mb.contentSize()) << "\n----------");
+
+    if (tunnelState->clientExpectsConnectResponse()) {
+        // hack: blindly tunnel peer response (to our CONNECT request) to the client as ours.
+        AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectedWriteDone",
+                                       CommIoCbPtrFun(tunnelConnectedWriteDone, tunnelState));
+        Comm::Write(srv, &mb, writeCall);
+    } else {
+        // we have to eat the connect response from the peer (so that the client
+        // does not see it) and only then start shoveling data to the client
+        AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectReqWriteDone",
+                                       CommIoCbPtrFun(tunnelConnectReqWriteDone,
+                                                      tunnelState));
+        Comm::Write(srv, &mb, writeCall);
+        tunnelState->connectReqWriting = true;
+
+        tunnelState->connectRespBuf = new MemBuf;
+        // SQUID_TCP_SO_RCVBUF: we should not accumulate more than regular I/O buffer
+        // can hold since any CONNECT response leftovers have to fit into server.buf.
+        // 2*SQUID_TCP_SO_RCVBUF: HttpMsg::parse() zero-terminates, which uses space.
+        tunnelState->connectRespBuf->init(SQUID_TCP_SO_RCVBUF, 2*SQUID_TCP_SO_RCVBUF);
+        tunnelState->readConnectResponse();
+
+        assert(tunnelState->waitingForConnectExchange());
+    }
 
     AsyncCall::Pointer timeoutCall = commCbCall(5, 4, "tunnelTimeout",
                                      CommTimeoutCbPtrFun(tunnelTimeout, tunnelState));
     commSetConnTimeout(srv, Config.Timeout.read, timeoutCall);
 }
 
@@ -745,28 +989,28 @@
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
 
     if (peer_paths == NULL || peer_paths->size() < 1) {
         debugs(26, 3, HERE << "No paths found. Aborting CONNECT");
         if (!err) {
-            err = new ErrorState(ERR_CANNOT_FORWARD, HTTP_SERVICE_UNAVAILABLE, tunnelState->request);
+            err = new ErrorState(ERR_CANNOT_FORWARD, Http::scServiceUnavailable, tunnelState->request.getRaw());
         }
         *tunnelState->status_ptr = err->httpStatus;
         err->callback = tunnelErrorComplete;
         err->callback_data = tunnelState;
         errorSend(tunnelState->client.conn, err);
         return;
     }
     delete err;
 
     if (Ip::Qos::TheConfig.isAclTosActive()) {
-        tunnelState->serverDestinations[0]->tos = GetTosToServer(tunnelState->request);
+        tunnelState->serverDestinations[0]->tos = GetTosToServer(tunnelState->request.getRaw());
     }
 
 #if SO_MARK && USE_LIBCAP
-    tunnelState->serverDestinations[0]->nfmark = GetNfmarkToServer(tunnelState->request);
+    tunnelState->serverDestinations[0]->nfmark = GetNfmarkToServer(tunnelState->request.getRaw());
 #endif
 
     debugs(26, 3, HERE << "paths=" << peer_paths->size() << ", p[0]={" << (*peer_paths)[0] << "}, serverDest[0]={" <<
            tunnelState->serverDestinations[0] << "}");
 
     AsyncCall::Pointer call = commCbCall(26,3, "tunnelConnectDone", CommConnectCbPtrFun(tunnelConnectDone, tunnelState));
@@ -774,27 +1018,12 @@
     cs->setHost(tunnelState->url);
     AsyncJob::Start(cs);
 }
 
 CBDATA_CLASS_INIT(TunnelStateData);
 
-void *
-TunnelStateData::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(TunnelStateData);
-    TunnelStateData *result = cbdataAlloc(TunnelStateData);
-    return result;
-}
-
-void
-TunnelStateData::operator delete (void *address)
-{
-    TunnelStateData *t = static_cast<TunnelStateData *>(address);
-    cbdataFree(t);
-}
-
 bool
 TunnelStateData::noConnections() const
 {
     return !Comm::IsConnOpen(server.conn) && !Comm::IsConnOpen(client.conn);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/typedefs.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/typedefs.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/typedefs.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/typedefs.h	2015-05-01 18:05:19.000000000 +0800
@@ -45,13 +45,12 @@
     size_t kb;
 } kb_t;
 
 typedef struct _CommWriteStateData CommWriteStateData;
 
 #if SQUID_SNMP
-#include "snmp_vars.h"
 #include "cache_snmp.h"
 typedef variable_list *(oid_ParseFn) (variable_list *, snint *);
 #endif
 
 typedef void FREE(void *);
 typedef void CBDUNL(void *);
@@ -72,13 +71,12 @@
 typedef void IDCB(const char *ident, void *data);
 
 #include "anyp/ProtocolType.h"
 class CachePeer;
 typedef void IRCB(CachePeer *, peer_t, AnyP::ProtocolType, void *, void *data);
 
-typedef void RH(void *data, char *);
 /* in wordlist.h */
 
 class wordlist;
 typedef void UH(void *data, wordlist *);
 typedef int READ_HANDLER(int, char *, int);
 typedef int WRITE_HANDLER(int, const char *, int);
@@ -87,13 +85,12 @@
 typedef void STABH(void *);
 typedef void ERCB(int fd, void *, size_t);
 class StoreEntry;
 typedef void OBJH(StoreEntry *);
 typedef void SIGHDLR(int sig);
 typedef void STVLDCB(void *, int, int);
-typedef void HLPCB(void *, char *buf);
 typedef int HLPSAVAIL(void *);
 typedef void HLPSONEQ(void *);
 typedef void HLPCMDOPTS(int *argc, char **argv);
 typedef void IDNSCB(void *, const rfc1035_rr *, int, const char *);
 
 /* MD5 cache keys */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/unlinkd.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/unlinkd.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/unlinkd.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/unlinkd.cc	2015-05-01 18:05:19.000000000 +0800
@@ -215,13 +215,13 @@
 
     const char *args[2];
     Ip::Address localhost;
 
     args[0] = "(unlinkd)";
     args[1] = NULL;
-    localhost.SetLocalhost();
+    localhost.setLocalhost();
 
     pid = ipcCreate(
 #if USE_POLL && _SQUID_OSF_
               /* pipes and poll() don't get along on DUNIX -DW */
               IPC_STREAM,
 #elif _SQUID_WINDOWS_
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/url.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/url.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/url.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/url.cc	2015-05-01 18:05:19.000000000 +0800
@@ -198,13 +198,13 @@
  * If the 'request' arg is non-NULL, put parsed values there instead
  * of allocating a new HttpRequest.
  *
  * This abuses HttpRequest as a way of representing the parsed url
  * and its components.
  * method is used to switch parsers and to init the HttpRequest.
- * If method is METHOD_CONNECT, then rather than a URL a hostname:port is
+ * If method is Http::METHOD_CONNECT, then rather than a URL a hostname:port is
  * looked for.
  * The url is non const so that if its too long we can NULL-terminate it in place.
  */
 
 /*
  * This routine parses a URL. Its assumed that the URL is complete -
@@ -233,20 +233,20 @@
     if ((l = strlen(url)) + Config.appendDomainLen > (MAX_URL - 1)) {
         /* terminate so it doesn't overflow other buffers */
         *(url + (MAX_URL >> 1)) = '\0';
         debugs(23, DBG_IMPORTANT, "urlParse: URL too large (" << l << " bytes)");
         return NULL;
     }
-    if (method == METHOD_CONNECT) {
+    if (method == Http::METHOD_CONNECT) {
         port = CONNECT_PORT;
 
         if (sscanf(url, "[%[^]]]:%d", host, &port) < 1)
             if (sscanf(url, "%[^:]:%d", host, &port) < 1)
                 return NULL;
 
-    } else if ((method == METHOD_OPTIONS || method == METHOD_TRACE) &&
+    } else if ((method == Http::METHOD_OPTIONS || method == Http::METHOD_TRACE) &&
                strcmp(url, "*") == 0) {
         protocol = AnyP::PROTO_HTTP;
         port = urlDefaultPort(protocol);
         return urlParseFinish(method, protocol, url, host, login, port, request);
     } else if (!strncmp(url, "urn:", 4)) {
         return urnParse(method, url, request);
@@ -351,13 +351,13 @@
                 /* therefore we MUST accept the case where they are not bracketed at all. */
                 t = NULL;
             }
         }
 
         // Bug 3183 sanity check: If scheme is present, host must be too.
-        if (protocol != AnyP::PROTO_NONE && (host == NULL || *host == '\0')) {
+        if (protocol != AnyP::PROTO_NONE && host[0] == '\0') {
             debugs(23, DBG_IMPORTANT, "SECURITY ALERT: Missing hostname in URL '" << url << "'. see access.log for details.");
             return NULL;
         }
 
         if (t && *t == ':') {
             *t = '\0';
@@ -496,46 +496,36 @@
 }
 
 const char *
 urlCanonical(HttpRequest * request)
 {
     LOCAL_ARRAY(char, portbuf, 32);
-/// \todo AYJ: Performance: making this a ptr and allocating when needed will be better than a write and future xstrdup().
     LOCAL_ARRAY(char, urlbuf, MAX_URL);
 
     if (request->canonical)
         return request->canonical;
 
     if (request->protocol == AnyP::PROTO_URN) {
         snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(request->urlpath));
+    } else if (request->method.id() == Http::METHOD_CONNECT) {
+        snprintf(urlbuf, MAX_URL, "%s:%d", request->GetHost(), request->port);
     } else {
-/// \todo AYJ: this could use "if..else and method == METHOD_CONNECT" easier.
-        switch (request->method.id()) {
+        portbuf[0] = '\0';
 
-        case METHOD_CONNECT:
-            snprintf(urlbuf, MAX_URL, "%s:%d", request->GetHost(), request->port);
-            break;
-
-        default:
-            portbuf[0] = '\0';
+        if (request->port != urlDefaultPort(request->protocol))
+            snprintf(portbuf, 32, ":%d", request->port);
 
-            if (request->port != urlDefaultPort(request->protocol))
-                snprintf(portbuf, 32, ":%d", request->port);
-
-            const URLScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
-            snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
-                     sch.const_str(),
-                     request->login,
-                     *request->login ? "@" : null_string,
-                     request->GetHost(),
-                     portbuf,
-                     SQUIDSTRINGPRINT(request->urlpath));
-
-            break;
-        }
+        const URLScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
+        snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
+                 sch.const_str(),
+                 request->login,
+                 *request->login ? "@" : null_string,
+                 request->GetHost(),
+                 portbuf,
+                 SQUIDSTRINGPRINT(request->urlpath));
     }
 
     return (request->canonical = xstrdup(urlbuf));
 }
 
 /** \todo AYJ: Performance: This is an *almost* duplicate of urlCanonical. But elides the query-string.
@@ -550,79 +540,66 @@
     LOCAL_ARRAY(char, loginbuf, MAX_LOGIN_SZ + 1);
     char *t;
 
     if (request->protocol == AnyP::PROTO_URN) {
         snprintf(buf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(request->urlpath));
+    } else if (request->method.id() == Http::METHOD_CONNECT) {
+        snprintf(buf, MAX_URL, "%s:%d", request->GetHost(), request->port);
     } else {
-/// \todo AYJ: this could use "if..else and method == METHOD_CONNECT" easier.
-        switch (request->method.id()) {
-
-        case METHOD_CONNECT:
-            snprintf(buf, MAX_URL, "%s:%d",
-                     request->GetHost(),
-                     request->port);
-            break;
-
-        default:
-            portbuf[0] = '\0';
+        portbuf[0] = '\0';
 
-            if (request->port != urlDefaultPort(request->protocol))
-                snprintf(portbuf, 32, ":%d", request->port);
+        if (request->port != urlDefaultPort(request->protocol))
+            snprintf(portbuf, 32, ":%d", request->port);
 
-            loginbuf[0] = '\0';
+        loginbuf[0] = '\0';
 
-            if ((int) strlen(request->login) > 0) {
-                strcpy(loginbuf, request->login);
+        if ((int) strlen(request->login) > 0) {
+            strcpy(loginbuf, request->login);
 
-                if ((t = strchr(loginbuf, ':')))
-                    *t = '\0';
+            if ((t = strchr(loginbuf, ':')))
+                *t = '\0';
 
-                strcat(loginbuf, "@");
-            }
-
-            const URLScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
-            snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
-                     sch.const_str(),
-                     loginbuf,
-                     request->GetHost(),
-                     portbuf,
-                     SQUIDSTRINGPRINT(request->urlpath));
-            /*
-             * strip arguments AFTER a question-mark
-             */
+            strcat(loginbuf, "@");
+        }
 
-            if (Config.onoff.strip_query_terms)
-                if ((t = strchr(buf, '?'))) {
-                    ++t;
-                    *t = '\0';
-                }
+        const URLScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
+        snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
+                 sch.const_str(),
+                 loginbuf,
+                 request->GetHost(),
+                 portbuf,
+                 SQUIDSTRINGPRINT(request->urlpath));
+        /*
+         * strip arguments AFTER a question-mark
+         */
 
-            break;
-        }
+        if (Config.onoff.strip_query_terms)
+            if ((t = strchr(buf, '?')))
+                *(++t) = '\0';
     }
 
     if (stringHasCntl(buf))
         xstrncpy(buf, rfc1738_escape_unescaped(buf), MAX_URL);
 
     return buf;
 }
 
 /**
  * Yet another alternative to urlCanonical.
- * This one addes the https:// parts to METHOD_CONNECT URL
+ * This one adds the https:// parts to Http::METHOD_CONNECT URL
  * for use in error page outputs.
  * Luckily we can leverage the others instead of duplicating.
  */
 const char *
 urlCanonicalFakeHttps(const HttpRequest * request)
 {
     LOCAL_ARRAY(char, buf, MAX_URL);
 
     // method CONNECT and port HTTPS
-    if (request->method == METHOD_CONNECT && request->port == 443) {
+    if (request->method == Http::METHOD_CONNECT && request->port == 443) {
         snprintf(buf, MAX_URL, "https://%s/*", request->GetHost());
         return buf;
     }
 
     // else do the normal complete canonical thing.
     return urlCanonicalClean(request);
@@ -668,13 +645,13 @@
  * memory using safe_free().
  */
 char *
 urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
 {
 
-    if (req->method.id() == METHOD_CONNECT) {
+    if (req->method.id() == Http::METHOD_CONNECT) {
         return (NULL);
     }
 
     char *urlbuf = (char *)xmalloc(MAX_URL * sizeof(char));
 
     if (req->protocol == AnyP::PROTO_URN) {
@@ -839,21 +816,21 @@
      * there.
      *
      * So, we should delegate them to HTTP. The problem is that we
      * do not have a default protocol from the client side of HTTP.
      */
 
-    if (r->method == METHOD_CONNECT)
+    if (r->method == Http::METHOD_CONNECT)
         return 1;
 
     // we support OPTIONS and TRACE directed at us (with a 501 reply, for now)
     // we also support forwarding OPTIONS and TRACE, except for the *-URI ones
-    if (r->method == METHOD_OPTIONS || r->method == METHOD_TRACE)
+    if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)
         return (r->header.getInt64(HDR_MAX_FORWARDS) == 0 || r->urlpath != "*");
 
-    if (r->method == METHOD_PURGE)
+    if (r->method == Http::METHOD_PURGE)
         return 1;
 
     /* does method match the protocol? */
     switch (r->protocol) {
 
     case AnyP::PROTO_URN:
@@ -863,23 +840,23 @@
     case AnyP::PROTO_CACHE_OBJECT:
         rc = 1;
         break;
 
     case AnyP::PROTO_FTP:
 
-        if (r->method == METHOD_PUT)
+        if (r->method == Http::METHOD_PUT)
             rc = 1;
 
     case AnyP::PROTO_GOPHER:
 
     case AnyP::PROTO_WAIS:
 
     case AnyP::PROTO_WHOIS:
-        if (r->method == METHOD_GET)
+        if (r->method == Http::METHOD_GET)
             rc = 1;
-        else if (r->method == METHOD_HEAD)
+        else if (r->method == Http::METHOD_HEAD)
             rc = 1;
 
         break;
 
     case AnyP::PROTO_HTTPS:
 #if USE_SSL
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/urn.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/urn.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/urn.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/urn.cc	2015-05-01 18:05:19.000000000 +0800
@@ -28,14 +28,15 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #include "squid.h"
+#include "cbdata.h"
 #include "errorpage.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
 #include "MemBuf.h"
 #include "mime_header.h"
@@ -51,37 +52,37 @@
 
 class UrnState : public StoreClient
 {
 
 public:
     void created (StoreEntry *newEntry);
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
     void start (HttpRequest *, StoreEntry *);
     char *getHost (String &urlpath);
     void setUriResFromRequest(HttpRequest *);
     bool RequestNeedsMenu(HttpRequest *r);
     void updateRequestURL(HttpRequest *r, char const *newPath, const size_t newPath_len);
     void createUriResRequest (String &uri);
 
     virtual ~UrnState();
 
     StoreEntry *entry;
     store_client *sc;
     StoreEntry *urlres_e;
-    HttpRequest *request;
-    HttpRequest *urlres_r;
+    HttpRequest::Pointer request;
+    HttpRequest::Pointer urlres_r;
 
     struct {
-        unsigned int force_menu:1;
+        bool force_menu;
     } flags;
     char reqbuf[URN_REQBUF_SZ];
     int reqofs;
 
 private:
     char *urlres;
+
+    CBDATA_CLASS2(UrnState);
 };
 
 typedef struct {
     char *url;
     char *host;
     int rtt;
@@ -93,31 +94,15 @@
 
 static STCB urnHandleReply;
 static url_entry *urnParseReply(const char *inbuf, const HttpRequestMethod&);
 static const char *const crlf = "\r\n";
 static QS url_entry_sort;
 
-CBDATA_TYPE(UrnState);
-void *
-UrnState::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (UrnState));
-    CBDATA_INIT_TYPE(UrnState);
-    return cbdataAlloc(UrnState);
-
-}
-
-void
-UrnState::operator delete (void *address)
-{
-    UrnState * tmp = (UrnState *)address;
-    cbdataFree (tmp);
-}
+CBDATA_CLASS_INIT(UrnState);
 
-UrnState::~UrnState ()
+UrnState::~UrnState()
 {
     safe_free(urlres);
 }
 
 static url_entry *
 urnFindMinRtt(url_entry * urls, const HttpRequestMethod& m, int *rtt_ret)
@@ -213,57 +198,55 @@
 
 void
 UrnState::setUriResFromRequest(HttpRequest *r)
 {
     if (RequestNeedsMenu(r)) {
         updateRequestURL(r, r->urlpath.rawBuf() + 5, r->urlpath.size() - 5 );
-        flags.force_menu = 1;
+        flags.force_menu = true;
     }
 
     createUriResRequest (r->urlpath);
 
     if (urlres_r == NULL) {
         debugs(52, 3, "urnStart: Bad uri-res URL " << urlres);
-        ErrorState *err = new ErrorState(ERR_URN_RESOLVE, HTTP_NOT_FOUND, r);
+        ErrorState *err = new ErrorState(ERR_URN_RESOLVE, Http::scNotFound, r);
         err->url = urlres;
         urlres = NULL;
         errorAppendEntry(entry, err);
         return;
     }
 
-    HTTPMSGLOCK(urlres_r);
     urlres_r->header.putStr(HDR_ACCEPT, "text/plain");
 }
 
 void
 UrnState::start(HttpRequest * r, StoreEntry * e)
 {
     debugs(52, 3, "urnStart: '" << e->url() << "'" );
     entry = e;
-    request = HTTPMSGLOCK(r);
+    request = r;
 
     entry->lock();
     setUriResFromRequest(r);
 
     if (urlres_r == NULL)
         return;
 
-    StoreEntry::getPublic (this, urlres, METHOD_GET);
+    StoreEntry::getPublic (this, urlres, Http::METHOD_GET);
 }
 
 void
 UrnState::created(StoreEntry *newEntry)
 {
     urlres_e = newEntry;
 
     if (urlres_e->isNull()) {
-        urlres_e = storeCreateEntry(urlres, urlres, RequestFlags(), METHOD_GET);
+        urlres_e = storeCreateEntry(urlres, urlres, RequestFlags(), Http::METHOD_GET);
         sc = storeClientListAdd(urlres_e, this);
-        FwdState::fwdStart(Comm::ConnectionPointer(), urlres_e, urlres_r);
+        FwdState::fwdStart(Comm::ConnectionPointer(), urlres_e, urlres_r.getRaw());
     } else {
-
         urlres_e->lock();
         sc = storeClientListAdd(urlres_e, this);
     }
 
     reqofs = 0;
     StoreIOBuffer tempBuffer;
@@ -301,14 +284,12 @@
 
 static void
 urnHandleReplyError(UrnState *urnState, StoreEntry *urlres_e)
 {
     urlres_e->unlock();
     urnState->entry->unlock();
-    HTTPMSGUNLOCK(urnState->request);
-    HTTPMSGUNLOCK(urnState->urlres_r);
     delete urnState;
 }
 
 /* TODO: use the clientStream support for this */
 static void
 urnHandleReply(void *data, StoreIOBuffer result)
@@ -368,17 +349,17 @@
     }
 
     s = buf + k;
     assert(urlres_e->getReply());
     rep = new HttpReply;
     rep->parseCharBuf(buf, k);
-    debugs(52, 3, "reply exists, code=" << rep->sline.status << ".");
+    debugs(52, 3, "reply exists, code=" << rep->sline.status() << ".");
 
-    if (rep->sline.status != HTTP_OK) {
+    if (rep->sline.status() != Http::scOkay) {
         debugs(52, 3, "urnHandleReply: failed.");
-        err = new ErrorState(ERR_URN_RESOLVE, HTTP_NOT_FOUND, urnState->request);
+        err = new ErrorState(ERR_URN_RESOLVE, Http::scNotFound, urnState->request.getRaw());
         err->url = xstrdup(e->url());
         errorAppendEntry(e, err);
         delete rep;
         urnHandleReplyError(urnState, urlres_e);
         return;
     }
@@ -393,14 +374,14 @@
     for (i = 0; NULL != urls[i].url; ++i)
         ++urlcnt;
 
     debugs(53, 3, "urnFindMinRtt: Counted " << i << " URLs");
 
     if (urls == NULL) {		/* unkown URN error */
-        debugs(52, 3, "urnTranslateDone: unknown URN " << e->url()  );
-        err = new ErrorState(ERR_URN_RESOLVE, HTTP_NOT_FOUND, urnState->request);
+        debugs(52, 3, "urnTranslateDone: unknown URN " << e->url());
+        err = new ErrorState(ERR_URN_RESOLVE, Http::scNotFound, urnState->request.getRaw());
         err->url = xstrdup(e->url());
         errorAppendEntry(e, err);
         urnHandleReplyError(urnState, urlres_e);
         return;
     }
 
@@ -435,13 +416,13 @@
         "<HR noshade size=\"1px\">\n"
         "<ADDRESS>\n"
         "Generated by %s@%s\n"
         "</ADDRESS>\n",
         APP_FULLNAME, getMyHostname());
     rep = new HttpReply;
-    rep->setHeaders(HTTP_MOVED_TEMPORARILY, NULL, "text/html", mb->contentSize(), 0, squid_curtime);
+    rep->setHeaders(Http::scFound, NULL, "text/html", mb->contentSize(), 0, squid_curtime);
 
     if (urnState->flags.force_menu) {
         debugs(51, 3, "urnHandleReply: forcing menu");
     } else if (min_u) {
         rep->header.putStr(HDR_LOCATION, min_u->url);
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/wccp2.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/wccp2.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/wccp2.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/wccp2.cc	2015-05-01 18:05:19.000000000 +0800
@@ -35,13 +35,12 @@
 #if USE_WCCPv2
 
 #include "cache_cf.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
-#include "compat/strsep.h"
 #include "event.h"
 #include "ip/Address.h"
 #include "md5.h"
 #include "Parsing.h"
 #include "Store.h"
 #include "SwapDir.h"
@@ -64,13 +63,13 @@
 /* KDW WCCP V2 */
 
 #define WCCP2_HASH_ASSIGNMENT		0x00
 #define WCCP2_MASK_ASSIGNMENT		0x01
 
 #define	WCCP2_NONE_SECURITY_LEN	0
-#define	WCCP2_MD5_SECURITY_LEN	16
+#define	WCCP2_MD5_SECURITY_LEN	SQUID_MD5_DIGEST_LENGTH // 16
 
 /* Useful defines */
 #define	WCCP2_NUMPORTS	8
 #define	WCCP2_PASSWORD_LEN	8
 
 /* WCCPv2 Pakcet format structures */
@@ -570,13 +569,13 @@
  *
  * Returns: 1 if we set it, 0 if not (eg, no security section, or non-md5)
  */
 static char
 wccp2_update_md5_security(char *password, char *ptr, char *packet, int len)
 {
-    uint8_t md5_digest[16];
+    uint8_t md5Digest[SQUID_MD5_DIGEST_LENGTH];
     char pwd[WCCP2_PASSWORD_LEN];
     SquidMD5_CTX M;
 
     struct wccp2_security_md5_t *ws;
 
     debugs(80, 5, "wccp2_update_md5_security: called");
@@ -598,24 +597,24 @@
     /* And now its the MD5 section! */
     /* According to the draft, the MD5 security hash is the combination of
      * the 8-octet password (padded w/ NUL bytes) and the entire WCCP packet,
      * including the WCCP message header. The WCCP security implementation
      * area should be zero'ed before calculating the MD5 hash.
      */
-    /* XXX eventually we should be able to kill md5_digest and blit it directly in */
+    /* XXX eventually we should be able to kill md5Digest and blit it directly in */
     memset(ws->security_implementation, 0, sizeof(ws->security_implementation));
 
     SquidMD5Init(&M);
 
     SquidMD5Update(&M, pwd, sizeof(pwd));
 
     SquidMD5Update(&M, packet, len);
 
-    SquidMD5Final(md5_digest, &M);
+    SquidMD5Final(md5Digest, &M);
 
-    memcpy(ws->security_implementation, md5_digest, sizeof(md5_digest));
+    memcpy(ws->security_implementation, md5Digest, sizeof(md5Digest));
 
     /* Finished! */
     return 1;
 }
 
 /*
@@ -624,13 +623,13 @@
 static char
 
 wccp2_check_security(struct wccp2_service_list_t *srv, char *security, char *packet, int len)
 {
 
     struct wccp2_security_md5_t *ws = (struct wccp2_security_md5_t *) security;
-    uint8_t md5_digest[16], md5_challenge[16];
+    uint8_t md5Digest[SQUID_MD5_DIGEST_LENGTH], md5_challenge[SQUID_MD5_DIGEST_LENGTH];
     char pwd[WCCP2_PASSWORD_LEN];
     SquidMD5_CTX M;
 
     /* Make sure the security type matches what we expect */
 
     if (ntohl(ws->security_option) != srv->wccp2_security_type) {
@@ -652,25 +651,25 @@
     /* The password field, for the MD5 hash, needs to be 8 bytes and NUL padded. */
     memset(pwd, 0, sizeof(pwd));
     strncpy(pwd, srv->wccp_password, sizeof(pwd));
     pwd[sizeof(pwd) - 1] = '\0';
 
     /* Take a copy of the challenge: we need to NUL it before comparing */
-    memcpy(md5_challenge, ws->security_implementation, 16);
+    memcpy(md5_challenge, ws->security_implementation, sizeof(md5_challenge));
 
     memset(ws->security_implementation, 0, sizeof(ws->security_implementation));
 
     SquidMD5Init(&M);
 
     SquidMD5Update(&M, pwd, sizeof(pwd));
 
     SquidMD5Update(&M, packet, len);
 
-    SquidMD5Final(md5_digest, &M);
+    SquidMD5Final(md5Digest, &M);
 
-    return (memcmp(md5_digest, md5_challenge, 16) == 0);
+    return (memcmp(md5Digest, md5_challenge, SQUID_MD5_DIGEST_LENGTH) == 0);
 }
 
 void
 wccp2Init(void)
 {
     Ip::Address_list *s;
@@ -678,33 +677,34 @@
     uint32_t service_flags;
 
     struct wccp2_service_list_t *service_list_ptr;
 
     struct wccp2_router_list_t *router_list_ptr;
 
-    struct wccp2_security_md5_t wccp2_security_md5;
-
     debugs(80, 5, "wccp2Init: Called");
 
     if (wccp2_connected == 1)
         return;
 
     wccp2_numrouters = 0;
 
     /* Calculate the number of routers configured in the config file */
     for (s = Config.Wccp2.router; s; s = s->next) {
-        if (!s->s.IsAnyAddr()) {
+        if (!s->s.isAnyAddr()) {
             /* Increment the counter */
             ++wccp2_numrouters;
         }
     }
 
     if (wccp2_numrouters == 0) {
         return;
     }
 
+    struct wccp2_security_md5_t wccp2_security_md5;
+    memset(&wccp2_security_md5, 0, sizeof(wccp2_security_md5));
+
     /* Initialise the list of services */
     wccp2InitServices();
 
     service_list_ptr = wccp2_service_list_head;
 
     while (service_list_ptr != NULL) {
@@ -846,23 +846,23 @@
         memcpy(ptr, &service_list_ptr->num_routers, sizeof(service_list_ptr->num_routers));
 
         ptr += sizeof(service_list_ptr->num_routers);
 
         /* Add each router.  Keep this functionality here to make sure the received_id can be updated in the packet */
         for (s = Config.Wccp2.router; s; s = s->next) {
-            if (!s->s.IsAnyAddr()) {
+            if (!s->s.isAnyAddr()) {
 
                 wccp2_here_i_am_header.length += sizeof(struct wccp2_router_id_element_t);
                 assert(wccp2_here_i_am_header.length <= WCCP_RESPONSE_SIZE);
 
                 /* Add a pointer to the router list for this router */
 
                 router_list_ptr->info = (struct wccp2_router_id_element_t *) ptr;
-                s->s.GetInAddr(router_list_ptr->info->router_address);
+                s->s.getInAddr(router_list_ptr->info->router_address);
                 router_list_ptr->info->received_id = htonl(0);
-                s->s.GetInAddr(router_list_ptr->router_sendto_address);
+                s->s.getInAddr(router_list_ptr->router_sendto_address);
                 router_list_ptr->member_change = htonl(0);
 
                 /* Build the next struct */
 
                 router_list_ptr->next = (wccp2_router_list_t*) xcalloc(1, sizeof(struct wccp2_router_list_t));
 
@@ -979,18 +979,18 @@
 
     if (wccp2_numrouters == 0 || !wccp2_service_list_head) {
         debugs(80, 2, "WCCPv2 Disabled. No IPv4 Router(s) configured.");
         return;
     }
 
-    if ( !Config.Wccp2.address.SetIPv4() ) {
+    if ( !Config.Wccp2.address.setIPv4() ) {
         debugs(80, DBG_CRITICAL, "WCCPv2 Disabled. Local address " << Config.Wccp2.address << " is not an IPv4 address.");
         return;
     }
 
-    Config.Wccp2.address.SetPort(WCCP_PORT);
+    Config.Wccp2.address.port(WCCP_PORT);
     theWccp2Connection = comm_open_listener(SOCK_DGRAM,
                                             0,
                                             Config.Wccp2.address,
                                             COMM_NONBLOCKING,
                                             "WCCPv2 Socket");
 
@@ -1068,19 +1068,24 @@
     struct wccp2_cache_list_t *cache_list_ptr_next;
 
     if (wccp2_connected == 0) {
         return;
     }
 
+    /* TODO A shutting-down cache should generate a removal query, informing the router
+     * (and therefore the caches in the group) that this cache is going
+     * away and no new traffic should be forwarded to it.
+     */
+
     if (theWccp2Connection > -1) {
         debugs(80, DBG_IMPORTANT, "FD " << theWccp2Connection << " Closing WCCPv2 socket");
         comm_close(theWccp2Connection);
         theWccp2Connection = -1;
     }
 
-    /* for each router on each service send a packet */
+    /* free all stored router state */
     service_list_ptr = wccp2_service_list_head;
 
     while (service_list_ptr != NULL) {
         for (router_list_ptr = &service_list_ptr->router_list_head; router_list_ptr != NULL; router_list_ptr = router_list_next) {
             for (cache_list_ptr = &router_list_ptr->cache_list_head; cache_list_ptr; cache_list_ptr = cache_list_ptr_next) {
                 cache_list_ptr_next = cache_list_ptr->next;
@@ -1168,30 +1173,32 @@
     debugs(80, 6, "wccp2HandleUdp: Called.");
 
     Comm::SetSelect(sock, COMM_SELECT_READ, wccp2HandleUdp, NULL, 0);
 
     /* FIXME INET6 : drop conversion boundary */
     Ip::Address from_tmp;
+    from_tmp.setIPv4();
 
     len = comm_udp_recvfrom(sock,
                             &wccp2_i_see_you,
                             WCCP_RESPONSE_SIZE,
                             0,
                             from_tmp);
-    /* FIXME INET6 : drop conversion boundary */
-    from_tmp.GetSockAddr(from);
 
     if (len < 0)
         return;
 
     if (ntohs(wccp2_i_see_you.version) != WCCP2_VERSION)
         return;
 
     if (ntohl(wccp2_i_see_you.type) != WCCP2_I_SEE_YOU)
         return;
 
+    /* FIXME INET6 : drop conversion boundary */
+    from_tmp.getSockAddr(from);
+
     debugs(80, 3, "Incoming WCCPv2 I_SEE_YOU length " << ntohs(wccp2_i_see_you.length) << ".");
 
     /* Record the total data length */
     data_length = ntohs(wccp2_i_see_you.length);
 
     offset = 0;
@@ -1551,13 +1558,13 @@
     /* Wait if store dirs are rebuilding */
     if (StoreController::store_dirs_rebuilding && Config.Wccp2.rebuildwait) {
         eventAdd("wccp2HereIam", wccp2HereIam, NULL, 1.0, 1);
         return;
     }
 
-    router.SetPort(WCCP_PORT);
+    router.port(WCCP_PORT);
 
     /* for each router on each service send a packet */
     service_list_ptr = wccp2_service_list_head;
 
     while (service_list_ptr != NULL) {
         debugs(80, 5, "wccp2HereIam: sending to service id " << service_list_ptr->info.service_id);
@@ -2200,88 +2207,78 @@
  * src_ip_hash, dst_ip_hash, source_port_hash, dst_port_hash, ports_defined,
  * ports_source, src_ip_alt_hash, dst_ip_alt_hash, src_port_alt_hash, dst_port_alt_hash
  */
 static int
 parse_wccp2_service_flags(char *flags)
 {
-    char *tmp, *tmp2;
-    char *flag;
-    int retflag = 0;
-
-    if (!flags) {
+    if (!flags)
         return 0;
-    }
 
-    tmp = xstrdup(flags);
-    tmp2 = tmp;
+    char *flag = flags;
+    int retflag = 0;
 
-    flag = strsep(&tmp2, ",");
+    while (size_t len = strcspn(flag, ",")) {
 
-    while (flag) {
-        if (strcmp(flag, "src_ip_hash") == 0) {
+        if (strncmp(flag, "src_ip_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_SRC_IP_HASH;
-        } else if (strcmp(flag, "dst_ip_hash") == 0) {
+        } else if (strncmp(flag, "dst_ip_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_DST_IP_HASH;
-        } else if (strcmp(flag, "source_port_hash") == 0) {
+        } else if (strncmp(flag, "source_port_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_SRC_PORT_HASH;
-        } else if (strcmp(flag, "dst_port_hash") == 0) {
+        } else if (strncmp(flag, "dst_port_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_DST_PORT_HASH;
-        } else if (strcmp(flag, "ports_source") == 0) {
+        } else if (strncmp(flag, "ports_source", len) == 0) {
             retflag |= WCCP2_SERVICE_PORTS_SOURCE;
-        } else if (strcmp(flag, "src_ip_alt_hash") == 0) {
+        } else if (strncmp(flag, "src_ip_alt_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_SRC_IP_ALT_HASH;
-        } else if (strcmp(flag, "dst_ip_alt_hash") == 0) {
+        } else if (strncmp(flag, "dst_ip_alt_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_DST_IP_ALT_HASH;
-        } else if (strcmp(flag, "src_port_alt_hash") == 0) {
+        } else if (strncmp(flag, "src_port_alt_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_SRC_PORT_ALT_HASH;
-        } else if (strcmp(flag, "dst_port_alt_hash") == 0) {
+        } else if (strncmp(flag, "dst_port_alt_hash", len) == 0) {
             retflag |= WCCP2_SERVICE_DST_PORT_ALT_HASH;
         } else {
+            flag[len] = '\0';
             fatalf("Unknown wccp2 service flag: %s\n", flag);
         }
 
-        flag = strsep(&tmp2, ",");
+        if (flag[len] == '\0')
+            break;
+
+        flag += len+1;
     }
 
-    xfree(tmp);
     return retflag;
 }
 
 static void
 parse_wccp2_service_ports(char *options, int portlist[])
 {
-    int i = 0;
-    int p;
-    char *tmp, *tmp2, *port;
-
     if (!options) {
         return;
     }
 
-    tmp = xstrdup(options);
-    tmp2 = tmp;
-
-    port = strsep(&tmp2, ",");
+    int i = 0;
+    char *tmp = options;
 
-    while (port && i < WCCP2_NUMPORTS) {
-        p = xatoi(port);
+    while (size_t len = strcspn(tmp, ",")) {
+        if (i >= WCCP2_NUMPORTS) {
+            fatalf("parse_wccp2_service_ports: too many ports (maximum: 8) in list '%s'\n", options);
+        }
+        int p = xatoi(tmp);
 
         if (p < 1 || p > 65535) {
-            fatalf("parse_wccp2_service_ports: port value '%s' isn't valid (1..65535)\n", port);
+            fatalf("parse_wccp2_service_ports: port value '%s' isn't valid (1..65535)\n", tmp);
         }
 
         portlist[i] = p;
         ++i;
-        port = strsep(&tmp2, ",");
-    }
-
-    if (i == WCCP2_NUMPORTS && port) {
-        fatalf("parse_wccp2_service_ports: too many ports (maximum: 8) in list '%s'\n", options);
+        if (tmp[len] == '\0')
+            return;
+        tmp += len+1;
     }
-
-    xfree(tmp);
 }
 
 void
 parse_wccp2_service_info(void *v)
 {
     char *t, *end;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/wccp.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/wccp.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/wccp.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/wccp.cc	2015-05-01 18:05:19.000000000 +0800
@@ -117,39 +117,39 @@
     wccp_here_i_am.revision = htonl(WCCP_REVISION);
     last_change = 0;
     last_id = 0;
     last_assign_buckets_change = 0;
     number_caches = 0;
 
-    if (!Config.Wccp.router.IsAnyAddr())
+    if (!Config.Wccp.router.isAnyAddr())
         if (!eventFind(wccpHereIam, NULL))
             eventAdd("wccpHereIam", wccpHereIam, NULL, 5.0, 1);
 }
 
 void
 wccpConnectionOpen(void)
 {
     debugs(80, 5, "wccpConnectionOpen: Called");
 
-    if (Config.Wccp.router.IsAnyAddr()) {
+    if (Config.Wccp.router.isAnyAddr()) {
         debugs(80, 2, "WCCPv1 disabled.");
         return;
     }
 
-    if ( !Config.Wccp.router.SetIPv4() ) {
+    if ( !Config.Wccp.router.setIPv4() ) {
         debugs(80, DBG_CRITICAL, "WCCPv1 Disabled. Router " << Config.Wccp.router << " is not an IPv4 address.");
         return;
     }
 
-    if ( !Config.Wccp.address.SetIPv4() ) {
+    if ( !Config.Wccp.address.setIPv4() ) {
         debugs(80, DBG_CRITICAL, "WCCPv1 Disabled. Local address " << Config.Wccp.address << " is not an IPv4 address.");
         return;
     }
 
-    Config.Wccp.address.SetPort(WCCP_PORT);
-    Config.Wccp.router.SetPort(WCCP_PORT);
+    Config.Wccp.address.port(WCCP_PORT);
+    Config.Wccp.router.port(WCCP_PORT);
 
     theWccpConnection = comm_open_listener(SOCK_DGRAM,
                                            IPPROTO_UDP,
                                            Config.Wccp.address,
                                            COMM_NONBLOCKING,
                                            "WCCP Socket");
@@ -161,13 +161,13 @@
 
     debugs(80, DBG_IMPORTANT, "Accepting WCCPv1 messages on " << Config.Wccp.address << ", FD " << theWccpConnection << ".");
 
     // Sadly WCCP only does IPv4
 
     struct sockaddr_in router;
-    Config.Wccp.router.GetSockAddr(router);
+    Config.Wccp.router.getSockAddr(router);
     if (connect(theWccpConnection, (struct sockaddr*)&router, sizeof(router)))
         fatal("Unable to connect WCCP out socket");
 
     struct sockaddr_in local;
     memset(&local, '\0', sizeof(local));
     socklen_t slen = sizeof(local);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/whois.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/whois.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/whois.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/whois.cc	2015-05-01 18:05:19.000000000 +0800
@@ -32,16 +32,16 @@
  */
 
 #include "squid.h"
 #include "comm.h"
 #include "comm/Write.h"
 #include "errorpage.h"
+#include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "HttpRequest.h"
-#include "forward.h"
 #include "SquidConfig.h"
 #include "StatCounters.h"
 #include "Store.h"
 #include "tools.h"
 
 #if HAVE_ERRNO_H
@@ -136,13 +136,13 @@
 
 void
 WhoisState::setReplyToOK(StoreEntry *sentry)
 {
     HttpReply *reply = new HttpReply;
     sentry->buffer();
-    reply->setHeaders(HTTP_OK, "Gatewaying", "text/plain", -1, -1, -2);
+    reply->setHeaders(Http::scOkay, "Gatewaying", "text/plain", -1, -1, -2);
     sentry->replaceHttpReply(reply);
 }
 
 void
 WhoisState::readReply(const Comm::ConnectionPointer &conn, char *aBuffer, size_t aBufferLength, comm_err_t flag, int xerrno)
 {
@@ -159,13 +159,13 @@
 
         if (ignoreErrno(errno)) {
             AsyncCall::Pointer call = commCbCall(5,4, "whoisReadReply",
                                                  CommIoCbPtrFun(whoisReadReply, this));
             comm_read(conn, aBuffer, BUFSIZ, call);
         } else {
-            ErrorState *err = new ErrorState(ERR_READ_ERROR, HTTP_INTERNAL_SERVER_ERROR, fwd->request);
+            ErrorState *err = new ErrorState(ERR_READ_ERROR, Http::scInternalServerError, fwd->request);
             err->xerrno = xerrno;
             fwd->fail(err);
             conn->close();
         }
         return;
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/win32.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/win32.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/win32.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/win32.cc	2015-05-01 18:05:19.000000000 +0800
@@ -29,13 +29,12 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #include "squid.h"
-#include "squid_windows.h"
 #include "win32.h"
 
 #if _SQUID_WINDOWS_
 #if HAVE_WIN32_PSAPI
 #include <psapi.h>
 #endif
@@ -45,121 +44,12 @@
 #include <fde.h>
 
 SQUIDCEXTERN LPCRITICAL_SECTION dbg_mutex;
 void WIN32_ExceptionHandlerCleanup(void);
 static LPTOP_LEVEL_EXCEPTION_FILTER Win32_Old_ExceptionHandler = NULL;
 
-int WIN32_pipe(int handles[2])
-{
-    int new_socket;
-    fde *F = NULL;
-
-    Ip::Address localhost;
-    Ip::Address handle0;
-    Ip::Address handle1;
-    struct addrinfo *AI = NULL;
-
-    localhost.SetLocalhost();
-
-    /* INET6: back-compatible: localhost pipes default to IPv4 unless set otherwise.
-     *        it is blocked by untested helpers on many admins configs
-     *        if this proves to be wrong it can die easily.
-     */
-    localhost.SetIPv4();
-
-    handles[0] = handles[1] = -1;
-
-    ++statCounter.syscalls.sock.sockets;
-
-    handle0 = localhost;
-    handle0.SetPort(0);
-    handle0.GetAddrInfo(AI);
-
-    if ((new_socket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol)) < 0)
-        return -1;
-
-    if (bind(new_socket, AI->ai_addr, AI->ai_addrlen) < 0 ||
-            listen(new_socket, 1) < 0 || getsockname(new_socket, AI->ai_addr, &(AI->ai_addrlen) ) < 0 ||
-            (handles[1] = socket(AI->ai_family, AI->ai_socktype, 0)) < 0) {
-        closesocket(new_socket);
-        return -1;
-    }
-
-    handle0 = *AI; // retrieve the new details returned by connect()
-
-    handle1.SetPort(handle1.GetPort());
-    handle1.GetAddrInfo(AI);
-
-    if (connect(handles[1], AI->ai_addr, AI->ai_addrlen) < 0 ||
-            (handles[0] = accept(new_socket, AI->ai_addr, &(AI->ai_addrlen)) ) < 0) {
-        closesocket(handles[1]);
-        handles[1] = -1;
-        closesocket(new_socket);
-        return -1;
-    }
-
-    closesocket(new_socket);
-
-    F = &fd_table[handles[0]];
-    F->local_addr = handle0;
-
-    F = &fd_table[handles[1]];
-    F->local_addr = localhost;
-    handle1.NtoA(F->ipaddr, MAX_IPSTRLEN);
-    F->remote_port = handle1.GetPort();
-
-    return 0;
-}
-
-int WIN32_getrusage(int who, struct rusage *usage)
-{
-#if HAVE_WIN32_PSAPI
-
-    if (WIN32_OS_version >= _WIN_OS_WINNT) {
-        /* On Windows NT and later call PSAPI.DLL for process Memory */
-        /* informations -- Guido Serassio                       */
-        HANDLE hProcess;
-        PROCESS_MEMORY_COUNTERS pmc;
-        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
-                               PROCESS_VM_READ,
-                               FALSE, GetCurrentProcessId());
-        {
-            /* Microsoft CRT doesn't have getrusage function,  */
-            /* so we get process CPU time information from PSAPI.DLL. */
-            FILETIME ftCreate, ftExit, ftKernel, ftUser;
-
-            if (GetProcessTimes(hProcess, &ftCreate, &ftExit, &ftKernel, &ftUser)) {
-                int64_t *ptUser = (int64_t *)&ftUser;
-                int64_t tUser64 = *ptUser / 10;
-                int64_t *ptKernel = (int64_t *)&ftKernel;
-                int64_t tKernel64 = *ptKernel / 10;
-                usage->ru_utime.tv_sec =(long)(tUser64 / 1000000);
-                usage->ru_stime.tv_sec =(long)(tKernel64 / 1000000);
-                usage->ru_utime.tv_usec =(long)(tUser64 % 1000000);
-                usage->ru_stime.tv_usec =(long)(tKernel64 % 1000000);
-            } else {
-                CloseHandle( hProcess );
-                return -1;
-            }
-        }
-
-        if (GetProcessMemoryInfo( hProcess, &pmc, sizeof(pmc))) {
-            usage->ru_maxrss=(DWORD)(pmc.WorkingSetSize / getpagesize());
-            usage->ru_majflt=pmc.PageFaultCount;
-        } else {
-            CloseHandle( hProcess );
-            return -1;
-        }
-
-        CloseHandle( hProcess );
-    }
-
-#endif
-    return 0;
-}
-
 int
 Win32__WSAFDIsSet(int fd, fd_set FAR * set)
 {
     fde *F = &fd_table[fd];
     SOCKET s = F->win32.handle;
 
@@ -206,7 +96,7 @@
 void WIN32_ExceptionHandlerCleanup()
 {
     if (Win32_Old_ExceptionHandler != NULL)
         SetUnhandledExceptionFilter(Win32_Old_ExceptionHandler);
 }
 
-#endif /* SQUID_MSWIN_ */
+#endif /* SQUID_WINDOWS_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/win32.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/win32.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/win32.h	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/win32.h	2015-05-01 18:05:19.000000000 +0800
@@ -32,28 +32,12 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #if _SQUID_WINDOWS_
 
-#if HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-#if HAVE_SYS_RESOURCE_H
-#include <sys/resource.h>
-#endif
-#if HAVE_SYS_SELECT_H
-#include <sys/select.h>
-#endif
-#if HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-int WIN32_pipe(int[2]);
-
-int WIN32_getrusage(int, struct rusage *);
 void WIN32_ExceptionHandlerInit(void);
 
 int Win32__WSAFDIsSet(int fd, fd_set* set);
 DWORD WIN32_IpAddrChangeMonitorInit();
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/WinSvc.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/WinSvc.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/src/WinSvc.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/src/WinSvc.cc	2015-05-01 18:05:19.000000000 +0800
@@ -29,14 +29,16 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
 
 #include "squid.h"
+#include "Debug.h"
+#include "globals.h"
 #include "protos.h"
-#include "squid_windows.h"
+#include "SquidConfig.h"
 
 #if _SQUID_WINDOWS_
 #ifndef _MSWSOCK_
 #include <mswsock.h>
 #endif
 #include <process.h>
@@ -44,36 +46,34 @@
 #include <crtdbg.h>
 #endif
 #endif
 
 /* forward declarations */
 static void WIN32_Exit(void);
-static void WIN32_Abort(int);
-
 static unsigned int GetOSVersion();
 void WIN32_svcstatusupdate(DWORD, DWORD);
 void WINAPI WIN32_svcHandler(DWORD);
+extern "C" void WINAPI SquidWinSvcMain(DWORD, char **);
+
 #if USE_WIN32_SERVICE
+static void WIN32_Abort(int);
 static int WIN32_StoreKey(const char *, DWORD, unsigned char *, int);
 static int WIN32_create_key(void);
 static void WIN32_build_argv (char *);
 #endif
-extern "C" void WINAPI SquidWinSvcMain(DWORD, char **);
 
 #if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
 void Squid_Win32InvalidParameterHandler(const wchar_t*, const wchar_t*, const wchar_t*, unsigned int, uintptr_t);
 #endif
 static int Win32SockInit(void);
 static void Win32SockCleanup(void);
 SQUIDCEXTERN LPCRITICAL_SECTION dbg_mutex;
 void WIN32_ExceptionHandlerCleanup(void);
 static int s_iInitCount = 0;
 static HANDLE NotifyAddrChange_thread = INVALID_HANDLE_VALUE;
 
-static int Squid_Aborting = 0;
-
 #undef NotifyAddrChange
 typedef DWORD(WINAPI * PFNotifyAddrChange) (OUT PHANDLE, IN LPOVERLAPPED);
 #define NOTIFYADDRCHANGE "NotifyAddrChange"
 
 #if USE_WIN32_SERVICE
 static SERVICE_STATUS svcStatus;
@@ -106,12 +106,14 @@
     SOFTWAREString,	    /* key[0] */
     VENDORString,	    /* key[1] */
     SOFTWARENAMEString,   /* key[2] */
     NULL,	    /* key[3] */
     NULL	    /* key[4] */
 };
+
+static int Squid_Aborting = 0;
 #endif
 
 /* ====================================================================== */
 /* LOCAL FUNCTIONS */
 /* ====================================================================== */
 
@@ -386,23 +388,22 @@
 }
 
 /* ====================================================================== */
 /* PUBLIC FUNCTIONS */
 /* ====================================================================== */
 
+#if USE_WIN32_SERVICE
 void
 WIN32_Abort(int sig)
 {
-#if USE_WIN32_SERVICE
     svcStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
     svcStatus.dwServiceSpecificExitCode = 1;
-#endif
-
     Squid_Aborting = 1;
     WIN32_Exit();
 }
+#endif
 
 void
 WIN32_IpAddrChangeMonitorExit()
 {
     DWORD status = ERROR_SUCCESS;
 
@@ -922,12 +923,13 @@
         {NULL, SquidWinSvcMain},
         {NULL, NULL}
     };
     char *c;
     char stderr_path[256];
 
+    SetErrorMode(SEM_NOGPFAULTERRORBOX);
     if ((argc == 2) && strstr(argv[1], _WIN_SQUID_SERVICE_OPTION)) {
         strcpy(stderr_path, argv[0]);
         strcat(stderr_path,".log");
         freopen(stderr_path, "w", stderr);
         setmode(fileno(stderr), O_TEXT);
         WIN32_run_mode = _WIN_SQUID_RUN_MODE_SERVICE;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/test-suite/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/test-suite/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/test-suite/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/test-suite/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -27,26 +27,24 @@
 
 ## Sort by dependencies - test lowest layers first
 TESTS += debug \
 	syntheticoperators \
 	VirtualDeleteOperator \
 	StackTest \
-	refcount\
 	splay\
 	MemPoolTest\
 	mem_node_test\
 	mem_hdr_test\
 	$(ESI_TESTS)
 
 ## Sort by alpha - any build failures are significant.
 check_PROGRAMS += debug \
 		$(ESI_TESTS) \
 		MemPoolTest\
 		mem_node_test\
 		mem_hdr_test \
-		refcount\
 		splay \
 		StackTest \
 		syntheticoperators \
 		VirtualDeleteOperator
 
 
@@ -83,14 +81,12 @@
 	$(top_builddir)/src/stmem.o \
 	$(top_builddir)/src/mem_node.o \
 	$(LDADD)
 
 MemPoolTest_SOURCES = MemPoolTest.cc
 
-refcount_SOURCES = refcount.cc
-
 splay_SOURCES = splay.cc
 
 StackTest_SOURCES = StackTest.cc $(DEBUG_SOURCE)
 
 syntheticoperators_SOURCES = syntheticoperators.cc $(DEBUG_SOURCE)
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/test-suite/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/test-suite/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/test-suite/Makefile.in	2015-05-01 16:51:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/test-suite/Makefile.in	2015-05-01 18:07:02.000000000 +0800
@@ -78,33 +78,79 @@
 build_triplet = @build@
 host_triplet = @host@
 DIST_COMMON = $(top_srcdir)/src/Common.am $(srcdir)/Makefile.in \
 	$(srcdir)/Makefile.am $(top_srcdir)/cfgaux/depcomp \
 	$(top_srcdir)/cfgaux/test-driver
 check_PROGRAMS = debug$(EXEEXT) $(am__EXEEXT_2) MemPoolTest$(EXEEXT) \
-	mem_node_test$(EXEEXT) mem_hdr_test$(EXEEXT) refcount$(EXEEXT) \
-	splay$(EXEEXT) StackTest$(EXEEXT) syntheticoperators$(EXEEXT) \
+	mem_node_test$(EXEEXT) mem_hdr_test$(EXEEXT) splay$(EXEEXT) \
+	StackTest$(EXEEXT) syntheticoperators$(EXEEXT) \
 	VirtualDeleteOperator$(EXEEXT)
 TESTS = debug$(EXEEXT) syntheticoperators$(EXEEXT) \
 	VirtualDeleteOperator$(EXEEXT) StackTest$(EXEEXT) \
-	refcount$(EXEEXT) splay$(EXEEXT) MemPoolTest$(EXEEXT) \
-	mem_node_test$(EXEEXT) mem_hdr_test$(EXEEXT) $(am__EXEEXT_2)
+	splay$(EXEEXT) MemPoolTest$(EXEEXT) mem_node_test$(EXEEXT) \
+	mem_hdr_test$(EXEEXT) $(am__EXEEXT_2)
 @USE_LOADABLE_MODULES_TRUE@am__append_1 = $(INCLTDL)
 EXTRA_PROGRAMS = mem_node_test$(EXEEXT) membanger$(EXEEXT) \
 	splay$(EXEEXT) tcp-banger2$(EXEEXT)
 subdir = test-suite
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude/init.m4 \
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -113,13 +159,14 @@
 @USE_ESI_TRUE@am__EXEEXT_2 = $(am__EXEEXT_1)
 am__objects_1 = test_tools.$(OBJEXT) stub_debug.$(OBJEXT) \
 	stub_tools.$(OBJEXT) stub_fatal.$(OBJEXT)
 am_ESIExpressions_OBJECTS = ESIExpressions.$(OBJEXT) $(am__objects_1)
 ESIExpressions_OBJECTS = $(am_ESIExpressions_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 am__DEPENDENCIES_4 = $(top_builddir)/src/globals.o \
 	$(top_builddir)/src/time.o $(top_builddir)/lib/libmiscutil.la \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3)
 ESIExpressions_DEPENDENCIES = $(top_builddir)/src/esi/Expression.o \
 	$(am__DEPENDENCIES_4)
@@ -163,18 +210,12 @@
 membanger_SOURCES = membanger.c
 membanger_OBJECTS = membanger.$(OBJEXT)
 membanger_LDADD = $(LDADD)
 membanger_DEPENDENCIES = $(top_builddir)/src/globals.o \
 	$(top_builddir)/src/time.o $(top_builddir)/lib/libmiscutil.la \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3)
-am_refcount_OBJECTS = refcount.$(OBJEXT)
-refcount_OBJECTS = $(am_refcount_OBJECTS)
-refcount_LDADD = $(LDADD)
-refcount_DEPENDENCIES = $(top_builddir)/src/globals.o \
-	$(top_builddir)/src/time.o $(top_builddir)/lib/libmiscutil.la \
-	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3)
 am_splay_OBJECTS = splay.$(OBJEXT)
 splay_OBJECTS = $(am_splay_OBJECTS)
 splay_LDADD = $(LDADD)
 splay_DEPENDENCIES = $(top_builddir)/src/globals.o \
 	$(top_builddir)/src/time.o $(top_builddir)/lib/libmiscutil.la \
 	$(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3)
@@ -240,19 +281,19 @@
 am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
 am__v_CXXLD_0 = @echo "  CXXLD   " $@;
 am__v_CXXLD_1 = 
 SOURCES = $(ESIExpressions_SOURCES) $(MemPoolTest_SOURCES) \
 	$(StackTest_SOURCES) $(VirtualDeleteOperator_SOURCES) \
 	$(debug_SOURCES) $(mem_hdr_test_SOURCES) \
-	$(mem_node_test_SOURCES) membanger.c $(refcount_SOURCES) \
-	$(splay_SOURCES) $(syntheticoperators_SOURCES) tcp-banger2.c
+	$(mem_node_test_SOURCES) membanger.c $(splay_SOURCES) \
+	$(syntheticoperators_SOURCES) tcp-banger2.c
 DIST_SOURCES = $(ESIExpressions_SOURCES) $(MemPoolTest_SOURCES) \
 	$(StackTest_SOURCES) $(VirtualDeleteOperator_SOURCES) \
 	$(debug_SOURCES) $(mem_hdr_test_SOURCES) \
-	$(mem_node_test_SOURCES) membanger.c $(refcount_SOURCES) \
-	$(splay_SOURCES) $(syntheticoperators_SOURCES) tcp-banger2.c
+	$(mem_node_test_SOURCES) membanger.c $(splay_SOURCES) \
+	$(syntheticoperators_SOURCES) tcp-banger2.c
 am__can_run_installinfo = \
   case $$AM_UPDATE_INFO_DIR in \
     n|no|NO) false;; \
     *) (install-info --version) >/dev/null 2>&1;; \
   esac
 am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
@@ -537,12 +578,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -580,12 +622,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -612,27 +655,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -698,13 +744,13 @@
 CLEANFILES = stub_debug.cc stub_tools.cc stub_fatal.cc
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 AUTOMAKE_OPTIONS = subdir-objects
 LDADD = \
 	$(top_builddir)/src/globals.o \
 	$(top_builddir)/src/time.o \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -730,13 +776,12 @@
 mem_hdr_test_LDADD = \
 	$(top_builddir)/src/stmem.o \
 	$(top_builddir)/src/mem_node.o \
 	$(LDADD)
 
 MemPoolTest_SOURCES = MemPoolTest.cc
-refcount_SOURCES = refcount.cc
 splay_SOURCES = splay.cc
 StackTest_SOURCES = StackTest.cc $(DEBUG_SOURCE)
 syntheticoperators_SOURCES = syntheticoperators.cc $(DEBUG_SOURCE)
 VirtualDeleteOperator_SOURCES = VirtualDeleteOperator.cc $(DEBUG_SOURCE)
 all: all-am
 
@@ -812,16 +857,12 @@
 	$(AM_V_CXXLD)$(CXXLINK) $(mem_node_test_OBJECTS) $(mem_node_test_LDADD) $(LIBS)
 
 membanger$(EXEEXT): $(membanger_OBJECTS) $(membanger_DEPENDENCIES) $(EXTRA_membanger_DEPENDENCIES) 
 	@rm -f membanger$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(membanger_OBJECTS) $(membanger_LDADD) $(LIBS)
 
-refcount$(EXEEXT): $(refcount_OBJECTS) $(refcount_DEPENDENCIES) $(EXTRA_refcount_DEPENDENCIES) 
-	@rm -f refcount$(EXEEXT)
-	$(AM_V_CXXLD)$(CXXLINK) $(refcount_OBJECTS) $(refcount_LDADD) $(LIBS)
-
 splay$(EXEEXT): $(splay_OBJECTS) $(splay_DEPENDENCIES) $(EXTRA_splay_DEPENDENCIES) 
 	@rm -f splay$(EXEEXT)
 	$(AM_V_CXXLD)$(CXXLINK) $(splay_OBJECTS) $(splay_LDADD) $(LIBS)
 
 syntheticoperators$(EXEEXT): $(syntheticoperators_OBJECTS) $(syntheticoperators_DEPENDENCIES) $(EXTRA_syntheticoperators_DEPENDENCIES) 
 	@rm -f syntheticoperators$(EXEEXT)
@@ -842,13 +883,12 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StackTest.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/VirtualDeleteOperator.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/debug.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mem_hdr_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mem_node_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/membanger.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/refcount.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/splay.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stub_debug.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stub_fatal.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stub_tools.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/syntheticoperators.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tcp-banger2.Po@am__quote@
@@ -1126,19 +1166,12 @@
 	@p='StackTest$(EXEEXT)'; \
 	b='StackTest'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
 	"$$tst" $(AM_TESTS_FD_REDIRECT)
-refcount.log: refcount$(EXEEXT)
-	@p='refcount$(EXEEXT)'; \
-	b='refcount'; \
-	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
-	--log-file $$b.log --trs-file $$b.trs \
-	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
-	"$$tst" $(AM_TESTS_FD_REDIRECT)
 splay.log: splay$(EXEEXT)
 	@p='splay$(EXEEXT)'; \
 	b='splay'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/test-suite: refcount.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/test-suite/splay.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/test-suite/splay.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/test-suite/splay.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/test-suite/splay.cc	2015-05-01 18:05:19.000000000 +0800
@@ -194,21 +194,24 @@
         /* check we don't segfault on NULL splay calls */
         safeTop = NULL;
         safeTop->splay(intnode(), compareintref);
         SplayCheck::BeginWalk();
         safeTop->walk(SplayCheck::WalkNodeRef, NULL);
     }
+
     /* check the check routine */
-    SplayCheck::BeginWalk();
-    intnode I;
-    I.i = 1;
-    /* check we don't segfault on NULL splay calls */
-    SplayCheck::WalkNodeRef(I, NULL);
-    I.i = 0;
-    SplayCheck::ExpectedFail = true;
-    SplayCheck::WalkNodeRef(I, NULL);
+    {
+        SplayCheck::BeginWalk();
+        intnode I;
+        I.i = 1;
+        /* check we don't segfault on NULL splay calls */
+        SplayCheck::WalkNodeRef(I, NULL);
+        I.i = 0;
+        SplayCheck::ExpectedFail = true;
+        SplayCheck::WalkNodeRef(I, NULL);
+    }
 
     {
         /* check for begin() */
         SplayNode<intnode> *safeTop = NULL;
 
         if (safeTop->start() != NULL)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/test-suite/stub_debug.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/test-suite/stub_debug.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/test-suite/stub_debug.cc	2015-05-01 17:44:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/test-suite/stub_debug.cc	2015-05-01 18:53:31.000000000 +0800
@@ -17,12 +17,13 @@
 
 char *Debug::debugOptions;
 char *Debug::cache_log= NULL;
 int Debug::rotateNumber = 0;
 int Debug::Levels[MAX_DEBUG_SECTIONS];
 int Debug::level;
+int Debug::sectionLevel;
 int Debug::override_X = 0;
 int Debug::log_stderr = 1;
 bool Debug::log_syslog = false;
 
 Ctx
 ctx_enter(const char *descr)
@@ -137,6 +138,26 @@
 
 const char*
 SkipBuildPrefix(const char* path)
 {
     return path;
 }
+
+std::ostream &
+Raw::print(std::ostream &os) const
+{
+    if (label_)
+        os << ' ' << label_ << '[' << size_ << ']';
+
+    if (!size_)
+        return os;
+
+    // finalize debugging level if no level was set explicitly via minLevel()
+    const int finalLevel = (level >= 0) ? level :
+                           (size_ > 40 ? DBG_DATA : Debug::sectionLevel);
+    if (finalLevel <= Debug::sectionLevel) {
+        os << (label_ ? '=' : ' ');
+        os.write(data_, size_);
+    }
+
+    return os;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/cachemgr.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/cachemgr.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/cachemgr.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/cachemgr.cc	2015-05-01 18:05:19.000000000 +0800
@@ -835,48 +835,48 @@
         error_html(buf);
         return 1;
     }
 
     S = *gethostbyname(req->hostname);
 
-    if ( !S.IsAnyAddr() ) {
+    if ( !S.isAnyAddr() ) {
         (void) 0;
     } else if ((S = req->hostname))
         (void) 0;
     else {
         snprintf(buf, sizeof(buf), "Unknown host: %s\n", req->hostname);
         error_html(buf);
         return 1;
     }
 
-    S.SetPort(req->port);
+    S.port(req->port);
 
-    S.GetAddrInfo(AI);
+    S.getAddrInfo(AI);
 
 #if USE_IPV6
     if ((s = socket( AI->ai_family, SOCK_STREAM, 0)) < 0) {
 #else
     if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
 #endif
         snprintf(buf, sizeof(buf), "socket: %s\n", xstrerror());
         error_html(buf);
-        S.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
         return 1;
     }
 
     if (connect(s, AI->ai_addr, AI->ai_addrlen) < 0) {
         snprintf(buf, sizeof(buf), "connect %s: %s\n",
-                 S.ToURL(ipbuf,MAX_IPSTRLEN),
+                 S.toUrl(ipbuf,MAX_IPSTRLEN),
                  xstrerror());
         error_html(buf);
-        S.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
         close(s);
         return 1;
     }
 
-    S.FreeAddrInfo(AI);
+    Ip::Address::FreeAddrInfo(AI);
 
     l = snprintf(buf, sizeof(buf),
                  "GET cache_object://%s/%s%s%s HTTP/1.0\r\n"
                  "User-Agent: cachemgr.cgi/%s\r\n"
                  "Accept: */*\r\n"
                  "%s"			/* Authentication info or nothing */
@@ -1051,30 +1051,31 @@
         ++q;
 
         rfc1738_unescape(t);
 
         rfc1738_unescape(q);
 
-        if (0 == strcasecmp(t, "server") && strlen(q))
+        if (0 == strcmp(t, "server") && strlen(q))
             req->server = xstrdup(q);
-        else if (0 == strcasecmp(t, "host") && strlen(q))
+        else if (0 == strcmp(t, "host") && strlen(q))
             req->hostname = xstrdup(q);
-        else if (0 == strcasecmp(t, "port") && strlen(q))
+        else if (0 == strcmp(t, "port") && strlen(q))
             req->port = atoi(q);
-        else if (0 == strcasecmp(t, "user_name") && strlen(q))
+        else if (0 == strcmp(t, "user_name") && strlen(q))
             req->user_name = xstrdup(q);
-        else if (0 == strcasecmp(t, "passwd") && strlen(q))
+        else if (0 == strcmp(t, "passwd") && strlen(q))
             req->passwd = xstrdup(q);
-        else if (0 == strcasecmp(t, "auth") && strlen(q))
+        else if (0 == strcmp(t, "auth") && strlen(q))
             req->pub_auth = xstrdup(q), decode_pub_auth(req);
-        else if (0 == strcasecmp(t, "operation"))
+        else if (0 == strcmp(t, "operation"))
             req->action = xstrdup(q);
-        else if (0 == strcasecmp(t, "workers") && strlen(q))
+        else if (0 == strcmp(t, "workers") && strlen(q))
             req->workers = xstrdup(q);
-        else if (0 == strcasecmp(t, "processes") && strlen(q))
+        else if (0 == strcmp(t, "processes") && strlen(q))
             req->processes = xstrdup(q);
+        safe_free(t);
     }
 
     if (req->server && !req->hostname) {
         char *p;
         req->hostname = strtok(req->server, ":");
 
@@ -1286,13 +1287,13 @@
         if ((token = strtok(NULL, ":")) != NULL) {
             int i;
 
             if (strcmp(token, "*") == 0)
 
                 ;   /* Wildcard port specification */
-            else if (strcasecmp(token, "any") == 0)
+            else if (strcmp(token, "any") == 0)
 
                 ;   /* Wildcard port specification */
             else if (sscanf(token, "%d", &i) != 1)
                 continue;
 
             else if (i != port)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/Makefile.am	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/Makefile.am	2015-05-01 18:05:19.000000000 +0800
@@ -18,12 +18,13 @@
 
 LDADD = \
 	$(top_builddir)/src/ip/libip.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
 
 include $(top_srcdir)/doc/manuals/Substitute.am
 
 ## Several files need to be shared but we cannot depend on the other
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/Makefile.in	2015-05-01 16:51:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/Makefile.in	2015-05-01 18:07:02.000000000 +0800
@@ -100,14 +100,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -120,18 +166,20 @@
 	cachemgr__CGIEXT_-stub_debug.$(OBJEXT) \
 	cachemgr__CGIEXT_-test_tools.$(OBJEXT) \
 	cachemgr__CGIEXT_-time.$(OBJEXT)
 cachemgr__CGIEXT__OBJECTS = $(am_cachemgr__CGIEXT__OBJECTS)
 cachemgr__CGIEXT__LDADD = $(LDADD)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 cachemgr__CGIEXT__DEPENDENCIES = $(top_builddir)/src/ip/libip.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la $(am__DEPENDENCIES_2) \
-	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
+	$(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
 cachemgr__CGIEXT__LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
@@ -141,13 +189,14 @@
 	test_tools.$(OBJEXT) time.$(OBJEXT)
 squidclient_OBJECTS = $(am_squidclient_OBJECTS)
 squidclient_LDADD = $(LDADD)
 squidclient_DEPENDENCIES = $(top_builddir)/src/ip/libip.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la $(am__DEPENDENCIES_2) \
-	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3)
+	$(am__DEPENDENCIES_3) $(am__DEPENDENCIES_3) \
+	$(am__DEPENDENCIES_3)
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
     *) f=$$p;; \
   esac;
 am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
@@ -512,12 +561,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -555,12 +605,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -587,27 +638,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -673,13 +727,13 @@
 CLEANFILES = test_tools.cc stub_debug.cc time.cc cachemgr.cgi.8
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1) -I$(srcdir)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 AUTOMAKE_OPTIONS = subdir-objects
 SUBDIRS = purge
 EXTRA_DIST = helper-mux.pl helper-mux.README helper-ok-dying.pl \
 	helper-ok.pl squidclient.1 cachemgr.conf cachemgr.cgi.8 \
 	cachemgr.cgi.8.in
@@ -687,12 +741,13 @@
 DISTCLEANFILES = 
 LDADD = \
 	$(top_builddir)/src/ip/libip.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
+	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
 
 SUBSTITUTE = sed "\
 	s%@DEFAULT_ERROR_DIR@%$(DEFAULT_ERROR_DIR)%g;\
 	s%@DEFAULT_MIME_TABLE@%$(DEFAULT_MIME_TABLE)%g;\
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/purge/copyout.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/purge/copyout.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/purge/copyout.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/purge/copyout.cc	2015-05-01 18:05:19.000000000 +0800
@@ -124,13 +124,14 @@
 
     // find hostname part after the scheme (okok, not counting port, etc.)
     const char* ptr = strstr( url, "://" );
     if ( ptr == 0 || strlen(ptr) < 4 ) return false;
 
     // create filename to store contents into
-    char *filename = new char[ strlen(url) + strlen(copydir) + strlen(index) ];
+    // NP: magic extra 5 bytes for the component delimiter and termination octets
+    char *filename = new char[ strlen(ptr) + strlen(copydir) + strlen(index) +5 ];
     assert( filename != 0 );
     strcpy( filename, copydir );
     strcat( filename, "/" );
     char* here = filename + strlen(filename);
     strcat( filename, ptr+3 );
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/purge/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/purge/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/purge/Makefile.in	2015-05-01 16:51:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/purge/Makefile.in	2015-05-01 18:07:03.000000000 +0800
@@ -91,14 +91,60 @@
 	$(top_srcdir)/acinclude/squid-util.m4 \
 	$(top_srcdir)/acinclude/compiler-flags.m4 \
 	$(top_srcdir)/acinclude/os-deps.m4 \
 	$(top_srcdir)/acinclude/krb5.m4 $(top_srcdir)/acinclude/pam.m4 \
 	$(top_srcdir)/acinclude/pkg.m4 \
 	$(top_srcdir)/acinclude/lib-checks.m4 \
-	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_0x.m4 \
+	$(top_srcdir)/acinclude/ax_cxx_compile_stdcxx_11.m4 \
 	$(top_srcdir)/acinclude/ax_cxx_0x_types.m4 \
+	$(top_srcdir)/helpers/basic_auth/modules.m4 \
+	$(top_srcdir)/helpers/basic_auth/DB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT-multi-domain/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/MSNT/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NCSA/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/NIS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/PAM/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/POP3/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/RADIUS/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SASL/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SMB/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/basic_auth/getpwnam/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/modules.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/fake/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/ntlm_auth/smb_lm/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/modules.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/SSPI/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/kerberos/required.m4 \
+	$(top_srcdir)/helpers/negotiate_auth/wrapper/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/modules.m4 \
+	$(top_srcdir)/helpers/digest_auth/LDAP/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/eDirectory/required.m4 \
+	$(top_srcdir)/helpers/digest_auth/file/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/modules.m4 \
+	$(top_srcdir)/helpers/log_daemon/DB/required.m4 \
+	$(top_srcdir)/helpers/log_daemon/file/required.m4 \
+	$(top_srcdir)/helpers/external_acl/modules.m4 \
+	$(top_srcdir)/helpers/external_acl/AD_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LDAP_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/LM_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/SQL_session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/eDirectory_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/file_userip/required.m4 \
+	$(top_srcdir)/helpers/external_acl/kerberos_ldap_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/session/required.m4 \
+	$(top_srcdir)/helpers/external_acl/time_quota/required.m4 \
+	$(top_srcdir)/helpers/external_acl/unix_group/required.m4 \
+	$(top_srcdir)/helpers/external_acl/wbinfo_group/required.m4 \
+	$(top_srcdir)/helpers/url_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/url_rewrite/fake/required.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/modules.m4 \
+	$(top_srcdir)/helpers/storeid_rewrite/file/required.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/include/autoconf.h
 CONFIG_CLEAN_FILES =
@@ -107,13 +153,14 @@
 PROGRAMS = $(bin_PROGRAMS)
 am_purge_OBJECTS = convert.$(OBJEXT) socket.$(OBJEXT) signal.$(OBJEXT) \
 	squid-tlv.$(OBJEXT) copyout.$(OBJEXT) conffile.$(OBJEXT) \
 	purge.$(OBJEXT)
 purge_OBJECTS = $(am_purge_OBJECTS)
 @ENABLE_XPROF_STATS_TRUE@am__DEPENDENCIES_1 = $(top_builddir)/lib/profiler/libprofiler.la
-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_2 = $(top_builddir)/compat/libcompat-squid.la \
+	$(am__DEPENDENCIES_1)
 am__DEPENDENCIES_3 =
 purge_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_3)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
@@ -456,12 +503,13 @@
 EXTERNAL_ACL_HELPERS = @EXTERNAL_ACL_HELPERS@
 EXT_LIBECAP_CFLAGS = @EXT_LIBECAP_CFLAGS@
 EXT_LIBECAP_LIBS = @EXT_LIBECAP_LIBS@
 FALSE = @FALSE@
 FGREP = @FGREP@
 GREP = @GREP@
+HAVE_CXX11 = @HAVE_CXX11@
 HOSTCXX = @HOSTCXX@
 ICAP_LIBS = @ICAP_LIBS@
 INCLTDL = @INCLTDL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -499,12 +547,13 @@
 MANIFEST_TOOL = @MANIFEST_TOOL@
 MINGW_LIBS = @MINGW_LIBS@
 MKDIR = @MKDIR@
 MKDIR_P = @MKDIR_P@
 MV = @MV@
 NEGOTIATE_AUTH_HELPERS = @NEGOTIATE_AUTH_HELPERS@
+NETTLELIB = @NETTLELIB@
 NM = @NM@
 NMEDIT = @NMEDIT@
 NTLM_AUTH_HELPERS = @NTLM_AUTH_HELPERS@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -531,27 +580,30 @@
 REPL_POLICIES = @REPL_POLICIES@
 RM = @RM@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SH = @SH@
 SHELL = @SHELL@
+SMBCLIENT = @SMBCLIENT@
 SNMPLIB = @SNMPLIB@
 SQUID_CFLAGS = @SQUID_CFLAGS@
 SQUID_CPPUNIT_INC = @SQUID_CPPUNIT_INC@
 SQUID_CPPUNIT_LA = @SQUID_CPPUNIT_LA@
 SQUID_CPPUNIT_LIBS = @SQUID_CPPUNIT_LIBS@
 SQUID_CXXFLAGS = @SQUID_CXXFLAGS@
 SSLLIB = @SSLLIB@
+STOREID_REWRITE_HELPERS = @STOREID_REWRITE_HELPERS@
 STORE_LIBS_TO_ADD = @STORE_LIBS_TO_ADD@
 STORE_LIBS_TO_BUILD = @STORE_LIBS_TO_BUILD@
 STORE_TESTS = @STORE_TESTS@
 STRIP = @STRIP@
 TR = @TR@
 TRUE = @TRUE@
 URL_REWRITE_HELPERS = @URL_REWRITE_HELPERS@
 VERSION = @VERSION@
+WBINFO = @WBINFO@
 WIN32_PSAPI = @WIN32_PSAPI@
 XMLLIB = @XMLLIB@
 XTRA_LIBS = @XTRA_LIBS@
 XTRA_OBJS = @XTRA_OBJS@
 abs_builddir = @abs_builddir@
 abs_srcdir = @abs_srcdir@
@@ -617,13 +669,13 @@
 CLEANFILES = 
 INCLUDES = -I$(top_srcdir) -I$(top_srcdir)/include -I$(top_srcdir)/lib \
 	-I$(top_srcdir)/src -I$(top_builddir)/include \
 	$(SQUID_CPPUNIT_INC) $(KRB5INCS) $(am__append_1)
 @ENABLE_XPROF_STATS_FALSE@LIBPROFILER = 
 @ENABLE_XPROF_STATS_TRUE@LIBPROFILER = $(top_builddir)/lib/profiler/libprofiler.la
-COMPAT_LIB = -L$(top_builddir)/compat -lcompat-squid $(LIBPROFILER)
+COMPAT_LIB = $(top_builddir)/compat/libcompat-squid.la $(LIBPROFILER)
 subst_perlshell = sed -e 's,[@]PERL[@],$(PERL),g' <$(srcdir)/$@.pl.in >$@ || ($(RM) -f $@ ; exit 1)
 purge_SOURCES = \
 	convert.cc \
 	convert.hh \
 	socket.cc \
 	socket.hh \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/purge/purge.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/purge/purge.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/purge/purge.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/purge/purge.cc	2015-05-01 18:05:19.000000000 +0800
@@ -129,13 +129,13 @@
 #ifndef DEFAULTPORT
 #define DEFAULTPORT 3128
 #endif // DEFAULTPORT
 
 volatile sig_atomic_t term_flag = 0; // 'terminate' is a gcc 2.8.x internal...
 char*  linebuffer = 0;
-size_t buffersize = 16834;
+size_t buffersize = 128*1024;
 static char* copydir = 0;
 static uint32_t debugFlag = 0;
 static unsigned purgeMode = 0;
 static bool iamalive = false;
 static bool reminder = false;
 static bool verbose  = false;
@@ -201,13 +201,14 @@
     va_list ap;
     const char* s;
 
     // first run: determine size
     unsigned size = strlen(start)+1;
     va_start( ap, start );
-    while ( (s=va_arg(ap,const char*)) != NULL ) size += strlen(s ? s : "");
+    while ( (s=va_arg(ap,const char*)) != NULL )
+        size += strlen(s);
     va_end(ap);
 
     // allocate
     char* result = new char[size];
     if ( result == 0 ) {
         perror( "string memory allocation" );
@@ -316,50 +317,58 @@
 //          ::serverHost (IN): cache host address
 //          ::serverPort (IN): cache port number
 {
     static const char* schablone = "PURGE %s HTTP/1.0\r\nAccept: */*\r\n\r\n";
     struct stat st;
     long size = ( fstat(fd,&st) == -1 ? -1 : long(st.st_size - metasize) );
-    int status = 0;
 
     // if we want to copy out the file, do that first of all.
     if ( ::copydir && *copydir && size > 0 )
         copy_out( st.st_size, metasize, ::debugFlag,
                   fn, url, ::copydir, ::envelope );
 
     // do we need to PURGE the file, yes, if purgemode bit#0 was set.
+    int status = 0;
     if ( ::purgeMode & 0x01 ) {
         unsigned long bufsize = strlen(url) + strlen(schablone) + 4;
         char* buffer = new char[bufsize];
 
         snprintf( buffer, bufsize, schablone, url );
         int sockfd = connectTo( serverHost, serverPort, true );
         if ( sockfd == -1 ) {
             fprintf( stderr, "unable to connect to server: %s\n", strerror(errno) );
             delete[] buffer;
             return false;
         }
 
-        int size = strlen(buffer);
-        if ( write( sockfd, buffer, size ) != size ) {
+        int content_size = strlen(buffer);
+        if ( write( sockfd, buffer, content_size ) != content_size ) {
             // error while talking to squid
             fprintf( stderr, "unable to talk to server: %s\n", strerror(errno) );
             close(sockfd);
             delete[] buffer;
             return false;
         }
         memset( buffer+8, 0, 4 );
-        if ( read( sockfd, buffer, bufsize ) < 1 ) {
+        int readLen = read(sockfd, buffer, bufsize);
+        if (readLen < 1) {
             // error while reading squid's answer
             fprintf( stderr, "unable to read answer: %s\n", strerror(errno) );
             close(sockfd);
             delete[] buffer;
             return false;
         }
+        buffer[bufsize-1] = '\0';
         close(sockfd);
-        status = strtol(buffer+8,0,10);
+        int64_t s = strtol(buffer+8,0,10);
+        if (s > 0 && s < 1000)
+            status = s;
+        else {
+            // error while reading squid's answer
+            fprintf( stderr, "invalid HTTP status in reply: %s\n", buffer+8);
+        }
         delete[] buffer;
     }
 
     // log the output of our operation
     bool flag = true;
     if ( ::verbose ) flag = ( log_extended( fn, status, size, &meta ) >= 0 );
@@ -388,13 +397,15 @@
     static const size_t addon = sizeof(unsigned char) + sizeof(unsigned int);
     bool flag = true;
 
     if ( debugFlag & 0x01 ) fprintf( stderr, "# [3] %s\n", fn );
     int fd = open( fn, O_RDONLY );
     if ( fd != -1 ) {
-        if ( read(fd,::linebuffer,::buffersize-1) > 60 ) {
+        memset(::linebuffer, 0, ::buffersize);
+        size_t readLen = read(fd,::linebuffer,::buffersize-1);
+        if ( readLen > 60 ) {
             ::linebuffer[ ::buffersize-1 ] = '\0'; // force-terminate string
 
             // check the offset into the start of object data. The offset is
             // stored in a host endianess after the first byte.
             unsigned int datastart;
             memcpy( &datastart, ::linebuffer + 1, sizeof(unsigned int) );
@@ -409,12 +420,20 @@
             // the URL as part of the list. First, gobble all meta data.
             unsigned int offset = addon;
             SquidMetaList meta;
             while ( offset + addon <= datastart ) {
                 unsigned int size = 0;
                 memcpy( &size, linebuffer+offset+sizeof(char), sizeof(unsigned int) );
+                if (size+offset < size) {
+                    fputs("WARNING: file corruption detected. 32-bit overflow in size field.\n", stderr);
+                    break;
+                }
+                if (size+offset > readLen) {
+                    fputs( "WARNING: Partial meta data loaded.\n", stderr );
+                    break;
+                }
                 meta.append( SquidMetaType(*(linebuffer+offset)),
                              size, linebuffer+offset+addon );
                 offset += ( addon + size );
             }
 
             // Now extract the key URL from the meta data.
@@ -537,29 +556,29 @@
 
     closedir(dir);
     return flag;
 }
 
 int
-checkForPortOnly( const char* optarg )
+checkForPortOnly( const char* arg )
 // purpose: see if somebody just put in a port instead of a hostname
 // paramtr: optarg (IN): argument from commandline
 // returns: 0..65535 is the valid port number in network byte order,
 //          -1 if not a port
 {
     // if there is a period in there, it must be a valid hostname
-    if ( strchr( optarg, '.' ) != 0 ) return -1;
+    if ( strchr( arg, '.' ) != 0 ) return -1;
 
     // if it is just a number between 0 and 65535, it must be a port
     char* errstr = 0;
-    unsigned long result = strtoul( optarg, &errstr, 0 );
-    if ( result < 65536 && errstr != optarg ) return htons(result);
+    unsigned long result = strtoul( arg, &errstr, 0 );
+    if ( result < 65536 && errstr != arg ) return htons(result);
 
 #if 0
     // one last try, test for a symbolical service name
-    struct servent* service = getservbyname( optarg, "tcp" );
+    struct servent* service = getservbyname( arg, "tcp" );
     return service ? service->s_port : -1;
 #else
     return -1;
 #endif
 }
 
@@ -592,14 +611,14 @@
         "\n", DEFAULT_SQUID_CONF, DEFAULTHOST, DEFAULTPORT );
 
 }
 
 void
 parseCommandline( int argc, char* argv[], REList*& head,
-                  char*& conffile, char*& copydir,
-                  struct in_addr& serverHost, unsigned short& serverPort )
+                  char*& conffile, char*& copyDirPath,
+                  struct in_addr& serverHostIp, unsigned short& serverHostPort )
 // paramtr: argc: see ::main().
 //          argv: see ::main().
 // returns: Does terminate the program on errors!
 // purpose: suck in any commandline options, and set the global vars.
 {
     int option, port, showme = 0;
@@ -620,15 +639,15 @@
         switch ( option ) {
         case 'a':
             ::iamalive = ! ::iamalive;
             break;
         case 'C':
             if ( optarg && *optarg ) {
-                if ( copydir ) xfree( (void*) copydir );
-                copydir = xstrdup(optarg);
-                assert(copydir);
+                if ( copyDirPath ) xfree( (void*) copyDirPath );
+                copyDirPath = xstrdup(optarg);
+                assert(copyDirPath);
             }
             break;
         case 'c':
             if ( !optarg || !*optarg ) {
                 fprintf( stderr, "%c requires a regex pattern argument!\n", option );
                 exit(1);
@@ -713,29 +732,29 @@
 
                 // fix: see if somebody just put in there a port (no periods)
                 // give port number precedence over host names
                 port = checkForPortOnly( optarg );
                 if ( port == -1 ) {
                     // assume that main() did set the default port
-                    if ( convertHostname(optarg,serverHost) == -1 ) {
+                    if ( convertHostname(optarg,serverHostIp) == -1 ) {
                         fprintf( stderr, "unable to resolve host %s!\n", optarg );
                         exit(1);
                     }
                 } else {
                     // assume that main() did set the default host
-                    serverPort = port;
+                    serverHostPort = port;
                 }
             } else {
                 // colon used, port is extra
                 *colon = 0;
                 ++colon;
-                if ( convertHostname(optarg,serverHost) == -1 ) {
+                if ( convertHostname(optarg,serverHostIp) == -1 ) {
                     fprintf( stderr, "unable to resolve host %s!\n", optarg );
                     exit(1);
                 }
-                if ( convertPortname(colon,serverPort) == -1 ) {
+                if ( convertPortname(colon,serverHostPort) == -1 ) {
                     fprintf( stderr, "unable to resolve port %s!\n", colon );
                     exit(1);
                 }
             }
             break;
         case 'P':
@@ -767,35 +786,35 @@
     }
 
     // postcondition: head != 0
     assert( head != 0 );
 
     // make sure that the copy out directory is there and accessible
-    if ( copydir && *copydir )
-        if ( assert_copydir( copydir ) != 0 ) exit(1);
+    if ( copyDirPath && *copyDirPath )
+        if ( assert_copydir( copyDirPath ) != 0 ) exit(1);
 
     // show results
     if ( showme ) {
         printf( "#\n# Currently active values for %s:\n",
                 ::programname);
         printf( "# Debug level       : " );
         if ( ::debugFlag ) printf( "%#6.4x", ::debugFlag );
         else printf( "production level" ); // printf omits 0x prefix for 0!
         printf( " + %s mode", ::no_fork ? "linear" : "parallel" );
         puts( ::verbose ? " + extra verbosity" : "" );
 
         printf( "# Copy-out directory: %s ",
-                copydir ? copydir : "copy-out mode disabled" );
-        if ( copydir )
+                copyDirPath ? copyDirPath : "copy-out mode disabled" );
+        if ( copyDirPath )
             printf( "(%s HTTP header)\n", ::envelope ? "prepend" : "no" );
         else
             puts("");
 
         printf( "# Squid config file : %s\n", conffile );
         printf( "# Cacheserveraddress: %s:%u\n",
-                inet_ntoa( serverHost ), ntohs( serverPort ) );
+                inet_ntoa( serverHostIp ), ntohs( serverHostPort ) );
         printf( "# purge mode        : 0x%02x\n", ::purgeMode );
         printf( "# Regular expression: " );
 
         unsigned count(0);
         for ( tail = head; tail != NULL; tail = tail->next ) {
             if ( count++ )
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/purge/socket.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/purge/socket.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/purge/socket.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/purge/socket.cc	2015-05-01 18:05:19.000000000 +0800
@@ -211,15 +211,15 @@
     if ( sockfd == -1 ) {
         perror( "socket" );
         return -1;
     }
 
     if ( reuse ) {
-        int reuse = 1;
+        int opt = 1;
         if ( setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR,
-                         (char*) &reuse, sizeof(int) ) == -1) {
+                         (char*) &opt, sizeof(int) ) == -1) {
             perror( "setsockopt( SO_REUSEADDR )" );
             close( sockfd );
             return -1;
         }
     }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/squidclient.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/squidclient.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/squidclient.1	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/squidclient.1	2015-05-01 18:05:19.000000000 +0800
@@ -1,12 +1,10 @@
 .if !'po4a'hide' .TH squidclient 1
 .
 .SH NAME
-.if !'po4a'hide' .B squidclient
-.if !'po4a'hide' \-
-A simple HTTP web client tool
+squidclient \- A simple HTTP web client tool
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B squidclient
 .if !'po4a'hide' .B "[ \-aknNrsv ] [ \-A"
 string
 .if !'po4a'hide' .B "] [ \-g"
@@ -182,16 +180,17 @@
 .
 .if !'po4a'hide' .TP
 .if !'po4a'hide' .B "\-W password"
 WWW authentication password
 .
 .SH AUTHOR
-Derived from Harvest. Further developed by by numerous individuals from
-the internet community. Development is led by Duane Wessels of the
-National Laboratory for Applied Network Research and funded by
-the National Science Foundation.
+This program and manual was written by
+.if !'po4a'hide' .I Amos Jeffries <amosjeffries@squid-cache.org>
+.PP
+Based on original code derived from Harvest and further developed by
+numerous individuals from the internet community.
 .
 .SH COPYRIGHT
 Distributed under the GNU General Public License (GNU GPL) version 2 or later (GPLv2+).
 .
 .SH QUESTIONS
 Questions on the usage of this program can be sent to the
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/squidclient.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/squidclient.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/squidclient.cc	2015-05-01 16:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/squidclient.cc	2015-05-01 18:05:19.000000000 +0800
@@ -208,13 +208,14 @@
 
 static int interrupted = 0;
 int
 main(int argc, char *argv[])
 {
     int conn, c, len, bytesWritten;
-    int port, to_stdout, reload;
+    uint16_t port;
+    bool to_stdout, reload;
     int ping, pcount;
     int keep_alive = 0;
     int opt_noaccept = 0;
     bool opt_verbose = false;
 #if HAVE_GSSAPI
     int www_neg = 0, proxy_neg = 0;
@@ -242,14 +243,14 @@
 
     /* set the defaults */
     hostname = "localhost";
     localhost = NULL;
     extra_hdrs[0] = '\0';
     port = CACHE_HTTP_PORT;
-    to_stdout = 1;
-    reload = 0;
+    to_stdout = true;
+    reload = false;
     ping = 0;
     pcount = 0;
     ping_int = 1 * 1000;
 
     Ip::ProbeTransport(); // determine IPv4 or IPv6 capabilities before parsing.
     if (argc < 2) {
@@ -289,25 +290,25 @@
 
             case 'l':		/* local host */
                 localhost = optarg;
                 break;
 
             case 's':		/* silent */
-                to_stdout = 0;
+                to_stdout = false;
                 break;
 
             case 'k':		/* backward compat */
                 keep_alive = 1;
                 break;
 
             case 'r':		/* reload */
-                reload = 1;
+                reload = true;
                 break;
 
             case 'p':		/* port number */
-                sscanf(optarg, "%d", &port);
+                sscanf(optarg, "%hd", &port);
                 if (port < 1)
                     port = CACHE_HTTP_PORT;	/* default */
                 break;
 
             case 'P':
                 put_file = xstrdup(optarg);
@@ -588,67 +589,70 @@
             if ( !iaddr.GetHostByName(hostname) ) {
                 fprintf(stderr, "client: ERROR: Cannot resolve %s: Host unknown.\n", hostname);
                 exit(1);
             }
         }
 
-        iaddr.GetAddrInfo(AI);
+        iaddr.getAddrInfo(AI);
         if ((conn = socket(AI->ai_family, AI->ai_socktype, 0)) < 0) {
             perror("client: socket");
-            iaddr.FreeAddrInfo(AI);
+            Ip::Address::FreeAddrInfo(AI);
             exit(1);
         }
-        iaddr.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
 
         if (localhost && client_comm_bind(conn, iaddr) < 0) {
             perror("client: bind");
             exit(1);
         }
 
-        iaddr.SetEmpty();
+        iaddr.setEmpty();
         if ( !iaddr.GetHostByName(hostname) ) {
             fprintf(stderr, "client: ERROR: Cannot resolve %s: Host unknown.\n", hostname);
             exit(1);
         }
 
-        iaddr.SetPort(port);
+        iaddr.port(port);
 
         if (opt_verbose) {
             char ipbuf[MAX_IPSTRLEN];
-            fprintf(stderr, "Connecting... %s(%s)\n", hostname, iaddr.NtoA(ipbuf, MAX_IPSTRLEN));
+            fprintf(stderr, "Connecting... %s(%s)\n", hostname, iaddr.toStr(ipbuf, MAX_IPSTRLEN));
         }
 
         if (client_comm_connect(conn, iaddr, ping ? &tv1 : NULL) < 0) {
             char hostnameBuf[MAX_IPSTRLEN];
-            iaddr.ToURL(hostnameBuf, MAX_IPSTRLEN);
+            iaddr.toUrl(hostnameBuf, MAX_IPSTRLEN);
             if (errno == 0) {
                 fprintf(stderr, "client: ERROR: Cannot connect to %s: Host unknown.\n", hostnameBuf);
             } else {
                 char tbuf[BUFSIZ];
                 snprintf(tbuf, BUFSIZ, "client: ERROR: Cannot connect to %s", hostnameBuf);
                 perror(tbuf);
             }
             exit(1);
         }
         if (opt_verbose) {
             char ipbuf[MAX_IPSTRLEN];
-            fprintf(stderr, "Connected to: %s (%s)\n", hostname, iaddr.NtoA(ipbuf, MAX_IPSTRLEN));
+            fprintf(stderr, "Connected to: %s (%s)\n", hostname, iaddr.toStr(ipbuf, MAX_IPSTRLEN));
         }
 
         /* Send the HTTP request */
+        fprintf(stderr, "Sending HTTP request ... ");
         bytesWritten = mywrite(conn, msg, strlen(msg));
 
         if (bytesWritten < 0) {
             perror("client: ERROR: write");
             exit(1);
         } else if ((unsigned) bytesWritten != strlen(msg)) {
             fprintf(stderr, "client: ERROR: Cannot send request?: %s\n", msg);
             exit(1);
         }
+        fprintf(stderr, "done.\n");
 
         if (put_file) {
+            fprintf(stderr, "Sending HTTP request payload ... ");
             int x;
             lseek(put_fd, 0, SEEK_SET);
             while ((x = read(put_fd, buf, sizeof(buf))) > 0) {
 
                 x = mywrite(conn, buf, x);
 
@@ -657,12 +661,14 @@
                 if (x <= 0)
                     break;
             }
 
             if (x != 0)
                 fprintf(stderr, "client: ERROR: Cannot send file.\n");
+            else
+                fprintf(stderr, "done.\n");
         }
         /* Read the data */
 
 #if _SQUID_WINDOWS_
         setmode(1, O_BINARY);
 #endif
@@ -732,45 +738,30 @@
     return 0;
 }
 
 static int
 client_comm_bind(int sock, const Ip::Address &addr)
 {
-
-    int res;
-
-    static struct addrinfo *AI = NULL;
-
     /* Set up the source socket address from which to send. */
-
-    addr.GetAddrInfo(AI);
-
-    res = bind(sock, AI->ai_addr, AI->ai_addrlen);
-
-    addr.FreeAddrInfo(AI);
-
+    static struct addrinfo *AI = NULL;
+    addr.getAddrInfo(AI);
+    int res = bind(sock, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
     return res;
 }
 
 static int
 client_comm_connect(int sock, const Ip::Address &addr, struct timeval *tvp)
 {
-    int res;
-    static struct addrinfo *AI = NULL;
-
     /* Set up the destination socket address for message to send to. */
-
-    addr.GetAddrInfo(AI);
-
-    res = connect(sock, AI->ai_addr, AI->ai_addrlen);
-
-    addr.FreeAddrInfo(AI);
-
+    static struct addrinfo *AI = NULL;
+    addr.getAddrInfo(AI);
+    int res = connect(sock, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
     if (tvp)
         (void) Now(tvp);
-
     return res;
 }
 
 static int
 Now(struct timeval *tp)
 {
@@ -774,16 +765,15 @@
 static int
 Now(struct timeval *tp)
 {
 #if GETTIMEOFDAY_NO_TZP
     return gettimeofday(tp);
 #else
-
     return gettimeofday(tp, NULL);
 #endif
-}				/* ARGSUSED */
+}
 
 void
 catchSignal(int sig)
 {
     interrupted = 1;
     fprintf(stderr, "Interrupted.\n");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/stub_debug.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/stub_debug.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.3.14/tools/stub_debug.cc	2015-05-01 17:44:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/squid/repos/squid-3.4.13/tools/stub_debug.cc	2015-05-01 18:53:33.000000000 +0800
@@ -17,12 +17,13 @@
 
 char *Debug::debugOptions;
 char *Debug::cache_log= NULL;
 int Debug::rotateNumber = 0;
 int Debug::Levels[MAX_DEBUG_SECTIONS];
 int Debug::level;
+int Debug::sectionLevel;
 int Debug::override_X = 0;
 int Debug::log_stderr = 1;
 bool Debug::log_syslog = false;
 
 Ctx
 ctx_enter(const char *descr)
@@ -137,6 +138,26 @@
 
 const char*
 SkipBuildPrefix(const char* path)
 {
     return path;
 }
+
+std::ostream &
+Raw::print(std::ostream &os) const
+{
+    if (label_)
+        os << ' ' << label_ << '[' << size_ << ']';
+
+    if (!size_)
+        return os;
+
+    // finalize debugging level if no level was set explicitly via minLevel()
+    const int finalLevel = (level >= 0) ? level :
+                           (size_ > 40 ? DBG_DATA : Debug::sectionLevel);
+    if (finalLevel <= Debug::sectionLevel) {
+        os << (label_ ? '=' : ' ');
+        os.write(data_, size_);
+    }
+
+    return os;
+}
