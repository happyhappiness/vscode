static void
urnHandleReply(void *data, StoreIOBuffer result)
{
    UrnState *urnState = static_cast<UrnState *>(data);
    StoreEntry *e = urnState->entry;
    StoreEntry *urlres_e = urnState->urlres_e;
    char *s = NULL;
    size_t k;
    HttpReply *rep;
    url_entry *urls;
    url_entry *u;
    url_entry *min_u;
    MemBuf *mb = NULL;
    ErrorState *err;
    int i;
    int urlcnt = 0;
    char *buf = urnState->reqbuf;
    StoreIOBuffer tempBuffer;

    debugs(52, 3, "urnHandleReply: Called with size=" << result.length << ".");

    if (EBIT_TEST(urlres_e->flags, ENTRY_ABORTED) || result.length == 0 || result.flags.error) {
        urnHandleReplyError(urnState, urlres_e);
        return;
    }

    /* Update reqofs to point to where in the buffer we'd be */
    urnState->reqofs += result.length;

    /* Handle reqofs being bigger than normal */
    if (urnState->reqofs >= URN_REQBUF_SZ) {
        urnHandleReplyError(urnState, urlres_e);
        return;
    }

    /* If we haven't received the entire object (urn), copy more */
    if (urlres_e->store_status == STORE_PENDING &&
            urnState->reqofs < URN_REQBUF_SZ) {
        tempBuffer.offset = urnState->reqofs;
        tempBuffer.length = URN_REQBUF_SZ;
        tempBuffer.data = urnState->reqbuf + urnState->reqofs;
        storeClientCopy(urnState->sc, urlres_e,
                        tempBuffer,
                        urnHandleReply,
                        urnState);
        return;
    }

    /* we know its STORE_OK */
    k = headersEnd(buf, urnState->reqofs);

    if (0 == k) {
        debugs(52, 1, "urnHandleReply: didn't find end-of-headers for " << e->url()  );
        urnHandleReplyError(urnState, urlres_e);
        return;
    }

    s = buf + k;
    assert(urlres_e->getReply());
    rep = new HttpReply;
    rep->parseCharBuf(buf, k);
    debugs(52, 3, "reply exists, code=" << rep->sline.status << ".");

    if (rep->sline.status != HTTP_OK) {
        debugs(52, 3, "urnHandleReply: failed.");
        err = errorCon(ERR_URN_RESOLVE, HTTP_NOT_FOUND, urnState->request);
        err->url = xstrdup(e->url());
        errorAppendEntry(e, err);
        delete rep;
        urnHandleReplyError(urnState, urlres_e);
        return;
    }

    delete rep;

    while (xisspace(*s))
        s++;

    urls = urnParseReply(s, urnState->request->method);

    for (i = 0; NULL != urls[i].url; i++)
        urlcnt++;

    debugs(53, 3, "urnFindMinRtt: Counted " << i << " URLs");

    if (urls == NULL) {		/* unkown URN error */
        debugs(52, 3, "urnTranslateDone: unknown URN " << e->url()  );
        err = errorCon(ERR_URN_RESOLVE, HTTP_NOT_FOUND, urnState->request);
        err->url = xstrdup(e->url());
        errorAppendEntry(e, err);
        urnHandleReplyError(urnState, urlres_e);
        return;
    }

    min_u = urnFindMinRtt(urls, urnState->request->method, NULL);
    qsort(urls, urlcnt, sizeof(*urls), url_entry_sort);
    e->buffer();
    mb = new MemBuf;
    mb->init();
    mb->Printf( "<TITLE>Select URL for %s</TITLE>\n"
                "<STYLE type=\"text/css\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\n"
                "<H2>Select URL for %s</H2>\n"
                "<TABLE BORDER=\"0\" WIDTH=\"100%%\">\n", e->url(), e->url());

    for (i = 0; i < urlcnt; i++) {
        u = &urls[i];
        debugs(52, 3, "URL {" << u->url << "}");
        mb->Printf(
            "<TR><TD><A HREF=\"%s\">%s</A></TD>", u->url, u->url);

        if (urls[i].rtt > 0)
            mb->Printf(
                "<TD align=\"right\">%4d <it>ms</it></TD>", u->rtt);
        else
            mb->Printf("<TD align=\"right\">Unknown</TD>");

        mb->Printf(
            "<TD>%s</TD></TR>\n", u->flags.cached ? "    [cached]" : " ");
    }

    mb->Printf(
        "</TABLE>"
        "<HR noshade size=\"1px\">\n"
        "<ADDRESS>\n"
        "Generated by %s@%s\n"
        "</ADDRESS>\n",
        APP_FULLNAME, getMyHostname());
    rep = new HttpReply;
    rep->setHeaders(HTTP_MOVED_TEMPORARILY, NULL, "text/html", mb->contentSize(), 0, squid_curtime);

    if (urnState->flags.force_menu) {
        debugs(51, 3, "urnHandleReply: forcing menu");
    } else if (min_u) {
        rep->header.putStr(HDR_LOCATION, min_u->url);
    }

    httpBodySet(&rep->body, mb);
    /* don't clean or delete mb; rep->body owns it now */
    e->replaceHttpReply(rep);
    e->complete();

    for (i = 0; i < urlcnt; i++) {
        safe_free(urls[i].url);
        safe_free(urls[i].host);
    }

    safe_free(urls);
    /* mb was absorbed in httpBodySet call, so we must not clean it */
    storeUnregister(urnState->sc, urlres_e, urnState);

    urnHandleReplyError(urnState, urlres_e);
}